# coding=utf-8
from abc import (
    abstractmethod,
)
import builtins
from conjure_python_client import (
    BinaryType,
    ConjureBeanType,
    ConjureDecoder,
    ConjureEncoder,
    ConjureEnumType,
    ConjureFieldDefinition,
    ConjureUnionType,
    OptionalTypeWrapper,
    Service,
)
from requests.adapters import (
    Response,
)
from typing import (
    Any,
    Dict,
    List,
    Optional,
    Set,
)

class api_Timestamp(ConjureBeanType):
    """
    Picosecond precision timestamp type, represented by an epoch time in seconds, a nanosecond offset, and
optional picosecond offset.
The nanosecond offset is from the start of the epoch second, so must be less than 1 billion.
The optional picosecond offset is only used for picosecond-precision data sources and is from the start of
the nanosecond, so must be less than 1000.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'seconds': ConjureFieldDefinition('seconds', int),
            'nanos': ConjureFieldDefinition('nanos', int),
            'picos': ConjureFieldDefinition('picos', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_seconds', '_nanos', '_picos']

    def __init__(self, nanos: int, seconds: int, picos: Optional[int] = None) -> None:
        self._seconds = seconds
        self._nanos = nanos
        self._picos = picos

    @builtins.property
    def seconds(self) -> int:
        return self._seconds

    @builtins.property
    def nanos(self) -> int:
        return self._nanos

    @builtins.property
    def picos(self) -> Optional[int]:
        return self._picos


api_Timestamp.__name__ = "Timestamp"
api_Timestamp.__qualname__ = "Timestamp"
api_Timestamp.__module__ = "scout_service_api.api"


class attachments_api_Attachment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', attachments_api_AttachmentRid),
            'title': ConjureFieldDefinition('title', str),
            's3_path': ConjureFieldDefinition('s3Path', attachments_api_S3Path),
            'file_type': ConjureFieldDefinition('fileType', str),
            'description': ConjureFieldDefinition('description', str),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'properties': ConjureFieldDefinition('properties', Dict[attachments_api_PropertyName, attachments_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[attachments_api_Label]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_title', '_s3_path', '_file_type', '_description', '_created_by', '_properties', '_labels', '_created_at', '_is_archived']

    def __init__(self, created_at: str, created_by: str, description: str, file_type: str, is_archived: bool, labels: List[str], properties: Dict[str, str], rid: str, s3_path: str, title: str) -> None:
        self._rid = rid
        self._title = title
        self._s3_path = s3_path
        self._file_type = file_type
        self._description = description
        self._created_by = created_by
        self._properties = properties
        self._labels = labels
        self._created_at = created_at
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def s3_path(self) -> str:
        return self._s3_path

    @builtins.property
    def file_type(self) -> str:
        return self._file_type

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


attachments_api_Attachment.__name__ = "Attachment"
attachments_api_Attachment.__qualname__ = "Attachment"
attachments_api_Attachment.__module__ = "scout_service_api.attachments_api"


class attachments_api_AttachmentService(Service):
    """
    The attachment service provides functionality for creating, updating, and archiving attachments uploaded to S3.
    """

    def create(self, auth_header: str, request: "attachments_api_CreateAttachmentRequest") -> "attachments_api_Attachment":
        """
        Create a new attachment. Assumes the file is already uploaded to S3 through the upload service.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/attachments/v1/attachments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), attachments_api_Attachment, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, rid: str) -> "attachments_api_Attachment":
        """
        Get an attachment by its RID.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/attachments/v1/attachments/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), attachments_api_Attachment, self._return_none_for_unknown_union_types)

    def get_batch(self, auth_header: str, request: "attachments_api_GetAttachmentsRequest") -> "attachments_api_GetAttachmentsResponse":
        """
        Get a set of attachments by their RIDs.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/attachments/v1/attachments/batch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), attachments_api_GetAttachmentsResponse, self._return_none_for_unknown_union_types)

    def get_content(self, auth_header: str, rid: str) -> Any:
        """
        Get the binary content of an attachment.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/attachments/v1/attachments/{rid}/content'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw

    def update(self, auth_header: str, request: "attachments_api_UpdateAttachmentRequest", rid: str) -> "attachments_api_Attachment":
        """
        Update an attachment. Only the fields that are set in the request will be updated.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/attachments/v1/attachments/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), attachments_api_Attachment, self._return_none_for_unknown_union_types)

    def archive(self, auth_header: str, rid: str) -> None:
        """
        Archive an attachment.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/attachments/v1/attachments/{rid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, rid: str) -> None:
        """
        Unarchive an attachment.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/attachments/v1/attachments/{rid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


attachments_api_AttachmentService.__name__ = "AttachmentService"
attachments_api_AttachmentService.__qualname__ = "AttachmentService"
attachments_api_AttachmentService.__module__ = "scout_service_api.attachments_api"


class attachments_api_CreateAttachmentRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3_path': ConjureFieldDefinition('s3Path', attachments_api_S3Path),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'properties': ConjureFieldDefinition('properties', Dict[attachments_api_PropertyName, attachments_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[attachments_api_Label])
        }

    __slots__: List[str] = ['_s3_path', '_title', '_description', '_properties', '_labels']

    def __init__(self, description: str, labels: List[str], properties: Dict[str, str], s3_path: str, title: str) -> None:
        self._s3_path = s3_path
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels

    @builtins.property
    def s3_path(self) -> str:
        return self._s3_path

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


attachments_api_CreateAttachmentRequest.__name__ = "CreateAttachmentRequest"
attachments_api_CreateAttachmentRequest.__qualname__ = "CreateAttachmentRequest"
attachments_api_CreateAttachmentRequest.__module__ = "scout_service_api.attachments_api"


class attachments_api_GetAttachmentsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'attachment_rids': ConjureFieldDefinition('attachmentRids', List[attachments_api_AttachmentRid])
        }

    __slots__: List[str] = ['_attachment_rids']

    def __init__(self, attachment_rids: List[str]) -> None:
        self._attachment_rids = attachment_rids

    @builtins.property
    def attachment_rids(self) -> List[str]:
        return self._attachment_rids


attachments_api_GetAttachmentsRequest.__name__ = "GetAttachmentsRequest"
attachments_api_GetAttachmentsRequest.__qualname__ = "GetAttachmentsRequest"
attachments_api_GetAttachmentsRequest.__module__ = "scout_service_api.attachments_api"


class attachments_api_GetAttachmentsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'response': ConjureFieldDefinition('response', List[attachments_api_Attachment])
        }

    __slots__: List[str] = ['_response']

    def __init__(self, response: List["attachments_api_Attachment"]) -> None:
        self._response = response

    @builtins.property
    def response(self) -> List["attachments_api_Attachment"]:
        return self._response


attachments_api_GetAttachmentsResponse.__name__ = "GetAttachmentsResponse"
attachments_api_GetAttachmentsResponse.__qualname__ = "GetAttachmentsResponse"
attachments_api_GetAttachmentsResponse.__module__ = "scout_service_api.attachments_api"


class attachments_api_Property(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', attachments_api_PropertyName),
            'value': ConjureFieldDefinition('value', attachments_api_PropertyValue)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


attachments_api_Property.__name__ = "Property"
attachments_api_Property.__qualname__ = "Property"
attachments_api_Property.__module__ = "scout_service_api.attachments_api"


class attachments_api_SearchAttachmentsQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["attachments_api_Property"] = None
    _and_: Optional[List["attachments_api_SearchAttachmentsQuery"]] = None
    _or_: Optional[List["attachments_api_SearchAttachmentsQuery"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', attachments_api_Label),
            'property': ConjureFieldDefinition('property', attachments_api_Property),
            'and_': ConjureFieldDefinition('and', List[attachments_api_SearchAttachmentsQuery]),
            'or_': ConjureFieldDefinition('or', List[attachments_api_SearchAttachmentsQuery])
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["attachments_api_Property"] = None,
            and_: Optional[List["attachments_api_SearchAttachmentsQuery"]] = None,
            or_: Optional[List["attachments_api_SearchAttachmentsQuery"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["attachments_api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["attachments_api_SearchAttachmentsQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["attachments_api_SearchAttachmentsQuery"]]:
        return self._or_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, attachments_api_SearchAttachmentsQueryVisitor):
            raise ValueError('{} is not an instance of attachments_api_SearchAttachmentsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)


attachments_api_SearchAttachmentsQuery.__name__ = "SearchAttachmentsQuery"
attachments_api_SearchAttachmentsQuery.__qualname__ = "SearchAttachmentsQuery"
attachments_api_SearchAttachmentsQuery.__module__ = "scout_service_api.attachments_api"


class attachments_api_SearchAttachmentsQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "attachments_api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["attachments_api_SearchAttachmentsQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["attachments_api_SearchAttachmentsQuery"]) -> Any:
        pass


attachments_api_SearchAttachmentsQueryVisitor.__name__ = "SearchAttachmentsQueryVisitor"
attachments_api_SearchAttachmentsQueryVisitor.__qualname__ = "SearchAttachmentsQueryVisitor"
attachments_api_SearchAttachmentsQueryVisitor.__module__ = "scout_service_api.attachments_api"


class attachments_api_UpdateAttachmentRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[attachments_api_PropertyName, attachments_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[attachments_api_Label]])
        }

    __slots__: List[str] = ['_title', '_description', '_properties', '_labels']

    def __init__(self, description: Optional[str] = None, labels: Optional[List[str]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels


attachments_api_UpdateAttachmentRequest.__name__ = "UpdateAttachmentRequest"
attachments_api_UpdateAttachmentRequest.__qualname__ = "UpdateAttachmentRequest"
attachments_api_UpdateAttachmentRequest.__module__ = "scout_service_api.attachments_api"


class authentication_AddToOrganizationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'user_uuid': ConjureFieldDefinition('userUuid', str),
            'org_uuid': ConjureFieldDefinition('orgUuid', str)
        }

    __slots__: List[str] = ['_user_uuid', '_org_uuid']

    def __init__(self, org_uuid: str, user_uuid: str) -> None:
        self._user_uuid = user_uuid
        self._org_uuid = org_uuid

    @builtins.property
    def user_uuid(self) -> str:
        return self._user_uuid

    @builtins.property
    def org_uuid(self) -> str:
        return self._org_uuid


authentication_AddToOrganizationRequest.__name__ = "AddToOrganizationRequest"
authentication_AddToOrganizationRequest.__qualname__ = "AddToOrganizationRequest"
authentication_AddToOrganizationRequest.__module__ = "scout_service_api.authentication"


class authentication_AuthenticationService(Service):
    """
    An internal-use-only service for managing users and org-memberships.
    """

    def create_user(self, auth_header: str, request: "authentication_CreateUserRequest") -> "authentication_User":
        """
        Only admins can create users.
Will throw if a user with the same email already exists.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/authentication/v1/users'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_User, self._return_none_for_unknown_union_types)

    def add_to_organization(self, auth_header: str, request: "authentication_AddToOrganizationRequest") -> None:
        """
        Only admins can add users to organizations.
Will throw if the user is already in the organization.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/authentication/v1/users/add-to-organization'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


authentication_AuthenticationService.__name__ = "AuthenticationService"
authentication_AuthenticationService.__qualname__ = "AuthenticationService"
authentication_AuthenticationService.__module__ = "scout_service_api.authentication"


class authentication_CreateUserRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', str),
            'email': ConjureFieldDefinition('email', str),
            'org_uuid': ConjureFieldDefinition('orgUuid', str)
        }

    __slots__: List[str] = ['_display_name', '_email', '_org_uuid']

    def __init__(self, display_name: str, email: str, org_uuid: str) -> None:
        self._display_name = display_name
        self._email = email
        self._org_uuid = org_uuid

    @builtins.property
    def display_name(self) -> str:
        return self._display_name

    @builtins.property
    def email(self) -> str:
        return self._email

    @builtins.property
    def org_uuid(self) -> str:
        return self._org_uuid


authentication_CreateUserRequest.__name__ = "CreateUserRequest"
authentication_CreateUserRequest.__qualname__ = "CreateUserRequest"
authentication_CreateUserRequest.__module__ = "scout_service_api.authentication"


class authentication_User(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', str),
            'uuid': ConjureFieldDefinition('uuid', OptionalTypeWrapper[str]),
            'display_name': ConjureFieldDefinition('displayName', str),
            'username': ConjureFieldDefinition('username', OptionalTypeWrapper[str]),
            'email': ConjureFieldDefinition('email', str),
            'org_rid': ConjureFieldDefinition('orgRid', str)
        }

    __slots__: List[str] = ['_rid', '_uuid', '_display_name', '_username', '_email', '_org_rid']

    def __init__(self, display_name: str, email: str, org_rid: str, rid: str, username: Optional[str] = None, uuid: Optional[str] = None) -> None:
        self._rid = rid
        self._uuid = uuid
        self._display_name = display_name
        self._username = username
        self._email = email
        self._org_rid = org_rid

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def uuid(self) -> Optional[str]:
        return self._uuid

    @builtins.property
    def display_name(self) -> str:
        return self._display_name

    @builtins.property
    def username(self) -> Optional[str]:
        return self._username

    @builtins.property
    def email(self) -> str:
        return self._email

    @builtins.property
    def org_rid(self) -> str:
        return self._org_rid


authentication_User.__name__ = "User"
authentication_User.__qualname__ = "User"
authentication_User.__module__ = "scout_service_api.authentication"


class authentication_api_AppearanceSetting(ConjureEnumType):

    SYSTEM = 'SYSTEM'
    '''SYSTEM'''
    LIGHT = 'LIGHT'
    '''LIGHT'''
    DARK = 'DARK'
    '''DARK'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authentication_api_AppearanceSetting.__name__ = "AppearanceSetting"
authentication_api_AppearanceSetting.__qualname__ = "AppearanceSetting"
authentication_api_AppearanceSetting.__module__ = "scout_service_api.authentication_api"


class authentication_api_AuthenticationServiceV2(Service):
    """
    This service provides operations for managing user and org profiles/settings.
Its name is a bit of a misnomer.
    """

    def get_my_profile(self, auth_header: str) -> "authentication_api_UserV2":
        """
        Gets the profile of the authenticated user.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/authentication/v2/my/profile'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserV2, self._return_none_for_unknown_union_types)

    def update_my_profile(self, auth_header: str, update_my_profile_request: "authentication_api_UpdateMyProfileRequest") -> "authentication_api_UserV2":
        """
        Updates the profile of the authenticated user.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(update_my_profile_request)

        _path = '/authentication/v2/my/profile'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserV2, self._return_none_for_unknown_union_types)

    def get_my_settings(self, auth_header: str) -> "authentication_api_UserSettings":
        """
        Gets the settings of the authenticated user.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/authentication/v2/my/settings'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserSettings, self._return_none_for_unknown_union_types)

    def update_my_settings(self, auth_header: str, user_settings: "authentication_api_UserSettings") -> "authentication_api_UserSettings":
        """
        Updates the settings of the authenticated user.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(user_settings)

        _path = '/authentication/v2/my/settings'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserSettings, self._return_none_for_unknown_union_types)

    def get_my_org_settings(self, auth_header: str) -> "authentication_api_OrgSettings":
        """
        Gets the settings of the org of the authenticated user.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/authentication/v2/org/settings'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_OrgSettings, self._return_none_for_unknown_union_types)

    def update_my_org_settings(self, auth_header: str, org_settings: "authentication_api_OrgSettings") -> "authentication_api_OrgSettings":
        """
        Updates the settings of the org of the authenticated user.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(org_settings)

        _path = '/authentication/v2/org/settings'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_OrgSettings, self._return_none_for_unknown_union_types)

    def search_users(self, auth_header: str, page: Optional[int] = None, page_size: Optional[int] = None, search_text: Optional[str] = None) -> "authentication_api_SearchUsersResponse":
        """
        Searches for users by email and displayName.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'searchText': search_text,
            'page': page,
            'pageSize': page_size,
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/authentication/v2/users'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_SearchUsersResponse, self._return_none_for_unknown_union_types)

    def search_users_v2(self, auth_header: str, request: "authentication_api_SearchUsersRequest") -> "authentication_api_SearchUsersResponseV2":
        """
        Searches for users by email and displayName.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/authentication/v2/users'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_SearchUsersResponseV2, self._return_none_for_unknown_union_types)

    def get_users(self, auth_header: str, user_rids: List[str] = None) -> List["authentication_api_UserV2"]:
        """
        Get users by RID.
        """
        user_rids = user_rids if user_rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(user_rids)

        _path = '/authentication/v2/users/batch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[authentication_api_UserV2], self._return_none_for_unknown_union_types)

    def get_user(self, auth_header: str, user_rid: str) -> "authentication_api_UserV2":
        """
        Gets a user by RID.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'userRid': user_rid,
        }

        _json: Any = None

        _path = '/authentication/v2/users/{userRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserV2, self._return_none_for_unknown_union_types)


authentication_api_AuthenticationServiceV2.__name__ = "AuthenticationServiceV2"
authentication_api_AuthenticationServiceV2.__qualname__ = "AuthenticationServiceV2"
authentication_api_AuthenticationServiceV2.__module__ = "scout_service_api.authentication_api"


class authentication_api_DefaultTimeRangeTypeSetting(ConjureEnumType):

    DEFAULT = 'DEFAULT'
    '''DEFAULT'''
    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authentication_api_DefaultTimeRangeTypeSetting.__name__ = "DefaultTimeRangeTypeSetting"
authentication_api_DefaultTimeRangeTypeSetting.__qualname__ = "DefaultTimeRangeTypeSetting"
authentication_api_DefaultTimeRangeTypeSetting.__module__ = "scout_service_api.authentication_api"


class authentication_api_OrgSettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'default_time_range_type': ConjureFieldDefinition('defaultTimeRangeType', OptionalTypeWrapper[authentication_api_DefaultTimeRangeTypeSetting])
        }

    __slots__: List[str] = ['_default_time_range_type']

    def __init__(self, default_time_range_type: Optional["authentication_api_DefaultTimeRangeTypeSetting"] = None) -> None:
        self._default_time_range_type = default_time_range_type

    @builtins.property
    def default_time_range_type(self) -> Optional["authentication_api_DefaultTimeRangeTypeSetting"]:
        return self._default_time_range_type


authentication_api_OrgSettings.__name__ = "OrgSettings"
authentication_api_OrgSettings.__qualname__ = "OrgSettings"
authentication_api_OrgSettings.__module__ = "scout_service_api.authentication_api"


class authentication_api_SearchUsersQuery(ConjureUnionType):
    _and_: Optional[List["authentication_api_SearchUsersQuery"]] = None
    _or_: Optional[List["authentication_api_SearchUsersQuery"]] = None
    _exact_match: Optional[str] = None
    _search_text: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', List[authentication_api_SearchUsersQuery]),
            'or_': ConjureFieldDefinition('or', List[authentication_api_SearchUsersQuery]),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'search_text': ConjureFieldDefinition('searchText', str)
        }

    def __init__(
            self,
            and_: Optional[List["authentication_api_SearchUsersQuery"]] = None,
            or_: Optional[List["authentication_api_SearchUsersQuery"]] = None,
            exact_match: Optional[str] = None,
            search_text: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (exact_match is not None) + (search_text is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'

    @builtins.property
    def and_(self) -> Optional[List["authentication_api_SearchUsersQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["authentication_api_SearchUsersQuery"]]:
        return self._or_

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """
        Performs case insensitive exact match on email
        """
        return self._exact_match

    @builtins.property
    def search_text(self) -> Optional[str]:
        """
        Searches email and display name
        """
        return self._search_text

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, authentication_api_SearchUsersQueryVisitor):
            raise ValueError('{} is not an instance of authentication_api_SearchUsersQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)


authentication_api_SearchUsersQuery.__name__ = "SearchUsersQuery"
authentication_api_SearchUsersQuery.__qualname__ = "SearchUsersQuery"
authentication_api_SearchUsersQuery.__module__ = "scout_service_api.authentication_api"


class authentication_api_SearchUsersQueryVisitor:

    @abstractmethod
    def _and(self, and_: List["authentication_api_SearchUsersQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["authentication_api_SearchUsersQuery"]) -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass


authentication_api_SearchUsersQueryVisitor.__name__ = "SearchUsersQueryVisitor"
authentication_api_SearchUsersQueryVisitor.__qualname__ = "SearchUsersQueryVisitor"
authentication_api_SearchUsersQueryVisitor.__module__ = "scout_service_api.authentication_api"


class authentication_api_SearchUsersRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', authentication_api_SearchUsersQuery),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[authentication_api_SortBy]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[authentication_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_query', '_sort_by', '_next_page_token', '_page_size']

    def __init__(self, query: "authentication_api_SearchUsersQuery", next_page_token: Optional[str] = None, page_size: Optional[int] = None, sort_by: Optional["authentication_api_SortBy"] = None) -> None:
        self._query = query
        self._sort_by = sort_by
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def query(self) -> "authentication_api_SearchUsersQuery":
        return self._query

    @builtins.property
    def sort_by(self) -> Optional["authentication_api_SortBy"]:
        """
        UPDATED_AT descending by default
        """
        return self._sort_by

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size


authentication_api_SearchUsersRequest.__name__ = "SearchUsersRequest"
authentication_api_SearchUsersRequest.__qualname__ = "SearchUsersRequest"
authentication_api_SearchUsersRequest.__module__ = "scout_service_api.authentication_api"


class authentication_api_SearchUsersResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'users': ConjureFieldDefinition('users', List[authentication_api_UserV2]),
            'total': ConjureFieldDefinition('total', int)
        }

    __slots__: List[str] = ['_users', '_total']

    def __init__(self, total: int, users: List["authentication_api_UserV2"]) -> None:
        self._users = users
        self._total = total

    @builtins.property
    def users(self) -> List["authentication_api_UserV2"]:
        return self._users

    @builtins.property
    def total(self) -> int:
        return self._total


authentication_api_SearchUsersResponse.__name__ = "SearchUsersResponse"
authentication_api_SearchUsersResponse.__qualname__ = "SearchUsersResponse"
authentication_api_SearchUsersResponse.__module__ = "scout_service_api.authentication_api"


class authentication_api_SearchUsersResponseV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[authentication_api_UserV2]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[authentication_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["authentication_api_UserV2"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["authentication_api_UserV2"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


authentication_api_SearchUsersResponseV2.__name__ = "SearchUsersResponseV2"
authentication_api_SearchUsersResponseV2.__qualname__ = "SearchUsersResponseV2"
authentication_api_SearchUsersResponseV2.__module__ = "scout_service_api.authentication_api"


class authentication_api_SortBy(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', authentication_api_SortByField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "authentication_api_SortByField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "authentication_api_SortByField":
        return self._field


authentication_api_SortBy.__name__ = "SortBy"
authentication_api_SortBy.__qualname__ = "SortBy"
authentication_api_SortBy.__module__ = "scout_service_api.authentication_api"


class authentication_api_SortByField(ConjureEnumType):

    NAME = 'NAME'
    '''NAME'''
    EMAIL = 'EMAIL'
    '''EMAIL'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UPDATED_AT = 'UPDATED_AT'
    '''UPDATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authentication_api_SortByField.__name__ = "SortByField"
authentication_api_SortByField.__qualname__ = "SortByField"
authentication_api_SortByField.__module__ = "scout_service_api.authentication_api"


class authentication_api_TimezoneSetting(ConjureEnumType):

    LOCAL = 'LOCAL'
    '''LOCAL'''
    UTC = 'UTC'
    '''UTC'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authentication_api_TimezoneSetting.__name__ = "TimezoneSetting"
authentication_api_TimezoneSetting.__qualname__ = "TimezoneSetting"
authentication_api_TimezoneSetting.__module__ = "scout_service_api.authentication_api"


class authentication_api_UpdateMyProfileRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', str)
        }

    __slots__: List[str] = ['_display_name']

    def __init__(self, display_name: str) -> None:
        self._display_name = display_name

    @builtins.property
    def display_name(self) -> str:
        return self._display_name


authentication_api_UpdateMyProfileRequest.__name__ = "UpdateMyProfileRequest"
authentication_api_UpdateMyProfileRequest.__qualname__ = "UpdateMyProfileRequest"
authentication_api_UpdateMyProfileRequest.__module__ = "scout_service_api.authentication_api"


class authentication_api_UserSettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'default_time_range_type': ConjureFieldDefinition('defaultTimeRangeType', OptionalTypeWrapper[authentication_api_DefaultTimeRangeTypeSetting]),
            'appearance': ConjureFieldDefinition('appearance', OptionalTypeWrapper[authentication_api_AppearanceSetting]),
            'timezone': ConjureFieldDefinition('timezone', OptionalTypeWrapper[authentication_api_TimezoneSetting]),
            'time_series_hover_tooltip_concise': ConjureFieldDefinition('timeSeriesHoverTooltipConcise', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_default_time_range_type', '_appearance', '_timezone', '_time_series_hover_tooltip_concise']

    def __init__(self, appearance: Optional["authentication_api_AppearanceSetting"] = None, default_time_range_type: Optional["authentication_api_DefaultTimeRangeTypeSetting"] = None, time_series_hover_tooltip_concise: Optional[bool] = None, timezone: Optional["authentication_api_TimezoneSetting"] = None) -> None:
        self._default_time_range_type = default_time_range_type
        self._appearance = appearance
        self._timezone = timezone
        self._time_series_hover_tooltip_concise = time_series_hover_tooltip_concise

    @builtins.property
    def default_time_range_type(self) -> Optional["authentication_api_DefaultTimeRangeTypeSetting"]:
        return self._default_time_range_type

    @builtins.property
    def appearance(self) -> Optional["authentication_api_AppearanceSetting"]:
        return self._appearance

    @builtins.property
    def timezone(self) -> Optional["authentication_api_TimezoneSetting"]:
        return self._timezone

    @builtins.property
    def time_series_hover_tooltip_concise(self) -> Optional[bool]:
        return self._time_series_hover_tooltip_concise


authentication_api_UserSettings.__name__ = "UserSettings"
authentication_api_UserSettings.__qualname__ = "UserSettings"
authentication_api_UserSettings.__module__ = "scout_service_api.authentication_api"


class authentication_api_UserV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', authentication_api_UserRid),
            'org_rid': ConjureFieldDefinition('orgRid', authentication_api_OrgRid),
            'email': ConjureFieldDefinition('email', str),
            'display_name': ConjureFieldDefinition('displayName', str),
            'avatar_url': ConjureFieldDefinition('avatarUrl', str)
        }

    __slots__: List[str] = ['_rid', '_org_rid', '_email', '_display_name', '_avatar_url']

    def __init__(self, avatar_url: str, display_name: str, email: str, org_rid: str, rid: str) -> None:
        self._rid = rid
        self._org_rid = org_rid
        self._email = email
        self._display_name = display_name
        self._avatar_url = avatar_url

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def org_rid(self) -> str:
        return self._org_rid

    @builtins.property
    def email(self) -> str:
        return self._email

    @builtins.property
    def display_name(self) -> str:
        return self._display_name

    @builtins.property
    def avatar_url(self) -> str:
        """
        Avatar URL or a default avatar if the user does not have one.
        """
        return self._avatar_url


authentication_api_UserV2.__name__ = "UserV2"
authentication_api_UserV2.__qualname__ = "UserV2"
authentication_api_UserV2.__module__ = "scout_service_api.authentication_api"


class authorization_AppendOrgAssignmentRulesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rules': ConjureFieldDefinition('rules', List[authorization_OrgAssignmentRule]),
            'last_version': ConjureFieldDefinition('lastVersion', int)
        }

    __slots__: List[str] = ['_rules', '_last_version']

    def __init__(self, last_version: int, rules: List["authorization_OrgAssignmentRule"]) -> None:
        self._rules = rules
        self._last_version = last_version

    @builtins.property
    def rules(self) -> List["authorization_OrgAssignmentRule"]:
        return self._rules

    @builtins.property
    def last_version(self) -> int:
        return self._last_version


authorization_AppendOrgAssignmentRulesRequest.__name__ = "AppendOrgAssignmentRulesRequest"
authorization_AppendOrgAssignmentRulesRequest.__qualname__ = "AppendOrgAssignmentRulesRequest"
authorization_AppendOrgAssignmentRulesRequest.__module__ = "scout_service_api.authorization"


class authorization_AuthorizationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[str])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


authorization_AuthorizationRequest.__name__ = "AuthorizationRequest"
authorization_AuthorizationRequest.__qualname__ = "AuthorizationRequest"
authorization_AuthorizationRequest.__module__ = "scout_service_api.authorization"


class authorization_AuthorizationService(Service):
    """
    Authorization service manages the permissions for a user
to access resources.
    """

    def authorize(self, auth_header: str, authorize_request: "authorization_AuthorizationRequest") -> List[str]:
        """
        Given a set of resources, returns the set of resources that the
user is authorized to access, per their organization.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(authorize_request)

        _path = '/authorization/v1/authorize'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[str], self._return_none_for_unknown_union_types)

    def register(self, auth_header: str, register_request: "authorization_RegistrationRequest") -> None:
        """
        Marks a resource as belonging to an organization.
Will throw if trying to register a resource that already
belongs to a different organization.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(register_request)

        _path = '/authorization/v1/register'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def check_admin(self, auth_header: str) -> None:
        """
        Given an authenticated session, this endpoint returns a HTTP 204 if the
authenticated user is an admin and HTTP 403 otherwise.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/authorization/v1/checkAdmin'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_access_token(self, request: "authorization_GetAccessTokenRequest") -> "authorization_GetAccessTokenResponse":
        """
        Provide an OIDC ID and access token to get a Nominal access token,
suitable for making API requests. Its expiry will match that of the
input access token, capped at 24h.
Throws NotAuthorized if either token is invalid or if the OIDC provider
is not known.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/authorization/v1/access-token'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_GetAccessTokenResponse, self._return_none_for_unknown_union_types)

    def get_org_assignment_rules(self, auth_header: str) -> "authorization_OrgAssignmentRulesResponse":
        """
        Gets the current org assignment rules.
Throws if the caller is not an admin.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/authorization/v1/org-assignment-rules'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_OrgAssignmentRulesResponse, self._return_none_for_unknown_union_types)

    def set_all_org_assignment_rules(self, auth_header: str, request: "authorization_SetOrgAssignmentRulesRequest") -> "authorization_OrgAssignmentRulesResponse":
        """
        Sets the org assignment rules, requiring the last known version
to avoid race conditions.
Throws if the caller is not an admin.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/authorization/v1/org-assignment-rules/set-all'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_OrgAssignmentRulesResponse, self._return_none_for_unknown_union_types)

    def append_org_assignment_rules(self, auth_header: str, request: "authorization_AppendOrgAssignmentRulesRequest") -> "authorization_OrgAssignmentRulesResponse":
        """
        Appends new org assignment rules to the current rules.
Pass the last known version to avoid race condition.
Throws if the caller is not an admin.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/authorization/v1/org-assignment-rules/append'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_OrgAssignmentRulesResponse, self._return_none_for_unknown_union_types)

    def get_user_filters(self, auth_header: str) -> "authorization_UserFiltersResponse":
        """
        Gets the user filters.
Throws if the caller is not an admin.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/authorization/v1/user-filters'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_UserFiltersResponse, self._return_none_for_unknown_union_types)

    def set_user_filter_for_one_org(self, auth_header: str, request: "authorization_SetUserFilterForOneOrgRequest") -> "authorization_UserFiltersResponse":
        """
        Sets the user filters for the specified org, overwriting
any existing filter. Requires the last known version to avoid
race conditions.
Throws if the caller is not an admin.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/authorization/v1/user-filters/set-one'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_UserFiltersResponse, self._return_none_for_unknown_union_types)

    def remove_user_filter_for_one_org(self, auth_header: str, request: "authorization_RemoveUserFilterForOneOrgRequest") -> "authorization_UserFiltersResponse":
        """
        Removes the user filter for an org. Requires the last known
version to avoid race conditions.
Throws if the caller is not an admin.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/authorization/v1/user-filters/remove-one'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_UserFiltersResponse, self._return_none_for_unknown_union_types)


authorization_AuthorizationService.__name__ = "AuthorizationService"
authorization_AuthorizationService.__qualname__ = "AuthorizationService"
authorization_AuthorizationService.__module__ = "scout_service_api.authorization"


class authorization_Condition(ConjureUnionType):
    """A condition to be evaluated on the ID token's claims"""
    _or_: Optional[List["authorization_Condition"]] = None
    _and_: Optional[List["authorization_Condition"]] = None
    _not_: Optional["authorization_Condition"] = None
    _exact: Optional["authorization_ExactClaimCondition"] = None
    _regex: Optional["authorization_RegexClaimCondition"] = None
    _contains: Optional["authorization_ContainsClaimCondition"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'or_': ConjureFieldDefinition('or', List[authorization_Condition]),
            'and_': ConjureFieldDefinition('and', List[authorization_Condition]),
            'not_': ConjureFieldDefinition('not', authorization_Condition),
            'exact': ConjureFieldDefinition('exact', authorization_ExactClaimCondition),
            'regex': ConjureFieldDefinition('regex', authorization_RegexClaimCondition),
            'contains': ConjureFieldDefinition('contains', authorization_ContainsClaimCondition)
        }

    def __init__(
            self,
            or_: Optional[List["authorization_Condition"]] = None,
            and_: Optional[List["authorization_Condition"]] = None,
            not_: Optional["authorization_Condition"] = None,
            exact: Optional["authorization_ExactClaimCondition"] = None,
            regex: Optional["authorization_RegexClaimCondition"] = None,
            contains: Optional["authorization_ContainsClaimCondition"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (or_ is not None) + (and_ is not None) + (not_ is not None) + (exact is not None) + (regex is not None) + (contains is not None) != 1:
                raise ValueError('a union must contain a single member')

            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if exact is not None:
                self._exact = exact
                self._type = 'exact'
            if regex is not None:
                self._regex = regex
                self._type = 'regex'
            if contains is not None:
                self._contains = contains
                self._type = 'contains'

        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'exact':
            if exact is None:
                raise ValueError('a union value must not be None')
            self._exact = exact
            self._type = 'exact'
        elif type_of_union == 'regex':
            if regex is None:
                raise ValueError('a union value must not be None')
            self._regex = regex
            self._type = 'regex'
        elif type_of_union == 'contains':
            if contains is None:
                raise ValueError('a union value must not be None')
            self._contains = contains
            self._type = 'contains'

    @builtins.property
    def or_(self) -> Optional[List["authorization_Condition"]]:
        return self._or_

    @builtins.property
    def and_(self) -> Optional[List["authorization_Condition"]]:
        return self._and_

    @builtins.property
    def not_(self) -> Optional["authorization_Condition"]:
        return self._not_

    @builtins.property
    def exact(self) -> Optional["authorization_ExactClaimCondition"]:
        return self._exact

    @builtins.property
    def regex(self) -> Optional["authorization_RegexClaimCondition"]:
        return self._regex

    @builtins.property
    def contains(self) -> Optional["authorization_ContainsClaimCondition"]:
        return self._contains

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, authorization_ConditionVisitor):
            raise ValueError('{} is not an instance of authorization_ConditionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'exact' and self.exact is not None:
            return visitor._exact(self.exact)
        if self._type == 'regex' and self.regex is not None:
            return visitor._regex(self.regex)
        if self._type == 'contains' and self.contains is not None:
            return visitor._contains(self.contains)


authorization_Condition.__name__ = "Condition"
authorization_Condition.__qualname__ = "Condition"
authorization_Condition.__module__ = "scout_service_api.authorization"


class authorization_ConditionVisitor:

    @abstractmethod
    def _or(self, or_: List["authorization_Condition"]) -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["authorization_Condition"]) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "authorization_Condition") -> Any:
        pass

    @abstractmethod
    def _exact(self, exact: "authorization_ExactClaimCondition") -> Any:
        pass

    @abstractmethod
    def _regex(self, regex: "authorization_RegexClaimCondition") -> Any:
        pass

    @abstractmethod
    def _contains(self, contains: "authorization_ContainsClaimCondition") -> Any:
        pass


authorization_ConditionVisitor.__name__ = "ConditionVisitor"
authorization_ConditionVisitor.__qualname__ = "ConditionVisitor"
authorization_ConditionVisitor.__module__ = "scout_service_api.authorization"


class authorization_ContainsClaimCondition(ConjureBeanType):
    """
    Returns true if the claim's value (expected to be an array)
contains the given value.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'array_claim': ConjureFieldDefinition('arrayClaim', str),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_array_claim', '_value']

    def __init__(self, array_claim: str, value: str) -> None:
        self._array_claim = array_claim
        self._value = value

    @builtins.property
    def array_claim(self) -> str:
        return self._array_claim

    @builtins.property
    def value(self) -> str:
        return self._value


authorization_ContainsClaimCondition.__name__ = "ContainsClaimCondition"
authorization_ContainsClaimCondition.__qualname__ = "ContainsClaimCondition"
authorization_ContainsClaimCondition.__module__ = "scout_service_api.authorization"


class authorization_ExactClaimCondition(ConjureBeanType):
    """
    Returns true if the claim's value matches the given value
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'claim': ConjureFieldDefinition('claim', str),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_claim', '_value']

    def __init__(self, claim: str, value: str) -> None:
        self._claim = claim
        self._value = value

    @builtins.property
    def claim(self) -> str:
        return self._claim

    @builtins.property
    def value(self) -> str:
        return self._value


authorization_ExactClaimCondition.__name__ = "ExactClaimCondition"
authorization_ExactClaimCondition.__qualname__ = "ExactClaimCondition"
authorization_ExactClaimCondition.__module__ = "scout_service_api.authorization"


class authorization_GetAccessTokenRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id_token': ConjureFieldDefinition('idToken', str),
            'access_token': ConjureFieldDefinition('accessToken', str)
        }

    __slots__: List[str] = ['_id_token', '_access_token']

    def __init__(self, access_token: str, id_token: str) -> None:
        self._id_token = id_token
        self._access_token = access_token

    @builtins.property
    def id_token(self) -> str:
        return self._id_token

    @builtins.property
    def access_token(self) -> str:
        """
        The access token's audience must be for the Nominal API.
        """
        return self._access_token


authorization_GetAccessTokenRequest.__name__ = "GetAccessTokenRequest"
authorization_GetAccessTokenRequest.__qualname__ = "GetAccessTokenRequest"
authorization_GetAccessTokenRequest.__module__ = "scout_service_api.authorization"


class authorization_GetAccessTokenResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'access_token': ConjureFieldDefinition('accessToken', str),
            'expires_at_seconds': ConjureFieldDefinition('expiresAtSeconds', int),
            'user_uuid': ConjureFieldDefinition('userUuid', str),
            'org_uuid': ConjureFieldDefinition('orgUuid', str)
        }

    __slots__: List[str] = ['_access_token', '_expires_at_seconds', '_user_uuid', '_org_uuid']

    def __init__(self, access_token: str, expires_at_seconds: int, org_uuid: str, user_uuid: str) -> None:
        self._access_token = access_token
        self._expires_at_seconds = expires_at_seconds
        self._user_uuid = user_uuid
        self._org_uuid = org_uuid

    @builtins.property
    def access_token(self) -> str:
        return self._access_token

    @builtins.property
    def expires_at_seconds(self) -> int:
        return self._expires_at_seconds

    @builtins.property
    def user_uuid(self) -> str:
        return self._user_uuid

    @builtins.property
    def org_uuid(self) -> str:
        return self._org_uuid


authorization_GetAccessTokenResponse.__name__ = "GetAccessTokenResponse"
authorization_GetAccessTokenResponse.__qualname__ = "GetAccessTokenResponse"
authorization_GetAccessTokenResponse.__module__ = "scout_service_api.authorization"


class authorization_OrgAssignmentRule(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'condition': ConjureFieldDefinition('condition', authorization_Condition),
            'org_rid': ConjureFieldDefinition('orgRid', authorization_OrgRid)
        }

    __slots__: List[str] = ['_condition', '_org_rid']

    def __init__(self, condition: "authorization_Condition", org_rid: str) -> None:
        self._condition = condition
        self._org_rid = org_rid

    @builtins.property
    def condition(self) -> "authorization_Condition":
        return self._condition

    @builtins.property
    def org_rid(self) -> str:
        return self._org_rid


authorization_OrgAssignmentRule.__name__ = "OrgAssignmentRule"
authorization_OrgAssignmentRule.__qualname__ = "OrgAssignmentRule"
authorization_OrgAssignmentRule.__module__ = "scout_service_api.authorization"


class authorization_OrgAssignmentRulesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rules': ConjureFieldDefinition('rules', List[authorization_OrgAssignmentRule]),
            'version': ConjureFieldDefinition('version', int)
        }

    __slots__: List[str] = ['_rules', '_version']

    def __init__(self, rules: List["authorization_OrgAssignmentRule"], version: int) -> None:
        self._rules = rules
        self._version = version

    @builtins.property
    def rules(self) -> List["authorization_OrgAssignmentRule"]:
        """
        The first rule that matches will be used to assign a user to an org.
If a user does not match any rule, they will be rejected.
        """
        return self._rules

    @builtins.property
    def version(self) -> int:
        return self._version


authorization_OrgAssignmentRulesResponse.__name__ = "OrgAssignmentRulesResponse"
authorization_OrgAssignmentRulesResponse.__qualname__ = "OrgAssignmentRulesResponse"
authorization_OrgAssignmentRulesResponse.__module__ = "scout_service_api.authorization"


class authorization_RegexClaimCondition(ConjureBeanType):
    """
    Returns true if the claim's value matches the given regex
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'claim': ConjureFieldDefinition('claim', str),
            'regex': ConjureFieldDefinition('regex', str)
        }

    __slots__: List[str] = ['_claim', '_regex']

    def __init__(self, claim: str, regex: str) -> None:
        self._claim = claim
        self._regex = regex

    @builtins.property
    def claim(self) -> str:
        return self._claim

    @builtins.property
    def regex(self) -> str:
        return self._regex


authorization_RegexClaimCondition.__name__ = "RegexClaimCondition"
authorization_RegexClaimCondition.__qualname__ = "RegexClaimCondition"
authorization_RegexClaimCondition.__module__ = "scout_service_api.authorization"


class authorization_RegistrationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[str]),
            'organization_rid': ConjureFieldDefinition('organizationRid', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_rids', '_organization_rid']

    def __init__(self, rids: List[str], organization_rid: Optional[str] = None) -> None:
        self._rids = rids
        self._organization_rid = organization_rid

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids

    @builtins.property
    def organization_rid(self) -> Optional[str]:
        """
        If omitted, will use the user's organizationRid.
        """
        return self._organization_rid


authorization_RegistrationRequest.__name__ = "RegistrationRequest"
authorization_RegistrationRequest.__qualname__ = "RegistrationRequest"
authorization_RegistrationRequest.__module__ = "scout_service_api.authorization"


class authorization_RemoveUserFilterForOneOrgRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'org_rid': ConjureFieldDefinition('orgRid', authorization_OrgRid),
            'last_version': ConjureFieldDefinition('lastVersion', int)
        }

    __slots__: List[str] = ['_org_rid', '_last_version']

    def __init__(self, last_version: int, org_rid: str) -> None:
        self._org_rid = org_rid
        self._last_version = last_version

    @builtins.property
    def org_rid(self) -> str:
        return self._org_rid

    @builtins.property
    def last_version(self) -> int:
        return self._last_version


authorization_RemoveUserFilterForOneOrgRequest.__name__ = "RemoveUserFilterForOneOrgRequest"
authorization_RemoveUserFilterForOneOrgRequest.__qualname__ = "RemoveUserFilterForOneOrgRequest"
authorization_RemoveUserFilterForOneOrgRequest.__module__ = "scout_service_api.authorization"


class authorization_SetOrgAssignmentRulesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rules': ConjureFieldDefinition('rules', List[authorization_OrgAssignmentRule]),
            'last_version': ConjureFieldDefinition('lastVersion', int)
        }

    __slots__: List[str] = ['_rules', '_last_version']

    def __init__(self, last_version: int, rules: List["authorization_OrgAssignmentRule"]) -> None:
        self._rules = rules
        self._last_version = last_version

    @builtins.property
    def rules(self) -> List["authorization_OrgAssignmentRule"]:
        return self._rules

    @builtins.property
    def last_version(self) -> int:
        return self._last_version


authorization_SetOrgAssignmentRulesRequest.__name__ = "SetOrgAssignmentRulesRequest"
authorization_SetOrgAssignmentRulesRequest.__qualname__ = "SetOrgAssignmentRulesRequest"
authorization_SetOrgAssignmentRulesRequest.__module__ = "scout_service_api.authorization"


class authorization_SetUserFilterForOneOrgRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'org_rid': ConjureFieldDefinition('orgRid', authorization_OrgRid),
            'user_filter': ConjureFieldDefinition('userFilter', authorization_UserFilter),
            'last_version': ConjureFieldDefinition('lastVersion', int)
        }

    __slots__: List[str] = ['_org_rid', '_user_filter', '_last_version']

    def __init__(self, last_version: int, org_rid: str, user_filter: "authorization_UserFilter") -> None:
        self._org_rid = org_rid
        self._user_filter = user_filter
        self._last_version = last_version

    @builtins.property
    def org_rid(self) -> str:
        return self._org_rid

    @builtins.property
    def user_filter(self) -> "authorization_UserFilter":
        return self._user_filter

    @builtins.property
    def last_version(self) -> int:
        return self._last_version


authorization_SetUserFilterForOneOrgRequest.__name__ = "SetUserFilterForOneOrgRequest"
authorization_SetUserFilterForOneOrgRequest.__qualname__ = "SetUserFilterForOneOrgRequest"
authorization_SetUserFilterForOneOrgRequest.__module__ = "scout_service_api.authorization"


class authorization_UserFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'condition': ConjureFieldDefinition('condition', authorization_Condition)
        }

    __slots__: List[str] = ['_condition']

    def __init__(self, condition: "authorization_Condition") -> None:
        self._condition = condition

    @builtins.property
    def condition(self) -> "authorization_Condition":
        return self._condition


authorization_UserFilter.__name__ = "UserFilter"
authorization_UserFilter.__qualname__ = "UserFilter"
authorization_UserFilter.__module__ = "scout_service_api.authorization"


class authorization_UserFiltersResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'user_filters_by_org': ConjureFieldDefinition('userFiltersByOrg', Dict[authorization_OrgRid, authorization_UserFilter]),
            'version': ConjureFieldDefinition('version', int)
        }

    __slots__: List[str] = ['_user_filters_by_org', '_version']

    def __init__(self, user_filters_by_org: Dict[str, "authorization_UserFilter"], version: int) -> None:
        self._user_filters_by_org = user_filters_by_org
        self._version = version

    @builtins.property
    def user_filters_by_org(self) -> Dict[str, "authorization_UserFilter"]:
        """
        If a user is assigned to an org, they must pass the filter or else be rejected.
If there is no filter for an org, all users assigned to that org are accepted.
        """
        return self._user_filters_by_org

    @builtins.property
    def version(self) -> int:
        return self._version


authorization_UserFiltersResponse.__name__ = "UserFiltersResponse"
authorization_UserFiltersResponse.__qualname__ = "UserFiltersResponse"
authorization_UserFiltersResponse.__module__ = "scout_service_api.authorization"


class comments_api_Comment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', comments_api_CommentRid),
            'parent': ConjureFieldDefinition('parent', comments_api_CommentParent),
            'author_rid': ConjureFieldDefinition('authorRid', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'edited_at': ConjureFieldDefinition('editedAt', OptionalTypeWrapper[str]),
            'deleted_at': ConjureFieldDefinition('deletedAt', OptionalTypeWrapper[str]),
            'content': ConjureFieldDefinition('content', str),
            'pinned_by': ConjureFieldDefinition('pinnedBy', OptionalTypeWrapper[str]),
            'pinned_at': ConjureFieldDefinition('pinnedAt', OptionalTypeWrapper[str]),
            'reactions': ConjureFieldDefinition('reactions', List[comments_api_Reaction]),
            'attachments': ConjureFieldDefinition('attachments', List[str])
        }

    __slots__: List[str] = ['_rid', '_parent', '_author_rid', '_created_at', '_edited_at', '_deleted_at', '_content', '_pinned_by', '_pinned_at', '_reactions', '_attachments']

    def __init__(self, attachments: List[str], author_rid: str, content: str, created_at: str, parent: "comments_api_CommentParent", reactions: List["comments_api_Reaction"], rid: str, deleted_at: Optional[str] = None, edited_at: Optional[str] = None, pinned_at: Optional[str] = None, pinned_by: Optional[str] = None) -> None:
        self._rid = rid
        self._parent = parent
        self._author_rid = author_rid
        self._created_at = created_at
        self._edited_at = edited_at
        self._deleted_at = deleted_at
        self._content = content
        self._pinned_by = pinned_by
        self._pinned_at = pinned_at
        self._reactions = reactions
        self._attachments = attachments

    @builtins.property
    def rid(self) -> str:
        """
        Unique resource identifier for the comment
        """
        return self._rid

    @builtins.property
    def parent(self) -> "comments_api_CommentParent":
        """
        The parent of the comment. It can be a resource or another comment.
        """
        return self._parent

    @builtins.property
    def author_rid(self) -> str:
        """
        The user who authored the comment
        """
        return self._author_rid

    @builtins.property
    def created_at(self) -> str:
        """
        The time the comment was created
        """
        return self._created_at

    @builtins.property
    def edited_at(self) -> Optional[str]:
        """
        The time the comment was edited. Empty if the comment has not been edited.
        """
        return self._edited_at

    @builtins.property
    def deleted_at(self) -> Optional[str]:
        """
        The time the comment was deleted. Empty if the comment has not been deleted.
        """
        return self._deleted_at

    @builtins.property
    def content(self) -> str:
        """
        The markdown content of the comment.
        """
        return self._content

    @builtins.property
    def pinned_by(self) -> Optional[str]:
        """
        The user who pinned the comment. Empty if the comment is not pinned.
        """
        return self._pinned_by

    @builtins.property
    def pinned_at(self) -> Optional[str]:
        """
        The time the comment was pinned. Empty if the comment is not pinned.
        """
        return self._pinned_at

    @builtins.property
    def reactions(self) -> List["comments_api_Reaction"]:
        """
        The reactions on the comment
        """
        return self._reactions

    @builtins.property
    def attachments(self) -> List[str]:
        """
        The comment's attachments
        """
        return self._attachments


comments_api_Comment.__name__ = "Comment"
comments_api_Comment.__qualname__ = "Comment"
comments_api_Comment.__module__ = "scout_service_api.comments_api"


class comments_api_CommentParent(ConjureUnionType):
    """The parent of a comment. It can be a resource or another comment in the case of a reply."""
    _resource: Optional["comments_api_CommentParentResource"] = None
    _comment: Optional["comments_api_CommentParentComment"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource': ConjureFieldDefinition('resource', comments_api_CommentParentResource),
            'comment': ConjureFieldDefinition('comment', comments_api_CommentParentComment)
        }

    def __init__(
            self,
            resource: Optional["comments_api_CommentParentResource"] = None,
            comment: Optional["comments_api_CommentParentComment"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (resource is not None) + (comment is not None) != 1:
                raise ValueError('a union must contain a single member')

            if resource is not None:
                self._resource = resource
                self._type = 'resource'
            if comment is not None:
                self._comment = comment
                self._type = 'comment'

        elif type_of_union == 'resource':
            if resource is None:
                raise ValueError('a union value must not be None')
            self._resource = resource
            self._type = 'resource'
        elif type_of_union == 'comment':
            if comment is None:
                raise ValueError('a union value must not be None')
            self._comment = comment
            self._type = 'comment'

    @builtins.property
    def resource(self) -> Optional["comments_api_CommentParentResource"]:
        return self._resource

    @builtins.property
    def comment(self) -> Optional["comments_api_CommentParentComment"]:
        return self._comment

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, comments_api_CommentParentVisitor):
            raise ValueError('{} is not an instance of comments_api_CommentParentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'resource' and self.resource is not None:
            return visitor._resource(self.resource)
        if self._type == 'comment' and self.comment is not None:
            return visitor._comment(self.comment)


comments_api_CommentParent.__name__ = "CommentParent"
comments_api_CommentParent.__qualname__ = "CommentParent"
comments_api_CommentParent.__module__ = "scout_service_api.comments_api"


class comments_api_CommentParentVisitor:

    @abstractmethod
    def _resource(self, resource: "comments_api_CommentParentResource") -> Any:
        pass

    @abstractmethod
    def _comment(self, comment: "comments_api_CommentParentComment") -> Any:
        pass


comments_api_CommentParentVisitor.__name__ = "CommentParentVisitor"
comments_api_CommentParentVisitor.__qualname__ = "CommentParentVisitor"
comments_api_CommentParentVisitor.__module__ = "scout_service_api.comments_api"


class comments_api_CommentParentComment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment_rid': ConjureFieldDefinition('commentRid', comments_api_CommentRid)
        }

    __slots__: List[str] = ['_comment_rid']

    def __init__(self, comment_rid: str) -> None:
        self._comment_rid = comment_rid

    @builtins.property
    def comment_rid(self) -> str:
        """
        The resource identifier for the comment that the comment is replying to
        """
        return self._comment_rid


comments_api_CommentParentComment.__name__ = "CommentParentComment"
comments_api_CommentParentComment.__qualname__ = "CommentParentComment"
comments_api_CommentParentComment.__module__ = "scout_service_api.comments_api"


class comments_api_CommentParentResource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_type': ConjureFieldDefinition('resourceType', comments_api_ResourceType),
            'resource_rid': ConjureFieldDefinition('resourceRid', comments_api_ResourceRid)
        }

    __slots__: List[str] = ['_resource_type', '_resource_rid']

    def __init__(self, resource_rid: str, resource_type: "comments_api_ResourceType") -> None:
        self._resource_type = resource_type
        self._resource_rid = resource_rid

    @builtins.property
    def resource_type(self) -> "comments_api_ResourceType":
        """
        The type of resource that the comment is associated with
        """
        return self._resource_type

    @builtins.property
    def resource_rid(self) -> str:
        """
        The resource identifier for the resource that the comment is associated with. For example, a run or a workbook.
        """
        return self._resource_rid


comments_api_CommentParentResource.__name__ = "CommentParentResource"
comments_api_CommentParentResource.__qualname__ = "CommentParentResource"
comments_api_CommentParentResource.__module__ = "scout_service_api.comments_api"


class comments_api_CommentsService(Service):
    """
    Comments service manages conversations about resources.
    """

    def get_conversation(self, auth_header: str, resource_rid: str, resource_type: "comments_api_ResourceType") -> "comments_api_Conversation":
        """
        A conversation is a fully resolved comment tree. It includes all comments for the given resource
and all the nested comments/replies to those comments.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceType': resource_type,
            'resourceRid': resource_rid,
        }

        _json: Any = None

        _path = '/comments/v1/conversations/{resourceType}/{resourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Conversation, self._return_none_for_unknown_union_types)

    def get_conversation_count(self, auth_header: str, resource_rid: str, resource_type: "comments_api_ResourceType", include_deleted: Optional[bool] = None) -> int:
        """
        Returns the number of comments in a conversation.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'includeDeleted': include_deleted,
        }

        _path_params: Dict[str, Any] = {
            'resourceType': resource_type,
            'resourceRid': resource_rid,
        }

        _json: Any = None

        _path = '/comments/v1/conversations/{resourceType}/{resourceRid}/count'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), int, self._return_none_for_unknown_union_types)

    def get_comment(self, auth_header: str, comment_rid: str) -> "comments_api_Comment":
        """
        Get a comment identified by its RID
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'commentRid': comment_rid,
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def create_comment(self, auth_header: str, request: "comments_api_CreateCommentRequest") -> "comments_api_Comment":
        """
        Create a comment on a resource
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/comments/v1/comments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def edit_comment(self, auth_header: str, comment_rid: str, request: "comments_api_EditCommentRequest") -> "comments_api_Comment":
        """
        Edit an existing comment
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'commentRid': comment_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/comments/v1/comments/{commentRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def delete_comment(self, auth_header: str, comment_rid: str) -> "comments_api_Comment":
        """
        Delete an existing comment
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'commentRid': comment_rid,
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def pin_comment(self, auth_header: str, comment_rid: str) -> "comments_api_Comment":
        """
        Pin a comment to the top of the conversation
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'commentRid': comment_rid,
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}/pin'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def unpin_comment(self, auth_header: str, comment_rid: str) -> "comments_api_Comment":
        """
        Unpin a comment from the top of the conversation
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'commentRid': comment_rid,
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}/pin'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def add_reaction(self, auth_header: str, comment_rid: str, type: "comments_api_ReactionType") -> "comments_api_Comment":
        """
        Create a reaction on a comment
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'commentRid': comment_rid,
            'type': type,
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}/reactions/{type}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def remove_reaction(self, auth_header: str, comment_rid: str, type: "comments_api_ReactionType") -> "comments_api_Comment":
        """
        Create a reaction on a comment
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'commentRid': comment_rid,
            'type': type,
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}/reactions/{type}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)


comments_api_CommentsService.__name__ = "CommentsService"
comments_api_CommentsService.__qualname__ = "CommentsService"
comments_api_CommentsService.__module__ = "scout_service_api.comments_api"


class comments_api_Conversation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_rid': ConjureFieldDefinition('resourceRid', comments_api_ResourceRid),
            'resource_type': ConjureFieldDefinition('resourceType', comments_api_ResourceType),
            'comments': ConjureFieldDefinition('comments', List[comments_api_ConversationNode])
        }

    __slots__: List[str] = ['_resource_rid', '_resource_type', '_comments']

    def __init__(self, comments: List["comments_api_ConversationNode"], resource_rid: str, resource_type: "comments_api_ResourceType") -> None:
        self._resource_rid = resource_rid
        self._resource_type = resource_type
        self._comments = comments

    @builtins.property
    def resource_rid(self) -> str:
        """
        RID for the resource that the conversation is associated with.
        """
        return self._resource_rid

    @builtins.property
    def resource_type(self) -> "comments_api_ResourceType":
        """
        The type of the resource that the conversation is associated with.
        """
        return self._resource_type

    @builtins.property
    def comments(self) -> List["comments_api_ConversationNode"]:
        """
        The comments on the conversation ordered by creation time.
Empty if the comment has no replies.
        """
        return self._comments


comments_api_Conversation.__name__ = "Conversation"
comments_api_Conversation.__qualname__ = "Conversation"
comments_api_Conversation.__module__ = "scout_service_api.comments_api"


class comments_api_ConversationNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', comments_api_Comment),
            'replies': ConjureFieldDefinition('replies', List[comments_api_ConversationNode])
        }

    __slots__: List[str] = ['_comment', '_replies']

    def __init__(self, comment: "comments_api_Comment", replies: List["comments_api_ConversationNode"]) -> None:
        self._comment = comment
        self._replies = replies

    @builtins.property
    def comment(self) -> "comments_api_Comment":
        """
        The comment
        """
        return self._comment

    @builtins.property
    def replies(self) -> List["comments_api_ConversationNode"]:
        """
        The comments on (aka replies to) the comment ordered by creation time. Empty if the comment has no replies.
        """
        return self._replies


comments_api_ConversationNode.__name__ = "ConversationNode"
comments_api_ConversationNode.__qualname__ = "ConversationNode"
comments_api_ConversationNode.__module__ = "scout_service_api.comments_api"


class comments_api_CreateCommentRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'parent': ConjureFieldDefinition('parent', comments_api_CommentParent),
            'content': ConjureFieldDefinition('content', str),
            'attachments': ConjureFieldDefinition('attachments', List[str])
        }

    __slots__: List[str] = ['_parent', '_content', '_attachments']

    def __init__(self, attachments: List[str], content: str, parent: "comments_api_CommentParent") -> None:
        self._parent = parent
        self._content = content
        self._attachments = attachments

    @builtins.property
    def parent(self) -> "comments_api_CommentParent":
        return self._parent

    @builtins.property
    def content(self) -> str:
        """
        The content of the comment. Markdown supported.
        """
        return self._content

    @builtins.property
    def attachments(self) -> List[str]:
        """
        Attachments to the comment.
        """
        return self._attachments


comments_api_CreateCommentRequest.__name__ = "CreateCommentRequest"
comments_api_CreateCommentRequest.__qualname__ = "CreateCommentRequest"
comments_api_CreateCommentRequest.__module__ = "scout_service_api.comments_api"


class comments_api_EditCommentRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'content': ConjureFieldDefinition('content', str),
            'attachments': ConjureFieldDefinition('attachments', List[str])
        }

    __slots__: List[str] = ['_content', '_attachments']

    def __init__(self, attachments: List[str], content: str) -> None:
        self._content = content
        self._attachments = attachments

    @builtins.property
    def content(self) -> str:
        """
        The content of the comment. Markdown supported.
        """
        return self._content

    @builtins.property
    def attachments(self) -> List[str]:
        """
        Attachments to the comment.
        """
        return self._attachments


comments_api_EditCommentRequest.__name__ = "EditCommentRequest"
comments_api_EditCommentRequest.__qualname__ = "EditCommentRequest"
comments_api_EditCommentRequest.__module__ = "scout_service_api.comments_api"


class comments_api_Reaction(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', comments_api_ReactionRid),
            'user_rid': ConjureFieldDefinition('userRid', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'type': ConjureFieldDefinition('type', comments_api_ReactionType)
        }

    __slots__: List[str] = ['_rid', '_user_rid', '_created_at', '_type']

    def __init__(self, created_at: str, rid: str, type: "comments_api_ReactionType", user_rid: str) -> None:
        self._rid = rid
        self._user_rid = user_rid
        self._created_at = created_at
        self._type = type

    @builtins.property
    def rid(self) -> str:
        """
        Unique resource identifier for the reaction
        """
        return self._rid

    @builtins.property
    def user_rid(self) -> str:
        """
        The user who authored the reaction
        """
        return self._user_rid

    @builtins.property
    def created_at(self) -> str:
        """
        The time the reaction was created
        """
        return self._created_at

    @builtins.property
    def type(self) -> "comments_api_ReactionType":
        """
        The type of reaction
        """
        return self._type


comments_api_Reaction.__name__ = "Reaction"
comments_api_Reaction.__qualname__ = "Reaction"
comments_api_Reaction.__module__ = "scout_service_api.comments_api"


class comments_api_ReactionType(ConjureEnumType):

    LIKE = 'LIKE'
    '''LIKE'''
    DISLIKE = 'DISLIKE'
    '''DISLIKE'''
    HEART = 'HEART'
    '''HEART'''
    HOORAY = 'HOORAY'
    '''HOORAY'''
    ROCKET = 'ROCKET'
    '''ROCKET'''
    EYES = 'EYES'
    '''EYES'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


comments_api_ReactionType.__name__ = "ReactionType"
comments_api_ReactionType.__qualname__ = "ReactionType"
comments_api_ReactionType.__module__ = "scout_service_api.comments_api"


class comments_api_ResourceType(ConjureEnumType):

    RUN = 'RUN'
    '''RUN'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


comments_api_ResourceType.__name__ = "ResourceType"
comments_api_ResourceType.__qualname__ = "ResourceType"
comments_api_ResourceType.__module__ = "scout_service_api.comments_api"


class datasource_Property(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', datasource_PropertyName),
            'value': ConjureFieldDefinition('value', datasource_PropertyValue)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


datasource_Property.__name__ = "Property"
datasource_Property.__qualname__ = "Property"
datasource_Property.__module__ = "scout_service_api.datasource"


class datasource_TimestampType(ConjureEnumType):

    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


datasource_TimestampType.__name__ = "TimestampType"
datasource_TimestampType.__qualname__ = "TimestampType"
datasource_TimestampType.__module__ = "scout_service_api.datasource"


class datasource_api_BatchGetChannelPrefixTreeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rids': ConjureFieldDefinition('dataSourceRids', List[datasource_api_DataSourceRid])
        }

    __slots__: List[str] = ['_data_source_rids']

    def __init__(self, data_source_rids: List[str]) -> None:
        self._data_source_rids = data_source_rids

    @builtins.property
    def data_source_rids(self) -> List[str]:
        return self._data_source_rids


datasource_api_BatchGetChannelPrefixTreeRequest.__name__ = "BatchGetChannelPrefixTreeRequest"
datasource_api_BatchGetChannelPrefixTreeRequest.__qualname__ = "BatchGetChannelPrefixTreeRequest"
datasource_api_BatchGetChannelPrefixTreeRequest.__module__ = "scout_service_api.datasource_api"


class datasource_api_BatchGetChannelPrefixTreeResponse(ConjureBeanType):
    """
    If the tree for a data source has not been indexed, it will be omitted from the map.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_prefix_trees': ConjureFieldDefinition('channelPrefixTrees', Dict[datasource_api_DataSourceRid, datasource_api_ChannelPrefixTree])
        }

    __slots__: List[str] = ['_channel_prefix_trees']

    def __init__(self, channel_prefix_trees: Dict[str, "datasource_api_ChannelPrefixTree"]) -> None:
        self._channel_prefix_trees = channel_prefix_trees

    @builtins.property
    def channel_prefix_trees(self) -> Dict[str, "datasource_api_ChannelPrefixTree"]:
        return self._channel_prefix_trees


datasource_api_BatchGetChannelPrefixTreeResponse.__name__ = "BatchGetChannelPrefixTreeResponse"
datasource_api_BatchGetChannelPrefixTreeResponse.__qualname__ = "BatchGetChannelPrefixTreeResponse"
datasource_api_BatchGetChannelPrefixTreeResponse.__module__ = "scout_service_api.datasource_api"


class datasource_api_ChannelMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', datasource_api_Channel),
            'data_source': ConjureFieldDefinition('dataSource', datasource_api_DataSourceRid),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[datasource_api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'data_type': ConjureFieldDefinition('dataType', OptionalTypeWrapper[datasource_api_SeriesDataType]),
            'series_rid': ConjureFieldDefinition('seriesRid', datasource_api_SeriesArchetypeRidOrLogicalSeriesRid)
        }

    __slots__: List[str] = ['_name', '_data_source', '_unit', '_description', '_data_type', '_series_rid']

    def __init__(self, data_source: str, name: str, series_rid: "datasource_api_SeriesArchetypeRidOrLogicalSeriesRid", data_type: Optional["datasource_api_SeriesDataType"] = None, description: Optional[str] = None, unit: Optional["datasource_api_Unit"] = None) -> None:
        self._name = name
        self._data_source = data_source
        self._unit = unit
        self._description = description
        self._data_type = data_type
        self._series_rid = series_rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def data_source(self) -> str:
        return self._data_source

    @builtins.property
    def unit(self) -> Optional["datasource_api_Unit"]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def data_type(self) -> Optional["datasource_api_SeriesDataType"]:
        return self._data_type

    @builtins.property
    def series_rid(self) -> "datasource_api_SeriesArchetypeRidOrLogicalSeriesRid":
        return self._series_rid


datasource_api_ChannelMetadata.__name__ = "ChannelMetadata"
datasource_api_ChannelMetadata.__qualname__ = "ChannelMetadata"
datasource_api_ChannelMetadata.__module__ = "scout_service_api.datasource_api"


class datasource_api_ChannelOrPrefix(ConjureUnionType):
    _channel: Optional["datasource_api_ChannelMetadata"] = None
    _prefix: Optional["datasource_api_DataSourcePrefixNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', datasource_api_ChannelMetadata),
            'prefix': ConjureFieldDefinition('prefix', datasource_api_DataSourcePrefixNode)
        }

    def __init__(
            self,
            channel: Optional["datasource_api_ChannelMetadata"] = None,
            prefix: Optional["datasource_api_DataSourcePrefixNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (channel is not None) + (prefix is not None) != 1:
                raise ValueError('a union must contain a single member')

            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if prefix is not None:
                self._prefix = prefix
                self._type = 'prefix'

        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'prefix':
            if prefix is None:
                raise ValueError('a union value must not be None')
            self._prefix = prefix
            self._type = 'prefix'

    @builtins.property
    def channel(self) -> Optional["datasource_api_ChannelMetadata"]:
        return self._channel

    @builtins.property
    def prefix(self) -> Optional["datasource_api_DataSourcePrefixNode"]:
        return self._prefix

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, datasource_api_ChannelOrPrefixVisitor):
            raise ValueError('{} is not an instance of datasource_api_ChannelOrPrefixVisitor'.format(visitor.__class__.__name__))
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'prefix' and self.prefix is not None:
            return visitor._prefix(self.prefix)


datasource_api_ChannelOrPrefix.__name__ = "ChannelOrPrefix"
datasource_api_ChannelOrPrefix.__qualname__ = "ChannelOrPrefix"
datasource_api_ChannelOrPrefix.__module__ = "scout_service_api.datasource_api"


class datasource_api_ChannelOrPrefixVisitor:

    @abstractmethod
    def _channel(self, channel: "datasource_api_ChannelMetadata") -> Any:
        pass

    @abstractmethod
    def _prefix(self, prefix: "datasource_api_DataSourcePrefixNode") -> Any:
        pass


datasource_api_ChannelOrPrefixVisitor.__name__ = "ChannelOrPrefixVisitor"
datasource_api_ChannelOrPrefixVisitor.__qualname__ = "ChannelOrPrefixVisitor"
datasource_api_ChannelOrPrefixVisitor.__module__ = "scout_service_api.datasource_api"


class datasource_api_ChannelPrefixTree(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'roots': ConjureFieldDefinition('roots', List[datasource_api_ChannelPrefixTreeNode]),
            'delimiter': ConjureFieldDefinition('delimiter', str)
        }

    __slots__: List[str] = ['_roots', '_delimiter']

    def __init__(self, delimiter: str, roots: List["datasource_api_ChannelPrefixTreeNode"]) -> None:
        self._roots = roots
        self._delimiter = delimiter

    @builtins.property
    def roots(self) -> List["datasource_api_ChannelPrefixTreeNode"]:
        return self._roots

    @builtins.property
    def delimiter(self) -> str:
        return self._delimiter


datasource_api_ChannelPrefixTree.__name__ = "ChannelPrefixTree"
datasource_api_ChannelPrefixTree.__qualname__ = "ChannelPrefixTree"
datasource_api_ChannelPrefixTree.__module__ = "scout_service_api.datasource_api"


class datasource_api_ChannelPrefixTreeNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'part': ConjureFieldDefinition('part', str),
            'children': ConjureFieldDefinition('children', List[datasource_api_ChannelPrefixTreeNode])
        }

    __slots__: List[str] = ['_part', '_children']

    def __init__(self, children: List["datasource_api_ChannelPrefixTreeNode"], part: str) -> None:
        self._part = part
        self._children = children

    @builtins.property
    def part(self) -> str:
        """
        Should be combined with the ancestor parts and the delimiter to form the full prefix.
        """
        return self._part

    @builtins.property
    def children(self) -> List["datasource_api_ChannelPrefixTreeNode"]:
        return self._children


datasource_api_ChannelPrefixTreeNode.__name__ = "ChannelPrefixTreeNode"
datasource_api_ChannelPrefixTreeNode.__qualname__ = "ChannelPrefixTreeNode"
datasource_api_ChannelPrefixTreeNode.__module__ = "scout_service_api.datasource_api"


class datasource_api_DataSourcePrefixNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'part': ConjureFieldDefinition('part', str),
            'data_source': ConjureFieldDefinition('dataSource', datasource_api_DataSourceRid)
        }

    __slots__: List[str] = ['_part', '_data_source']

    def __init__(self, data_source: str, part: str) -> None:
        self._part = part
        self._data_source = data_source

    @builtins.property
    def part(self) -> str:
        """
        Should be combined with the ancestor parts and the delimiter to form the full prefix.
        """
        return self._part

    @builtins.property
    def data_source(self) -> str:
        return self._data_source


datasource_api_DataSourcePrefixNode.__name__ = "DataSourcePrefixNode"
datasource_api_DataSourcePrefixNode.__qualname__ = "DataSourcePrefixNode"
datasource_api_DataSourcePrefixNode.__module__ = "scout_service_api.datasource_api"


class datasource_api_IndexChannelPrefixTreeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', datasource_api_DataSourceRid),
            'delimiter': ConjureFieldDefinition('delimiter', str)
        }

    __slots__: List[str] = ['_data_source_rid', '_delimiter']

    def __init__(self, data_source_rid: str, delimiter: str) -> None:
        self._data_source_rid = data_source_rid
        self._delimiter = delimiter

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def delimiter(self) -> str:
        return self._delimiter


datasource_api_IndexChannelPrefixTreeRequest.__name__ = "IndexChannelPrefixTreeRequest"
datasource_api_IndexChannelPrefixTreeRequest.__qualname__ = "IndexChannelPrefixTreeRequest"
datasource_api_IndexChannelPrefixTreeRequest.__module__ = "scout_service_api.datasource_api"


class datasource_api_SearchChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fuzzy_search_text': ConjureFieldDefinition('fuzzySearchText', str),
            'prefix': ConjureFieldDefinition('prefix', OptionalTypeWrapper[str]),
            'exact_match': ConjureFieldDefinition('exactMatch', List[str]),
            'data_sources': ConjureFieldDefinition('dataSources', List[datasource_api_DataSourceRid]),
            'previously_selected_channels': ConjureFieldDefinition('previouslySelectedChannels', Dict[datasource_api_DataSourceRid, List[datasource_api_Channel]]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[datasource_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_fuzzy_search_text', '_prefix', '_exact_match', '_data_sources', '_previously_selected_channels', '_next_page_token', '_page_size']

    def __init__(self, data_sources: List[str], exact_match: List[str], fuzzy_search_text: str, previously_selected_channels: Dict[str, List[str]], next_page_token: Optional[str] = None, page_size: Optional[int] = None, prefix: Optional[str] = None) -> None:
        self._fuzzy_search_text = fuzzy_search_text
        self._prefix = prefix
        self._exact_match = exact_match
        self._data_sources = data_sources
        self._previously_selected_channels = previously_selected_channels
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def fuzzy_search_text(self) -> str:
        return self._fuzzy_search_text

    @builtins.property
    def prefix(self) -> Optional[str]:
        return self._prefix

    @builtins.property
    def exact_match(self) -> List[str]:
        """
        Will return only channels that contain all strings specified as exact matches (case insensitive).
        """
        return self._exact_match

    @builtins.property
    def data_sources(self) -> List[str]:
        return self._data_sources

    @builtins.property
    def previously_selected_channels(self) -> Dict[str, List[str]]:
        """
        Data sources with the channels that were previously selected will be weighted more heavily. The previously
selected channel names will also factor into the similarity score.
        """
        return self._previously_selected_channels

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 1000. Will throw if larger than 1000.
        """
        return self._page_size


datasource_api_SearchChannelsRequest.__name__ = "SearchChannelsRequest"
datasource_api_SearchChannelsRequest.__qualname__ = "SearchChannelsRequest"
datasource_api_SearchChannelsRequest.__module__ = "scout_service_api.datasource_api"


class datasource_api_SearchChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[datasource_api_ChannelMetadata]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[datasource_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["datasource_api_ChannelMetadata"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["datasource_api_ChannelMetadata"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


datasource_api_SearchChannelsResponse.__name__ = "SearchChannelsResponse"
datasource_api_SearchChannelsResponse.__qualname__ = "SearchChannelsResponse"
datasource_api_SearchChannelsResponse.__module__ = "scout_service_api.datasource_api"


class datasource_api_SearchFilteredChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fuzzy_search_text': ConjureFieldDefinition('fuzzySearchText', str),
            'exact_match': ConjureFieldDefinition('exactMatch', List[str]),
            'data_sources': ConjureFieldDefinition('dataSources', List[datasource_api_DataSourceRid]),
            'previously_selected_channels': ConjureFieldDefinition('previouslySelectedChannels', Dict[datasource_api_DataSourceRid, List[datasource_api_Channel]]),
            'result_size': ConjureFieldDefinition('resultSize', OptionalTypeWrapper[int]),
            'tags': ConjureFieldDefinition('tags', Dict[datasource_api_DataSourceRid, Dict[api_TagName, api_TagValue]]),
            'min_data_updated_time': ConjureFieldDefinition('minDataUpdatedTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp])
        }

    __slots__: List[str] = ['_fuzzy_search_text', '_exact_match', '_data_sources', '_previously_selected_channels', '_result_size', '_tags', '_min_data_updated_time']

    def __init__(self, data_sources: List[str], exact_match: List[str], fuzzy_search_text: str, previously_selected_channels: Dict[str, List[str]], tags: Dict[str, Dict[str, str]], min_data_updated_time: Optional["scout_run_api_UtcTimestamp"] = None, result_size: Optional[int] = None) -> None:
        self._fuzzy_search_text = fuzzy_search_text
        self._exact_match = exact_match
        self._data_sources = data_sources
        self._previously_selected_channels = previously_selected_channels
        self._result_size = result_size
        self._tags = tags
        self._min_data_updated_time = min_data_updated_time

    @builtins.property
    def fuzzy_search_text(self) -> str:
        return self._fuzzy_search_text

    @builtins.property
    def exact_match(self) -> List[str]:
        """
        Will return only channels that contain all strings specified as exact matches (case insensitive).
        """
        return self._exact_match

    @builtins.property
    def data_sources(self) -> List[str]:
        return self._data_sources

    @builtins.property
    def previously_selected_channels(self) -> Dict[str, List[str]]:
        """
        Data sources with the channels that were previously selected will be weighted more heavily. The previously
selected channel names will also factor into the similarity score.
        """
        return self._previously_selected_channels

    @builtins.property
    def result_size(self) -> Optional[int]:
        """
        Defaults to 10000. Will throw if larger than 10000.
        """
        return self._result_size

    @builtins.property
    def tags(self) -> Dict[str, Dict[str, str]]:
        """
        If specified, search will only return channels containing a superset of the tags specified for the given datasource.
        """
        return self._tags

    @builtins.property
    def min_data_updated_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        """
        If specified, search will only return channels that have had new data after the specified time.
        """
        return self._min_data_updated_time


datasource_api_SearchFilteredChannelsRequest.__name__ = "SearchFilteredChannelsRequest"
datasource_api_SearchFilteredChannelsRequest.__qualname__ = "SearchFilteredChannelsRequest"
datasource_api_SearchFilteredChannelsRequest.__module__ = "scout_service_api.datasource_api"


class datasource_api_SearchFilteredChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[datasource_api_ChannelMetadata])
        }

    __slots__: List[str] = ['_results']

    def __init__(self, results: List["datasource_api_ChannelMetadata"]) -> None:
        self._results = results

    @builtins.property
    def results(self) -> List["datasource_api_ChannelMetadata"]:
        return self._results


datasource_api_SearchFilteredChannelsResponse.__name__ = "SearchFilteredChannelsResponse"
datasource_api_SearchFilteredChannelsResponse.__qualname__ = "SearchFilteredChannelsResponse"
datasource_api_SearchFilteredChannelsResponse.__module__ = "scout_service_api.datasource_api"


class datasource_api_SearchHierarchicalChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'parent': ConjureFieldDefinition('parent', List[str]),
            'data_sources': ConjureFieldDefinition('dataSources', List[datasource_api_DataSourceRid])
        }

    __slots__: List[str] = ['_parent', '_data_sources']

    def __init__(self, data_sources: List[str], parent: List[str]) -> None:
        self._parent = parent
        self._data_sources = data_sources

    @builtins.property
    def parent(self) -> List[str]:
        """
        The parent (represented as a list of parts) to search under. If empty, will return all top-level channels.
        """
        return self._parent

    @builtins.property
    def data_sources(self) -> List[str]:
        return self._data_sources


datasource_api_SearchHierarchicalChannelsRequest.__name__ = "SearchHierarchicalChannelsRequest"
datasource_api_SearchHierarchicalChannelsRequest.__qualname__ = "SearchHierarchicalChannelsRequest"
datasource_api_SearchHierarchicalChannelsRequest.__module__ = "scout_service_api.datasource_api"


class datasource_api_SearchHierarchicalChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[datasource_api_ChannelOrPrefix])
        }

    __slots__: List[str] = ['_results']

    def __init__(self, results: List["datasource_api_ChannelOrPrefix"]) -> None:
        self._results = results

    @builtins.property
    def results(self) -> List["datasource_api_ChannelOrPrefix"]:
        return self._results


datasource_api_SearchHierarchicalChannelsResponse.__name__ = "SearchHierarchicalChannelsResponse"
datasource_api_SearchHierarchicalChannelsResponse.__qualname__ = "SearchHierarchicalChannelsResponse"
datasource_api_SearchHierarchicalChannelsResponse.__module__ = "scout_service_api.datasource_api"


class datasource_api_SeriesArchetypeRidOrLogicalSeriesRid(ConjureUnionType):
    _series_archetype: Optional[str] = None
    _logical_series: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_archetype': ConjureFieldDefinition('seriesArchetype', datasource_api_SeriesArchetypeRid),
            'logical_series': ConjureFieldDefinition('logicalSeries', datasource_api_LogicalSeriesRid)
        }

    def __init__(
            self,
            series_archetype: Optional[str] = None,
            logical_series: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (series_archetype is not None) + (logical_series is not None) != 1:
                raise ValueError('a union must contain a single member')

            if series_archetype is not None:
                self._series_archetype = series_archetype
                self._type = 'seriesArchetype'
            if logical_series is not None:
                self._logical_series = logical_series
                self._type = 'logicalSeries'

        elif type_of_union == 'seriesArchetype':
            if series_archetype is None:
                raise ValueError('a union value must not be None')
            self._series_archetype = series_archetype
            self._type = 'seriesArchetype'
        elif type_of_union == 'logicalSeries':
            if logical_series is None:
                raise ValueError('a union value must not be None')
            self._logical_series = logical_series
            self._type = 'logicalSeries'

    @builtins.property
    def series_archetype(self) -> Optional[str]:
        return self._series_archetype

    @builtins.property
    def logical_series(self) -> Optional[str]:
        return self._logical_series

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, datasource_api_SeriesArchetypeRidOrLogicalSeriesRidVisitor):
            raise ValueError('{} is not an instance of datasource_api_SeriesArchetypeRidOrLogicalSeriesRidVisitor'.format(visitor.__class__.__name__))
        if self._type == 'seriesArchetype' and self.series_archetype is not None:
            return visitor._series_archetype(self.series_archetype)
        if self._type == 'logicalSeries' and self.logical_series is not None:
            return visitor._logical_series(self.logical_series)


datasource_api_SeriesArchetypeRidOrLogicalSeriesRid.__name__ = "SeriesArchetypeRidOrLogicalSeriesRid"
datasource_api_SeriesArchetypeRidOrLogicalSeriesRid.__qualname__ = "SeriesArchetypeRidOrLogicalSeriesRid"
datasource_api_SeriesArchetypeRidOrLogicalSeriesRid.__module__ = "scout_service_api.datasource_api"


class datasource_api_SeriesArchetypeRidOrLogicalSeriesRidVisitor:

    @abstractmethod
    def _series_archetype(self, series_archetype: str) -> Any:
        pass

    @abstractmethod
    def _logical_series(self, logical_series: str) -> Any:
        pass


datasource_api_SeriesArchetypeRidOrLogicalSeriesRidVisitor.__name__ = "SeriesArchetypeRidOrLogicalSeriesRidVisitor"
datasource_api_SeriesArchetypeRidOrLogicalSeriesRidVisitor.__qualname__ = "SeriesArchetypeRidOrLogicalSeriesRidVisitor"
datasource_api_SeriesArchetypeRidOrLogicalSeriesRidVisitor.__module__ = "scout_service_api.datasource_api"


class datasource_api_SeriesDataType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


datasource_api_SeriesDataType.__name__ = "SeriesDataType"
datasource_api_SeriesDataType.__qualname__ = "SeriesDataType"
datasource_api_SeriesDataType.__module__ = "scout_service_api.datasource_api"


class datasource_api_Unit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'symbol': ConjureFieldDefinition('symbol', str)
        }

    __slots__: List[str] = ['_name', '_symbol']

    def __init__(self, name: str, symbol: str) -> None:
        self._name = name
        self._symbol = symbol

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def symbol(self) -> str:
        return self._symbol


datasource_api_Unit.__name__ = "Unit"
datasource_api_Unit.__qualname__ = "Unit"
datasource_api_Unit.__module__ = "scout_service_api.datasource_api"


class datasource_logset_LogSetService(Service):
    """
    Log sets are a type of datasource which can be used to store log data.
    """

    def create(self, auth_header: str, request: "datasource_logset_api_CreateLogSetRequest") -> "datasource_logset_api_LogSetMetadata":
        """
        Creates a log set, to which logs can be attached using `attach-and-finalize`. The logs within a logset are
not searchable until the logset is finalized.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/log-set/v1/log-sets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_logset_api_LogSetMetadata, self._return_none_for_unknown_union_types)

    def attach_logs_and_finalize(self, auth_header: str, log_set_rid: str, request: "datasource_logset_api_AttachLogsAndFinalizeRequest") -> "datasource_logset_api_LogSetMetadata":
        """
        A logset is not considered readable until it has been finalized. Once finalized, the logset is immutable.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'logSetRid': log_set_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/log-set/v1/log-set/{logSetRid}/attach-and-finalize'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_logset_api_LogSetMetadata, self._return_none_for_unknown_union_types)

    def get_log_set_metadata(self, auth_header: str, log_set_rid: str) -> "datasource_logset_api_LogSetMetadata":
        """
        Returns metadata about a log set.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'logSetRid': log_set_rid,
        }

        _json: Any = None

        _path = '/data-source/log-set/v1/log-set/{logSetRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_logset_api_LogSetMetadata, self._return_none_for_unknown_union_types)

    def batch_get_log_set_metadata(self, auth_header: str, request: List[str] = None) -> List["datasource_logset_api_LogSetMetadata"]:
        """
        Returns metadata about a set of log sets.
        """
        request = request if request is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/log-set/v1/log-set/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[datasource_logset_api_LogSetMetadata], self._return_none_for_unknown_union_types)

    def search_log_sets(self, auth_header: str, request: "datasource_logset_api_SearchLogSetsRequest") -> "datasource_logset_api_SearchLogSetsResponse":
        """
        Searches all visible log sets based on log set metadata.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/log-set/v1/log-sets/get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_logset_api_SearchLogSetsResponse, self._return_none_for_unknown_union_types)

    def search_logs(self, auth_header: str, log_set_rid: str, request: "datasource_logset_api_SearchLogsRequest") -> "datasource_logset_api_SearchLogsResponse":
        """
        Searches logs within a single log set.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'logSetRid': log_set_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/log-set/v1/log-set/{logSetRid}/logs'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_logset_api_SearchLogsResponse, self._return_none_for_unknown_union_types)


datasource_logset_LogSetService.__name__ = "LogSetService"
datasource_logset_LogSetService.__qualname__ = "LogSetService"
datasource_logset_LogSetService.__module__ = "scout_service_api.datasource_logset"


class datasource_logset_api_AttachLogsAndFinalizeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'logs': ConjureFieldDefinition('logs', List[datasource_logset_api_Log])
        }

    __slots__: List[str] = ['_logs']

    def __init__(self, logs: List["datasource_logset_api_Log"]) -> None:
        self._logs = logs

    @builtins.property
    def logs(self) -> List["datasource_logset_api_Log"]:
        return self._logs


datasource_logset_api_AttachLogsAndFinalizeRequest.__name__ = "AttachLogsAndFinalizeRequest"
datasource_logset_api_AttachLogsAndFinalizeRequest.__qualname__ = "AttachLogsAndFinalizeRequest"
datasource_logset_api_AttachLogsAndFinalizeRequest.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_BasicLogBody(ConjureBeanType):
    """
    A largely unopinionated but very flexible format.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[str, str]),
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_properties', '_message']

    def __init__(self, message: str, properties: Dict[str, str]) -> None:
        self._properties = properties
        self._message = message

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def message(self) -> str:
        return self._message


datasource_logset_api_BasicLogBody.__name__ = "BasicLogBody"
datasource_logset_api_BasicLogBody.__qualname__ = "BasicLogBody"
datasource_logset_api_BasicLogBody.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_CreateLogSetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', Dict[str, str]),
            'timestamp_type': ConjureFieldDefinition('timestampType', datasource_TimestampType)
        }

    __slots__: List[str] = ['_name', '_description', '_origin_metadata', '_timestamp_type']

    def __init__(self, name: str, origin_metadata: Dict[str, str], timestamp_type: "datasource_TimestampType", description: Optional[str] = None) -> None:
        self._name = name
        self._description = description
        self._origin_metadata = origin_metadata
        self._timestamp_type = timestamp_type

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def origin_metadata(self) -> Dict[str, str]:
        return self._origin_metadata

    @builtins.property
    def timestamp_type(self) -> "datasource_TimestampType":
        return self._timestamp_type


datasource_logset_api_CreateLogSetRequest.__name__ = "CreateLogSetRequest"
datasource_logset_api_CreateLogSetRequest.__qualname__ = "CreateLogSetRequest"
datasource_logset_api_CreateLogSetRequest.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_Log(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time': ConjureFieldDefinition('time', api_Timestamp),
            'body': ConjureFieldDefinition('body', datasource_logset_api_LogBody)
        }

    __slots__: List[str] = ['_time', '_body']

    def __init__(self, body: "datasource_logset_api_LogBody", time: "api_Timestamp") -> None:
        self._time = time
        self._body = body

    @builtins.property
    def time(self) -> "api_Timestamp":
        return self._time

    @builtins.property
    def body(self) -> "datasource_logset_api_LogBody":
        return self._body


datasource_logset_api_Log.__name__ = "Log"
datasource_logset_api_Log.__qualname__ = "Log"
datasource_logset_api_Log.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_LogBody(ConjureUnionType):
    _basic: Optional["datasource_logset_api_BasicLogBody"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'basic': ConjureFieldDefinition('basic', datasource_logset_api_BasicLogBody)
        }

    def __init__(
            self,
            basic: Optional["datasource_logset_api_BasicLogBody"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (basic is not None) != 1:
                raise ValueError('a union must contain a single member')

            if basic is not None:
                self._basic = basic
                self._type = 'basic'

        elif type_of_union == 'basic':
            if basic is None:
                raise ValueError('a union value must not be None')
            self._basic = basic
            self._type = 'basic'

    @builtins.property
    def basic(self) -> Optional["datasource_logset_api_BasicLogBody"]:
        return self._basic

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, datasource_logset_api_LogBodyVisitor):
            raise ValueError('{} is not an instance of datasource_logset_api_LogBodyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'basic' and self.basic is not None:
            return visitor._basic(self.basic)


datasource_logset_api_LogBody.__name__ = "LogBody"
datasource_logset_api_LogBody.__qualname__ = "LogBody"
datasource_logset_api_LogBody.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_LogBodyVisitor:

    @abstractmethod
    def _basic(self, basic: "datasource_logset_api_BasicLogBody") -> Any:
        pass


datasource_logset_api_LogBodyVisitor.__name__ = "LogBodyVisitor"
datasource_logset_api_LogBodyVisitor.__qualname__ = "LogBodyVisitor"
datasource_logset_api_LogBodyVisitor.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_LogFormat(ConjureEnumType):

    V1 = 'V1'
    '''V1'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


datasource_logset_api_LogFormat.__name__ = "LogFormat"
datasource_logset_api_LogFormat.__qualname__ = "LogFormat"
datasource_logset_api_LogFormat.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_LogHandle(ConjureUnionType):
    _s3: Optional["datasource_logset_api_S3LogHandle"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3': ConjureFieldDefinition('s3', datasource_logset_api_S3LogHandle)
        }

    def __init__(
            self,
            s3: Optional["datasource_logset_api_S3LogHandle"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3 is not None:
                self._s3 = s3
                self._type = 's3'

        elif type_of_union == 's3':
            if s3 is None:
                raise ValueError('a union value must not be None')
            self._s3 = s3
            self._type = 's3'

    @builtins.property
    def s3(self) -> Optional["datasource_logset_api_S3LogHandle"]:
        return self._s3

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, datasource_logset_api_LogHandleVisitor):
            raise ValueError('{} is not an instance of datasource_logset_api_LogHandleVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3' and self.s3 is not None:
            return visitor._s3(self.s3)


datasource_logset_api_LogHandle.__name__ = "LogHandle"
datasource_logset_api_LogHandle.__qualname__ = "LogHandle"
datasource_logset_api_LogHandle.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_LogHandleVisitor:

    @abstractmethod
    def _s3(self, s3: "datasource_logset_api_S3LogHandle") -> Any:
        pass


datasource_logset_api_LogHandleVisitor.__name__ = "LogHandleVisitor"
datasource_logset_api_LogHandleVisitor.__qualname__ = "LogHandleVisitor"
datasource_logset_api_LogHandleVisitor.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_LogSetMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', datasource_logset_api_LogSetRid),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', Dict[str, str]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', str),
            'log_count': ConjureFieldDefinition('logCount', int),
            'timestamp_type': ConjureFieldDefinition('timestampType', datasource_TimestampType)
        }

    __slots__: List[str] = ['_rid', '_created_by', '_name', '_description', '_origin_metadata', '_created_at', '_updated_at', '_log_count', '_timestamp_type']

    def __init__(self, created_at: str, created_by: str, log_count: int, name: str, origin_metadata: Dict[str, str], rid: str, timestamp_type: "datasource_TimestampType", updated_at: str, description: Optional[str] = None) -> None:
        self._rid = rid
        self._created_by = created_by
        self._name = name
        self._description = description
        self._origin_metadata = origin_metadata
        self._created_at = created_at
        self._updated_at = updated_at
        self._log_count = log_count
        self._timestamp_type = timestamp_type

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def origin_metadata(self) -> Dict[str, str]:
        return self._origin_metadata

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at

    @builtins.property
    def log_count(self) -> int:
        return self._log_count

    @builtins.property
    def timestamp_type(self) -> "datasource_TimestampType":
        return self._timestamp_type


datasource_logset_api_LogSetMetadata.__name__ = "LogSetMetadata"
datasource_logset_api_LogSetMetadata.__qualname__ = "LogSetMetadata"
datasource_logset_api_LogSetMetadata.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_S3LogHandle(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'path': ConjureFieldDefinition('path', str),
            'format': ConjureFieldDefinition('format', datasource_logset_api_LogFormat)
        }

    __slots__: List[str] = ['_path', '_format']

    def __init__(self, format: "datasource_logset_api_LogFormat", path: str) -> None:
        self._path = path
        self._format = format

    @builtins.property
    def path(self) -> str:
        return self._path

    @builtins.property
    def format(self) -> "datasource_logset_api_LogFormat":
        return self._format


datasource_logset_api_S3LogHandle.__name__ = "S3LogHandle"
datasource_logset_api_S3LogHandle.__qualname__ = "S3LogHandle"
datasource_logset_api_S3LogHandle.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_SearchLogSetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[datasource_logset_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_token', '_page_size']

    def __init__(self, page_size: Optional[int] = None, token: Optional[str] = None) -> None:
        self._token = token
        self._page_size = page_size

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        The maximum allowed page size is 1000. Defaults to the maximum if not supplied.
        """
        return self._page_size


datasource_logset_api_SearchLogSetsRequest.__name__ = "SearchLogSetsRequest"
datasource_logset_api_SearchLogSetsRequest.__qualname__ = "SearchLogSetsRequest"
datasource_logset_api_SearchLogSetsRequest.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_SearchLogSetsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'values': ConjureFieldDefinition('values', List[datasource_logset_api_LogSetMetadata]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[datasource_logset_api_Token])
        }

    __slots__: List[str] = ['_values', '_next_page_token']

    def __init__(self, values: List["datasource_logset_api_LogSetMetadata"], next_page_token: Optional[str] = None) -> None:
        self._values = values
        self._next_page_token = next_page_token

    @builtins.property
    def values(self) -> List["datasource_logset_api_LogSetMetadata"]:
        return self._values

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


datasource_logset_api_SearchLogSetsResponse.__name__ = "SearchLogSetsResponse"
datasource_logset_api_SearchLogSetsResponse.__qualname__ = "SearchLogSetsResponse"
datasource_logset_api_SearchLogSetsResponse.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_SearchLogsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[datasource_logset_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_token', '_page_size']

    def __init__(self, page_size: Optional[int] = None, token: Optional[str] = None) -> None:
        self._token = token
        self._page_size = page_size

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        The maximum allowed page size is 10000. Defaults to the maximum if not supplied.
        """
        return self._page_size


datasource_logset_api_SearchLogsRequest.__name__ = "SearchLogsRequest"
datasource_logset_api_SearchLogsRequest.__qualname__ = "SearchLogsRequest"
datasource_logset_api_SearchLogsRequest.__module__ = "scout_service_api.datasource_logset_api"


class datasource_logset_api_SearchLogsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'logs': ConjureFieldDefinition('logs', List[datasource_logset_api_Log]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[datasource_logset_api_Token])
        }

    __slots__: List[str] = ['_logs', '_next_page_token']

    def __init__(self, logs: List["datasource_logset_api_Log"], next_page_token: Optional[str] = None) -> None:
        self._logs = logs
        self._next_page_token = next_page_token

    @builtins.property
    def logs(self) -> List["datasource_logset_api_Log"]:
        return self._logs

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


datasource_logset_api_SearchLogsResponse.__name__ = "SearchLogsResponse"
datasource_logset_api_SearchLogsResponse.__qualname__ = "SearchLogsResponse"
datasource_logset_api_SearchLogsResponse.__module__ = "scout_service_api.datasource_logset_api"


class datasource_pagination_api_PageRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'page_token': ConjureFieldDefinition('pageToken', OptionalTypeWrapper[datasource_pagination_api_PageToken]),
            'page_size': ConjureFieldDefinition('pageSize', int)
        }

    __slots__: List[str] = ['_page_token', '_page_size']

    def __init__(self, page_size: int, page_token: Optional[str] = None) -> None:
        self._page_token = page_token
        self._page_size = page_size

    @builtins.property
    def page_token(self) -> Optional[str]:
        return self._page_token

    @builtins.property
    def page_size(self) -> int:
        return self._page_size


datasource_pagination_api_PageRequest.__name__ = "PageRequest"
datasource_pagination_api_PageRequest.__qualname__ = "PageRequest"
datasource_pagination_api_PageRequest.__module__ = "scout_service_api.datasource_pagination_api"


class datasource_pagination_api_PageResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[datasource_pagination_api_PageToken])
        }

    __slots__: List[str] = ['_next_page_token']

    def __init__(self, next_page_token: Optional[str] = None) -> None:
        self._next_page_token = next_page_token

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


datasource_pagination_api_PageResponse.__name__ = "PageResponse"
datasource_pagination_api_PageResponse.__qualname__ = "PageResponse"
datasource_pagination_api_PageResponse.__module__ = "scout_service_api.datasource_pagination_api"


class event_CreateEvent(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'associations': ConjureFieldDefinition('associations', List[str]),
            'dataset_rid': ConjureFieldDefinition('datasetRid', str),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration),
            'name': ConjureFieldDefinition('name', str),
            'type': ConjureFieldDefinition('type', OptionalTypeWrapper[event_EventType])
        }

    __slots__: List[str] = ['_associations', '_dataset_rid', '_timestamp', '_duration', '_name', '_type']

    def __init__(self, associations: List[str], dataset_rid: str, duration: "scout_run_api_Duration", name: str, timestamp: "api_Timestamp", type: Optional["event_EventType"] = None) -> None:
        self._associations = associations
        self._dataset_rid = dataset_rid
        self._timestamp = timestamp
        self._duration = duration
        self._name = name
        self._type = type

    @builtins.property
    def associations(self) -> List[str]:
        return self._associations

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def type(self) -> Optional["event_EventType"]:
        return self._type


event_CreateEvent.__name__ = "CreateEvent"
event_CreateEvent.__qualname__ = "CreateEvent"
event_CreateEvent.__module__ = "scout_service_api.event"


class event_Event(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration),
            'name': ConjureFieldDefinition('name', str),
            'dataset_rid': ConjureFieldDefinition('datasetRid', str),
            'type': ConjureFieldDefinition('type', event_EventType)
        }

    __slots__: List[str] = ['_uuid', '_timestamp', '_duration', '_name', '_dataset_rid', '_type']

    def __init__(self, dataset_rid: str, duration: "scout_run_api_Duration", name: str, timestamp: "api_Timestamp", type: "event_EventType", uuid: str) -> None:
        self._uuid = uuid
        self._timestamp = timestamp
        self._duration = duration
        self._name = name
        self._dataset_rid = dataset_rid
        self._type = type

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def type(self) -> "event_EventType":
        return self._type


event_Event.__name__ = "Event"
event_Event.__qualname__ = "Event"
event_Event.__module__ = "scout_service_api.event"


class event_EventService(Service):
    """
    An Event is an annotated moment or time range.
The Event Service is responsible for creating and retrieving events for a particular data source.
    """

    def create_event(self, auth_header: str, request: "event_CreateEvent") -> "event_Event":
        """
        Creates an event
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/event/v1/events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), event_Event, self._return_none_for_unknown_union_types)

    def get_events(self, auth_header: str, request: "event_GetEvents") -> List["event_Event"]:
        """
        Gets a set of events by UUIDs
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/event/v1/get-events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[event_Event], self._return_none_for_unknown_union_types)


event_EventService.__name__ = "EventService"
event_EventService.__qualname__ = "EventService"
event_EventService.__module__ = "scout_service_api.event"


class event_EventType(ConjureEnumType):

    INFO = 'INFO'
    '''INFO'''
    FLAG = 'FLAG'
    '''FLAG'''
    ERROR = 'ERROR'
    '''ERROR'''
    SUCCESS = 'SUCCESS'
    '''SUCCESS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


event_EventType.__name__ = "EventType"
event_EventType.__qualname__ = "EventType"
event_EventType.__module__ = "scout_service_api.event"


class event_GetEvents(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuids': ConjureFieldDefinition('uuids', List[str])
        }

    __slots__: List[str] = ['_uuids']

    def __init__(self, uuids: List[str]) -> None:
        self._uuids = uuids

    @builtins.property
    def uuids(self) -> List[str]:
        return self._uuids


event_GetEvents.__name__ = "GetEvents"
event_GetEvents.__qualname__ = "GetEvents"
event_GetEvents.__module__ = "scout_service_api.event"


class ingest_api_AbsoluteTimestamp(ConjureUnionType):
    _iso8601: Optional["ingest_api_Iso8601Timestamp"] = None
    _epoch_of_time_unit: Optional["ingest_api_EpochTimestamp"] = None
    _custom_format: Optional["ingest_api_CustomTimestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'iso8601': ConjureFieldDefinition('iso8601', ingest_api_Iso8601Timestamp),
            'epoch_of_time_unit': ConjureFieldDefinition('epochOfTimeUnit', ingest_api_EpochTimestamp),
            'custom_format': ConjureFieldDefinition('customFormat', ingest_api_CustomTimestamp)
        }

    def __init__(
            self,
            iso8601: Optional["ingest_api_Iso8601Timestamp"] = None,
            epoch_of_time_unit: Optional["ingest_api_EpochTimestamp"] = None,
            custom_format: Optional["ingest_api_CustomTimestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (iso8601 is not None) + (epoch_of_time_unit is not None) + (custom_format is not None) != 1:
                raise ValueError('a union must contain a single member')

            if iso8601 is not None:
                self._iso8601 = iso8601
                self._type = 'iso8601'
            if epoch_of_time_unit is not None:
                self._epoch_of_time_unit = epoch_of_time_unit
                self._type = 'epochOfTimeUnit'
            if custom_format is not None:
                self._custom_format = custom_format
                self._type = 'customFormat'

        elif type_of_union == 'iso8601':
            if iso8601 is None:
                raise ValueError('a union value must not be None')
            self._iso8601 = iso8601
            self._type = 'iso8601'
        elif type_of_union == 'epochOfTimeUnit':
            if epoch_of_time_unit is None:
                raise ValueError('a union value must not be None')
            self._epoch_of_time_unit = epoch_of_time_unit
            self._type = 'epochOfTimeUnit'
        elif type_of_union == 'customFormat':
            if custom_format is None:
                raise ValueError('a union value must not be None')
            self._custom_format = custom_format
            self._type = 'customFormat'

    @builtins.property
    def iso8601(self) -> Optional["ingest_api_Iso8601Timestamp"]:
        return self._iso8601

    @builtins.property
    def epoch_of_time_unit(self) -> Optional["ingest_api_EpochTimestamp"]:
        return self._epoch_of_time_unit

    @builtins.property
    def custom_format(self) -> Optional["ingest_api_CustomTimestamp"]:
        return self._custom_format

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_AbsoluteTimestampVisitor):
            raise ValueError('{} is not an instance of ingest_api_AbsoluteTimestampVisitor'.format(visitor.__class__.__name__))
        if self._type == 'iso8601' and self.iso8601 is not None:
            return visitor._iso8601(self.iso8601)
        if self._type == 'epochOfTimeUnit' and self.epoch_of_time_unit is not None:
            return visitor._epoch_of_time_unit(self.epoch_of_time_unit)
        if self._type == 'customFormat' and self.custom_format is not None:
            return visitor._custom_format(self.custom_format)


ingest_api_AbsoluteTimestamp.__name__ = "AbsoluteTimestamp"
ingest_api_AbsoluteTimestamp.__qualname__ = "AbsoluteTimestamp"
ingest_api_AbsoluteTimestamp.__module__ = "scout_service_api.ingest_api"


class ingest_api_AbsoluteTimestampVisitor:

    @abstractmethod
    def _iso8601(self, iso8601: "ingest_api_Iso8601Timestamp") -> Any:
        pass

    @abstractmethod
    def _epoch_of_time_unit(self, epoch_of_time_unit: "ingest_api_EpochTimestamp") -> Any:
        pass

    @abstractmethod
    def _custom_format(self, custom_format: "ingest_api_CustomTimestamp") -> Any:
        pass


ingest_api_AbsoluteTimestampVisitor.__name__ = "AbsoluteTimestampVisitor"
ingest_api_AbsoluteTimestampVisitor.__qualname__ = "AbsoluteTimestampVisitor"
ingest_api_AbsoluteTimestampVisitor.__module__ = "scout_service_api.ingest_api"


class ingest_api_AsyncHandle(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', str)
        }

    __slots__: List[str] = ['_rid']

    def __init__(self, rid: str) -> None:
        self._rid = rid

    @builtins.property
    def rid(self) -> str:
        return self._rid


ingest_api_AsyncHandle.__name__ = "AsyncHandle"
ingest_api_AsyncHandle.__qualname__ = "AsyncHandle"
ingest_api_AsyncHandle.__module__ = "scout_service_api.ingest_api"


class ingest_api_ChannelConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'prefix_tree_delimiter': ConjureFieldDefinition('prefixTreeDelimiter', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_prefix_tree_delimiter']

    def __init__(self, prefix_tree_delimiter: Optional[str] = None) -> None:
        self._prefix_tree_delimiter = prefix_tree_delimiter

    @builtins.property
    def prefix_tree_delimiter(self) -> Optional[str]:
        """
        If set, will construct a prefix tree for channels of the dataset using the given delimiter.
        """
        return self._prefix_tree_delimiter


ingest_api_ChannelConfig.__name__ = "ChannelConfig"
ingest_api_ChannelConfig.__qualname__ = "ChannelConfig"
ingest_api_ChannelConfig.__module__ = "scout_service_api.ingest_api"


class ingest_api_CompleteMultipartUploadResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'location': ConjureFieldDefinition('location', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_location']

    def __init__(self, location: Optional[str] = None) -> None:
        self._location = location

    @builtins.property
    def location(self) -> Optional[str]:
        return self._location


ingest_api_CompleteMultipartUploadResponse.__name__ = "CompleteMultipartUploadResponse"
ingest_api_CompleteMultipartUploadResponse.__qualname__ = "CompleteMultipartUploadResponse"
ingest_api_CompleteMultipartUploadResponse.__module__ = "scout_service_api.ingest_api"


class ingest_api_CustomTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'format': ConjureFieldDefinition('format', str),
            'default_year': ConjureFieldDefinition('defaultYear', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_format', '_default_year']

    def __init__(self, format: str, default_year: Optional[int] = None) -> None:
        self._format = format
        self._default_year = default_year

    @builtins.property
    def format(self) -> str:
        """
        The format string should be in the format of the `DateTimeFormatter` class in Java.
        """
        return self._format

    @builtins.property
    def default_year(self) -> Optional[int]:
        """
        Default year is accepted as an optional field for cases like IRIG time format and will be overridden by year in time format.
        """
        return self._default_year


ingest_api_CustomTimestamp.__name__ = "CustomTimestamp"
ingest_api_CustomTimestamp.__qualname__ = "CustomTimestamp"
ingest_api_CustomTimestamp.__module__ = "scout_service_api.ingest_api"


class ingest_api_DatasetSpec(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_name']

    def __init__(self, name: Optional[str] = None) -> None:
        self._name = name

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name


ingest_api_DatasetSpec.__name__ = "DatasetSpec"
ingest_api_DatasetSpec.__qualname__ = "DatasetSpec"
ingest_api_DatasetSpec.__module__ = "scout_service_api.ingest_api"


class ingest_api_DeprecatedNewCsv(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[str, str]),
            'time_column_spec': ConjureFieldDefinition('timeColumnSpec', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'channel_config': ConjureFieldDefinition('channelConfig', OptionalTypeWrapper[ingest_api_ChannelConfig])
        }

    __slots__: List[str] = ['_source', '_name', '_properties', '_time_column_spec', '_channel_config']

    def __init__(self, properties: Dict[str, str], source: "ingest_api_IngestSource", channel_config: Optional["ingest_api_ChannelConfig"] = None, name: Optional[str] = None, time_column_spec: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._source = source
        self._name = name
        self._properties = properties
        self._time_column_spec = time_column_spec
        self._channel_config = channel_config

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def time_column_spec(self) -> Optional["ingest_api_TimestampMetadata"]:
        return self._time_column_spec

    @builtins.property
    def channel_config(self) -> Optional["ingest_api_ChannelConfig"]:
        return self._channel_config


ingest_api_DeprecatedNewCsv.__name__ = "DeprecatedNewCsv"
ingest_api_DeprecatedNewCsv.__qualname__ = "DeprecatedNewCsv"
ingest_api_DeprecatedNewCsv.__module__ = "scout_service_api.ingest_api"


class ingest_api_DeprecatedNewDataSource(ConjureUnionType):
    _csv: Optional["ingest_api_DeprecatedNewCsv"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'csv': ConjureFieldDefinition('csv', ingest_api_DeprecatedNewCsv)
        }

    def __init__(
            self,
            csv: Optional["ingest_api_DeprecatedNewCsv"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (csv is not None) != 1:
                raise ValueError('a union must contain a single member')

            if csv is not None:
                self._csv = csv
                self._type = 'csv'

        elif type_of_union == 'csv':
            if csv is None:
                raise ValueError('a union value must not be None')
            self._csv = csv
            self._type = 'csv'

    @builtins.property
    def csv(self) -> Optional["ingest_api_DeprecatedNewCsv"]:
        return self._csv

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_DeprecatedNewDataSourceVisitor):
            raise ValueError('{} is not an instance of ingest_api_DeprecatedNewDataSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'csv' and self.csv is not None:
            return visitor._csv(self.csv)


ingest_api_DeprecatedNewDataSource.__name__ = "DeprecatedNewDataSource"
ingest_api_DeprecatedNewDataSource.__qualname__ = "DeprecatedNewDataSource"
ingest_api_DeprecatedNewDataSource.__module__ = "scout_service_api.ingest_api"


class ingest_api_DeprecatedNewDataSourceVisitor:

    @abstractmethod
    def _csv(self, csv: "ingest_api_DeprecatedNewCsv") -> Any:
        pass


ingest_api_DeprecatedNewDataSourceVisitor.__name__ = "DeprecatedNewDataSourceVisitor"
ingest_api_DeprecatedNewDataSourceVisitor.__qualname__ = "DeprecatedNewDataSourceVisitor"
ingest_api_DeprecatedNewDataSourceVisitor.__module__ = "scout_service_api.ingest_api"


class ingest_api_DeprecatedTimestampMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_name': ConjureFieldDefinition('seriesName', str),
            'is_absolute': ConjureFieldDefinition('isAbsolute', bool)
        }

    __slots__: List[str] = ['_series_name', '_is_absolute']

    def __init__(self, is_absolute: bool, series_name: str) -> None:
        self._series_name = series_name
        self._is_absolute = is_absolute

    @builtins.property
    def series_name(self) -> str:
        return self._series_name

    @builtins.property
    def is_absolute(self) -> bool:
        return self._is_absolute


ingest_api_DeprecatedTimestampMetadata.__name__ = "DeprecatedTimestampMetadata"
ingest_api_DeprecatedTimestampMetadata.__qualname__ = "DeprecatedTimestampMetadata"
ingest_api_DeprecatedTimestampMetadata.__module__ = "scout_service_api.ingest_api"


class ingest_api_DeprecatedTriggerIngest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'properties': ConjureFieldDefinition('properties', Dict[str, str]),
            'dataset_name': ConjureFieldDefinition('datasetName', OptionalTypeWrapper[str]),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[ingest_api_DeprecatedTimestampMetadata])
        }

    __slots__: List[str] = ['_source', '_properties', '_dataset_name', '_timestamp_metadata']

    def __init__(self, properties: Dict[str, str], source: "ingest_api_IngestSource", dataset_name: Optional[str] = None, timestamp_metadata: Optional["ingest_api_DeprecatedTimestampMetadata"] = None) -> None:
        self._source = source
        self._properties = properties
        self._dataset_name = dataset_name
        self._timestamp_metadata = timestamp_metadata

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def dataset_name(self) -> Optional[str]:
        return self._dataset_name

    @builtins.property
    def timestamp_metadata(self) -> Optional["ingest_api_DeprecatedTimestampMetadata"]:
        return self._timestamp_metadata


ingest_api_DeprecatedTriggerIngest.__name__ = "DeprecatedTriggerIngest"
ingest_api_DeprecatedTriggerIngest.__qualname__ = "DeprecatedTriggerIngest"
ingest_api_DeprecatedTriggerIngest.__module__ = "scout_service_api.ingest_api"


class ingest_api_EpochTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', ingest_api_TimeUnit)
        }

    __slots__: List[str] = ['_time_unit']

    def __init__(self, time_unit: "ingest_api_TimeUnit") -> None:
        self._time_unit = time_unit

    @builtins.property
    def time_unit(self) -> "ingest_api_TimeUnit":
        return self._time_unit


ingest_api_EpochTimestamp.__name__ = "EpochTimestamp"
ingest_api_EpochTimestamp.__qualname__ = "EpochTimestamp"
ingest_api_EpochTimestamp.__module__ = "scout_service_api.ingest_api"


class ingest_api_ErrorResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_type': ConjureFieldDefinition('errorType', ingest_api_ErrorType),
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_error_type', '_message']

    def __init__(self, error_type: str, message: str) -> None:
        self._error_type = error_type
        self._message = message

    @builtins.property
    def error_type(self) -> str:
        return self._error_type

    @builtins.property
    def message(self) -> str:
        return self._message


ingest_api_ErrorResult.__name__ = "ErrorResult"
ingest_api_ErrorResult.__qualname__ = "ErrorResult"
ingest_api_ErrorResult.__module__ = "scout_service_api.ingest_api"


class ingest_api_ExistingDatasetIngestDestination(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_rid': ConjureFieldDefinition('datasetRid', str)
        }

    __slots__: List[str] = ['_dataset_rid']

    def __init__(self, dataset_rid: str) -> None:
        self._dataset_rid = dataset_rid

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid


ingest_api_ExistingDatasetIngestDestination.__name__ = "ExistingDatasetIngestDestination"
ingest_api_ExistingDatasetIngestDestination.__qualname__ = "ExistingDatasetIngestDestination"
ingest_api_ExistingDatasetIngestDestination.__module__ = "scout_service_api.ingest_api"


class ingest_api_InProgressResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_api_InProgressResult.__name__ = "InProgressResult"
ingest_api_InProgressResult.__qualname__ = "InProgressResult"
ingest_api_InProgressResult.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestDataSource(ConjureUnionType):
    _existing_data_source: Optional[str] = None
    _new_data_source: Optional["ingest_api_DeprecatedNewDataSource"] = None
    _new_data_source_v2: Optional["ingest_api_NewDataSource"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'existing_data_source': ConjureFieldDefinition('existingDataSource', ingest_api_DataSourceRid),
            'new_data_source': ConjureFieldDefinition('newDataSource', ingest_api_DeprecatedNewDataSource),
            'new_data_source_v2': ConjureFieldDefinition('newDataSourceV2', ingest_api_NewDataSource)
        }

    def __init__(
            self,
            existing_data_source: Optional[str] = None,
            new_data_source: Optional["ingest_api_DeprecatedNewDataSource"] = None,
            new_data_source_v2: Optional["ingest_api_NewDataSource"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (existing_data_source is not None) + (new_data_source is not None) + (new_data_source_v2 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if existing_data_source is not None:
                self._existing_data_source = existing_data_source
                self._type = 'existingDataSource'
            if new_data_source is not None:
                self._new_data_source = new_data_source
                self._type = 'newDataSource'
            if new_data_source_v2 is not None:
                self._new_data_source_v2 = new_data_source_v2
                self._type = 'newDataSourceV2'

        elif type_of_union == 'existingDataSource':
            if existing_data_source is None:
                raise ValueError('a union value must not be None')
            self._existing_data_source = existing_data_source
            self._type = 'existingDataSource'
        elif type_of_union == 'newDataSource':
            if new_data_source is None:
                raise ValueError('a union value must not be None')
            self._new_data_source = new_data_source
            self._type = 'newDataSource'
        elif type_of_union == 'newDataSourceV2':
            if new_data_source_v2 is None:
                raise ValueError('a union value must not be None')
            self._new_data_source_v2 = new_data_source_v2
            self._type = 'newDataSourceV2'

    @builtins.property
    def existing_data_source(self) -> Optional[str]:
        return self._existing_data_source

    @builtins.property
    def new_data_source(self) -> Optional["ingest_api_DeprecatedNewDataSource"]:
        return self._new_data_source

    @builtins.property
    def new_data_source_v2(self) -> Optional["ingest_api_NewDataSource"]:
        return self._new_data_source_v2

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestDataSourceVisitor):
            raise ValueError('{} is not an instance of ingest_api_IngestDataSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'existingDataSource' and self.existing_data_source is not None:
            return visitor._existing_data_source(self.existing_data_source)
        if self._type == 'newDataSource' and self.new_data_source is not None:
            return visitor._new_data_source(self.new_data_source)
        if self._type == 'newDataSourceV2' and self.new_data_source_v2 is not None:
            return visitor._new_data_source_v2(self.new_data_source_v2)


ingest_api_IngestDataSource.__name__ = "IngestDataSource"
ingest_api_IngestDataSource.__qualname__ = "IngestDataSource"
ingest_api_IngestDataSource.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestDataSourceVisitor:

    @abstractmethod
    def _existing_data_source(self, existing_data_source: str) -> Any:
        pass

    @abstractmethod
    def _new_data_source(self, new_data_source: "ingest_api_DeprecatedNewDataSource") -> Any:
        pass

    @abstractmethod
    def _new_data_source_v2(self, new_data_source_v2: "ingest_api_NewDataSource") -> Any:
        pass


ingest_api_IngestDataSourceVisitor.__name__ = "IngestDataSourceVisitor"
ingest_api_IngestDataSourceVisitor.__qualname__ = "IngestDataSourceVisitor"
ingest_api_IngestDataSourceVisitor.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestDestination(ConjureUnionType):
    _new_dataset: Optional["ingest_api_NewDatasetIngestDestination"] = None
    _existing_dataset: Optional["ingest_api_ExistingDatasetIngestDestination"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new_dataset': ConjureFieldDefinition('newDataset', ingest_api_NewDatasetIngestDestination),
            'existing_dataset': ConjureFieldDefinition('existingDataset', ingest_api_ExistingDatasetIngestDestination)
        }

    def __init__(
            self,
            new_dataset: Optional["ingest_api_NewDatasetIngestDestination"] = None,
            existing_dataset: Optional["ingest_api_ExistingDatasetIngestDestination"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (new_dataset is not None) + (existing_dataset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if new_dataset is not None:
                self._new_dataset = new_dataset
                self._type = 'newDataset'
            if existing_dataset is not None:
                self._existing_dataset = existing_dataset
                self._type = 'existingDataset'

        elif type_of_union == 'newDataset':
            if new_dataset is None:
                raise ValueError('a union value must not be None')
            self._new_dataset = new_dataset
            self._type = 'newDataset'
        elif type_of_union == 'existingDataset':
            if existing_dataset is None:
                raise ValueError('a union value must not be None')
            self._existing_dataset = existing_dataset
            self._type = 'existingDataset'

    @builtins.property
    def new_dataset(self) -> Optional["ingest_api_NewDatasetIngestDestination"]:
        return self._new_dataset

    @builtins.property
    def existing_dataset(self) -> Optional["ingest_api_ExistingDatasetIngestDestination"]:
        return self._existing_dataset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestDestinationVisitor):
            raise ValueError('{} is not an instance of ingest_api_IngestDestinationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'newDataset' and self.new_dataset is not None:
            return visitor._new_dataset(self.new_dataset)
        if self._type == 'existingDataset' and self.existing_dataset is not None:
            return visitor._existing_dataset(self.existing_dataset)


ingest_api_IngestDestination.__name__ = "IngestDestination"
ingest_api_IngestDestination.__qualname__ = "IngestDestination"
ingest_api_IngestDestination.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestDestinationVisitor:

    @abstractmethod
    def _new_dataset(self, new_dataset: "ingest_api_NewDatasetIngestDestination") -> Any:
        pass

    @abstractmethod
    def _existing_dataset(self, existing_dataset: "ingest_api_ExistingDatasetIngestDestination") -> Any:
        pass


ingest_api_IngestDestinationVisitor.__name__ = "IngestDestinationVisitor"
ingest_api_IngestDestinationVisitor.__qualname__ = "IngestDestinationVisitor"
ingest_api_IngestDestinationVisitor.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestProgressV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', str),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[str]),
            'ingest_status': ConjureFieldDefinition('ingestStatus', ingest_api_IngestStatusV2),
            'incalculable': ConjureFieldDefinition('incalculable', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_start_time', '_end_time', '_ingest_status', '_incalculable']

    def __init__(self, ingest_status: "ingest_api_IngestStatusV2", start_time: str, end_time: Optional[str] = None, incalculable: Optional[bool] = None) -> None:
        self._start_time = start_time
        self._end_time = end_time
        self._ingest_status = ingest_status
        self._incalculable = incalculable

    @builtins.property
    def start_time(self) -> str:
        """
        Timestamp at start of ingest
        """
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional[str]:
        """
        Timestamp at end of ingest, empty if still in progress
        """
        return self._end_time

    @builtins.property
    def ingest_status(self) -> "ingest_api_IngestStatusV2":
        """
        Status of ingest, contains error if failed
        """
        return self._ingest_status

    @builtins.property
    def incalculable(self) -> Optional[bool]:
        """
        Whether ingest duration can be reliably calculated
        """
        return self._incalculable


ingest_api_IngestProgressV2.__name__ = "IngestProgressV2"
ingest_api_IngestProgressV2.__qualname__ = "IngestProgressV2"
ingest_api_IngestProgressV2.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestRunDataSource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source': ConjureFieldDefinition('dataSource', ingest_api_IngestDataSource),
            'time_offset_spec': ConjureFieldDefinition('timeOffsetSpec', OptionalTypeWrapper[ingest_api_TimeOffsetSpec])
        }

    __slots__: List[str] = ['_data_source', '_time_offset_spec']

    def __init__(self, data_source: "ingest_api_IngestDataSource", time_offset_spec: Optional["ingest_api_TimeOffsetSpec"] = None) -> None:
        self._data_source = data_source
        self._time_offset_spec = time_offset_spec

    @builtins.property
    def data_source(self) -> "ingest_api_IngestDataSource":
        return self._data_source

    @builtins.property
    def time_offset_spec(self) -> Optional["ingest_api_TimeOffsetSpec"]:
        return self._time_offset_spec


ingest_api_IngestRunDataSource.__name__ = "IngestRunDataSource"
ingest_api_IngestRunDataSource.__qualname__ = "IngestRunDataSource"
ingest_api_IngestRunDataSource.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', OptionalTypeWrapper[str]),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'start_time': ConjureFieldDefinition('startTime', ingest_api_UtcTimestamp),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[ingest_api_UtcTimestamp]),
            'properties': ConjureFieldDefinition('properties', Dict[ingest_api_PropertyName, ingest_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[ingest_api_Label]),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str]),
            'data_sources': ConjureFieldDefinition('dataSources', Dict[ingest_api_DataSourceRefName, ingest_api_IngestRunDataSource])
        }

    __slots__: List[str] = ['_rid', '_title', '_description', '_start_time', '_end_time', '_properties', '_labels', '_run_prefix', '_data_sources']

    def __init__(self, data_sources: Dict[str, "ingest_api_IngestRunDataSource"], description: str, labels: List[str], properties: Dict[str, str], start_time: "ingest_api_UtcTimestamp", title: str, end_time: Optional["ingest_api_UtcTimestamp"] = None, rid: Optional[str] = None, run_prefix: Optional[str] = None) -> None:
        self._rid = rid
        self._title = title
        self._description = description
        self._start_time = start_time
        self._end_time = end_time
        self._properties = properties
        self._labels = labels
        self._run_prefix = run_prefix
        self._data_sources = data_sources

    @builtins.property
    def rid(self) -> Optional[str]:
        """
        If a run with the same rid already exists, the run will be updated.
        """
        return self._rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def start_time(self) -> "ingest_api_UtcTimestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["ingest_api_UtcTimestamp"]:
        return self._end_time

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        """
        for example, SIM, HTL, FLT
        """
        return self._run_prefix

    @builtins.property
    def data_sources(self) -> Dict[str, "ingest_api_IngestRunDataSource"]:
        return self._data_sources


ingest_api_IngestRunRequest.__name__ = "IngestRunRequest"
ingest_api_IngestRunRequest.__qualname__ = "IngestRunRequest"
ingest_api_IngestRunRequest.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestRunResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', ingest_api_RunRid)
        }

    __slots__: List[str] = ['_run_rid']

    def __init__(self, run_rid: str) -> None:
        self._run_rid = run_rid

    @builtins.property
    def run_rid(self) -> str:
        return self._run_rid


ingest_api_IngestRunResponse.__name__ = "IngestRunResponse"
ingest_api_IngestRunResponse.__qualname__ = "IngestRunResponse"
ingest_api_IngestRunResponse.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestService(Service):
    """
    The Ingest Service handles the data ingestion into Nominal/Clickhouse.
    """

    def deprecated_trigger_ingest(self, auth_header: str, trigger_ingest: "ingest_api_DeprecatedTriggerIngest") -> "ingest_api_TriggeredIngest":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(trigger_ingest)

        _path = '/ingest/v1/trigger-ingest'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_TriggeredIngest, self._return_none_for_unknown_union_types)

    def trigger_ingest(self, auth_header: str, trigger_ingest: "ingest_api_TriggerIngest") -> "ingest_api_TriggeredIngest":
        """
        Triggers an ingest job for the given data source.
The ingest job will be processed asynchronously.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(trigger_ingest)

        _path = '/ingest/v1/trigger-ingest-v2'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_TriggeredIngest, self._return_none_for_unknown_union_types)

    def trigger_file_ingest(self, auth_header: str, trigger_ingest: "ingest_api_TriggerFileIngest") -> "ingest_api_TriggeredIngest":
        """
        Triggers an ingest job of a new file, allowing either creating a new dataset or uploading to an
existing one.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(trigger_ingest)

        _path = '/ingest/v1/trigger-file-ingest'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_TriggeredIngest, self._return_none_for_unknown_union_types)

    def ingest_run(self, auth_header: str, request: "ingest_api_IngestRunRequest") -> "ingest_api_IngestRunResponse":
        """
        Creates a run and ingests data sources to be added to the run.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/ingest/v1/ingest-run'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_IngestRunResponse, self._return_none_for_unknown_union_types)

    def ingest_video(self, auth_header: str, ingest_video: "ingest_api_IngestVideoRequest") -> "ingest_api_IngestVideoResponse":
        """
        Ingests video data from a S3 Nominal upload bucket.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(ingest_video)

        _path = '/ingest/v1/ingest-video'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_IngestVideoResponse, self._return_none_for_unknown_union_types)


ingest_api_IngestService.__name__ = "IngestService"
ingest_api_IngestService.__qualname__ = "IngestService"
ingest_api_IngestService.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestSource(ConjureUnionType):
    _s3: Optional["ingest_api_S3IngestSource"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3': ConjureFieldDefinition('s3', ingest_api_S3IngestSource)
        }

    def __init__(
            self,
            s3: Optional["ingest_api_S3IngestSource"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3 is not None:
                self._s3 = s3
                self._type = 's3'

        elif type_of_union == 's3':
            if s3 is None:
                raise ValueError('a union value must not be None')
            self._s3 = s3
            self._type = 's3'

    @builtins.property
    def s3(self) -> Optional["ingest_api_S3IngestSource"]:
        return self._s3

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestSourceVisitor):
            raise ValueError('{} is not an instance of ingest_api_IngestSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3' and self.s3 is not None:
            return visitor._s3(self.s3)


ingest_api_IngestSource.__name__ = "IngestSource"
ingest_api_IngestSource.__qualname__ = "IngestSource"
ingest_api_IngestSource.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestSourceVisitor:

    @abstractmethod
    def _s3(self, s3: "ingest_api_S3IngestSource") -> Any:
        pass


ingest_api_IngestSourceVisitor.__name__ = "IngestSourceVisitor"
ingest_api_IngestSourceVisitor.__qualname__ = "IngestSourceVisitor"
ingest_api_IngestSourceVisitor.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestSourceMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[ingest_api_TimestampMetadata])
        }

    __slots__: List[str] = ['_timestamp_metadata']

    def __init__(self, timestamp_metadata: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._timestamp_metadata = timestamp_metadata

    @builtins.property
    def timestamp_metadata(self) -> Optional["ingest_api_TimestampMetadata"]:
        return self._timestamp_metadata


ingest_api_IngestSourceMetadata.__name__ = "IngestSourceMetadata"
ingest_api_IngestSourceMetadata.__qualname__ = "IngestSourceMetadata"
ingest_api_IngestSourceMetadata.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestStatus(ConjureEnumType):

    IN_PROGRESS = 'IN_PROGRESS'
    '''IN_PROGRESS'''
    COMPLETED = 'COMPLETED'
    '''COMPLETED'''
    FAILED = 'FAILED'
    '''FAILED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


ingest_api_IngestStatus.__name__ = "IngestStatus"
ingest_api_IngestStatus.__qualname__ = "IngestStatus"
ingest_api_IngestStatus.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestStatusV2(ConjureUnionType):
    _success: Optional["ingest_api_SuccessResult"] = None
    _error: Optional["ingest_api_ErrorResult"] = None
    _in_progress: Optional["ingest_api_InProgressResult"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', ingest_api_SuccessResult),
            'error': ConjureFieldDefinition('error', ingest_api_ErrorResult),
            'in_progress': ConjureFieldDefinition('inProgress', ingest_api_InProgressResult)
        }

    def __init__(
            self,
            success: Optional["ingest_api_SuccessResult"] = None,
            error: Optional["ingest_api_ErrorResult"] = None,
            in_progress: Optional["ingest_api_InProgressResult"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) + (in_progress is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'
            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'
        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'

    @builtins.property
    def success(self) -> Optional["ingest_api_SuccessResult"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["ingest_api_ErrorResult"]:
        return self._error

    @builtins.property
    def in_progress(self) -> Optional["ingest_api_InProgressResult"]:
        return self._in_progress

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestStatusV2Visitor):
            raise ValueError('{} is not an instance of ingest_api_IngestStatusV2Visitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)


ingest_api_IngestStatusV2.__name__ = "IngestStatusV2"
ingest_api_IngestStatusV2.__qualname__ = "IngestStatusV2"
ingest_api_IngestStatusV2.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestStatusV2Visitor:

    @abstractmethod
    def _success(self, success: "ingest_api_SuccessResult") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "ingest_api_ErrorResult") -> Any:
        pass

    @abstractmethod
    def _in_progress(self, in_progress: "ingest_api_InProgressResult") -> Any:
        pass


ingest_api_IngestStatusV2Visitor.__name__ = "IngestStatusV2Visitor"
ingest_api_IngestStatusV2Visitor.__qualname__ = "IngestStatusV2Visitor"
ingest_api_IngestStatusV2Visitor.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestVideoRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sources': ConjureFieldDefinition('sources', List[ingest_api_IngestSource]),
            'properties': ConjureFieldDefinition('properties', Dict[ingest_api_PropertyName, ingest_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[ingest_api_Label]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'timestamps': ConjureFieldDefinition('timestamps', ingest_api_VideoTimestampManifest)
        }

    __slots__: List[str] = ['_sources', '_properties', '_labels', '_title', '_description', '_timestamps']

    def __init__(self, labels: List[str], properties: Dict[str, str], sources: List["ingest_api_IngestSource"], timestamps: "ingest_api_VideoTimestampManifest", description: Optional[str] = None, title: Optional[str] = None) -> None:
        self._sources = sources
        self._properties = properties
        self._labels = labels
        self._title = title
        self._description = description
        self._timestamps = timestamps

    @builtins.property
    def sources(self) -> List["ingest_api_IngestSource"]:
        return self._sources

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def timestamps(self) -> "ingest_api_VideoTimestampManifest":
        return self._timestamps


ingest_api_IngestVideoRequest.__name__ = "IngestVideoRequest"
ingest_api_IngestVideoRequest.__qualname__ = "IngestVideoRequest"
ingest_api_IngestVideoRequest.__module__ = "scout_service_api.ingest_api"


class ingest_api_IngestVideoResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_rid': ConjureFieldDefinition('videoRid', str),
            'async_handle': ConjureFieldDefinition('asyncHandle', ingest_api_AsyncHandle)
        }

    __slots__: List[str] = ['_video_rid', '_async_handle']

    def __init__(self, async_handle: "ingest_api_AsyncHandle", video_rid: str) -> None:
        self._video_rid = video_rid
        self._async_handle = async_handle

    @builtins.property
    def video_rid(self) -> str:
        return self._video_rid

    @builtins.property
    def async_handle(self) -> "ingest_api_AsyncHandle":
        return self._async_handle


ingest_api_IngestVideoResponse.__name__ = "IngestVideoResponse"
ingest_api_IngestVideoResponse.__qualname__ = "IngestVideoResponse"
ingest_api_IngestVideoResponse.__module__ = "scout_service_api.ingest_api"


class ingest_api_InitiateMultipartUploadRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filename': ConjureFieldDefinition('filename', str),
            'filetype': ConjureFieldDefinition('filetype', str)
        }

    __slots__: List[str] = ['_filename', '_filetype']

    def __init__(self, filename: str, filetype: str) -> None:
        self._filename = filename
        self._filetype = filetype

    @builtins.property
    def filename(self) -> str:
        return self._filename

    @builtins.property
    def filetype(self) -> str:
        return self._filetype


ingest_api_InitiateMultipartUploadRequest.__name__ = "InitiateMultipartUploadRequest"
ingest_api_InitiateMultipartUploadRequest.__qualname__ = "InitiateMultipartUploadRequest"
ingest_api_InitiateMultipartUploadRequest.__module__ = "scout_service_api.ingest_api"


class ingest_api_InitiateMultipartUploadResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'upload_id': ConjureFieldDefinition('uploadId', str),
            'key': ConjureFieldDefinition('key', str)
        }

    __slots__: List[str] = ['_upload_id', '_key']

    def __init__(self, key: str, upload_id: str) -> None:
        self._upload_id = upload_id
        self._key = key

    @builtins.property
    def upload_id(self) -> str:
        return self._upload_id

    @builtins.property
    def key(self) -> str:
        return self._key


ingest_api_InitiateMultipartUploadResponse.__name__ = "InitiateMultipartUploadResponse"
ingest_api_InitiateMultipartUploadResponse.__qualname__ = "InitiateMultipartUploadResponse"
ingest_api_InitiateMultipartUploadResponse.__module__ = "scout_service_api.ingest_api"


class ingest_api_Iso8601Timestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_api_Iso8601Timestamp.__name__ = "Iso8601Timestamp"
ingest_api_Iso8601Timestamp.__qualname__ = "Iso8601Timestamp"
ingest_api_Iso8601Timestamp.__module__ = "scout_service_api.ingest_api"


class ingest_api_NewDataSource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'properties': ConjureFieldDefinition('properties', Dict[ingest_api_PropertyName, ingest_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[ingest_api_Label]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'time_column_spec': ConjureFieldDefinition('timeColumnSpec', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'channel_config': ConjureFieldDefinition('channelConfig', OptionalTypeWrapper[ingest_api_ChannelConfig])
        }

    __slots__: List[str] = ['_source', '_properties', '_labels', '_description', '_name', '_time_column_spec', '_channel_config']

    def __init__(self, labels: List[str], properties: Dict[str, str], source: "ingest_api_IngestSource", channel_config: Optional["ingest_api_ChannelConfig"] = None, description: Optional[str] = None, name: Optional[str] = None, time_column_spec: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._source = source
        self._properties = properties
        self._labels = labels
        self._description = description
        self._name = name
        self._time_column_spec = time_column_spec
        self._channel_config = channel_config

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def time_column_spec(self) -> Optional["ingest_api_TimestampMetadata"]:
        return self._time_column_spec

    @builtins.property
    def channel_config(self) -> Optional["ingest_api_ChannelConfig"]:
        return self._channel_config


ingest_api_NewDataSource.__name__ = "NewDataSource"
ingest_api_NewDataSource.__qualname__ = "NewDataSource"
ingest_api_NewDataSource.__module__ = "scout_service_api.ingest_api"


class ingest_api_NewDatasetIngestDestination(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_name': ConjureFieldDefinition('datasetName', OptionalTypeWrapper[str]),
            'dataset_description': ConjureFieldDefinition('datasetDescription', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[ingest_api_PropertyName, ingest_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[ingest_api_Label]),
            'channel_config': ConjureFieldDefinition('channelConfig', OptionalTypeWrapper[ingest_api_ChannelConfig])
        }

    __slots__: List[str] = ['_dataset_name', '_dataset_description', '_properties', '_labels', '_channel_config']

    def __init__(self, labels: List[str], properties: Dict[str, str], channel_config: Optional["ingest_api_ChannelConfig"] = None, dataset_description: Optional[str] = None, dataset_name: Optional[str] = None) -> None:
        self._dataset_name = dataset_name
        self._dataset_description = dataset_description
        self._properties = properties
        self._labels = labels
        self._channel_config = channel_config

    @builtins.property
    def dataset_name(self) -> Optional[str]:
        return self._dataset_name

    @builtins.property
    def dataset_description(self) -> Optional[str]:
        return self._dataset_description

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def channel_config(self) -> Optional["ingest_api_ChannelConfig"]:
        return self._channel_config


ingest_api_NewDatasetIngestDestination.__name__ = "NewDatasetIngestDestination"
ingest_api_NewDatasetIngestDestination.__qualname__ = "NewDatasetIngestDestination"
ingest_api_NewDatasetIngestDestination.__module__ = "scout_service_api.ingest_api"


class ingest_api_NoTimestampManifest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'starting_timestamp': ConjureFieldDefinition('startingTimestamp', ingest_api_UtcTimestamp),
            'scale_parameter': ConjureFieldDefinition('scaleParameter', OptionalTypeWrapper[ingest_api_ScaleParameter])
        }

    __slots__: List[str] = ['_starting_timestamp', '_scale_parameter']

    def __init__(self, starting_timestamp: "ingest_api_UtcTimestamp", scale_parameter: Optional["ingest_api_ScaleParameter"] = None) -> None:
        self._starting_timestamp = starting_timestamp
        self._scale_parameter = scale_parameter

    @builtins.property
    def starting_timestamp(self) -> "ingest_api_UtcTimestamp":
        return self._starting_timestamp

    @builtins.property
    def scale_parameter(self) -> Optional["ingest_api_ScaleParameter"]:
        """
        A field that specifies that the frame rate of the video does not match the frame rate of the camera | i.e. a slowed down or sped up video. Can specify either the camera frame rate or the absolute end time.
        """
        return self._scale_parameter


ingest_api_NoTimestampManifest.__name__ = "NoTimestampManifest"
ingest_api_NoTimestampManifest.__qualname__ = "NoTimestampManifest"
ingest_api_NoTimestampManifest.__module__ = "scout_service_api.ingest_api"


class ingest_api_Part(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'part_number': ConjureFieldDefinition('partNumber', int),
            'etag': ConjureFieldDefinition('etag', str)
        }

    __slots__: List[str] = ['_part_number', '_etag']

    def __init__(self, etag: str, part_number: int) -> None:
        self._part_number = part_number
        self._etag = etag

    @builtins.property
    def part_number(self) -> int:
        return self._part_number

    @builtins.property
    def etag(self) -> str:
        return self._etag


ingest_api_Part.__name__ = "Part"
ingest_api_Part.__qualname__ = "Part"
ingest_api_Part.__module__ = "scout_service_api.ingest_api"


class ingest_api_PartWithSize(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'part_number': ConjureFieldDefinition('partNumber', int),
            'etag': ConjureFieldDefinition('etag', str),
            'size': ConjureFieldDefinition('size', int)
        }

    __slots__: List[str] = ['_part_number', '_etag', '_size']

    def __init__(self, etag: str, part_number: int, size: int) -> None:
        self._part_number = part_number
        self._etag = etag
        self._size = size

    @builtins.property
    def part_number(self) -> int:
        return self._part_number

    @builtins.property
    def etag(self) -> str:
        return self._etag

    @builtins.property
    def size(self) -> int:
        return self._size


ingest_api_PartWithSize.__name__ = "PartWithSize"
ingest_api_PartWithSize.__qualname__ = "PartWithSize"
ingest_api_PartWithSize.__module__ = "scout_service_api.ingest_api"


class ingest_api_RelativeTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', ingest_api_TimeUnit),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_time_unit', '_offset']

    def __init__(self, time_unit: "ingest_api_TimeUnit", offset: Optional[str] = None) -> None:
        self._time_unit = time_unit
        self._offset = offset

    @builtins.property
    def time_unit(self) -> "ingest_api_TimeUnit":
        return self._time_unit

    @builtins.property
    def offset(self) -> Optional[str]:
        """
        Starting timestamp to use when indexing the file. This field is required when uploading a new file to an existing dataset.
        """
        return self._offset


ingest_api_RelativeTimestamp.__name__ = "RelativeTimestamp"
ingest_api_RelativeTimestamp.__qualname__ = "RelativeTimestamp"
ingest_api_RelativeTimestamp.__module__ = "scout_service_api.ingest_api"


class ingest_api_S3IngestSource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'path': ConjureFieldDefinition('path', str)
        }

    __slots__: List[str] = ['_path']

    def __init__(self, path: str) -> None:
        self._path = path

    @builtins.property
    def path(self) -> str:
        return self._path


ingest_api_S3IngestSource.__name__ = "S3IngestSource"
ingest_api_S3IngestSource.__qualname__ = "S3IngestSource"
ingest_api_S3IngestSource.__module__ = "scout_service_api.ingest_api"


class ingest_api_ScaleParameter(ConjureUnionType):
    _true_frame_rate: Optional[float] = None
    _ending_timestamp: Optional["ingest_api_UtcTimestamp"] = None
    _scale_factor: Optional[float] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'true_frame_rate': ConjureFieldDefinition('trueFrameRate', float),
            'ending_timestamp': ConjureFieldDefinition('endingTimestamp', ingest_api_UtcTimestamp),
            'scale_factor': ConjureFieldDefinition('scaleFactor', float)
        }

    def __init__(
            self,
            true_frame_rate: Optional[float] = None,
            ending_timestamp: Optional["ingest_api_UtcTimestamp"] = None,
            scale_factor: Optional[float] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (true_frame_rate is not None) + (ending_timestamp is not None) + (scale_factor is not None) != 1:
                raise ValueError('a union must contain a single member')

            if true_frame_rate is not None:
                self._true_frame_rate = true_frame_rate
                self._type = 'trueFrameRate'
            if ending_timestamp is not None:
                self._ending_timestamp = ending_timestamp
                self._type = 'endingTimestamp'
            if scale_factor is not None:
                self._scale_factor = scale_factor
                self._type = 'scaleFactor'

        elif type_of_union == 'trueFrameRate':
            if true_frame_rate is None:
                raise ValueError('a union value must not be None')
            self._true_frame_rate = true_frame_rate
            self._type = 'trueFrameRate'
        elif type_of_union == 'endingTimestamp':
            if ending_timestamp is None:
                raise ValueError('a union value must not be None')
            self._ending_timestamp = ending_timestamp
            self._type = 'endingTimestamp'
        elif type_of_union == 'scaleFactor':
            if scale_factor is None:
                raise ValueError('a union value must not be None')
            self._scale_factor = scale_factor
            self._type = 'scaleFactor'

    @builtins.property
    def true_frame_rate(self) -> Optional[float]:
        return self._true_frame_rate

    @builtins.property
    def ending_timestamp(self) -> Optional["ingest_api_UtcTimestamp"]:
        """
        the timestamp corresponding to absolute starting timestamp plus absolute duration of the video.
        """
        return self._ending_timestamp

    @builtins.property
    def scale_factor(self) -> Optional[float]:
        """
        the scale factor can be used to calculate whether media duration differs from a video's | real duration, and if so, the true frame rate of the camera. The video time will thus be scaled | by the ratio of the real duration to media duration, or media frame rate to true frame rate.
        """
        return self._scale_factor

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_ScaleParameterVisitor):
            raise ValueError('{} is not an instance of ingest_api_ScaleParameterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'trueFrameRate' and self.true_frame_rate is not None:
            return visitor._true_frame_rate(self.true_frame_rate)
        if self._type == 'endingTimestamp' and self.ending_timestamp is not None:
            return visitor._ending_timestamp(self.ending_timestamp)
        if self._type == 'scaleFactor' and self.scale_factor is not None:
            return visitor._scale_factor(self.scale_factor)


ingest_api_ScaleParameter.__name__ = "ScaleParameter"
ingest_api_ScaleParameter.__qualname__ = "ScaleParameter"
ingest_api_ScaleParameter.__module__ = "scout_service_api.ingest_api"


class ingest_api_ScaleParameterVisitor:

    @abstractmethod
    def _true_frame_rate(self, true_frame_rate: float) -> Any:
        pass

    @abstractmethod
    def _ending_timestamp(self, ending_timestamp: "ingest_api_UtcTimestamp") -> Any:
        pass

    @abstractmethod
    def _scale_factor(self, scale_factor: float) -> Any:
        pass


ingest_api_ScaleParameterVisitor.__name__ = "ScaleParameterVisitor"
ingest_api_ScaleParameterVisitor.__qualname__ = "ScaleParameterVisitor"
ingest_api_ScaleParameterVisitor.__module__ = "scout_service_api.ingest_api"


class ingest_api_SignPartResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'url': ConjureFieldDefinition('url', str),
            'headers': ConjureFieldDefinition('headers', Dict[str, str])
        }

    __slots__: List[str] = ['_url', '_headers']

    def __init__(self, headers: Dict[str, str], url: str) -> None:
        self._url = url
        self._headers = headers

    @builtins.property
    def url(self) -> str:
        return self._url

    @builtins.property
    def headers(self) -> Dict[str, str]:
        return self._headers


ingest_api_SignPartResponse.__name__ = "SignPartResponse"
ingest_api_SignPartResponse.__qualname__ = "SignPartResponse"
ingest_api_SignPartResponse.__module__ = "scout_service_api.ingest_api"


class ingest_api_SkipRowsConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'header_row_index': ConjureFieldDefinition('headerRowIndex', int),
            'data_start_row_index': ConjureFieldDefinition('dataStartRowIndex', int)
        }

    __slots__: List[str] = ['_header_row_index', '_data_start_row_index']

    def __init__(self, data_start_row_index: int, header_row_index: int) -> None:
        self._header_row_index = header_row_index
        self._data_start_row_index = data_start_row_index

    @builtins.property
    def header_row_index(self) -> int:
        return self._header_row_index

    @builtins.property
    def data_start_row_index(self) -> int:
        return self._data_start_row_index


ingest_api_SkipRowsConfig.__name__ = "SkipRowsConfig"
ingest_api_SkipRowsConfig.__qualname__ = "SkipRowsConfig"
ingest_api_SkipRowsConfig.__module__ = "scout_service_api.ingest_api"


class ingest_api_SuccessResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_api_SuccessResult.__name__ = "SuccessResult"
ingest_api_SuccessResult.__qualname__ = "SuccessResult"
ingest_api_SuccessResult.__module__ = "scout_service_api.ingest_api"


class ingest_api_TimeOffsetSpec(ConjureUnionType):
    _nanos: Optional["scout_run_api_Duration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'nanos': ConjureFieldDefinition('nanos', scout_run_api_Duration)
        }

    def __init__(
            self,
            nanos: Optional["scout_run_api_Duration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (nanos is not None) != 1:
                raise ValueError('a union must contain a single member')

            if nanos is not None:
                self._nanos = nanos
                self._type = 'nanos'

        elif type_of_union == 'nanos':
            if nanos is None:
                raise ValueError('a union value must not be None')
            self._nanos = nanos
            self._type = 'nanos'

    @builtins.property
    def nanos(self) -> Optional["scout_run_api_Duration"]:
        return self._nanos

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_TimeOffsetSpecVisitor):
            raise ValueError('{} is not an instance of ingest_api_TimeOffsetSpecVisitor'.format(visitor.__class__.__name__))
        if self._type == 'nanos' and self.nanos is not None:
            return visitor._nanos(self.nanos)


ingest_api_TimeOffsetSpec.__name__ = "TimeOffsetSpec"
ingest_api_TimeOffsetSpec.__qualname__ = "TimeOffsetSpec"
ingest_api_TimeOffsetSpec.__module__ = "scout_service_api.ingest_api"


class ingest_api_TimeOffsetSpecVisitor:

    @abstractmethod
    def _nanos(self, nanos: "scout_run_api_Duration") -> Any:
        pass


ingest_api_TimeOffsetSpecVisitor.__name__ = "TimeOffsetSpecVisitor"
ingest_api_TimeOffsetSpecVisitor.__qualname__ = "TimeOffsetSpecVisitor"
ingest_api_TimeOffsetSpecVisitor.__module__ = "scout_service_api.ingest_api"


class ingest_api_TimeUnit(ConjureEnumType):

    HOURS = 'HOURS'
    '''HOURS'''
    MINUTES = 'MINUTES'
    '''MINUTES'''
    SECONDS = 'SECONDS'
    '''SECONDS'''
    MILLISECONDS = 'MILLISECONDS'
    '''MILLISECONDS'''
    MICROSECONDS = 'MICROSECONDS'
    '''MICROSECONDS'''
    NANOSECONDS = 'NANOSECONDS'
    '''NANOSECONDS'''
    PICOSECONDS = 'PICOSECONDS'
    '''PICOSECONDS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


ingest_api_TimeUnit.__name__ = "TimeUnit"
ingest_api_TimeUnit.__qualname__ = "TimeUnit"
ingest_api_TimeUnit.__module__ = "scout_service_api.ingest_api"


class ingest_api_TimestampManifest(ConjureBeanType):
    """
    The timestamp manifest files will contain a list of absolute timestamps, in nanoseconds, that correspond to 
each frame in a video. Each file should be of type JSON and store a single list, the length of which equals
the number of frames in its corresponding video.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sources': ConjureFieldDefinition('sources', List[ingest_api_IngestSource])
        }

    __slots__: List[str] = ['_sources']

    def __init__(self, sources: List["ingest_api_IngestSource"]) -> None:
        self._sources = sources

    @builtins.property
    def sources(self) -> List["ingest_api_IngestSource"]:
        return self._sources


ingest_api_TimestampManifest.__name__ = "TimestampManifest"
ingest_api_TimestampManifest.__qualname__ = "TimestampManifest"
ingest_api_TimestampManifest.__module__ = "scout_service_api.ingest_api"


class ingest_api_TimestampMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_name': ConjureFieldDefinition('seriesName', str),
            'timestamp_type': ConjureFieldDefinition('timestampType', ingest_api_TimestampType)
        }

    __slots__: List[str] = ['_series_name', '_timestamp_type']

    def __init__(self, series_name: str, timestamp_type: "ingest_api_TimestampType") -> None:
        self._series_name = series_name
        self._timestamp_type = timestamp_type

    @builtins.property
    def series_name(self) -> str:
        return self._series_name

    @builtins.property
    def timestamp_type(self) -> "ingest_api_TimestampType":
        return self._timestamp_type


ingest_api_TimestampMetadata.__name__ = "TimestampMetadata"
ingest_api_TimestampMetadata.__qualname__ = "TimestampMetadata"
ingest_api_TimestampMetadata.__module__ = "scout_service_api.ingest_api"


class ingest_api_TimestampType(ConjureUnionType):
    _relative: Optional["ingest_api_RelativeTimestamp"] = None
    _absolute: Optional["ingest_api_AbsoluteTimestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'relative': ConjureFieldDefinition('relative', ingest_api_RelativeTimestamp),
            'absolute': ConjureFieldDefinition('absolute', ingest_api_AbsoluteTimestamp)
        }

    def __init__(
            self,
            relative: Optional["ingest_api_RelativeTimestamp"] = None,
            absolute: Optional["ingest_api_AbsoluteTimestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (relative is not None) + (absolute is not None) != 1:
                raise ValueError('a union must contain a single member')

            if relative is not None:
                self._relative = relative
                self._type = 'relative'
            if absolute is not None:
                self._absolute = absolute
                self._type = 'absolute'

        elif type_of_union == 'relative':
            if relative is None:
                raise ValueError('a union value must not be None')
            self._relative = relative
            self._type = 'relative'
        elif type_of_union == 'absolute':
            if absolute is None:
                raise ValueError('a union value must not be None')
            self._absolute = absolute
            self._type = 'absolute'

    @builtins.property
    def relative(self) -> Optional["ingest_api_RelativeTimestamp"]:
        return self._relative

    @builtins.property
    def absolute(self) -> Optional["ingest_api_AbsoluteTimestamp"]:
        return self._absolute

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_TimestampTypeVisitor):
            raise ValueError('{} is not an instance of ingest_api_TimestampTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'relative' and self.relative is not None:
            return visitor._relative(self.relative)
        if self._type == 'absolute' and self.absolute is not None:
            return visitor._absolute(self.absolute)


ingest_api_TimestampType.__name__ = "TimestampType"
ingest_api_TimestampType.__qualname__ = "TimestampType"
ingest_api_TimestampType.__module__ = "scout_service_api.ingest_api"


class ingest_api_TimestampTypeVisitor:

    @abstractmethod
    def _relative(self, relative: "ingest_api_RelativeTimestamp") -> Any:
        pass

    @abstractmethod
    def _absolute(self, absolute: "ingest_api_AbsoluteTimestamp") -> Any:
        pass


ingest_api_TimestampTypeVisitor.__name__ = "TimestampTypeVisitor"
ingest_api_TimestampTypeVisitor.__qualname__ = "TimestampTypeVisitor"
ingest_api_TimestampTypeVisitor.__module__ = "scout_service_api.ingest_api"


class ingest_api_TriggerFileIngest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'source_metadata': ConjureFieldDefinition('sourceMetadata', ingest_api_IngestSourceMetadata),
            'destination': ConjureFieldDefinition('destination', ingest_api_IngestDestination)
        }

    __slots__: List[str] = ['_source', '_source_metadata', '_destination']

    def __init__(self, destination: "ingest_api_IngestDestination", source: "ingest_api_IngestSource", source_metadata: "ingest_api_IngestSourceMetadata") -> None:
        self._source = source
        self._source_metadata = source_metadata
        self._destination = destination

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def source_metadata(self) -> "ingest_api_IngestSourceMetadata":
        return self._source_metadata

    @builtins.property
    def destination(self) -> "ingest_api_IngestDestination":
        return self._destination


ingest_api_TriggerFileIngest.__name__ = "TriggerFileIngest"
ingest_api_TriggerFileIngest.__qualname__ = "TriggerFileIngest"
ingest_api_TriggerFileIngest.__module__ = "scout_service_api.ingest_api"


class ingest_api_TriggerIngest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'properties': ConjureFieldDefinition('properties', Dict[ingest_api_PropertyName, ingest_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[ingest_api_Label]),
            'dataset_name': ConjureFieldDefinition('datasetName', OptionalTypeWrapper[str]),
            'dataset_description': ConjureFieldDefinition('datasetDescription', OptionalTypeWrapper[str]),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'channel_config': ConjureFieldDefinition('channelConfig', OptionalTypeWrapper[ingest_api_ChannelConfig])
        }

    __slots__: List[str] = ['_source', '_properties', '_labels', '_dataset_name', '_dataset_description', '_timestamp_metadata', '_channel_config']

    def __init__(self, labels: List[str], properties: Dict[str, str], source: "ingest_api_IngestSource", channel_config: Optional["ingest_api_ChannelConfig"] = None, dataset_description: Optional[str] = None, dataset_name: Optional[str] = None, timestamp_metadata: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._source = source
        self._properties = properties
        self._labels = labels
        self._dataset_name = dataset_name
        self._dataset_description = dataset_description
        self._timestamp_metadata = timestamp_metadata
        self._channel_config = channel_config

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def dataset_name(self) -> Optional[str]:
        return self._dataset_name

    @builtins.property
    def dataset_description(self) -> Optional[str]:
        return self._dataset_description

    @builtins.property
    def timestamp_metadata(self) -> Optional["ingest_api_TimestampMetadata"]:
        return self._timestamp_metadata

    @builtins.property
    def channel_config(self) -> Optional["ingest_api_ChannelConfig"]:
        """
        If absent, will default to a channel config that constructs a prefix tree with `.` as the delimiter.
        """
        return self._channel_config


ingest_api_TriggerIngest.__name__ = "TriggerIngest"
ingest_api_TriggerIngest.__qualname__ = "TriggerIngest"
ingest_api_TriggerIngest.__module__ = "scout_service_api.ingest_api"


class ingest_api_TriggeredIngest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_rid': ConjureFieldDefinition('datasetRid', str),
            'dataset_file_id': ConjureFieldDefinition('datasetFileId', OptionalTypeWrapper[str]),
            'async_handle': ConjureFieldDefinition('asyncHandle', OptionalTypeWrapper[ingest_api_AsyncHandle])
        }

    __slots__: List[str] = ['_dataset_rid', '_dataset_file_id', '_async_handle']

    def __init__(self, dataset_rid: str, async_handle: Optional["ingest_api_AsyncHandle"] = None, dataset_file_id: Optional[str] = None) -> None:
        self._dataset_rid = dataset_rid
        self._dataset_file_id = dataset_file_id
        self._async_handle = async_handle

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def dataset_file_id(self) -> Optional[str]:
        return self._dataset_file_id

    @builtins.property
    def async_handle(self) -> Optional["ingest_api_AsyncHandle"]:
        return self._async_handle


ingest_api_TriggeredIngest.__name__ = "TriggeredIngest"
ingest_api_TriggeredIngest.__qualname__ = "TriggeredIngest"
ingest_api_TriggeredIngest.__module__ = "scout_service_api.ingest_api"


class ingest_api_UtcTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'seconds_since_epoch': ConjureFieldDefinition('secondsSinceEpoch', int),
            'offset_nanoseconds': ConjureFieldDefinition('offsetNanoseconds', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_seconds_since_epoch', '_offset_nanoseconds']

    def __init__(self, seconds_since_epoch: int, offset_nanoseconds: Optional[int] = None) -> None:
        self._seconds_since_epoch = seconds_since_epoch
        self._offset_nanoseconds = offset_nanoseconds

    @builtins.property
    def seconds_since_epoch(self) -> int:
        return self._seconds_since_epoch

    @builtins.property
    def offset_nanoseconds(self) -> Optional[int]:
        return self._offset_nanoseconds


ingest_api_UtcTimestamp.__name__ = "UtcTimestamp"
ingest_api_UtcTimestamp.__qualname__ = "UtcTimestamp"
ingest_api_UtcTimestamp.__module__ = "scout_service_api.ingest_api"


class ingest_api_VideoTimestampManifest(ConjureUnionType):
    _no_manifest: Optional["ingest_api_NoTimestampManifest"] = None
    _timestamp_manifests: Optional["ingest_api_TimestampManifest"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'no_manifest': ConjureFieldDefinition('noManifest', ingest_api_NoTimestampManifest),
            'timestamp_manifests': ConjureFieldDefinition('timestampManifests', ingest_api_TimestampManifest)
        }

    def __init__(
            self,
            no_manifest: Optional["ingest_api_NoTimestampManifest"] = None,
            timestamp_manifests: Optional["ingest_api_TimestampManifest"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (no_manifest is not None) + (timestamp_manifests is not None) != 1:
                raise ValueError('a union must contain a single member')

            if no_manifest is not None:
                self._no_manifest = no_manifest
                self._type = 'noManifest'
            if timestamp_manifests is not None:
                self._timestamp_manifests = timestamp_manifests
                self._type = 'timestampManifests'

        elif type_of_union == 'noManifest':
            if no_manifest is None:
                raise ValueError('a union value must not be None')
            self._no_manifest = no_manifest
            self._type = 'noManifest'
        elif type_of_union == 'timestampManifests':
            if timestamp_manifests is None:
                raise ValueError('a union value must not be None')
            self._timestamp_manifests = timestamp_manifests
            self._type = 'timestampManifests'

    @builtins.property
    def no_manifest(self) -> Optional["ingest_api_NoTimestampManifest"]:
        return self._no_manifest

    @builtins.property
    def timestamp_manifests(self) -> Optional["ingest_api_TimestampManifest"]:
        return self._timestamp_manifests

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_VideoTimestampManifestVisitor):
            raise ValueError('{} is not an instance of ingest_api_VideoTimestampManifestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'noManifest' and self.no_manifest is not None:
            return visitor._no_manifest(self.no_manifest)
        if self._type == 'timestampManifests' and self.timestamp_manifests is not None:
            return visitor._timestamp_manifests(self.timestamp_manifests)


ingest_api_VideoTimestampManifest.__name__ = "VideoTimestampManifest"
ingest_api_VideoTimestampManifest.__qualname__ = "VideoTimestampManifest"
ingest_api_VideoTimestampManifest.__module__ = "scout_service_api.ingest_api"


class ingest_api_VideoTimestampManifestVisitor:

    @abstractmethod
    def _no_manifest(self, no_manifest: "ingest_api_NoTimestampManifest") -> Any:
        pass

    @abstractmethod
    def _timestamp_manifests(self, timestamp_manifests: "ingest_api_TimestampManifest") -> Any:
        pass


ingest_api_VideoTimestampManifestVisitor.__name__ = "VideoTimestampManifestVisitor"
ingest_api_VideoTimestampManifestVisitor.__qualname__ = "VideoTimestampManifestVisitor"
ingest_api_VideoTimestampManifestVisitor.__module__ = "scout_service_api.ingest_api"


class openapi_OpenApiSpecService(Service):
    """
    This service hosts the OpenAPI specification for the Nominal API.
    """

    def get_open_api(self, auth_header: str) -> str:
        """
        Publishes the Nominal OpenAPI Specification.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/openapi'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), str, self._return_none_for_unknown_union_types)


openapi_OpenApiSpecService.__name__ = "OpenApiSpecService"
openapi_OpenApiSpecService.__qualname__ = "OpenApiSpecService"
openapi_OpenApiSpecService.__module__ = "scout_service_api.openapi"


class scout_InternalVersioningService(Service):
    """
    These endpoints are not intended to be used directly by clients, since
they require saving resource-specific state associated with new commits.
    """

    def init_resource_versioning(self, auth_header: str, request: "scout_versioning_api_InitResourceVersioningRequest", resource_rid: str) -> "scout_versioning_api_BranchAndCommit":
        """
        Creates a root commit (no parents) and a "main" branch 
pointing to that commit, for the given resource.
Throws if the resource already has a commit graph.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/versioning/internal/{resourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_BranchAndCommit, self._return_none_for_unknown_union_types)

    def save_working_state(self, auth_header: str, branch_name: str, request: "scout_versioning_api_SaveWorkingStateRequest", resource_rid: str) -> "scout_versioning_api_BranchAndCommit":
        """
        Creates a non-permanent commit on the given branch,
Throws if the branch doesn't exist.
Throws if latestCommit is passed and is not the latest commit.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'branchName': branch_name,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/versioning/internal/{resourceRid}/branch/{branchName}/working-state'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_BranchAndCommit, self._return_none_for_unknown_union_types)

    def commit(self, auth_header: str, branch_name: str, request: "scout_versioning_api_CommitRequest", resource_rid: str) -> "scout_versioning_api_BranchAndCommit":
        """
        Creates a new permanent commit on the given branch.
Throws if the branch doesn't exist.
Throws if latestCommit is passed and is not the latest commit.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'branchName': branch_name,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/versioning/internal/{resourceRid}/branch/{branchName}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_BranchAndCommit, self._return_none_for_unknown_union_types)

    def compact_commits(self, auth_header: str, request: "scout_versioning_api_CompactCommitsRequest", resource_rid: str) -> List[str]:
        """
        Compacts the commit graph for the resource by deleting
working state commits that match the provided strategy.
Persists commits that are pointed to by branches.
Returns the set of commits that were compacted.
Throws if the resource doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/versioning/internal/{resourceRid}/compact-commits'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_CommitId], self._return_none_for_unknown_union_types)


scout_InternalVersioningService.__name__ = "InternalVersioningService"
scout_InternalVersioningService.__qualname__ = "InternalVersioningService"
scout_InternalVersioningService.__module__ = "scout_service_api.scout"


class scout_NotebookService(Service):
    """
    NotebookService manages workbooks (formerly known as notebooks).
    """

    def create(self, auth_header: str, request: "scout_notebook_api_CreateNotebookRequest") -> "scout_notebook_api_Notebook":
        """
        Creates a new workbook. The workbook will be associated with the provided run. If the run does not exist, 
a RunNotFound error will be thrown.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/notebook'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_Notebook, self._return_none_for_unknown_union_types)

    def update(self, auth_header: str, request: "scout_notebook_api_UpdateNotebookRequest", rid: str) -> "scout_notebook_api_Notebook":
        """
        Updates the contents of a workbook.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/notebook/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_Notebook, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, rid: str) -> "scout_notebook_api_Notebook":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_Notebook, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, rids: List[str] = None) -> List["scout_notebook_api_Notebook"]:
        rids = rids if rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(rids)

        _path = '/scout/v2/notebook/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_notebook_api_Notebook], self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "scout_notebook_api_UpdateNotebookMetadataRequest", rid: str) -> "scout_notebook_api_NotebookMetadata":
        """
        Updates metadata about a workbook, but not its contents.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/notebook/{rid}/update-metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_NotebookMetadata, self._return_none_for_unknown_union_types)

    def get_all_labels_and_properties(self, auth_header: str) -> "scout_notebook_api_GetAllLabelsAndPropertiesResponse":
        """
        Returns all properties (key value pairs) and labels that have been previously used on workbook. These can
be used to organize workbooks.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/scout/v2/notebook/get-all-labels-properties'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_GetAllLabelsAndPropertiesResponse, self._return_none_for_unknown_union_types)

    def search(self, auth_header: str, request: "scout_notebook_api_SearchNotebooksRequest") -> "scout_notebook_api_SearchNotebooksResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/notebook/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_SearchNotebooksResponse, self._return_none_for_unknown_union_types)

    def lock(self, auth_header: str, rid: str) -> None:
        """
        Makes a workbook uneditable.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}/lock'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unlock(self, auth_header: str, rid: str) -> None:
        """
        Unlocks a workbook for editing.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}/unlock'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def archive(self, auth_header: str, rid: str) -> None:
        """
        Archives a workbook, which excludes it from search and hides it from being publicly visible, but does not
permanently delete it. Archived workbooks can be unarchived.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, rid: str) -> None:
        """
        Makes a previously archived workbook searchable.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def delete(self, auth_header: str, rid: str) -> None:
        """
        The workbook will be deleted and is not recoverable. For soft deletion, use archive.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_NotebookService.__name__ = "NotebookService"
scout_NotebookService.__qualname__ = "NotebookService"
scout_NotebookService.__module__ = "scout_service_api.scout"


class scout_RunService(Service):
    """
    Runs are collections of channels and metadata from one or more data sources, synchronized over a 
range of real time, which represents a test event or simulation. These API endpoints let you
manage runs in the Nominal app.
    """

    def create_run(self, auth_header: str, details: "scout_run_api_CreateRunRequest") -> "scout_run_api_Run":
        """
        Create a new run in Nominal.

Throws if start is equal to or after end.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(details)

        _path = '/scout/v1/run'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def update_run(self, auth_header: str, details: "scout_run_api_UpdateRunRequest", rid: str) -> "scout_run_api_Run":
        """
        Updates an existing run based on its RID.

Throws if start is equal to or after end.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(details)

        _path = '/scout/v1/run/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def add_data_sources_to_run(self, auth_header: str, request: Dict[str, "scout_run_api_CreateRunDataSource"], run_rid: str) -> "scout_run_api_Run":
        """
        Adds datasources to the run in question.

Throws if any of the ref names conflict with existing data sources or each other.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'runRid': run_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/run/{runRid}/data-sources'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def create_or_update_run(self, auth_header: str, details: "scout_run_api_CreateOrUpdateRunRequest") -> "scout_run_api_Run":
        """
        Updates a run if it exists, otherwise it's created from scratch.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(details)

        _path = '/scout/v1/run/create-or-update'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def get_run(self, auth_header: str, rid: str) -> "scout_run_api_Run":
        """
        Fetches details about the run in question based on its RID.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v1/run/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def get_run_with_data_review_metrics(self, auth_header: str, rid: str) -> "scout_run_api_RunWithDataReviewMetrics":
        """
        Fetches details about the run in question based on its RID, 
including metrics for check and violation review status.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v1/run/{rid}/with-data-review-metrics'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_RunWithDataReviewMetrics, self._return_none_for_unknown_union_types)

    def get_run_with_data_review_summary(self, auth_header: str, rid: str) -> "scout_run_api_RunWithDataReviewSummary":
        """
        Fetches details about the run in question based on its RID, including a summary of the data review status.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v1/run/{rid}/with-data-review-summary'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_RunWithDataReviewSummary, self._return_none_for_unknown_union_types)

    def get_run_by_id(self, auth_header: str, get_run_by_id_request: "scout_run_api_GetRunByIdRequest") -> "scout_run_api_Run":
        """
        Fetches a run based on the run number, rather than RID.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(get_run_by_id_request)

        _path = '/scout/v1/run/by-id'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def get_runs(self, auth_header: str, rids: List[str] = None) -> Dict[str, "scout_run_api_Run"]:
        """
        Fetches a list of run details based on a list of RIDs.
        """
        rids = rids if rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(rids)

        _path = '/scout/v1/run/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_run_api_RunRid, scout_run_api_Run], self._return_none_for_unknown_union_types)

    def get_runs_by_asset(self, auth_header: str, request: "scout_run_api_GetRunsByAssetRequest") -> "scout_run_api_GetRunsByAssetResponse":
        """
        Fetches the runs with the given asset.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/run/by-asset'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_GetRunsByAssetResponse, self._return_none_for_unknown_union_types)

    def get_all_runs_properties_and_labels(self, auth_header: str) -> "scout_run_api_AllRunsPropertiesAndLabelsResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/scout/v1/all-runs-properties-labels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_AllRunsPropertiesAndLabelsResponse, self._return_none_for_unknown_union_types)

    def search_runs(self, auth_header: str, list_runs_request: "scout_run_api_SearchRunsRequest") -> "scout_run_api_SearchRunsResponse":
        """
        Searches for runs that match the given ilters.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(list_runs_request)

        _path = '/scout/v1/search-runs'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_SearchRunsResponse, self._return_none_for_unknown_union_types)

    def search_runs_with_data_review_metrics(self, auth_header: str, list_runs_request: "scout_run_api_SearchRunsRequest") -> "scout_run_api_SearchRunsWithDataReviewMetricsResponse":
        """
        Searches for runs that match the given filters and 
includes metrics for check and violation review status
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(list_runs_request)

        _path = '/scout/v1/search-runs-with-data-review-metrics'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_SearchRunsWithDataReviewMetricsResponse, self._return_none_for_unknown_union_types)

    def search_runs_with_data_review_summary(self, auth_header: str, list_runs_request: "scout_run_api_SearchRunsRequest") -> "scout_run_api_SearchRunsWithDataReviewSummaryResponse":
        """
        Searches for runs that match the given filters and includes a summary of the data review status.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(list_runs_request)

        _path = '/scout/v1/search-runs-with-data-review-summary'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_SearchRunsWithDataReviewSummaryResponse, self._return_none_for_unknown_union_types)

    def archive_run(self, auth_header: str, rid: str) -> bool:
        """
        Soft-deletes a run. Runs still exist in the database but are no longer visible.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v1/archive-run/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), bool, self._return_none_for_unknown_union_types)

    def get_data_source_ref_name_and_type_list(self, auth_header: str) -> List["scout_run_api_RefNameAndType"]:
        """
        Returns the list of ref names that are in use across an entire organization.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/scout/v1/data-source-ref-names-and-types'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_run_api_RefNameAndType], self._return_none_for_unknown_union_types)

    def search_channels(self, auth_header: str, request: "scout_run_api_SearchRunChannelsRequest", rid: str) -> "scout_run_api_SearchRunChannelsResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/run/{rid}/search-channels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_SearchRunChannelsResponse, self._return_none_for_unknown_union_types)

    def get_events(self, auth_header: str, rid: str, next_page_token: Optional[str] = None) -> "scout_run_api_GetEventsForRunPage":
        """
        Fetches a list of events associated with the run.

Returns a maximum page size of 1000.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'nextPageToken': next_page_token,
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v1/run/{rid}/events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_GetEventsForRunPage, self._return_none_for_unknown_union_types)

    def publish_events(self, auth_header: str, request: "scout_run_api_PublishEventsToRunRequest", rid: str) -> None:
        """
        Adds a set of new events to the run.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/run/{rid}/events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def delete_events_from_run(self, auth_header: str, request: "scout_run_api_DeleteEventsFromRunRequest", rid: str) -> None:
        """
        Deletes events from the run.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/run/{rid}/delete-events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def update_run_attachment(self, auth_header: str, request: "scout_run_api_UpdateAttachmentsRequest", rid: str) -> None:
        """
        Updates the attachments associated with a run.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/run/{rid}/attachments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_RunService.__name__ = "RunService"
scout_RunService.__qualname__ = "RunService"
scout_RunService.__module__ = "scout_service_api.scout"


class scout_TemplateService(Service):
    """
    TemplateService manages templates, which are workbooks that
can be re-used across runs. Templates are versioned.
    """

    def create(self, auth_header: str, request: "scout_template_api_CreateTemplateRequest") -> "scout_template_api_Template":
        """
        Creates a new template.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/template'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, template_rid: str, branch: Optional[str] = None, commit: Optional[str] = None) -> "scout_template_api_Template":
        """
        Must only pass one of (branch, commit). If neither are passed,
the latest commit on the "main" branch is returned.
Throws if the template, branch, or commit doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': branch,
            'commit': commit,
        }

        _path_params: Dict[str, Any] = {
            'templateRid': template_rid,
        }

        _json: Any = None

        _path = '/scout/v1/template/{templateRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)

    def save_working_state(self, auth_header: str, request: "scout_template_api_SaveTemplateRequest", template_rid: str, branch: Optional[str] = None) -> "scout_template_api_Template":
        """
        Creates a commit that may be compacted, e.g cleaned up and not exist anymore.
Throws if the template or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you save to an archived template.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': branch,
        }

        _path_params: Dict[str, Any] = {
            'templateRid': template_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/template/{templateRid}/save-working-state'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)

    def commit(self, auth_header: str, request: "scout_template_api_CommitTemplateRequest", template_rid: str, branch: Optional[str] = None) -> "scout_template_api_Template":
        """
        Creates a commit with a commit message. 
Throws if the template or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you commit to an archived template.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': branch,
        }

        _path_params: Dict[str, Any] = {
            'templateRid': template_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/template/{templateRid}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "scout_template_api_UpdateMetadataRequest", template_rid: str) -> "scout_template_api_TemplateMetadata":
        """
        Throws if the template doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'templateRid': template_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/template/{templateRid}/metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_TemplateMetadata, self._return_none_for_unknown_union_types)

    def search_templates(self, auth_header: str, request: "scout_template_api_SearchTemplatesRequest") -> "scout_template_api_SearchTemplatesResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/template/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_SearchTemplatesResponse, self._return_none_for_unknown_union_types)

    def get_all_labels_and_properties(self, auth_header: str) -> "scout_template_api_GetAllLabelsAndPropertiesResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/scout/v1/template/get-all-labels-properties'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_GetAllLabelsAndPropertiesResponse, self._return_none_for_unknown_union_types)

    def merge_to_main(self, auth_header: str, request: "scout_template_api_MergeToMainRequest", template_rid: str) -> "scout_template_api_Template":
        """
        Merges the given branch to the "main" branch.
Throws if the template or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you merge on an archived template.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'templateRid': template_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/template/{templateRid}/merge-to-main'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)


scout_TemplateService.__name__ = "TemplateService"
scout_TemplateService.__qualname__ = "TemplateService"
scout_TemplateService.__module__ = "scout_service_api.scout"


class scout_UnitsService(Service):
    """
    The Units Service serves as a comprehensive catalog of the units of measurement supported by scout. Units, by 
default, follow the UCUM convention for representation.
    """

    def get_all_units(self, auth_header: str) -> "scout_units_api_GetUnitsResponse":
        """
        Returns all known units, grouped by the physical property they measure.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/units/v1/units'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_units_api_GetUnitsResponse, self._return_none_for_unknown_union_types)

    def get_unit(self, auth_header: str, unit: str) -> Optional["scout_units_api_Unit"]:
        """
        Returns information for a unit symbol if available. Returns as empty if the provided symbol cannot be parsed.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(unit)

        _path = '/units/v1/units/get-unit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[scout_units_api_Unit], self._return_none_for_unknown_union_types)

    def get_commensurable_units(self, auth_header: str, unit: str) -> List["scout_units_api_Unit"]:
        """
        Returns the set of units that can be converted to and from the given unit.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(unit)

        _path = '/units/v1/units/commensurable-units'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_units_api_Unit], self._return_none_for_unknown_union_types)


scout_UnitsService.__name__ = "UnitsService"
scout_UnitsService.__qualname__ = "UnitsService"
scout_UnitsService.__module__ = "scout_service_api.scout"


class scout_VersioningService(Service):
    """
    This is the external-facing portion of VersioningService which
gives clients access to functionality that doesn't create new
commits. The creation of new commits should be done via the
resource-specific services.
    """

    def create_branch(self, auth_header: str, request: "scout_versioning_api_CreateBranchRequest", resource_rid: str) -> "scout_versioning_api_Branch":
        """
        Creates a mutable pointer to the provided commit.
"Saves"/"commits" can be performed on this pointer.
Throws if the name is already used as a commit
pointer for this resource.
Throws if the provided commit doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/versioning/{resourceRid}/branch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Branch, self._return_none_for_unknown_union_types)

    def create_tag(self, auth_header: str, request: "scout_versioning_api_CreateTagRequest", resource_rid: str) -> "scout_versioning_api_Tag":
        """
        Creates an immutable pointer to the provided commit.
Throws if the name is already used as a commit
pointer for this resource.
Throws if the provided commit doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/versioning/{resourceRid}/tag'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Tag, self._return_none_for_unknown_union_types)

    def get_commit(self, auth_header: str, commit_id: str, resource_rid: str) -> "scout_versioning_api_Commit":
        """
        Throws if the commit doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'commitId': commit_id,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/commit/{commitId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Commit, self._return_none_for_unknown_union_types)

    def batch_get_commits(self, auth_header: str, resource_and_commit_ids: List["scout_versioning_api_ResourceAndCommitId"] = None) -> List["scout_versioning_api_Commit"]:
        """
        Filters out resources that are not authorized.
        """
        resource_and_commit_ids = resource_and_commit_ids if resource_and_commit_ids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(resource_and_commit_ids)

        _path = '/scout/v1/versioning/commit/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Commit], self._return_none_for_unknown_union_types)

    def get_commit_by_branch(self, auth_header: str, branch_name: str, resource_rid: str) -> "scout_versioning_api_Commit":
        """
        Returns the commit pointed to by the branch.
Throws if the branch doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'branchName': branch_name,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/branch/{branchName}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Commit, self._return_none_for_unknown_union_types)

    def get_commit_by_tag(self, auth_header: str, resource_rid: str, tag_name: str) -> "scout_versioning_api_Commit":
        """
        Returns the commit pointed to by the tag.
Throws if the tag doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'tagName': tag_name,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/tag/{tagName}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Commit, self._return_none_for_unknown_union_types)

    def get_least_common_ancestor(self, auth_header: str, request: "scout_versioning_api_GetLeastCommonAncestorRequest", resource_rid: str) -> str:
        """
        Returns the least common ancestor of the two commits.
Throws if either commit doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/versioning/{resourceRid}/commit/least-common-ancestor'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_CommitId, self._return_none_for_unknown_union_types)

    def get_commit_history(self, auth_header: str, commit_id: str, resource_rid: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> "scout_versioning_api_CommitHistory":
        """
        Returns the commit history sorted by creation time descending.
Excludes working state commits.
Throws if the commit doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'pageSize': page_size,
            'nextPageToken': next_page_token,
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'commitId': commit_id,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/commit/{commitId}/history'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_CommitHistory, self._return_none_for_unknown_union_types)

    def persist_commits(self, auth_header: str, request: List["scout_versioning_api_ResourceAndCommitId"] = None) -> None:
        """
        Persists the commits so that they are not compacted.
This operation is atomic - either all commits are persisted
or none are (in the case of an error).
        """
        request = request if request is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/versioning/commit/persist'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_branch(self, auth_header: str, branch_name: str, resource_rid: str) -> "scout_versioning_api_Branch":
        """
        Throws if the branch doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'branchName': branch_name,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/branch/{branchName}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Branch, self._return_none_for_unknown_union_types)

    def get_branches(self, auth_header: str, resource_rid: str) -> List["scout_versioning_api_Branch"]:
        """
        Returns all branches for the resource in order of
most recently updated.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/branch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Branch], self._return_none_for_unknown_union_types)

    def batch_get_branches(self, auth_header: str, resource_and_branches: List["scout_versioning_api_ResourceAndBranchName"] = None) -> List["scout_versioning_api_Branch"]:
        """
        Omits branches that are not authorized.
        """
        resource_and_branches = resource_and_branches if resource_and_branches is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(resource_and_branches)

        _path = '/scout/v1/versioning/branch/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Branch], self._return_none_for_unknown_union_types)

    def get_tag(self, auth_header: str, resource_rid: str, tag_name: str) -> "scout_versioning_api_Tag":
        """
        Throws if the tag doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'tagName': tag_name,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/tag/{tagName}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Tag, self._return_none_for_unknown_union_types)

    def batch_get_tags(self, auth_header: str, resource_and_commits: List["scout_versioning_api_ResourceAndCommitId"] = None) -> List["scout_versioning_api_Tag"]:
        """
        Omits tags that are not authorized.
        """
        resource_and_commits = resource_and_commits if resource_and_commits is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(resource_and_commits)

        _path = '/scout/v1/versioning/tag/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Tag], self._return_none_for_unknown_union_types)

    def get_tags_by_resource(self, auth_header: str, resource_rid: str) -> List["scout_versioning_api_Tag"]:
        """
        Returns all tags for the resource in order of
most recently created.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/tag'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Tag], self._return_none_for_unknown_union_types)

    def delete_branch(self, auth_header: str, branch_name: str, resource_rid: str) -> None:
        """
        Deletes the branch pointer.
Throws if the branch doesn't exist.
Throws if you attempt to delete the "main" branch.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'branchName': branch_name,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/branch/{branchName}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def delete_branches(self, auth_header: str, resource_and_branches: List["scout_versioning_api_ResourceAndBranchName"] = None) -> None:
        """
        Deletes the branch pointers.
Throws if any resource or branch is non-existent
or unauthorized.
Throws if any attempt is made to delete "main".
        """
        resource_and_branches = resource_and_branches if resource_and_branches is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(resource_and_branches)

        _path = '/scout/v1/versioning/branch/batch-delete'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def delete_tag(self, auth_header: str, resource_rid: str, tag_name: str) -> None:
        """
        Deletes the tag pointer.
Throws if the tag doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'resourceRid': resource_rid,
            'tagName': tag_name,
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/tag/{tagName}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_VersioningService.__name__ = "VersioningService"
scout_VersioningService.__qualname__ = "VersioningService"
scout_VersioningService.__module__ = "scout_service_api.scout"


class scout_api_ChannelLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_ref': ConjureFieldDefinition('dataSourceRef', scout_api_DataSourceRefName),
            'channel': ConjureFieldDefinition('channel', scout_api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_source_ref', '_channel', '_tags']

    def __init__(self, channel: str, data_source_ref: str, tags: Dict[str, str]) -> None:
        self._data_source_ref = data_source_ref
        self._channel = channel
        self._tags = tags

    @builtins.property
    def data_source_ref(self) -> str:
        return self._data_source_ref

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags


scout_api_ChannelLocator.__name__ = "ChannelLocator"
scout_api_ChannelLocator.__qualname__ = "ChannelLocator"
scout_api_ChannelLocator.__module__ = "scout_service_api.scout_api"


class scout_asset_api_AddDataScopesToAssetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_scopes': ConjureFieldDefinition('dataScopes', List[scout_asset_api_CreateAssetDataScope])
        }

    __slots__: List[str] = ['_data_scopes']

    def __init__(self, data_scopes: List["scout_asset_api_CreateAssetDataScope"]) -> None:
        self._data_scopes = data_scopes

    @builtins.property
    def data_scopes(self) -> List["scout_asset_api_CreateAssetDataScope"]:
        """
        The data scopes to add to the asset.

Throws if any existing data scopes have data scope names that conflict with the data scope names
in the request.
        """
        return self._data_scopes


scout_asset_api_AddDataScopesToAssetRequest.__name__ = "AddDataScopesToAssetRequest"
scout_asset_api_AddDataScopesToAssetRequest.__qualname__ = "AddDataScopesToAssetRequest"
scout_asset_api_AddDataScopesToAssetRequest.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_Asset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_AssetRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label]),
            'links': ConjureFieldDefinition('links', List[scout_run_api_Link]),
            'data_scopes': ConjureFieldDefinition('dataScopes', List[scout_asset_api_AssetDataScope]),
            'created_by': ConjureFieldDefinition('createdBy', OptionalTypeWrapper[str]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', str),
            'attachments': ConjureFieldDefinition('attachments', List[scout_rids_api_AttachmentRid])
        }

    __slots__: List[str] = ['_rid', '_title', '_description', '_properties', '_labels', '_links', '_data_scopes', '_created_by', '_created_at', '_updated_at', '_attachments']

    def __init__(self, attachments: List[str], created_at: str, data_scopes: List["scout_asset_api_AssetDataScope"], labels: List[str], links: List["scout_run_api_Link"], properties: Dict[str, str], rid: str, title: str, updated_at: str, created_by: Optional[str] = None, description: Optional[str] = None) -> None:
        self._rid = rid
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._links = links
        self._data_scopes = data_scopes
        self._created_by = created_by
        self._created_at = created_at
        self._updated_at = updated_at
        self._attachments = attachments

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        """
        Labels associated with the asset. These labels do not have a time dimension.
To associate labels with a range of time, create a time range on the asset with labels.
        """
        return self._labels

    @builtins.property
    def links(self) -> List["scout_run_api_Link"]:
        """
        Links associated with the asset. These links do not have a time dimension.
To associate links with a range of time, create a time range on the asset with links.
        """
        return self._links

    @builtins.property
    def data_scopes(self) -> List["scout_asset_api_AssetDataScope"]:
        """
        The data scopes associated with the asset.
        """
        return self._data_scopes

    @builtins.property
    def created_by(self) -> Optional[str]:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at

    @builtins.property
    def attachments(self) -> List[str]:
        return self._attachments


scout_asset_api_Asset.__name__ = "Asset"
scout_asset_api_Asset.__qualname__ = "Asset"
scout_asset_api_Asset.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_AssetDataScope(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_scope_name': ConjureFieldDefinition('dataScopeName', scout_asset_api_DataScopeName),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_run_api_Duration]),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_run_api_WeakTimestampType),
            'series_tags': ConjureFieldDefinition('seriesTags', Dict[scout_asset_api_SeriesTagName, scout_asset_api_SeriesTagValue])
        }

    __slots__: List[str] = ['_data_scope_name', '_data_source', '_offset', '_timestamp_type', '_series_tags']

    def __init__(self, data_scope_name: str, data_source: "scout_run_api_DataSource", series_tags: Dict[str, str], timestamp_type: "scout_run_api_WeakTimestampType", offset: Optional["scout_run_api_Duration"] = None) -> None:
        self._data_scope_name = data_scope_name
        self._data_source = data_source
        self._offset = offset
        self._timestamp_type = timestamp_type
        self._series_tags = series_tags

    @builtins.property
    def data_scope_name(self) -> str:
        """
        The name of the data scope. The name is guaranteed to be be unique within the context of an asset.
        """
        return self._data_scope_name

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def offset(self) -> Optional["scout_run_api_Duration"]:
        return self._offset

    @builtins.property
    def timestamp_type(self) -> "scout_run_api_WeakTimestampType":
        return self._timestamp_type

    @builtins.property
    def series_tags(self) -> Dict[str, str]:
        """
        Filters the data source to series matching these tag values. The filtered set of series should be
the ones that belong to the asset.
        """
        return self._series_tags


scout_asset_api_AssetDataScope.__name__ = "AssetDataScope"
scout_asset_api_AssetDataScope.__qualname__ = "AssetDataScope"
scout_asset_api_AssetDataScope.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_ChannelMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_asset_api_Channel),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[scout_asset_api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'data_type': ConjureFieldDefinition('dataType', OptionalTypeWrapper[scout_asset_api_SeriesDataType])
        }

    __slots__: List[str] = ['_name', '_data_source', '_unit', '_description', '_data_type']

    def __init__(self, data_source: "scout_run_api_DataSource", name: str, data_type: Optional["scout_asset_api_SeriesDataType"] = None, description: Optional[str] = None, unit: Optional["scout_asset_api_Unit"] = None) -> None:
        self._name = name
        self._data_source = data_source
        self._unit = unit
        self._description = description
        self._data_type = data_type

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def unit(self) -> Optional["scout_asset_api_Unit"]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def data_type(self) -> Optional["scout_asset_api_SeriesDataType"]:
        return self._data_type


scout_asset_api_ChannelMetadata.__name__ = "ChannelMetadata"
scout_asset_api_ChannelMetadata.__qualname__ = "ChannelMetadata"
scout_asset_api_ChannelMetadata.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_CreateAssetDataScope(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_scope_name': ConjureFieldDefinition('dataScopeName', scout_asset_api_DataScopeName),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_run_api_Duration]),
            'series_tags': ConjureFieldDefinition('seriesTags', Dict[scout_asset_api_SeriesTagName, scout_asset_api_SeriesTagValue])
        }

    __slots__: List[str] = ['_data_scope_name', '_data_source', '_offset', '_series_tags']

    def __init__(self, data_scope_name: str, data_source: "scout_run_api_DataSource", series_tags: Dict[str, str], offset: Optional["scout_run_api_Duration"] = None) -> None:
        self._data_scope_name = data_scope_name
        self._data_source = data_source
        self._offset = offset
        self._series_tags = series_tags

    @builtins.property
    def data_scope_name(self) -> str:
        """
        The name of the data scope. The name is guaranteed to be be unique within the context of an asset.
        """
        return self._data_scope_name

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def offset(self) -> Optional["scout_run_api_Duration"]:
        return self._offset

    @builtins.property
    def series_tags(self) -> Dict[str, str]:
        """
        Filters the data source to series matching these tag values. The filtered set of series should be
the ones that belong to the asset.
        """
        return self._series_tags


scout_asset_api_CreateAssetDataScope.__name__ = "CreateAssetDataScope"
scout_asset_api_CreateAssetDataScope.__qualname__ = "CreateAssetDataScope"
scout_asset_api_CreateAssetDataScope.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_CreateAssetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label]),
            'links': ConjureFieldDefinition('links', List[scout_run_api_Link]),
            'data_scopes': ConjureFieldDefinition('dataScopes', List[scout_asset_api_CreateAssetDataScope]),
            'attachments': ConjureFieldDefinition('attachments', List[scout_rids_api_AttachmentRid])
        }

    __slots__: List[str] = ['_title', '_description', '_properties', '_labels', '_links', '_data_scopes', '_attachments']

    def __init__(self, attachments: List[str], data_scopes: List["scout_asset_api_CreateAssetDataScope"], labels: List[str], links: List["scout_run_api_Link"], properties: Dict[str, str], title: str, description: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._links = links
        self._data_scopes = data_scopes
        self._attachments = attachments

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def links(self) -> List["scout_run_api_Link"]:
        return self._links

    @builtins.property
    def data_scopes(self) -> List["scout_asset_api_CreateAssetDataScope"]:
        """
        The data scopes associated with the asset.
        """
        return self._data_scopes

    @builtins.property
    def attachments(self) -> List[str]:
        return self._attachments


scout_asset_api_CreateAssetRequest.__name__ = "CreateAssetRequest"
scout_asset_api_CreateAssetRequest.__qualname__ = "CreateAssetRequest"
scout_asset_api_CreateAssetRequest.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_SearchAssetChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'data_scope_name_filter': ConjureFieldDefinition('dataScopeNameFilter', OptionalTypeWrapper[List[scout_asset_api_DataScopeName]]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_search_text', '_data_scope_name_filter', '_next_page_token', '_page_size']

    def __init__(self, search_text: str, data_scope_name_filter: Optional[List[str]] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._search_text = search_text
        self._data_scope_name_filter = data_scope_name_filter
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def search_text(self) -> str:
        return self._search_text

    @builtins.property
    def data_scope_name_filter(self) -> Optional[List[str]]:
        """
        If not empty, will filter to channels from the selected data scope names.
        """
        return self._data_scope_name_filter

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 1000. Will throw if larger than 10000.
        """
        return self._page_size


scout_asset_api_SearchAssetChannelsRequest.__name__ = "SearchAssetChannelsRequest"
scout_asset_api_SearchAssetChannelsRequest.__qualname__ = "SearchAssetChannelsRequest"
scout_asset_api_SearchAssetChannelsRequest.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_SearchAssetChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_asset_api_ChannelMetadata]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_asset_api_ChannelMetadata"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_asset_api_ChannelMetadata"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_asset_api_SearchAssetChannelsResponse.__name__ = "SearchAssetChannelsResponse"
scout_asset_api_SearchAssetChannelsResponse.__qualname__ = "SearchAssetChannelsResponse"
scout_asset_api_SearchAssetChannelsResponse.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_SearchAssetsQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["scout_run_api_Property"] = None
    _and_: Optional[List["scout_asset_api_SearchAssetsQuery"]] = None
    _or_: Optional[List["scout_asset_api_SearchAssetsQuery"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', scout_run_api_Label),
            'property': ConjureFieldDefinition('property', scout_run_api_Property),
            'and_': ConjureFieldDefinition('and', List[scout_asset_api_SearchAssetsQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_asset_api_SearchAssetsQuery])
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["scout_run_api_Property"] = None,
            and_: Optional[List["scout_asset_api_SearchAssetsQuery"]] = None,
            or_: Optional[List["scout_asset_api_SearchAssetsQuery"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["scout_run_api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["scout_asset_api_SearchAssetsQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_asset_api_SearchAssetsQuery"]]:
        return self._or_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_asset_api_SearchAssetsQueryVisitor):
            raise ValueError('{} is not an instance of scout_asset_api_SearchAssetsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)


scout_asset_api_SearchAssetsQuery.__name__ = "SearchAssetsQuery"
scout_asset_api_SearchAssetsQuery.__qualname__ = "SearchAssetsQuery"
scout_asset_api_SearchAssetsQuery.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_SearchAssetsQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_run_api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_asset_api_SearchAssetsQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_asset_api_SearchAssetsQuery"]) -> Any:
        pass


scout_asset_api_SearchAssetsQueryVisitor.__name__ = "SearchAssetsQueryVisitor"
scout_asset_api_SearchAssetsQueryVisitor.__qualname__ = "SearchAssetsQueryVisitor"
scout_asset_api_SearchAssetsQueryVisitor.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_SearchAssetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', scout_asset_api_SortOptions),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'query': ConjureFieldDefinition('query', scout_asset_api_SearchAssetsQuery),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[scout_rids_api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_sort', '_page_size', '_next_page_token', '_query', '_archived_statuses']

    def __init__(self, query: "scout_asset_api_SearchAssetsQuery", sort: "scout_asset_api_SortOptions", archived_statuses: Optional[List["scout_rids_api_ArchivedStatus"]] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._sort = sort
        self._page_size = page_size
        self._next_page_token = next_page_token
        self._query = query
        self._archived_statuses = archived_statuses

    @builtins.property
    def sort(self) -> "scout_asset_api_SortOptions":
        return self._sort

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Page sizes greater than 10_000 will be rejected
        """
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def query(self) -> "scout_asset_api_SearchAssetsQuery":
        return self._query

    @builtins.property
    def archived_statuses(self) -> Optional[List["scout_rids_api_ArchivedStatus"]]:
        """
        Default search status is NOT_ARCHIVED if none are provided. Allows for including archived assets in search.
        """
        return self._archived_statuses


scout_asset_api_SearchAssetsRequest.__name__ = "SearchAssetsRequest"
scout_asset_api_SearchAssetsRequest.__qualname__ = "SearchAssetsRequest"
scout_asset_api_SearchAssetsRequest.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_SearchAssetsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_asset_api_Asset]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_asset_api_Asset"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_asset_api_Asset"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_asset_api_SearchAssetsResponse.__name__ = "SearchAssetsResponse"
scout_asset_api_SearchAssetsResponse.__qualname__ = "SearchAssetsResponse"
scout_asset_api_SearchAssetsResponse.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_SeriesDataType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_asset_api_SeriesDataType.__name__ = "SeriesDataType"
scout_asset_api_SeriesDataType.__qualname__ = "SeriesDataType"
scout_asset_api_SeriesDataType.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_SortField(ConjureEnumType):

    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_asset_api_SortField.__name__ = "SortField"
scout_asset_api_SortField.__qualname__ = "SortField"
scout_asset_api_SortField.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_asset_api_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_asset_api_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_asset_api_SortField":
        return self._field


scout_asset_api_SortOptions.__name__ = "SortOptions"
scout_asset_api_SortOptions.__qualname__ = "SortOptions"
scout_asset_api_SortOptions.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_Unit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'symbol': ConjureFieldDefinition('symbol', str)
        }

    __slots__: List[str] = ['_name', '_symbol']

    def __init__(self, name: str, symbol: str) -> None:
        self._name = name
        self._symbol = symbol

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def symbol(self) -> str:
        return self._symbol


scout_asset_api_Unit.__name__ = "Unit"
scout_asset_api_Unit.__qualname__ = "Unit"
scout_asset_api_Unit.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_UpdateAssetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[scout_run_api_Label]]),
            'links': ConjureFieldDefinition('links', OptionalTypeWrapper[List[scout_run_api_Link]]),
            'data_scopes': ConjureFieldDefinition('dataScopes', OptionalTypeWrapper[List[scout_asset_api_CreateAssetDataScope]])
        }

    __slots__: List[str] = ['_title', '_description', '_properties', '_labels', '_links', '_data_scopes']

    def __init__(self, data_scopes: Optional[List["scout_asset_api_CreateAssetDataScope"]] = None, description: Optional[str] = None, labels: Optional[List[str]] = None, links: Optional[List["scout_run_api_Link"]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._links = links
        self._data_scopes = data_scopes

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def links(self) -> Optional[List["scout_run_api_Link"]]:
        return self._links

    @builtins.property
    def data_scopes(self) -> Optional[List["scout_asset_api_CreateAssetDataScope"]]:
        """
        The data scopes for the asset. This will replace all existing data scopes with the scopes specified.
        """
        return self._data_scopes


scout_asset_api_UpdateAssetRequest.__name__ = "UpdateAssetRequest"
scout_asset_api_UpdateAssetRequest.__qualname__ = "UpdateAssetRequest"
scout_asset_api_UpdateAssetRequest.__module__ = "scout_service_api.scout_asset_api"


class scout_asset_api_UpdateAttachmentsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'attachments_to_add': ConjureFieldDefinition('attachmentsToAdd', List[scout_rids_api_AttachmentRid]),
            'attachments_to_remove': ConjureFieldDefinition('attachmentsToRemove', List[scout_rids_api_AttachmentRid])
        }

    __slots__: List[str] = ['_attachments_to_add', '_attachments_to_remove']

    def __init__(self, attachments_to_add: List[str], attachments_to_remove: List[str]) -> None:
        self._attachments_to_add = attachments_to_add
        self._attachments_to_remove = attachments_to_remove

    @builtins.property
    def attachments_to_add(self) -> List[str]:
        return self._attachments_to_add

    @builtins.property
    def attachments_to_remove(self) -> List[str]:
        return self._attachments_to_remove


scout_asset_api_UpdateAttachmentsRequest.__name__ = "UpdateAttachmentsRequest"
scout_asset_api_UpdateAttachmentsRequest.__qualname__ = "UpdateAttachmentsRequest"
scout_asset_api_UpdateAttachmentsRequest.__module__ = "scout_service_api.scout_asset_api"


class scout_assets_AssetService(Service):
    """
    An asset is a physical entity within an organization, such as a vehicle or ground station. Assets are comprised
of some metadata about the data, as well as a set of data scopes that define the data belonging to the asset. API
endpoints allow for CRUD operations on asset objects.
    """

    def create_asset(self, auth_header: str, details: "scout_asset_api_CreateAssetRequest") -> "scout_asset_api_Asset":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(details)

        _path = '/scout/v1/asset'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_Asset, self._return_none_for_unknown_union_types)

    def update_asset(self, auth_header: str, details: "scout_asset_api_UpdateAssetRequest", rid: str) -> "scout_asset_api_Asset":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(details)

        _path = '/scout/v1/asset/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_Asset, self._return_none_for_unknown_union_types)

    def add_data_scopes_to_asset(self, asset_rid: str, auth_header: str, request: "scout_asset_api_AddDataScopesToAssetRequest") -> "scout_asset_api_Asset":
        """
        Adds data scopes to an asset.

Throws if the asset already has data scopes with data scope names matching those in the request.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'assetRid': asset_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/asset/{assetRid}/data-sources'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_Asset, self._return_none_for_unknown_union_types)

    def get_assets(self, auth_header: str, rids: List[str] = None) -> Dict[str, "scout_asset_api_Asset"]:
        rids = rids if rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(rids)

        _path = '/scout/v1/asset/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_rids_api_AssetRid, scout_asset_api_Asset], self._return_none_for_unknown_union_types)

    def archive(self, auth_header: str, rid: str) -> None:

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v1/archive/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, rid: str) -> None:

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v1/unarchive/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def search_assets(self, auth_header: str, search_assets_request: "scout_asset_api_SearchAssetsRequest") -> "scout_asset_api_SearchAssetsResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(search_assets_request)

        _path = '/scout/v1/search-assets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_SearchAssetsResponse, self._return_none_for_unknown_union_types)

    def update_asset_attachments(self, auth_header: str, request: "scout_asset_api_UpdateAttachmentsRequest", rid: str) -> None:
        """
        Update the attachments associated with an asset.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/asset/{rid}/attachments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_assets_AssetService.__name__ = "AssetService"
scout_assets_AssetService.__qualname__ = "AssetService"
scout_assets_AssetService.__module__ = "scout_service_api.scout_assets"


class scout_catalog_AbsoluteTimestamp(ConjureUnionType):
    _iso8601: Optional["scout_catalog_Iso8601Timestamp"] = None
    _epoch_of_time_unit: Optional["scout_catalog_EpochTimestamp"] = None
    _custom_format: Optional["scout_catalog_CustomTimestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'iso8601': ConjureFieldDefinition('iso8601', scout_catalog_Iso8601Timestamp),
            'epoch_of_time_unit': ConjureFieldDefinition('epochOfTimeUnit', scout_catalog_EpochTimestamp),
            'custom_format': ConjureFieldDefinition('customFormat', scout_catalog_CustomTimestamp)
        }

    def __init__(
            self,
            iso8601: Optional["scout_catalog_Iso8601Timestamp"] = None,
            epoch_of_time_unit: Optional["scout_catalog_EpochTimestamp"] = None,
            custom_format: Optional["scout_catalog_CustomTimestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (iso8601 is not None) + (epoch_of_time_unit is not None) + (custom_format is not None) != 1:
                raise ValueError('a union must contain a single member')

            if iso8601 is not None:
                self._iso8601 = iso8601
                self._type = 'iso8601'
            if epoch_of_time_unit is not None:
                self._epoch_of_time_unit = epoch_of_time_unit
                self._type = 'epochOfTimeUnit'
            if custom_format is not None:
                self._custom_format = custom_format
                self._type = 'customFormat'

        elif type_of_union == 'iso8601':
            if iso8601 is None:
                raise ValueError('a union value must not be None')
            self._iso8601 = iso8601
            self._type = 'iso8601'
        elif type_of_union == 'epochOfTimeUnit':
            if epoch_of_time_unit is None:
                raise ValueError('a union value must not be None')
            self._epoch_of_time_unit = epoch_of_time_unit
            self._type = 'epochOfTimeUnit'
        elif type_of_union == 'customFormat':
            if custom_format is None:
                raise ValueError('a union value must not be None')
            self._custom_format = custom_format
            self._type = 'customFormat'

    @builtins.property
    def iso8601(self) -> Optional["scout_catalog_Iso8601Timestamp"]:
        return self._iso8601

    @builtins.property
    def epoch_of_time_unit(self) -> Optional["scout_catalog_EpochTimestamp"]:
        return self._epoch_of_time_unit

    @builtins.property
    def custom_format(self) -> Optional["scout_catalog_CustomTimestamp"]:
        return self._custom_format

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_AbsoluteTimestampVisitor):
            raise ValueError('{} is not an instance of scout_catalog_AbsoluteTimestampVisitor'.format(visitor.__class__.__name__))
        if self._type == 'iso8601' and self.iso8601 is not None:
            return visitor._iso8601(self.iso8601)
        if self._type == 'epochOfTimeUnit' and self.epoch_of_time_unit is not None:
            return visitor._epoch_of_time_unit(self.epoch_of_time_unit)
        if self._type == 'customFormat' and self.custom_format is not None:
            return visitor._custom_format(self.custom_format)


scout_catalog_AbsoluteTimestamp.__name__ = "AbsoluteTimestamp"
scout_catalog_AbsoluteTimestamp.__qualname__ = "AbsoluteTimestamp"
scout_catalog_AbsoluteTimestamp.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_AbsoluteTimestampVisitor:

    @abstractmethod
    def _iso8601(self, iso8601: "scout_catalog_Iso8601Timestamp") -> Any:
        pass

    @abstractmethod
    def _epoch_of_time_unit(self, epoch_of_time_unit: "scout_catalog_EpochTimestamp") -> Any:
        pass

    @abstractmethod
    def _custom_format(self, custom_format: "scout_catalog_CustomTimestamp") -> Any:
        pass


scout_catalog_AbsoluteTimestampVisitor.__name__ = "AbsoluteTimestampVisitor"
scout_catalog_AbsoluteTimestampVisitor.__qualname__ = "AbsoluteTimestampVisitor"
scout_catalog_AbsoluteTimestampVisitor.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_AddFileToDataset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[scout_catalog_TimestampMetadata])
        }

    __slots__: List[str] = ['_handle', '_timestamp_metadata']

    def __init__(self, handle: "scout_catalog_Handle", timestamp_metadata: Optional["scout_catalog_TimestampMetadata"] = None) -> None:
        self._handle = handle
        self._timestamp_metadata = timestamp_metadata

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle

    @builtins.property
    def timestamp_metadata(self) -> Optional["scout_catalog_TimestampMetadata"]:
        return self._timestamp_metadata


scout_catalog_AddFileToDataset.__name__ = "AddFileToDataset"
scout_catalog_AddFileToDataset.__qualname__ = "AddFileToDataset"
scout_catalog_AddFileToDataset.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_AllPropertiesAndLabelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[datasource_PropertyName, List[datasource_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[datasource_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_catalog_AllPropertiesAndLabelsResponse.__name__ = "AllPropertiesAndLabelsResponse"
scout_catalog_AllPropertiesAndLabelsResponse.__qualname__ = "AllPropertiesAndLabelsResponse"
scout_catalog_AllPropertiesAndLabelsResponse.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_Bounds(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'type': ConjureFieldDefinition('type', datasource_TimestampType)
        }

    __slots__: List[str] = ['_start', '_end', '_type']

    def __init__(self, end: "api_Timestamp", start: "api_Timestamp", type: "datasource_TimestampType") -> None:
        self._start = start
        self._end = end
        self._type = type

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def type(self) -> "datasource_TimestampType":
        return self._type


scout_catalog_Bounds.__name__ = "Bounds"
scout_catalog_Bounds.__qualname__ = "Bounds"
scout_catalog_Bounds.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_CatalogService(Service):
    """
    The Catalog Service provides the ability to query for information about Datasets that are stored in
the Nominal platform. A Dataset is the Nominal representation of data that has been uploaded to Nominal via
a file, primarily CSV.
    """

    def get_enriched_dataset(self, auth_header: str, dataset_uuid: str) -> "scout_catalog_EnrichedDataset":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetUuid': dataset_uuid,
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetUuid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def get_enriched_datasets(self, auth_header: str, get_datasets_request: "scout_catalog_GetDatasetsRequest") -> List["scout_catalog_EnrichedDataset"]:

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(get_datasets_request)

        _path = '/catalog/v1/datasets/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_catalog_EnrichedDataset], self._return_none_for_unknown_union_types)

    def get_dataset(self, auth_header: str, dataset_uuid: str) -> "scout_catalog_Dataset":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetUuid': dataset_uuid,
        }

        _json: Any = None

        _path = '/catalog/v1/datasets-simple/{datasetUuid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_Dataset, self._return_none_for_unknown_union_types)

    def get_datasets(self, auth_header: str, get_datasets_request: "scout_catalog_GetDatasetsRequest") -> List["scout_catalog_Dataset"]:

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(get_datasets_request)

        _path = '/catalog/v1/datasets-simple/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_catalog_Dataset], self._return_none_for_unknown_union_types)

    def get_dataset_file(self, auth_header: str, dataset_rid: str, file_id: str) -> "scout_catalog_DatasetFile":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
            'fileId': file_id,
        }

        _json: Any = None

        _path = '/catalog/v1/dataset/{datasetRid}/file/{fileId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFile, self._return_none_for_unknown_union_types)

    def search_datasets_by_text(self, auth_header: str, request: "scout_catalog_SearchDatasetsByTextRequest") -> "scout_catalog_SearchDatasetsByTextResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/catalog/v1/search-datasets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_SearchDatasetsByTextResponse, self._return_none_for_unknown_union_types)

    def search_datasets(self, auth_header: str, request: "scout_catalog_SearchDatasetsRequest") -> "scout_catalog_SearchDatasetsResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/catalog/v1/search-datasets-v2'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_SearchDatasetsResponse, self._return_none_for_unknown_union_types)

    def update_dataset_ingest_status_v2(self, auth_header: str, details: "scout_catalog_UpdateIngestStatusV2") -> "scout_catalog_IngestStatusV2":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(details)

        _path = '/catalog/v1/datasets/ingest-status-v2'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_IngestStatusV2, self._return_none_for_unknown_union_types)

    def get_ingest_progress_v2(self, auth_header: str, dataset_rid: str) -> "scout_catalog_IngestProgressV2":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/ingest-progress-v2'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_IngestProgressV2, self._return_none_for_unknown_union_types)

    def get_handle_for_dataset(self, auth_header: str, dataset: str) -> "scout_catalog_Handle":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'dataset': dataset,
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{dataset}/handle'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_Handle, self._return_none_for_unknown_union_types)

    def get_series_details(self, auth_header: str, get_series_details: "scout_catalog_GetSeriesDetailsRequest") -> "scout_catalog_SeriesDetails":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(get_series_details)

        _path = '/catalog/v1/series/details'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_SeriesDetails, self._return_none_for_unknown_union_types)

    def create_dataset(self, auth_header: str, details: "scout_catalog_CreateDataset") -> "scout_catalog_EnrichedDataset":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(details)

        _path = '/catalog/v1/datasets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def create_or_update_dataset(self, auth_header: str, details: "scout_catalog_CreateDataset") -> "scout_catalog_EnrichedDataset":
        """
        Creates a dataset if the s3 path does not exist, otherwise updates the dataset
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(details)

        _path = '/catalog/v1/datasets/create-or-update'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def add_file_to_dataset(self, auth_header: str, dataset_rid: str, request: "scout_catalog_AddFileToDataset") -> "scout_catalog_DatasetFile":
        """
        Adds a single file to an existing dataset.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/catalog/v1/datasets/{datasetRid}/add-file'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFile, self._return_none_for_unknown_union_types)

    def list_dataset_files(self, auth_header: str, dataset_rid: str, next_page_token: Optional[str] = None) -> "scout_catalog_DatasetFilesPage":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'nextPageToken': next_page_token,
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/files'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFilesPage, self._return_none_for_unknown_union_types)

    def mark_file_ingest_successful(self, auth_header: str, dataset_rid: str, file_id: str, request: "scout_catalog_MarkFileIngestSuccessful") -> "scout_catalog_DatasetFile":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
            'fileId': file_id,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/catalog/v1/datasets/{datasetRid}/file/{fileId}/success'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFile, self._return_none_for_unknown_union_types)

    def mark_file_ingest_error(self, auth_header: str, dataset_rid: str, file_id: str, request: "scout_catalog_MarkFileIngestError") -> "scout_catalog_DatasetFile":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
            'fileId': file_id,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/catalog/v1/datasets/{datasetRid}/file/{fileId}/error'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFile, self._return_none_for_unknown_union_types)

    def update_dataset_metadata(self, auth_header: str, dataset_rid: str, request: "scout_catalog_UpdateDatasetMetadata") -> "scout_catalog_EnrichedDataset":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/catalog/v1/datasets/{datasetRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def update_bounds(self, auth_header: str, request: "scout_catalog_UpdateBoundsRequest", rid: str) -> "scout_catalog_EnrichedDataset":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/catalog/v1/datasets/{rid}/bounds'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def delete_dataset_series(self, auth_header: str, dataset_rid: str) -> "scout_catalog_DeleteSeriesResult":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
        }

        _json: Any = None

        _path = '/catalog/v1/series/for-dataset/{datasetRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DeleteSeriesResult, self._return_none_for_unknown_union_types)

    def archive_dataset(self, auth_header: str, dataset_rid: str) -> None:
        """
        Archives a dataset, which will hide it from search results unless the includeArchived flag is set to true. The
dataset can still be directly accessed by its UUID/rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive_dataset(self, auth_header: str, dataset_rid: str) -> None:
        """
        Undoes the archiving of a dataset.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'datasetRid': dataset_rid,
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_all_properties_and_labels(self, auth_header: str) -> "scout_catalog_AllPropertiesAndLabelsResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/all-properties-labels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_AllPropertiesAndLabelsResponse, self._return_none_for_unknown_union_types)


scout_catalog_CatalogService.__name__ = "CatalogService"
scout_catalog_CatalogService.__qualname__ = "CatalogService"
scout_catalog_CatalogService.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_Channel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'name': ConjureFieldDefinition('name', str),
            'dataset_uuid': ConjureFieldDefinition('datasetUuid', str)
        }

    __slots__: List[str] = ['_uuid', '_name', '_dataset_uuid']

    def __init__(self, dataset_uuid: str, name: str, uuid: str) -> None:
        self._uuid = uuid
        self._name = name
        self._dataset_uuid = dataset_uuid

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def dataset_uuid(self) -> str:
        return self._dataset_uuid


scout_catalog_Channel.__name__ = "Channel"
scout_catalog_Channel.__qualname__ = "Channel"
scout_catalog_Channel.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_ChannelConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'prefix_tree_delimiter': ConjureFieldDefinition('prefixTreeDelimiter', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_prefix_tree_delimiter']

    def __init__(self, prefix_tree_delimiter: Optional[str] = None) -> None:
        self._prefix_tree_delimiter = prefix_tree_delimiter

    @builtins.property
    def prefix_tree_delimiter(self) -> Optional[str]:
        """
        If set, will construct a prefix tree for channels of the dataset using the given delimiter.
        """
        return self._prefix_tree_delimiter


scout_catalog_ChannelConfig.__name__ = "ChannelConfig"
scout_catalog_ChannelConfig.__qualname__ = "ChannelConfig"
scout_catalog_ChannelConfig.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_ChannelDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'name': ConjureFieldDefinition('name', str),
            'origin_metadata': ConjureFieldDefinition('originMetadata', Dict[str, str]),
            'csv_index': ConjureFieldDefinition('csvIndex', int),
            'dataset_uuid': ConjureFieldDefinition('datasetUuid', str),
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle)
        }

    __slots__: List[str] = ['_uuid', '_name', '_origin_metadata', '_csv_index', '_dataset_uuid', '_handle']

    def __init__(self, csv_index: int, dataset_uuid: str, handle: "scout_catalog_Handle", name: str, origin_metadata: Dict[str, str], uuid: str) -> None:
        self._uuid = uuid
        self._name = name
        self._origin_metadata = origin_metadata
        self._csv_index = csv_index
        self._dataset_uuid = dataset_uuid
        self._handle = handle

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def origin_metadata(self) -> Dict[str, str]:
        return self._origin_metadata

    @builtins.property
    def csv_index(self) -> int:
        return self._csv_index

    @builtins.property
    def dataset_uuid(self) -> str:
        return self._dataset_uuid

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle


scout_catalog_ChannelDetails.__name__ = "ChannelDetails"
scout_catalog_ChannelDetails.__qualname__ = "ChannelDetails"
scout_catalog_ChannelDetails.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_CreateDataset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle),
            'metadata': ConjureFieldDefinition('metadata', Dict[str, str]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_catalog_DatasetOriginMetadata),
            'labels': ConjureFieldDefinition('labels', List[datasource_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[datasource_PropertyName, datasource_PropertyValue]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_name', '_handle', '_metadata', '_origin_metadata', '_labels', '_properties', '_description']

    def __init__(self, handle: "scout_catalog_Handle", labels: List[str], metadata: Dict[str, str], name: str, origin_metadata: "scout_catalog_DatasetOriginMetadata", properties: Dict[str, str], description: Optional[str] = None) -> None:
        self._name = name
        self._handle = handle
        self._metadata = metadata
        self._origin_metadata = origin_metadata
        self._labels = labels
        self._properties = properties
        self._description = description

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle

    @builtins.property
    def metadata(self) -> Dict[str, str]:
        return self._metadata

    @builtins.property
    def origin_metadata(self) -> "scout_catalog_DatasetOriginMetadata":
        return self._origin_metadata

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description


scout_catalog_CreateDataset.__name__ = "CreateDataset"
scout_catalog_CreateDataset.__qualname__ = "CreateDataset"
scout_catalog_CreateDataset.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_CustomTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'format': ConjureFieldDefinition('format', str),
            'default_year': ConjureFieldDefinition('defaultYear', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_format', '_default_year']

    def __init__(self, format: str, default_year: Optional[int] = None) -> None:
        self._format = format
        self._default_year = default_year

    @builtins.property
    def format(self) -> str:
        """
        The format string should be in the format of the `DateTimeFormatter` class in Java.
        """
        return self._format

    @builtins.property
    def default_year(self) -> Optional[int]:
        """
        Year is accepted as an optional field for cases like IRIG time format, and will be assumed as current year if not provided.
        """
        return self._default_year


scout_catalog_CustomTimestamp.__name__ = "CustomTimestamp"
scout_catalog_CustomTimestamp.__qualname__ = "CustomTimestamp"
scout_catalog_CustomTimestamp.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_Dataset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', str),
            'name': ConjureFieldDefinition('name', str),
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_catalog_DatasetOriginMetadata),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_catalog_Bounds]),
            'properties': ConjureFieldDefinition('properties', Dict[datasource_PropertyName, datasource_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[datasource_Label]),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_catalog_WeakTimestampType)
        }

    __slots__: List[str] = ['_rid', '_name', '_handle', '_description', '_origin_metadata', '_bounds', '_properties', '_labels', '_timestamp_type']

    def __init__(self, handle: "scout_catalog_Handle", labels: List[str], name: str, origin_metadata: "scout_catalog_DatasetOriginMetadata", properties: Dict[str, str], rid: str, timestamp_type: "scout_catalog_WeakTimestampType", bounds: Optional["scout_catalog_Bounds"] = None, description: Optional[str] = None) -> None:
        self._rid = rid
        self._name = name
        self._handle = handle
        self._description = description
        self._origin_metadata = origin_metadata
        self._bounds = bounds
        self._properties = properties
        self._labels = labels
        self._timestamp_type = timestamp_type

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def origin_metadata(self) -> "scout_catalog_DatasetOriginMetadata":
        return self._origin_metadata

    @builtins.property
    def bounds(self) -> Optional["scout_catalog_Bounds"]:
        return self._bounds

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def timestamp_type(self) -> "scout_catalog_WeakTimestampType":
        return self._timestamp_type


scout_catalog_Dataset.__name__ = "Dataset"
scout_catalog_Dataset.__qualname__ = "Dataset"
scout_catalog_Dataset.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_DatasetFile(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', datasource_DatasetFileId),
            'dataset_rid': ConjureFieldDefinition('datasetRid', datasource_DatasetRid),
            'name': ConjureFieldDefinition('name', str),
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_catalog_Bounds]),
            'uploaded_at': ConjureFieldDefinition('uploadedAt', str),
            'ingested_at': ConjureFieldDefinition('ingestedAt', OptionalTypeWrapper[str]),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[scout_catalog_TimestampMetadata])
        }

    __slots__: List[str] = ['_id', '_dataset_rid', '_name', '_handle', '_bounds', '_uploaded_at', '_ingested_at', '_timestamp_metadata']

    def __init__(self, dataset_rid: str, handle: "scout_catalog_Handle", id: str, name: str, uploaded_at: str, bounds: Optional["scout_catalog_Bounds"] = None, ingested_at: Optional[str] = None, timestamp_metadata: Optional["scout_catalog_TimestampMetadata"] = None) -> None:
        self._id = id
        self._dataset_rid = dataset_rid
        self._name = name
        self._handle = handle
        self._bounds = bounds
        self._uploaded_at = uploaded_at
        self._ingested_at = ingested_at
        self._timestamp_metadata = timestamp_metadata

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle

    @builtins.property
    def bounds(self) -> Optional["scout_catalog_Bounds"]:
        return self._bounds

    @builtins.property
    def uploaded_at(self) -> str:
        """
        Timestamp that the file was received and stored, but not processed or made available to consumers.
        """
        return self._uploaded_at

    @builtins.property
    def ingested_at(self) -> Optional[str]:
        """
        Timestamp that the file is ingested at and made available for processing. If the file has failed to be
ingested for any reason or is still being processed, then this value will be empty.
        """
        return self._ingested_at

    @builtins.property
    def timestamp_metadata(self) -> Optional["scout_catalog_TimestampMetadata"]:
        return self._timestamp_metadata


scout_catalog_DatasetFile.__name__ = "DatasetFile"
scout_catalog_DatasetFile.__qualname__ = "DatasetFile"
scout_catalog_DatasetFile.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_DatasetFilesPage(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'files': ConjureFieldDefinition('files', List[scout_catalog_DatasetFile]),
            'next_page': ConjureFieldDefinition('nextPage', OptionalTypeWrapper[datasource_Token])
        }

    __slots__: List[str] = ['_files', '_next_page']

    def __init__(self, files: List["scout_catalog_DatasetFile"], next_page: Optional[str] = None) -> None:
        self._files = files
        self._next_page = next_page

    @builtins.property
    def files(self) -> List["scout_catalog_DatasetFile"]:
        return self._files

    @builtins.property
    def next_page(self) -> Optional[str]:
        return self._next_page


scout_catalog_DatasetFilesPage.__name__ = "DatasetFilesPage"
scout_catalog_DatasetFilesPage.__qualname__ = "DatasetFilesPage"
scout_catalog_DatasetFilesPage.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_DatasetFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


scout_catalog_DatasetFilter.__name__ = "DatasetFilter"
scout_catalog_DatasetFilter.__qualname__ = "DatasetFilter"
scout_catalog_DatasetFilter.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_DatasetOriginMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'path': ConjureFieldDefinition('path', OptionalTypeWrapper[str]),
            'x_series_is_absolute': ConjureFieldDefinition('xSeriesIsAbsolute', OptionalTypeWrapper[bool]),
            'schema_directive_path': ConjureFieldDefinition('schemaDirectivePath', OptionalTypeWrapper[str]),
            'x_series_column_name': ConjureFieldDefinition('xSeriesColumnName', OptionalTypeWrapper[str]),
            'x_series_time_unit': ConjureFieldDefinition('xSeriesTimeUnit', OptionalTypeWrapper[scout_catalog_TimeUnit]),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[scout_catalog_TimestampMetadata]),
            'channel_config': ConjureFieldDefinition('channelConfig', OptionalTypeWrapper[scout_catalog_ChannelConfig])
        }

    __slots__: List[str] = ['_path', '_x_series_is_absolute', '_schema_directive_path', '_x_series_column_name', '_x_series_time_unit', '_timestamp_metadata', '_channel_config']

    def __init__(self, channel_config: Optional["scout_catalog_ChannelConfig"] = None, path: Optional[str] = None, schema_directive_path: Optional[str] = None, timestamp_metadata: Optional["scout_catalog_TimestampMetadata"] = None, x_series_column_name: Optional[str] = None, x_series_is_absolute: Optional[bool] = None, x_series_time_unit: Optional["scout_catalog_TimeUnit"] = None) -> None:
        self._path = path
        self._x_series_is_absolute = x_series_is_absolute
        self._schema_directive_path = schema_directive_path
        self._x_series_column_name = x_series_column_name
        self._x_series_time_unit = x_series_time_unit
        self._timestamp_metadata = timestamp_metadata
        self._channel_config = channel_config

    @builtins.property
    def path(self) -> Optional[str]:
        return self._path

    @builtins.property
    def x_series_is_absolute(self) -> Optional[bool]:
        return self._x_series_is_absolute

    @builtins.property
    def schema_directive_path(self) -> Optional[str]:
        return self._schema_directive_path

    @builtins.property
    def x_series_column_name(self) -> Optional[str]:
        return self._x_series_column_name

    @builtins.property
    def x_series_time_unit(self) -> Optional["scout_catalog_TimeUnit"]:
        return self._x_series_time_unit

    @builtins.property
    def timestamp_metadata(self) -> Optional["scout_catalog_TimestampMetadata"]:
        return self._timestamp_metadata

    @builtins.property
    def channel_config(self) -> Optional["scout_catalog_ChannelConfig"]:
        return self._channel_config


scout_catalog_DatasetOriginMetadata.__name__ = "DatasetOriginMetadata"
scout_catalog_DatasetOriginMetadata.__qualname__ = "DatasetOriginMetadata"
scout_catalog_DatasetOriginMetadata.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_DeleteSeriesResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'number_deleted': ConjureFieldDefinition('numberDeleted', int)
        }

    __slots__: List[str] = ['_number_deleted']

    def __init__(self, number_deleted: int) -> None:
        self._number_deleted = number_deleted

    @builtins.property
    def number_deleted(self) -> int:
        return self._number_deleted


scout_catalog_DeleteSeriesResult.__name__ = "DeleteSeriesResult"
scout_catalog_DeleteSeriesResult.__qualname__ = "DeleteSeriesResult"
scout_catalog_DeleteSeriesResult.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_EnrichedDataset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', str),
            'uuid': ConjureFieldDefinition('uuid', str),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'display_name': ConjureFieldDefinition('displayName', str),
            'metadata': ConjureFieldDefinition('metadata', Dict[str, str]),
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_catalog_DatasetOriginMetadata),
            'ingest_date': ConjureFieldDefinition('ingestDate', str),
            'ingest_status': ConjureFieldDefinition('ingestStatus', scout_catalog_IngestStatus),
            'retention_policy': ConjureFieldDefinition('retentionPolicy', scout_catalog_RetentionPolicy),
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[str]),
            'run_date': ConjureFieldDefinition('runDate', OptionalTypeWrapper[str]),
            'shorthand': ConjureFieldDefinition('shorthand', OptionalTypeWrapper[str]),
            'source': ConjureFieldDefinition('source', OptionalTypeWrapper[str]),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_catalog_Bounds]),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_catalog_WeakTimestampType),
            'labels': ConjureFieldDefinition('labels', List[datasource_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[datasource_PropertyName, datasource_PropertyValue])
        }

    __slots__: List[str] = ['_rid', '_uuid', '_name', '_description', '_display_name', '_metadata', '_handle', '_origin_metadata', '_ingest_date', '_ingest_status', '_retention_policy', '_run_rid', '_run_date', '_shorthand', '_source', '_bounds', '_timestamp_type', '_labels', '_properties']

    def __init__(self, display_name: str, handle: "scout_catalog_Handle", ingest_date: str, ingest_status: "scout_catalog_IngestStatus", labels: List[str], metadata: Dict[str, str], name: str, origin_metadata: "scout_catalog_DatasetOriginMetadata", properties: Dict[str, str], retention_policy: "scout_catalog_RetentionPolicy", rid: str, timestamp_type: "scout_catalog_WeakTimestampType", uuid: str, bounds: Optional["scout_catalog_Bounds"] = None, description: Optional[str] = None, run_date: Optional[str] = None, run_rid: Optional[str] = None, shorthand: Optional[str] = None, source: Optional[str] = None) -> None:
        self._rid = rid
        self._uuid = uuid
        self._name = name
        self._description = description
        self._display_name = display_name
        self._metadata = metadata
        self._handle = handle
        self._origin_metadata = origin_metadata
        self._ingest_date = ingest_date
        self._ingest_status = ingest_status
        self._retention_policy = retention_policy
        self._run_rid = run_rid
        self._run_date = run_date
        self._shorthand = shorthand
        self._source = source
        self._bounds = bounds
        self._timestamp_type = timestamp_type
        self._labels = labels
        self._properties = properties

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def display_name(self) -> str:
        return self._display_name

    @builtins.property
    def metadata(self) -> Dict[str, str]:
        return self._metadata

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle

    @builtins.property
    def origin_metadata(self) -> "scout_catalog_DatasetOriginMetadata":
        return self._origin_metadata

    @builtins.property
    def ingest_date(self) -> str:
        return self._ingest_date

    @builtins.property
    def ingest_status(self) -> "scout_catalog_IngestStatus":
        return self._ingest_status

    @builtins.property
    def retention_policy(self) -> "scout_catalog_RetentionPolicy":
        return self._retention_policy

    @builtins.property
    def run_rid(self) -> Optional[str]:
        return self._run_rid

    @builtins.property
    def run_date(self) -> Optional[str]:
        return self._run_date

    @builtins.property
    def shorthand(self) -> Optional[str]:
        return self._shorthand

    @builtins.property
    def source(self) -> Optional[str]:
        return self._source

    @builtins.property
    def bounds(self) -> Optional["scout_catalog_Bounds"]:
        return self._bounds

    @builtins.property
    def timestamp_type(self) -> "scout_catalog_WeakTimestampType":
        return self._timestamp_type

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties


scout_catalog_EnrichedDataset.__name__ = "EnrichedDataset"
scout_catalog_EnrichedDataset.__qualname__ = "EnrichedDataset"
scout_catalog_EnrichedDataset.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_EpochTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', scout_catalog_TimeUnit)
        }

    __slots__: List[str] = ['_time_unit']

    def __init__(self, time_unit: "scout_catalog_TimeUnit") -> None:
        self._time_unit = time_unit

    @builtins.property
    def time_unit(self) -> "scout_catalog_TimeUnit":
        return self._time_unit


scout_catalog_EpochTimestamp.__name__ = "EpochTimestamp"
scout_catalog_EpochTimestamp.__qualname__ = "EpochTimestamp"
scout_catalog_EpochTimestamp.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_ErrorResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_type': ConjureFieldDefinition('errorType', scout_catalog_ErrorType),
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_error_type', '_message']

    def __init__(self, error_type: str, message: str) -> None:
        self._error_type = error_type
        self._message = message

    @builtins.property
    def error_type(self) -> str:
        return self._error_type

    @builtins.property
    def message(self) -> str:
        return self._message


scout_catalog_ErrorResult.__name__ = "ErrorResult"
scout_catalog_ErrorResult.__qualname__ = "ErrorResult"
scout_catalog_ErrorResult.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_GetChannelsForDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_uuids': ConjureFieldDefinition('datasetUuids', List[str])
        }

    __slots__: List[str] = ['_dataset_uuids']

    def __init__(self, dataset_uuids: List[str]) -> None:
        self._dataset_uuids = dataset_uuids

    @builtins.property
    def dataset_uuids(self) -> List[str]:
        return self._dataset_uuids


scout_catalog_GetChannelsForDatasetsRequest.__name__ = "GetChannelsForDatasetsRequest"
scout_catalog_GetChannelsForDatasetsRequest.__qualname__ = "GetChannelsForDatasetsRequest"
scout_catalog_GetChannelsForDatasetsRequest.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_GetDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_rids': ConjureFieldDefinition('datasetRids', List[str])
        }

    __slots__: List[str] = ['_dataset_rids']

    def __init__(self, dataset_rids: List[str]) -> None:
        self._dataset_rids = dataset_rids

    @builtins.property
    def dataset_rids(self) -> List[str]:
        return self._dataset_rids


scout_catalog_GetDatasetsRequest.__name__ = "GetDatasetsRequest"
scout_catalog_GetDatasetsRequest.__qualname__ = "GetDatasetsRequest"
scout_catalog_GetDatasetsRequest.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_GetDetailsForChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_uuids': ConjureFieldDefinition('channelUuids', List[str])
        }

    __slots__: List[str] = ['_channel_uuids']

    def __init__(self, channel_uuids: List[str]) -> None:
        self._channel_uuids = channel_uuids

    @builtins.property
    def channel_uuids(self) -> List[str]:
        return self._channel_uuids


scout_catalog_GetDetailsForChannelsRequest.__name__ = "GetDetailsForChannelsRequest"
scout_catalog_GetDetailsForChannelsRequest.__qualname__ = "GetDetailsForChannelsRequest"
scout_catalog_GetDetailsForChannelsRequest.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_GetHandlesForDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_uuids': ConjureFieldDefinition('datasetUuids', List[str])
        }

    __slots__: List[str] = ['_dataset_uuids']

    def __init__(self, dataset_uuids: List[str]) -> None:
        self._dataset_uuids = dataset_uuids

    @builtins.property
    def dataset_uuids(self) -> List[str]:
        return self._dataset_uuids


scout_catalog_GetHandlesForDatasetsRequest.__name__ = "GetHandlesForDatasetsRequest"
scout_catalog_GetHandlesForDatasetsRequest.__qualname__ = "GetHandlesForDatasetsRequest"
scout_catalog_GetHandlesForDatasetsRequest.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_GetSeriesDetailsByName(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_rid': ConjureFieldDefinition('datasetRid', str),
            'name': ConjureFieldDefinition('name', str)
        }

    __slots__: List[str] = ['_dataset_rid', '_name']

    def __init__(self, dataset_rid: str, name: str) -> None:
        self._dataset_rid = dataset_rid
        self._name = name

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def name(self) -> str:
        return self._name


scout_catalog_GetSeriesDetailsByName.__name__ = "GetSeriesDetailsByName"
scout_catalog_GetSeriesDetailsByName.__qualname__ = "GetSeriesDetailsByName"
scout_catalog_GetSeriesDetailsByName.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_GetSeriesDetailsByRid(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', str)
        }

    __slots__: List[str] = ['_rid']

    def __init__(self, rid: str) -> None:
        self._rid = rid

    @builtins.property
    def rid(self) -> str:
        return self._rid


scout_catalog_GetSeriesDetailsByRid.__name__ = "GetSeriesDetailsByRid"
scout_catalog_GetSeriesDetailsByRid.__qualname__ = "GetSeriesDetailsByRid"
scout_catalog_GetSeriesDetailsByRid.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_GetSeriesDetailsRequest(ConjureUnionType):
    _by_rid: Optional["scout_catalog_GetSeriesDetailsByRid"] = None
    _by_name: Optional["scout_catalog_GetSeriesDetailsByName"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'by_rid': ConjureFieldDefinition('byRid', scout_catalog_GetSeriesDetailsByRid),
            'by_name': ConjureFieldDefinition('byName', scout_catalog_GetSeriesDetailsByName)
        }

    def __init__(
            self,
            by_rid: Optional["scout_catalog_GetSeriesDetailsByRid"] = None,
            by_name: Optional["scout_catalog_GetSeriesDetailsByName"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (by_rid is not None) + (by_name is not None) != 1:
                raise ValueError('a union must contain a single member')

            if by_rid is not None:
                self._by_rid = by_rid
                self._type = 'byRid'
            if by_name is not None:
                self._by_name = by_name
                self._type = 'byName'

        elif type_of_union == 'byRid':
            if by_rid is None:
                raise ValueError('a union value must not be None')
            self._by_rid = by_rid
            self._type = 'byRid'
        elif type_of_union == 'byName':
            if by_name is None:
                raise ValueError('a union value must not be None')
            self._by_name = by_name
            self._type = 'byName'

    @builtins.property
    def by_rid(self) -> Optional["scout_catalog_GetSeriesDetailsByRid"]:
        return self._by_rid

    @builtins.property
    def by_name(self) -> Optional["scout_catalog_GetSeriesDetailsByName"]:
        return self._by_name

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_GetSeriesDetailsRequestVisitor):
            raise ValueError('{} is not an instance of scout_catalog_GetSeriesDetailsRequestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'byRid' and self.by_rid is not None:
            return visitor._by_rid(self.by_rid)
        if self._type == 'byName' and self.by_name is not None:
            return visitor._by_name(self.by_name)


scout_catalog_GetSeriesDetailsRequest.__name__ = "GetSeriesDetailsRequest"
scout_catalog_GetSeriesDetailsRequest.__qualname__ = "GetSeriesDetailsRequest"
scout_catalog_GetSeriesDetailsRequest.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_GetSeriesDetailsRequestVisitor:

    @abstractmethod
    def _by_rid(self, by_rid: "scout_catalog_GetSeriesDetailsByRid") -> Any:
        pass

    @abstractmethod
    def _by_name(self, by_name: "scout_catalog_GetSeriesDetailsByName") -> Any:
        pass


scout_catalog_GetSeriesDetailsRequestVisitor.__name__ = "GetSeriesDetailsRequestVisitor"
scout_catalog_GetSeriesDetailsRequestVisitor.__qualname__ = "GetSeriesDetailsRequestVisitor"
scout_catalog_GetSeriesDetailsRequestVisitor.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_Handle(ConjureUnionType):
    _s3: Optional["scout_catalog_S3Handle"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3': ConjureFieldDefinition('s3', scout_catalog_S3Handle)
        }

    def __init__(
            self,
            s3: Optional["scout_catalog_S3Handle"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3 is not None:
                self._s3 = s3
                self._type = 's3'

        elif type_of_union == 's3':
            if s3 is None:
                raise ValueError('a union value must not be None')
            self._s3 = s3
            self._type = 's3'

    @builtins.property
    def s3(self) -> Optional["scout_catalog_S3Handle"]:
        return self._s3

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_HandleVisitor):
            raise ValueError('{} is not an instance of scout_catalog_HandleVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3' and self.s3 is not None:
            return visitor._s3(self.s3)


scout_catalog_Handle.__name__ = "Handle"
scout_catalog_Handle.__qualname__ = "Handle"
scout_catalog_Handle.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_HandleVisitor:

    @abstractmethod
    def _s3(self, s3: "scout_catalog_S3Handle") -> Any:
        pass


scout_catalog_HandleVisitor.__name__ = "HandleVisitor"
scout_catalog_HandleVisitor.__qualname__ = "HandleVisitor"
scout_catalog_HandleVisitor.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_InProgressResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_catalog_InProgressResult.__name__ = "InProgressResult"
scout_catalog_InProgressResult.__qualname__ = "InProgressResult"
scout_catalog_InProgressResult.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_IngestProgressV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', str),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[str]),
            'ingest_status': ConjureFieldDefinition('ingestStatus', scout_catalog_IngestStatusV2),
            'incalculable': ConjureFieldDefinition('incalculable', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_start_time', '_end_time', '_ingest_status', '_incalculable']

    def __init__(self, ingest_status: "scout_catalog_IngestStatusV2", start_time: str, end_time: Optional[str] = None, incalculable: Optional[bool] = None) -> None:
        self._start_time = start_time
        self._end_time = end_time
        self._ingest_status = ingest_status
        self._incalculable = incalculable

    @builtins.property
    def start_time(self) -> str:
        """
        Timestamp at start of ingest
        """
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional[str]:
        """
        Timestamp at end of ingest, empty if still in progress
        """
        return self._end_time

    @builtins.property
    def ingest_status(self) -> "scout_catalog_IngestStatusV2":
        """
        Status of ingest, contains error if failed
        """
        return self._ingest_status

    @builtins.property
    def incalculable(self) -> Optional[bool]:
        """
        Whether ingest duration can be reliably calculated
        """
        return self._incalculable


scout_catalog_IngestProgressV2.__name__ = "IngestProgressV2"
scout_catalog_IngestProgressV2.__qualname__ = "IngestProgressV2"
scout_catalog_IngestProgressV2.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_IngestStatus(ConjureEnumType):

    IN_PROGRESS = 'IN_PROGRESS'
    '''IN_PROGRESS'''
    COMPLETED = 'COMPLETED'
    '''COMPLETED'''
    FAILED = 'FAILED'
    '''FAILED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_IngestStatus.__name__ = "IngestStatus"
scout_catalog_IngestStatus.__qualname__ = "IngestStatus"
scout_catalog_IngestStatus.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_IngestStatusV2(ConjureUnionType):
    _success: Optional["scout_catalog_SuccessResult"] = None
    _error: Optional["scout_catalog_ErrorResult"] = None
    _in_progress: Optional["scout_catalog_InProgressResult"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_catalog_SuccessResult),
            'error': ConjureFieldDefinition('error', scout_catalog_ErrorResult),
            'in_progress': ConjureFieldDefinition('inProgress', scout_catalog_InProgressResult)
        }

    def __init__(
            self,
            success: Optional["scout_catalog_SuccessResult"] = None,
            error: Optional["scout_catalog_ErrorResult"] = None,
            in_progress: Optional["scout_catalog_InProgressResult"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) + (in_progress is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'
            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'
        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'

    @builtins.property
    def success(self) -> Optional["scout_catalog_SuccessResult"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["scout_catalog_ErrorResult"]:
        return self._error

    @builtins.property
    def in_progress(self) -> Optional["scout_catalog_InProgressResult"]:
        return self._in_progress

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_IngestStatusV2Visitor):
            raise ValueError('{} is not an instance of scout_catalog_IngestStatusV2Visitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)


scout_catalog_IngestStatusV2.__name__ = "IngestStatusV2"
scout_catalog_IngestStatusV2.__qualname__ = "IngestStatusV2"
scout_catalog_IngestStatusV2.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_IngestStatusV2Visitor:

    @abstractmethod
    def _success(self, success: "scout_catalog_SuccessResult") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "scout_catalog_ErrorResult") -> Any:
        pass

    @abstractmethod
    def _in_progress(self, in_progress: "scout_catalog_InProgressResult") -> Any:
        pass


scout_catalog_IngestStatusV2Visitor.__name__ = "IngestStatusV2Visitor"
scout_catalog_IngestStatusV2Visitor.__qualname__ = "IngestStatusV2Visitor"
scout_catalog_IngestStatusV2Visitor.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_Iso8601Timestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_catalog_Iso8601Timestamp.__name__ = "Iso8601Timestamp"
scout_catalog_Iso8601Timestamp.__qualname__ = "Iso8601Timestamp"
scout_catalog_Iso8601Timestamp.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_ListDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'include_filters': ConjureFieldDefinition('includeFilters', OptionalTypeWrapper[List[scout_catalog_DatasetFilter]]),
            'exclude_filters': ConjureFieldDefinition('excludeFilters', OptionalTypeWrapper[List[scout_catalog_DatasetFilter]])
        }

    __slots__: List[str] = ['_include_filters', '_exclude_filters']

    def __init__(self, exclude_filters: Optional[List["scout_catalog_DatasetFilter"]] = None, include_filters: Optional[List["scout_catalog_DatasetFilter"]] = None) -> None:
        self._include_filters = include_filters
        self._exclude_filters = exclude_filters

    @builtins.property
    def include_filters(self) -> Optional[List["scout_catalog_DatasetFilter"]]:
        return self._include_filters

    @builtins.property
    def exclude_filters(self) -> Optional[List["scout_catalog_DatasetFilter"]]:
        return self._exclude_filters


scout_catalog_ListDatasetsRequest.__name__ = "ListDatasetsRequest"
scout_catalog_ListDatasetsRequest.__qualname__ = "ListDatasetsRequest"
scout_catalog_ListDatasetsRequest.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_MarkFileIngestError(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_result': ConjureFieldDefinition('errorResult', scout_catalog_ErrorResult)
        }

    __slots__: List[str] = ['_error_result']

    def __init__(self, error_result: "scout_catalog_ErrorResult") -> None:
        self._error_result = error_result

    @builtins.property
    def error_result(self) -> "scout_catalog_ErrorResult":
        return self._error_result


scout_catalog_MarkFileIngestError.__name__ = "MarkFileIngestError"
scout_catalog_MarkFileIngestError.__qualname__ = "MarkFileIngestError"
scout_catalog_MarkFileIngestError.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_MarkFileIngestSuccessful(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bounds': ConjureFieldDefinition('bounds', scout_catalog_Bounds),
            'ingested_at': ConjureFieldDefinition('ingestedAt', api_Timestamp)
        }

    __slots__: List[str] = ['_bounds', '_ingested_at']

    def __init__(self, bounds: "scout_catalog_Bounds", ingested_at: "api_Timestamp") -> None:
        self._bounds = bounds
        self._ingested_at = ingested_at

    @builtins.property
    def bounds(self) -> "scout_catalog_Bounds":
        return self._bounds

    @builtins.property
    def ingested_at(self) -> "api_Timestamp":
        """
        The ingestion timestamp is produced by CSV splitter and stored directly in the clickhouse table.
It's produced externally and passed here to handle retries and failures, and must be nanosecond precision.
Two files cannot have the same ingested at timestamp.
        """
        return self._ingested_at


scout_catalog_MarkFileIngestSuccessful.__name__ = "MarkFileIngestSuccessful"
scout_catalog_MarkFileIngestSuccessful.__qualname__ = "MarkFileIngestSuccessful"
scout_catalog_MarkFileIngestSuccessful.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_RelativeTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', scout_catalog_TimeUnit),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_time_unit', '_offset']

    def __init__(self, time_unit: "scout_catalog_TimeUnit", offset: Optional[str] = None) -> None:
        self._time_unit = time_unit
        self._offset = offset

    @builtins.property
    def time_unit(self) -> "scout_catalog_TimeUnit":
        return self._time_unit

    @builtins.property
    def offset(self) -> Optional[str]:
        return self._offset


scout_catalog_RelativeTimestamp.__name__ = "RelativeTimestamp"
scout_catalog_RelativeTimestamp.__qualname__ = "RelativeTimestamp"
scout_catalog_RelativeTimestamp.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_RetentionPolicy(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'type': ConjureFieldDefinition('type', scout_catalog_RetentionPolicyType),
            'expiry_days': ConjureFieldDefinition('expiryDays', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_type', '_expiry_days']

    def __init__(self, type: "scout_catalog_RetentionPolicyType", expiry_days: Optional[int] = None) -> None:
        self._type = type
        self._expiry_days = expiry_days

    @builtins.property
    def type(self) -> "scout_catalog_RetentionPolicyType":
        return self._type

    @builtins.property
    def expiry_days(self) -> Optional[int]:
        return self._expiry_days


scout_catalog_RetentionPolicy.__name__ = "RetentionPolicy"
scout_catalog_RetentionPolicy.__qualname__ = "RetentionPolicy"
scout_catalog_RetentionPolicy.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_RetentionPolicyType(ConjureEnumType):

    KEEP_UNTIL_EXPIRY = 'KEEP_UNTIL_EXPIRY'
    '''KEEP_UNTIL_EXPIRY'''
    KEEP_FOREVER = 'KEEP_FOREVER'
    '''KEEP_FOREVER'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_RetentionPolicyType.__name__ = "RetentionPolicyType"
scout_catalog_RetentionPolicyType.__qualname__ = "RetentionPolicyType"
scout_catalog_RetentionPolicyType.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_S3Handle(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket': ConjureFieldDefinition('bucket', str),
            'key': ConjureFieldDefinition('key', str)
        }

    __slots__: List[str] = ['_bucket', '_key']

    def __init__(self, bucket: str, key: str) -> None:
        self._bucket = bucket
        self._key = key

    @builtins.property
    def bucket(self) -> str:
        return self._bucket

    @builtins.property
    def key(self) -> str:
        return self._key


scout_catalog_S3Handle.__name__ = "S3Handle"
scout_catalog_S3Handle.__qualname__ = "S3Handle"
scout_catalog_S3Handle.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SearchDatasetsByTextRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', OptionalTypeWrapper[str]),
            'include_filters': ConjureFieldDefinition('includeFilters', OptionalTypeWrapper[List[scout_catalog_DatasetFilter]]),
            'exclude_filters': ConjureFieldDefinition('excludeFilters', OptionalTypeWrapper[List[scout_catalog_DatasetFilter]]),
            'page_request': ConjureFieldDefinition('pageRequest', OptionalTypeWrapper[datasource_pagination_api_PageRequest]),
            'include_archived': ConjureFieldDefinition('includeArchived', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_search_text', '_include_filters', '_exclude_filters', '_page_request', '_include_archived']

    def __init__(self, exclude_filters: Optional[List["scout_catalog_DatasetFilter"]] = None, include_archived: Optional[bool] = None, include_filters: Optional[List["scout_catalog_DatasetFilter"]] = None, page_request: Optional["datasource_pagination_api_PageRequest"] = None, search_text: Optional[str] = None) -> None:
        self._search_text = search_text
        self._include_filters = include_filters
        self._exclude_filters = exclude_filters
        self._page_request = page_request
        self._include_archived = include_archived

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def include_filters(self) -> Optional[List["scout_catalog_DatasetFilter"]]:
        return self._include_filters

    @builtins.property
    def exclude_filters(self) -> Optional[List["scout_catalog_DatasetFilter"]]:
        return self._exclude_filters

    @builtins.property
    def page_request(self) -> Optional["datasource_pagination_api_PageRequest"]:
        """
        The PageRequest.pageToken must be an integer offset. If a PageRequest.pageSize is not provided, the 
default page size (100) will be used.
        """
        return self._page_request

    @builtins.property
    def include_archived(self) -> Optional[bool]:
        """
        Defaults to false if not specified.
        """
        return self._include_archived


scout_catalog_SearchDatasetsByTextRequest.__name__ = "SearchDatasetsByTextRequest"
scout_catalog_SearchDatasetsByTextRequest.__qualname__ = "SearchDatasetsByTextRequest"
scout_catalog_SearchDatasetsByTextRequest.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SearchDatasetsByTextResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_catalog_EnrichedDataset]),
            'page_response': ConjureFieldDefinition('pageResponse', datasource_pagination_api_PageResponse)
        }

    __slots__: List[str] = ['_results', '_page_response']

    def __init__(self, page_response: "datasource_pagination_api_PageResponse", results: List["scout_catalog_EnrichedDataset"]) -> None:
        self._results = results
        self._page_response = page_response

    @builtins.property
    def results(self) -> List["scout_catalog_EnrichedDataset"]:
        return self._results

    @builtins.property
    def page_response(self) -> "datasource_pagination_api_PageResponse":
        return self._page_response


scout_catalog_SearchDatasetsByTextResponse.__name__ = "SearchDatasetsByTextResponse"
scout_catalog_SearchDatasetsByTextResponse.__qualname__ = "SearchDatasetsByTextResponse"
scout_catalog_SearchDatasetsByTextResponse.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SearchDatasetsQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _exact_match: Optional[str] = None
    _label: Optional[str] = None
    _properties: Optional["datasource_Property"] = None
    _ingest_status: Optional["scout_catalog_IngestStatus"] = None
    _ingested_before_inclusive: Optional[str] = None
    _ingested_after_inclusive: Optional[str] = None
    _archive_status: Optional[bool] = None
    _and_: Optional[List["scout_catalog_SearchDatasetsQuery"]] = None
    _or_: Optional[List["scout_catalog_SearchDatasetsQuery"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'label': ConjureFieldDefinition('label', datasource_Label),
            'properties': ConjureFieldDefinition('properties', datasource_Property),
            'ingest_status': ConjureFieldDefinition('ingestStatus', scout_catalog_IngestStatus),
            'ingested_before_inclusive': ConjureFieldDefinition('ingestedBeforeInclusive', str),
            'ingested_after_inclusive': ConjureFieldDefinition('ingestedAfterInclusive', str),
            'archive_status': ConjureFieldDefinition('archiveStatus', bool),
            'and_': ConjureFieldDefinition('and', List[scout_catalog_SearchDatasetsQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_catalog_SearchDatasetsQuery])
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            exact_match: Optional[str] = None,
            label: Optional[str] = None,
            properties: Optional["datasource_Property"] = None,
            ingest_status: Optional["scout_catalog_IngestStatus"] = None,
            ingested_before_inclusive: Optional[str] = None,
            ingested_after_inclusive: Optional[str] = None,
            archive_status: Optional[bool] = None,
            and_: Optional[List["scout_catalog_SearchDatasetsQuery"]] = None,
            or_: Optional[List["scout_catalog_SearchDatasetsQuery"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (exact_match is not None) + (label is not None) + (properties is not None) + (ingest_status is not None) + (ingested_before_inclusive is not None) + (ingested_after_inclusive is not None) + (archive_status is not None) + (and_ is not None) + (or_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if label is not None:
                self._label = label
                self._type = 'label'
            if properties is not None:
                self._properties = properties
                self._type = 'properties'
            if ingest_status is not None:
                self._ingest_status = ingest_status
                self._type = 'ingestStatus'
            if ingested_before_inclusive is not None:
                self._ingested_before_inclusive = ingested_before_inclusive
                self._type = 'ingestedBeforeInclusive'
            if ingested_after_inclusive is not None:
                self._ingested_after_inclusive = ingested_after_inclusive
                self._type = 'ingestedAfterInclusive'
            if archive_status is not None:
                self._archive_status = archive_status
                self._type = 'archiveStatus'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'properties':
            if properties is None:
                raise ValueError('a union value must not be None')
            self._properties = properties
            self._type = 'properties'
        elif type_of_union == 'ingestStatus':
            if ingest_status is None:
                raise ValueError('a union value must not be None')
            self._ingest_status = ingest_status
            self._type = 'ingestStatus'
        elif type_of_union == 'ingestedBeforeInclusive':
            if ingested_before_inclusive is None:
                raise ValueError('a union value must not be None')
            self._ingested_before_inclusive = ingested_before_inclusive
            self._type = 'ingestedBeforeInclusive'
        elif type_of_union == 'ingestedAfterInclusive':
            if ingested_after_inclusive is None:
                raise ValueError('a union value must not be None')
            self._ingested_after_inclusive = ingested_after_inclusive
            self._type = 'ingestedAfterInclusive'
        elif type_of_union == 'archiveStatus':
            if archive_status is None:
                raise ValueError('a union value must not be None')
            self._archive_status = archive_status
            self._type = 'archiveStatus'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """
        Performs case insensitive exact match search on the name.
        """
        return self._exact_match

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def properties(self) -> Optional["datasource_Property"]:
        return self._properties

    @builtins.property
    def ingest_status(self) -> Optional["scout_catalog_IngestStatus"]:
        return self._ingest_status

    @builtins.property
    def ingested_before_inclusive(self) -> Optional[str]:
        return self._ingested_before_inclusive

    @builtins.property
    def ingested_after_inclusive(self) -> Optional[str]:
        return self._ingested_after_inclusive

    @builtins.property
    def archive_status(self) -> Optional[bool]:
        return self._archive_status

    @builtins.property
    def and_(self) -> Optional[List["scout_catalog_SearchDatasetsQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_catalog_SearchDatasetsQuery"]]:
        return self._or_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_SearchDatasetsQueryVisitor):
            raise ValueError('{} is not an instance of scout_catalog_SearchDatasetsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'properties' and self.properties is not None:
            return visitor._properties(self.properties)
        if self._type == 'ingestStatus' and self.ingest_status is not None:
            return visitor._ingest_status(self.ingest_status)
        if self._type == 'ingestedBeforeInclusive' and self.ingested_before_inclusive is not None:
            return visitor._ingested_before_inclusive(self.ingested_before_inclusive)
        if self._type == 'ingestedAfterInclusive' and self.ingested_after_inclusive is not None:
            return visitor._ingested_after_inclusive(self.ingested_after_inclusive)
        if self._type == 'archiveStatus' and self.archive_status is not None:
            return visitor._archive_status(self.archive_status)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)


scout_catalog_SearchDatasetsQuery.__name__ = "SearchDatasetsQuery"
scout_catalog_SearchDatasetsQuery.__qualname__ = "SearchDatasetsQuery"
scout_catalog_SearchDatasetsQuery.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SearchDatasetsQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _properties(self, properties: "datasource_Property") -> Any:
        pass

    @abstractmethod
    def _ingest_status(self, ingest_status: "scout_catalog_IngestStatus") -> Any:
        pass

    @abstractmethod
    def _ingested_before_inclusive(self, ingested_before_inclusive: str) -> Any:
        pass

    @abstractmethod
    def _ingested_after_inclusive(self, ingested_after_inclusive: str) -> Any:
        pass

    @abstractmethod
    def _archive_status(self, archive_status: bool) -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_catalog_SearchDatasetsQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_catalog_SearchDatasetsQuery"]) -> Any:
        pass


scout_catalog_SearchDatasetsQueryVisitor.__name__ = "SearchDatasetsQueryVisitor"
scout_catalog_SearchDatasetsQueryVisitor.__qualname__ = "SearchDatasetsQueryVisitor"
scout_catalog_SearchDatasetsQueryVisitor.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SearchDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_catalog_SearchDatasetsQuery),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[datasource_Token]),
            'sort_options': ConjureFieldDefinition('sortOptions', scout_catalog_SortOptions)
        }

    __slots__: List[str] = ['_query', '_page_size', '_token', '_sort_options']

    def __init__(self, query: "scout_catalog_SearchDatasetsQuery", sort_options: "scout_catalog_SortOptions", page_size: Optional[int] = None, token: Optional[str] = None) -> None:
        self._query = query
        self._page_size = page_size
        self._token = token
        self._sort_options = sort_options

    @builtins.property
    def query(self) -> "scout_catalog_SearchDatasetsQuery":
        return self._query

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token

    @builtins.property
    def sort_options(self) -> "scout_catalog_SortOptions":
        return self._sort_options


scout_catalog_SearchDatasetsRequest.__name__ = "SearchDatasetsRequest"
scout_catalog_SearchDatasetsRequest.__qualname__ = "SearchDatasetsRequest"
scout_catalog_SearchDatasetsRequest.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SearchDatasetsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_catalog_EnrichedDataset]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[datasource_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_catalog_EnrichedDataset"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_catalog_EnrichedDataset"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_catalog_SearchDatasetsResponse.__name__ = "SearchDatasetsResponse"
scout_catalog_SearchDatasetsResponse.__qualname__ = "SearchDatasetsResponse"
scout_catalog_SearchDatasetsResponse.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SeriesDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', str),
            'name': ConjureFieldDefinition('name', str),
            'origin_metadata': ConjureFieldDefinition('originMetadata', Dict[str, str]),
            'csv_index': ConjureFieldDefinition('csvIndex', OptionalTypeWrapper[int]),
            'dataset_rid': ConjureFieldDefinition('datasetRid', str),
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle)
        }

    __slots__: List[str] = ['_rid', '_name', '_origin_metadata', '_csv_index', '_dataset_rid', '_handle']

    def __init__(self, dataset_rid: str, handle: "scout_catalog_Handle", name: str, origin_metadata: Dict[str, str], rid: str, csv_index: Optional[int] = None) -> None:
        self._rid = rid
        self._name = name
        self._origin_metadata = origin_metadata
        self._csv_index = csv_index
        self._dataset_rid = dataset_rid
        self._handle = handle

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def origin_metadata(self) -> Dict[str, str]:
        return self._origin_metadata

    @builtins.property
    def csv_index(self) -> Optional[int]:
        return self._csv_index

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle


scout_catalog_SeriesDetails.__name__ = "SeriesDetails"
scout_catalog_SeriesDetails.__qualname__ = "SeriesDetails"
scout_catalog_SeriesDetails.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SkipRowsConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'header_row_index': ConjureFieldDefinition('headerRowIndex', int),
            'data_start_row_index': ConjureFieldDefinition('dataStartRowIndex', int)
        }

    __slots__: List[str] = ['_header_row_index', '_data_start_row_index']

    def __init__(self, data_start_row_index: int, header_row_index: int) -> None:
        self._header_row_index = header_row_index
        self._data_start_row_index = data_start_row_index

    @builtins.property
    def header_row_index(self) -> int:
        return self._header_row_index

    @builtins.property
    def data_start_row_index(self) -> int:
        return self._data_start_row_index


scout_catalog_SkipRowsConfig.__name__ = "SkipRowsConfig"
scout_catalog_SkipRowsConfig.__qualname__ = "SkipRowsConfig"
scout_catalog_SkipRowsConfig.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SortField(ConjureEnumType):

    INGEST_DATE = 'INGEST_DATE'
    '''INGEST_DATE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_SortField.__name__ = "SortField"
scout_catalog_SortField.__qualname__ = "SortField"
scout_catalog_SortField.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_catalog_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_catalog_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_catalog_SortField":
        return self._field


scout_catalog_SortOptions.__name__ = "SortOptions"
scout_catalog_SortOptions.__qualname__ = "SortOptions"
scout_catalog_SortOptions.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_SuccessResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_catalog_SuccessResult.__name__ = "SuccessResult"
scout_catalog_SuccessResult.__qualname__ = "SuccessResult"
scout_catalog_SuccessResult.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_TimeUnit(ConjureEnumType):

    DAYS = 'DAYS'
    '''DAYS'''
    HOURS = 'HOURS'
    '''HOURS'''
    MINUTES = 'MINUTES'
    '''MINUTES'''
    SECONDS = 'SECONDS'
    '''SECONDS'''
    MILLISECONDS = 'MILLISECONDS'
    '''MILLISECONDS'''
    MICROSECONDS = 'MICROSECONDS'
    '''MICROSECONDS'''
    NANOSECONDS = 'NANOSECONDS'
    '''NANOSECONDS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_TimeUnit.__name__ = "TimeUnit"
scout_catalog_TimeUnit.__qualname__ = "TimeUnit"
scout_catalog_TimeUnit.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_TimestampMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_name': ConjureFieldDefinition('seriesName', str),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_catalog_TimestampType)
        }

    __slots__: List[str] = ['_series_name', '_timestamp_type']

    def __init__(self, series_name: str, timestamp_type: "scout_catalog_TimestampType") -> None:
        self._series_name = series_name
        self._timestamp_type = timestamp_type

    @builtins.property
    def series_name(self) -> str:
        return self._series_name

    @builtins.property
    def timestamp_type(self) -> "scout_catalog_TimestampType":
        return self._timestamp_type


scout_catalog_TimestampMetadata.__name__ = "TimestampMetadata"
scout_catalog_TimestampMetadata.__qualname__ = "TimestampMetadata"
scout_catalog_TimestampMetadata.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_TimestampType(ConjureUnionType):
    _relative: Optional["scout_catalog_RelativeTimestamp"] = None
    _absolute: Optional["scout_catalog_AbsoluteTimestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'relative': ConjureFieldDefinition('relative', scout_catalog_RelativeTimestamp),
            'absolute': ConjureFieldDefinition('absolute', scout_catalog_AbsoluteTimestamp)
        }

    def __init__(
            self,
            relative: Optional["scout_catalog_RelativeTimestamp"] = None,
            absolute: Optional["scout_catalog_AbsoluteTimestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (relative is not None) + (absolute is not None) != 1:
                raise ValueError('a union must contain a single member')

            if relative is not None:
                self._relative = relative
                self._type = 'relative'
            if absolute is not None:
                self._absolute = absolute
                self._type = 'absolute'

        elif type_of_union == 'relative':
            if relative is None:
                raise ValueError('a union value must not be None')
            self._relative = relative
            self._type = 'relative'
        elif type_of_union == 'absolute':
            if absolute is None:
                raise ValueError('a union value must not be None')
            self._absolute = absolute
            self._type = 'absolute'

    @builtins.property
    def relative(self) -> Optional["scout_catalog_RelativeTimestamp"]:
        return self._relative

    @builtins.property
    def absolute(self) -> Optional["scout_catalog_AbsoluteTimestamp"]:
        return self._absolute

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_TimestampTypeVisitor):
            raise ValueError('{} is not an instance of scout_catalog_TimestampTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'relative' and self.relative is not None:
            return visitor._relative(self.relative)
        if self._type == 'absolute' and self.absolute is not None:
            return visitor._absolute(self.absolute)


scout_catalog_TimestampType.__name__ = "TimestampType"
scout_catalog_TimestampType.__qualname__ = "TimestampType"
scout_catalog_TimestampType.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_TimestampTypeVisitor:

    @abstractmethod
    def _relative(self, relative: "scout_catalog_RelativeTimestamp") -> Any:
        pass

    @abstractmethod
    def _absolute(self, absolute: "scout_catalog_AbsoluteTimestamp") -> Any:
        pass


scout_catalog_TimestampTypeVisitor.__name__ = "TimestampTypeVisitor"
scout_catalog_TimestampTypeVisitor.__qualname__ = "TimestampTypeVisitor"
scout_catalog_TimestampTypeVisitor.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_UnitConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unit_metadata_key': ConjureFieldDefinition('unitMetadataKey', str)
        }

    __slots__: List[str] = ['_unit_metadata_key']

    def __init__(self, unit_metadata_key: str) -> None:
        self._unit_metadata_key = unit_metadata_key

    @builtins.property
    def unit_metadata_key(self) -> str:
        """
        If set, will extract the series unit from the column metadata of the ingested file.
        """
        return self._unit_metadata_key


scout_catalog_UnitConfig.__name__ = "UnitConfig"
scout_catalog_UnitConfig.__qualname__ = "UnitConfig"
scout_catalog_UnitConfig.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_UpdateBoundsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bounds': ConjureFieldDefinition('bounds', scout_catalog_Bounds)
        }

    __slots__: List[str] = ['_bounds']

    def __init__(self, bounds: "scout_catalog_Bounds") -> None:
        self._bounds = bounds

    @builtins.property
    def bounds(self) -> "scout_catalog_Bounds":
        return self._bounds


scout_catalog_UpdateBoundsRequest.__name__ = "UpdateBoundsRequest"
scout_catalog_UpdateBoundsRequest.__qualname__ = "UpdateBoundsRequest"
scout_catalog_UpdateBoundsRequest.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_UpdateDatasetMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[datasource_Label]]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[datasource_PropertyName, datasource_PropertyValue]])
        }

    __slots__: List[str] = ['_name', '_description', '_labels', '_properties']

    def __init__(self, description: Optional[str] = None, labels: Optional[List[str]] = None, name: Optional[str] = None, properties: Optional[Dict[str, str]] = None) -> None:
        self._name = name
        self._description = description
        self._labels = labels
        self._properties = properties

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties


scout_catalog_UpdateDatasetMetadata.__name__ = "UpdateDatasetMetadata"
scout_catalog_UpdateDatasetMetadata.__qualname__ = "UpdateDatasetMetadata"
scout_catalog_UpdateDatasetMetadata.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_UpdateIngestStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'status': ConjureFieldDefinition('status', scout_catalog_IngestStatus),
            'dataset_uuid': ConjureFieldDefinition('datasetUuid', str)
        }

    __slots__: List[str] = ['_status', '_dataset_uuid']

    def __init__(self, dataset_uuid: str, status: "scout_catalog_IngestStatus") -> None:
        self._status = status
        self._dataset_uuid = dataset_uuid

    @builtins.property
    def status(self) -> "scout_catalog_IngestStatus":
        return self._status

    @builtins.property
    def dataset_uuid(self) -> str:
        return self._dataset_uuid


scout_catalog_UpdateIngestStatus.__name__ = "UpdateIngestStatus"
scout_catalog_UpdateIngestStatus.__qualname__ = "UpdateIngestStatus"
scout_catalog_UpdateIngestStatus.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_UpdateIngestStatusV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'status': ConjureFieldDefinition('status', scout_catalog_IngestStatusV2),
            'dataset_uuid': ConjureFieldDefinition('datasetUuid', str)
        }

    __slots__: List[str] = ['_status', '_dataset_uuid']

    def __init__(self, dataset_uuid: str, status: "scout_catalog_IngestStatusV2") -> None:
        self._status = status
        self._dataset_uuid = dataset_uuid

    @builtins.property
    def status(self) -> "scout_catalog_IngestStatusV2":
        return self._status

    @builtins.property
    def dataset_uuid(self) -> str:
        return self._dataset_uuid


scout_catalog_UpdateIngestStatusV2.__name__ = "UpdateIngestStatusV2"
scout_catalog_UpdateIngestStatusV2.__qualname__ = "UpdateIngestStatusV2"
scout_catalog_UpdateIngestStatusV2.__module__ = "scout_service_api.scout_catalog"


class scout_catalog_WeakTimestampType(ConjureEnumType):
    """
    If a CSV dataset is still being split, the timestamp type is not known.
    """

    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    PENDING = 'PENDING'
    '''PENDING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_WeakTimestampType.__name__ = "WeakTimestampType"
scout_catalog_WeakTimestampType.__qualname__ = "WeakTimestampType"
scout_catalog_WeakTimestampType.__module__ = "scout_service_api.scout_catalog"


class scout_channelvariables_api_ChannelVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'compute_spec': ConjureFieldDefinition('computeSpec', scout_channelvariables_api_ComputeSpec)
        }

    __slots__: List[str] = ['_display_name', '_variable_name', '_compute_spec']

    def __init__(self, compute_spec: "scout_channelvariables_api_ComputeSpec", variable_name: str, display_name: Optional[str] = None) -> None:
        self._display_name = display_name
        self._variable_name = variable_name
        self._compute_spec = compute_spec

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def compute_spec(self) -> "scout_channelvariables_api_ComputeSpec":
        return self._compute_spec


scout_channelvariables_api_ChannelVariable.__name__ = "ChannelVariable"
scout_channelvariables_api_ChannelVariable.__qualname__ = "ChannelVariable"
scout_channelvariables_api_ChannelVariable.__module__ = "scout_service_api.scout_channelvariables_api"


class scout_channelvariables_api_ComputeSpec(ConjureUnionType):
    _v1: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_channelvariables_api_ComputeSpecV1)
        }

    def __init__(
            self,
            v1: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional[str]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_channelvariables_api_ComputeSpecVisitor):
            raise ValueError('{} is not an instance of scout_channelvariables_api_ComputeSpecVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_channelvariables_api_ComputeSpec.__name__ = "ComputeSpec"
scout_channelvariables_api_ComputeSpec.__qualname__ = "ComputeSpec"
scout_channelvariables_api_ComputeSpec.__module__ = "scout_service_api.scout_channelvariables_api"


class scout_channelvariables_api_ComputeSpecVisitor:

    @abstractmethod
    def _v1(self, v1: str) -> Any:
        pass


scout_channelvariables_api_ComputeSpecVisitor.__name__ = "ComputeSpecVisitor"
scout_channelvariables_api_ComputeSpecVisitor.__qualname__ = "ComputeSpecVisitor"
scout_channelvariables_api_ComputeSpecVisitor.__module__ = "scout_service_api.scout_channelvariables_api"


class scout_chart_api_DeprecatedDefinitionAndSchemaVersion(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'schema_version': ConjureFieldDefinition('schemaVersion', str),
            'definition': ConjureFieldDefinition('definition', scout_chart_api_JsonString)
        }

    __slots__: List[str] = ['_schema_version', '_definition']

    def __init__(self, definition: str, schema_version: str) -> None:
        self._schema_version = schema_version
        self._definition = definition

    @builtins.property
    def schema_version(self) -> str:
        return self._schema_version

    @builtins.property
    def definition(self) -> str:
        return self._definition


scout_chart_api_DeprecatedDefinitionAndSchemaVersion.__name__ = "DeprecatedDefinitionAndSchemaVersion"
scout_chart_api_DeprecatedDefinitionAndSchemaVersion.__qualname__ = "DeprecatedDefinitionAndSchemaVersion"
scout_chart_api_DeprecatedDefinitionAndSchemaVersion.__module__ = "scout_service_api.scout_chart_api"


class scout_chartdefinition_api_AxisDisplayOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'show_title': ConjureFieldDefinition('showTitle', bool),
            'axis_width': ConjureFieldDefinition('axisWidth', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_show_title', '_axis_width']

    def __init__(self, show_title: bool, axis_width: Optional[float] = None) -> None:
        self._show_title = show_title
        self._axis_width = axis_width

    @builtins.property
    def show_title(self) -> bool:
        return self._show_title

    @builtins.property
    def axis_width(self) -> Optional[float]:
        return self._axis_width


scout_chartdefinition_api_AxisDisplayOptions.__name__ = "AxisDisplayOptions"
scout_chartdefinition_api_AxisDisplayOptions.__qualname__ = "AxisDisplayOptions"
scout_chartdefinition_api_AxisDisplayOptions.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisDomainType(ConjureEnumType):

    NUMERIC = 'NUMERIC'
    '''NUMERIC'''
    CATEGORICAL = 'CATEGORICAL'
    '''CATEGORICAL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_AxisDomainType.__name__ = "AxisDomainType"
scout_chartdefinition_api_AxisDomainType.__qualname__ = "AxisDomainType"
scout_chartdefinition_api_AxisDomainType.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisPosition(ConjureEnumType):

    LEFT = 'LEFT'
    '''LEFT'''
    RIGHT = 'RIGHT'
    '''RIGHT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_AxisPosition.__name__ = "AxisPosition"
scout_chartdefinition_api_AxisPosition.__qualname__ = "AxisPosition"
scout_chartdefinition_api_AxisPosition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisRange(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', OptionalTypeWrapper[float]),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_start', '_end']

    def __init__(self, end: Optional[float] = None, start: Optional[float] = None) -> None:
        self._start = start
        self._end = end

    @builtins.property
    def start(self) -> Optional[float]:
        return self._start

    @builtins.property
    def end(self) -> Optional[float]:
        return self._end


scout_chartdefinition_api_AxisRange.__name__ = "AxisRange"
scout_chartdefinition_api_AxisRange.__qualname__ = "AxisRange"
scout_chartdefinition_api_AxisRange.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisThresholdGroup(ConjureUnionType):
    _line_thresholds: Optional["scout_chartdefinition_api_LineThresholdGroup"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'line_thresholds': ConjureFieldDefinition('lineThresholds', scout_chartdefinition_api_LineThresholdGroup)
        }

    def __init__(
            self,
            line_thresholds: Optional["scout_chartdefinition_api_LineThresholdGroup"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (line_thresholds is not None) != 1:
                raise ValueError('a union must contain a single member')

            if line_thresholds is not None:
                self._line_thresholds = line_thresholds
                self._type = 'lineThresholds'

        elif type_of_union == 'lineThresholds':
            if line_thresholds is None:
                raise ValueError('a union value must not be None')
            self._line_thresholds = line_thresholds
            self._type = 'lineThresholds'

    @builtins.property
    def line_thresholds(self) -> Optional["scout_chartdefinition_api_LineThresholdGroup"]:
        return self._line_thresholds

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_AxisThresholdGroupVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_AxisThresholdGroupVisitor'.format(visitor.__class__.__name__))
        if self._type == 'lineThresholds' and self.line_thresholds is not None:
            return visitor._line_thresholds(self.line_thresholds)


scout_chartdefinition_api_AxisThresholdGroup.__name__ = "AxisThresholdGroup"
scout_chartdefinition_api_AxisThresholdGroup.__qualname__ = "AxisThresholdGroup"
scout_chartdefinition_api_AxisThresholdGroup.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisThresholdGroupVisitor:

    @abstractmethod
    def _line_thresholds(self, line_thresholds: "scout_chartdefinition_api_LineThresholdGroup") -> Any:
        pass


scout_chartdefinition_api_AxisThresholdGroupVisitor.__name__ = "AxisThresholdGroupVisitor"
scout_chartdefinition_api_AxisThresholdGroupVisitor.__qualname__ = "AxisThresholdGroupVisitor"
scout_chartdefinition_api_AxisThresholdGroupVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisThresholdVisualization(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'axis_id': ConjureFieldDefinition('axisId', scout_chartdefinition_api_AxisId),
            'visibility': ConjureFieldDefinition('visibility', bool),
            'thresholds': ConjureFieldDefinition('thresholds', scout_chartdefinition_api_AxisThresholdGroup)
        }

    __slots__: List[str] = ['_axis_id', '_visibility', '_thresholds']

    def __init__(self, axis_id: str, thresholds: "scout_chartdefinition_api_AxisThresholdGroup", visibility: bool) -> None:
        self._axis_id = axis_id
        self._visibility = visibility
        self._thresholds = thresholds

    @builtins.property
    def axis_id(self) -> str:
        return self._axis_id

    @builtins.property
    def visibility(self) -> bool:
        """
        Determines it's current visibility in the time series chart.
        """
        return self._visibility

    @builtins.property
    def thresholds(self) -> "scout_chartdefinition_api_AxisThresholdGroup":
        return self._thresholds


scout_chartdefinition_api_AxisThresholdVisualization.__name__ = "AxisThresholdVisualization"
scout_chartdefinition_api_AxisThresholdVisualization.__qualname__ = "AxisThresholdVisualization"
scout_chartdefinition_api_AxisThresholdVisualization.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_CartesianChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_CartesianChartDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_CartesianChartDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_CartesianChartDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_CartesianChartDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_CartesianChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_CartesianChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_CartesianChartDefinition.__name__ = "CartesianChartDefinition"
scout_chartdefinition_api_CartesianChartDefinition.__qualname__ = "CartesianChartDefinition"
scout_chartdefinition_api_CartesianChartDefinition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_CartesianChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_CartesianChartDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_CartesianChartDefinitionVisitor.__name__ = "CartesianChartDefinitionVisitor"
scout_chartdefinition_api_CartesianChartDefinitionVisitor.__qualname__ = "CartesianChartDefinitionVisitor"
scout_chartdefinition_api_CartesianChartDefinitionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_CartesianChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_CartesianPlot]),
            'events': ConjureFieldDefinition('events', List[scout_chartdefinition_api_Event]),
            'comparison_run_groups': ConjureFieldDefinition('comparisonRunGroups', List[scout_comparisonrun_api_ComparisonRunGroup]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'value_axes': ConjureFieldDefinition('valueAxes', List[scout_chartdefinition_api_ValueAxis])
        }

    __slots__: List[str] = ['_plots', '_events', '_comparison_run_groups', '_title', '_value_axes']

    def __init__(self, comparison_run_groups: List["scout_comparisonrun_api_ComparisonRunGroup"], events: List["scout_chartdefinition_api_Event"], plots: List["scout_chartdefinition_api_CartesianPlot"], value_axes: List["scout_chartdefinition_api_ValueAxis"], title: Optional[str] = None) -> None:
        self._plots = plots
        self._events = events
        self._comparison_run_groups = comparison_run_groups
        self._title = title
        self._value_axes = value_axes

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_CartesianPlot"]:
        return self._plots

    @builtins.property
    def events(self) -> List["scout_chartdefinition_api_Event"]:
        return self._events

    @builtins.property
    def comparison_run_groups(self) -> List["scout_comparisonrun_api_ComparisonRunGroup"]:
        return self._comparison_run_groups

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def value_axes(self) -> List["scout_chartdefinition_api_ValueAxis"]:
        return self._value_axes


scout_chartdefinition_api_CartesianChartDefinitionV1.__name__ = "CartesianChartDefinitionV1"
scout_chartdefinition_api_CartesianChartDefinitionV1.__qualname__ = "CartesianChartDefinitionV1"
scout_chartdefinition_api_CartesianChartDefinitionV1.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_CartesianPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x_variable_name': ConjureFieldDefinition('xVariableName', scout_channelvariables_api_ChannelVariableName),
            'y_variable_name': ConjureFieldDefinition('yVariableName', scout_channelvariables_api_ChannelVariableName),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'x_axis_id': ConjureFieldDefinition('xAxisId', scout_chartdefinition_api_AxisId),
            'y_axis_id': ConjureFieldDefinition('yAxisId', scout_chartdefinition_api_AxisId),
            'color': ConjureFieldDefinition('color', scout_api_HexColor)
        }

    __slots__: List[str] = ['_x_variable_name', '_y_variable_name', '_enabled', '_x_axis_id', '_y_axis_id', '_color']

    def __init__(self, color: str, x_axis_id: str, x_variable_name: str, y_axis_id: str, y_variable_name: str, enabled: Optional[bool] = None) -> None:
        self._x_variable_name = x_variable_name
        self._y_variable_name = y_variable_name
        self._enabled = enabled
        self._x_axis_id = x_axis_id
        self._y_axis_id = y_axis_id
        self._color = color

    @builtins.property
    def x_variable_name(self) -> str:
        return self._x_variable_name

    @builtins.property
    def y_variable_name(self) -> str:
        return self._y_variable_name

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def x_axis_id(self) -> str:
        return self._x_axis_id

    @builtins.property
    def y_axis_id(self) -> str:
        return self._y_axis_id

    @builtins.property
    def color(self) -> str:
        return self._color


scout_chartdefinition_api_CartesianPlot.__name__ = "CartesianPlot"
scout_chartdefinition_api_CartesianPlot.__qualname__ = "CartesianPlot"
scout_chartdefinition_api_CartesianPlot.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ChecklistChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_ChecklistChartDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_ChecklistChartDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_ChecklistChartDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_ChecklistChartDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ChecklistChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ChecklistChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_ChecklistChartDefinition.__name__ = "ChecklistChartDefinition"
scout_chartdefinition_api_ChecklistChartDefinition.__qualname__ = "ChecklistChartDefinition"
scout_chartdefinition_api_ChecklistChartDefinition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ChecklistChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_ChecklistChartDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_ChecklistChartDefinitionVisitor.__name__ = "ChecklistChartDefinitionVisitor"
scout_chartdefinition_api_ChecklistChartDefinitionVisitor.__qualname__ = "ChecklistChartDefinitionVisitor"
scout_chartdefinition_api_ChecklistChartDefinitionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ChecklistChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'selected_checklist_rids': ConjureFieldDefinition('selectedChecklistRids', List[str]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_selected_checklist_rids', '_title']

    def __init__(self, selected_checklist_rids: List[str], title: Optional[str] = None) -> None:
        self._selected_checklist_rids = selected_checklist_rids
        self._title = title

    @builtins.property
    def selected_checklist_rids(self) -> List[str]:
        return self._selected_checklist_rids

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title


scout_chartdefinition_api_ChecklistChartDefinitionV1.__name__ = "ChecklistChartDefinitionV1"
scout_chartdefinition_api_ChecklistChartDefinitionV1.__qualname__ = "ChecklistChartDefinitionV1"
scout_chartdefinition_api_ChecklistChartDefinitionV1.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_DefaultFill(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color': ConjureFieldDefinition('color', scout_api_HexColor)
        }

    __slots__: List[str] = ['_color']

    def __init__(self, color: str) -> None:
        self._color = color

    @builtins.property
    def color(self) -> str:
        return self._color


scout_chartdefinition_api_DefaultFill.__name__ = "DefaultFill"
scout_chartdefinition_api_DefaultFill.__qualname__ = "DefaultFill"
scout_chartdefinition_api_DefaultFill.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumRawVisualisation(ConjureBeanType):
    """
    The settings for a raw enum visualisation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color_map': ConjureFieldDefinition('colorMap', OptionalTypeWrapper[Dict[str, scout_api_HexColor]])
        }

    __slots__: List[str] = ['_color_map']

    def __init__(self, color_map: Optional[Dict[str, str]] = None) -> None:
        self._color_map = color_map

    @builtins.property
    def color_map(self) -> Optional[Dict[str, str]]:
        return self._color_map


scout_chartdefinition_api_EnumRawVisualisation.__name__ = "EnumRawVisualisation"
scout_chartdefinition_api_EnumRawVisualisation.__qualname__ = "EnumRawVisualisation"
scout_chartdefinition_api_EnumRawVisualisation.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumValueChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'visualisation': ConjureFieldDefinition('visualisation', scout_chartdefinition_api_EnumValueVisualisation)
        }

    __slots__: List[str] = ['_variable_name', '_visualisation']

    def __init__(self, variable_name: str, visualisation: "scout_chartdefinition_api_EnumValueVisualisation") -> None:
        self._variable_name = variable_name
        self._visualisation = visualisation

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def visualisation(self) -> "scout_chartdefinition_api_EnumValueVisualisation":
        return self._visualisation


scout_chartdefinition_api_EnumValueChannel.__name__ = "EnumValueChannel"
scout_chartdefinition_api_EnumValueChannel.__qualname__ = "EnumValueChannel"
scout_chartdefinition_api_EnumValueChannel.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumValueVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_EnumRawVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_EnumRawVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_EnumRawVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_EnumRawVisualisation"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_EnumValueVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_EnumValueVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_chartdefinition_api_EnumValueVisualisation.__name__ = "EnumValueVisualisation"
scout_chartdefinition_api_EnumValueVisualisation.__qualname__ = "EnumValueVisualisation"
scout_chartdefinition_api_EnumValueVisualisation.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumValueVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_EnumRawVisualisation") -> Any:
        pass


scout_chartdefinition_api_EnumValueVisualisationVisitor.__name__ = "EnumValueVisualisationVisitor"
scout_chartdefinition_api_EnumValueVisualisationVisitor.__qualname__ = "EnumValueVisualisationVisitor"
scout_chartdefinition_api_EnumValueVisualisationVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Event(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'event_uuid': ConjureFieldDefinition('eventUuid', str),
            'is_pinned': ConjureFieldDefinition('isPinned', bool)
        }

    __slots__: List[str] = ['_display_name', '_event_uuid', '_is_pinned']

    def __init__(self, event_uuid: str, is_pinned: bool, display_name: Optional[str] = None) -> None:
        self._display_name = display_name
        self._event_uuid = event_uuid
        self._is_pinned = is_pinned

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def event_uuid(self) -> str:
        return self._event_uuid

    @builtins.property
    def is_pinned(self) -> bool:
        return self._is_pinned


scout_chartdefinition_api_Event.__name__ = "Event"
scout_chartdefinition_api_Event.__qualname__ = "Event"
scout_chartdefinition_api_Event.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_FrequencyChartDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_FrequencyChartDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_FrequencyChartDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_FrequencyChartDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_FrequencyChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_FrequencyChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_FrequencyChartDefinition.__name__ = "FrequencyChartDefinition"
scout_chartdefinition_api_FrequencyChartDefinition.__qualname__ = "FrequencyChartDefinition"
scout_chartdefinition_api_FrequencyChartDefinition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_FrequencyChartDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_FrequencyChartDefinitionVisitor.__name__ = "FrequencyChartDefinitionVisitor"
scout_chartdefinition_api_FrequencyChartDefinitionVisitor.__qualname__ = "FrequencyChartDefinitionVisitor"
scout_chartdefinition_api_FrequencyChartDefinitionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_FrequencyPlot]),
            'events': ConjureFieldDefinition('events', List[scout_chartdefinition_api_Event]),
            'comparison_run_groups': ConjureFieldDefinition('comparisonRunGroups', List[scout_comparisonrun_api_ComparisonRunGroup]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'value_axes': ConjureFieldDefinition('valueAxes', List[scout_chartdefinition_api_ValueAxis])
        }

    __slots__: List[str] = ['_plots', '_events', '_comparison_run_groups', '_title', '_value_axes']

    def __init__(self, comparison_run_groups: List["scout_comparisonrun_api_ComparisonRunGroup"], events: List["scout_chartdefinition_api_Event"], plots: List["scout_chartdefinition_api_FrequencyPlot"], value_axes: List["scout_chartdefinition_api_ValueAxis"], title: Optional[str] = None) -> None:
        self._plots = plots
        self._events = events
        self._comparison_run_groups = comparison_run_groups
        self._title = title
        self._value_axes = value_axes

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_FrequencyPlot"]:
        return self._plots

    @builtins.property
    def events(self) -> List["scout_chartdefinition_api_Event"]:
        return self._events

    @builtins.property
    def comparison_run_groups(self) -> List["scout_comparisonrun_api_ComparisonRunGroup"]:
        return self._comparison_run_groups

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def value_axes(self) -> List["scout_chartdefinition_api_ValueAxis"]:
        return self._value_axes


scout_chartdefinition_api_FrequencyChartDefinitionV1.__name__ = "FrequencyChartDefinitionV1"
scout_chartdefinition_api_FrequencyChartDefinitionV1.__qualname__ = "FrequencyChartDefinitionV1"
scout_chartdefinition_api_FrequencyChartDefinitionV1.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'y_axis_id': ConjureFieldDefinition('yAxisId', scout_chartdefinition_api_AxisId),
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_LineStyle)
        }

    __slots__: List[str] = ['_variable_name', '_enabled', '_y_axis_id', '_color', '_line_style']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_LineStyle", variable_name: str, y_axis_id: str, enabled: Optional[bool] = None) -> None:
        self._variable_name = variable_name
        self._enabled = enabled
        self._y_axis_id = y_axis_id
        self._color = color
        self._line_style = line_style

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def y_axis_id(self) -> str:
        return self._y_axis_id

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_LineStyle":
        return self._line_style


scout_chartdefinition_api_FrequencyPlot.__name__ = "FrequencyPlot"
scout_chartdefinition_api_FrequencyPlot.__qualname__ = "FrequencyPlot"
scout_chartdefinition_api_FrequencyPlot.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoLineStyle(ConjureEnumType):

    POINTS = 'POINTS'
    '''POINTS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_GeoLineStyle.__name__ = "GeoLineStyle"
scout_chartdefinition_api_GeoLineStyle.__qualname__ = "GeoLineStyle"
scout_chartdefinition_api_GeoLineStyle.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoPlotFromLatLong(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'latitude_variable_name': ConjureFieldDefinition('latitudeVariableName', scout_channelvariables_api_ChannelVariableName),
            'longitude_variable_name': ConjureFieldDefinition('longitudeVariableName', scout_channelvariables_api_ChannelVariableName),
            'secondary_variables': ConjureFieldDefinition('secondaryVariables', OptionalTypeWrapper[List[scout_chartdefinition_api_GeoSecondaryVariable]]),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str]),
            'visualization_options': ConjureFieldDefinition('visualizationOptions', scout_chartdefinition_api_GeoPlotVisualizationOptions)
        }

    __slots__: List[str] = ['_latitude_variable_name', '_longitude_variable_name', '_secondary_variables', '_enabled', '_label', '_visualization_options']

    def __init__(self, latitude_variable_name: str, longitude_variable_name: str, visualization_options: "scout_chartdefinition_api_GeoPlotVisualizationOptions", enabled: Optional[bool] = None, label: Optional[str] = None, secondary_variables: Optional[List["scout_chartdefinition_api_GeoSecondaryVariable"]] = None) -> None:
        self._latitude_variable_name = latitude_variable_name
        self._longitude_variable_name = longitude_variable_name
        self._secondary_variables = secondary_variables
        self._enabled = enabled
        self._label = label
        self._visualization_options = visualization_options

    @builtins.property
    def latitude_variable_name(self) -> str:
        return self._latitude_variable_name

    @builtins.property
    def longitude_variable_name(self) -> str:
        return self._longitude_variable_name

    @builtins.property
    def secondary_variables(self) -> Optional[List["scout_chartdefinition_api_GeoSecondaryVariable"]]:
        """
        optional for backcompatibility
        """
        return self._secondary_variables

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def visualization_options(self) -> "scout_chartdefinition_api_GeoPlotVisualizationOptions":
        return self._visualization_options


scout_chartdefinition_api_GeoPlotFromLatLong.__name__ = "GeoPlotFromLatLong"
scout_chartdefinition_api_GeoPlotFromLatLong.__qualname__ = "GeoPlotFromLatLong"
scout_chartdefinition_api_GeoPlotFromLatLong.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visible': ConjureFieldDefinition('visible', bool),
            'variable_name': ConjureFieldDefinition('variableName', OptionalTypeWrapper[scout_channelvariables_api_ChannelVariableName])
        }

    __slots__: List[str] = ['_visible', '_variable_name']

    def __init__(self, visible: bool, variable_name: Optional[str] = None) -> None:
        self._visible = visible
        self._variable_name = variable_name

    @builtins.property
    def visible(self) -> bool:
        return self._visible

    @builtins.property
    def variable_name(self) -> Optional[str]:
        return self._variable_name


scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig.__name__ = "GeoPlotSecondaryVisibilityConfig"
scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig.__qualname__ = "GeoPlotSecondaryVisibilityConfig"
scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoPlotVisualizationOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_GeoLineStyle),
            'secondary_color_visualization': ConjureFieldDefinition('secondaryColorVisualization', OptionalTypeWrapper[scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig])
        }

    __slots__: List[str] = ['_color', '_line_style', '_secondary_color_visualization']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_GeoLineStyle", secondary_color_visualization: Optional["scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig"] = None) -> None:
        self._color = color
        self._line_style = line_style
        self._secondary_color_visualization = secondary_color_visualization

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_GeoLineStyle":
        return self._line_style

    @builtins.property
    def secondary_color_visualization(self) -> Optional["scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig"]:
        """
        If visible, overwrites any existing visualization options on the geo plot.
        """
        return self._secondary_color_visualization


scout_chartdefinition_api_GeoPlotVisualizationOptions.__name__ = "GeoPlotVisualizationOptions"
scout_chartdefinition_api_GeoPlotVisualizationOptions.__qualname__ = "GeoPlotVisualizationOptions"
scout_chartdefinition_api_GeoPlotVisualizationOptions.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption(ConjureUnionType):
    """Specifies how values of a secondary channel should be visualized."""
    _as_colors: Optional["scout_chartdefinition_api_ValueToColorMap"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'as_colors': ConjureFieldDefinition('asColors', scout_chartdefinition_api_ValueToColorMap)
        }

    def __init__(
            self,
            as_colors: Optional["scout_chartdefinition_api_ValueToColorMap"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (as_colors is not None) != 1:
                raise ValueError('a union must contain a single member')

            if as_colors is not None:
                self._as_colors = as_colors
                self._type = 'asColors'

        elif type_of_union == 'asColors':
            if as_colors is None:
                raise ValueError('a union value must not be None')
            self._as_colors = as_colors
            self._type = 'asColors'

    @builtins.property
    def as_colors(self) -> Optional["scout_chartdefinition_api_ValueToColorMap"]:
        return self._as_colors

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'asColors' and self.as_colors is not None:
            return visitor._as_colors(self.as_colors)


scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption.__name__ = "GeoSecondaryPlotVisualizationOption"
scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption.__qualname__ = "GeoSecondaryPlotVisualizationOption"
scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor:

    @abstractmethod
    def _as_colors(self, as_colors: "scout_chartdefinition_api_ValueToColorMap") -> Any:
        pass


scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor.__name__ = "GeoSecondaryPlotVisualizationOptionVisitor"
scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor.__qualname__ = "GeoSecondaryPlotVisualizationOptionVisitor"
scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoSecondaryVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'visualization_option': ConjureFieldDefinition('visualizationOption', OptionalTypeWrapper[scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption])
        }

    __slots__: List[str] = ['_variable_name', '_visualization_option']

    def __init__(self, variable_name: str, visualization_option: Optional["scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption"] = None) -> None:
        self._variable_name = variable_name
        self._visualization_option = visualization_option

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def visualization_option(self) -> Optional["scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption"]:
        return self._visualization_option


scout_chartdefinition_api_GeoSecondaryVariable.__name__ = "GeoSecondaryVariable"
scout_chartdefinition_api_GeoSecondaryVariable.__qualname__ = "GeoSecondaryVariable"
scout_chartdefinition_api_GeoSecondaryVariable.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoVizDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_GeoVizDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_GeoVizDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_GeoVizDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_GeoVizDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_GeoVizDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_GeoVizDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_GeoVizDefinition.__name__ = "GeoVizDefinition"
scout_chartdefinition_api_GeoVizDefinition.__qualname__ = "GeoVizDefinition"
scout_chartdefinition_api_GeoVizDefinition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoVizDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_GeoVizDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_GeoVizDefinitionVisitor.__name__ = "GeoVizDefinitionVisitor"
scout_chartdefinition_api_GeoVizDefinitionVisitor.__qualname__ = "GeoVizDefinitionVisitor"
scout_chartdefinition_api_GeoVizDefinitionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoVizDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_GeoPlotFromLatLong]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_plots', '_title']

    def __init__(self, plots: List["scout_chartdefinition_api_GeoPlotFromLatLong"], title: Optional[str] = None) -> None:
        self._plots = plots
        self._title = title

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_GeoPlotFromLatLong"]:
        return self._plots

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title


scout_chartdefinition_api_GeoVizDefinitionV1.__name__ = "GeoVizDefinitionV1"
scout_chartdefinition_api_GeoVizDefinitionV1.__qualname__ = "GeoVizDefinitionV1"
scout_chartdefinition_api_GeoVizDefinitionV1.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_HistogramChartDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_HistogramChartDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_HistogramChartDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_HistogramChartDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_HistogramChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_HistogramChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_HistogramChartDefinition.__name__ = "HistogramChartDefinition"
scout_chartdefinition_api_HistogramChartDefinition.__qualname__ = "HistogramChartDefinition"
scout_chartdefinition_api_HistogramChartDefinition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_HistogramChartDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_HistogramChartDefinitionVisitor.__name__ = "HistogramChartDefinitionVisitor"
scout_chartdefinition_api_HistogramChartDefinitionVisitor.__qualname__ = "HistogramChartDefinitionVisitor"
scout_chartdefinition_api_HistogramChartDefinitionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_HistogramPlot]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'display_settings': ConjureFieldDefinition('displaySettings', scout_chartdefinition_api_HistogramDisplaySettings),
            'numeric_bucket_strategy': ConjureFieldDefinition('numericBucketStrategy', OptionalTypeWrapper[scout_compute_api_NumericHistogramBucketStrategy]),
            'value_axis': ConjureFieldDefinition('valueAxis', OptionalTypeWrapper[scout_chartdefinition_api_ValueAxis])
        }

    __slots__: List[str] = ['_plots', '_title', '_display_settings', '_numeric_bucket_strategy', '_value_axis']

    def __init__(self, display_settings: "scout_chartdefinition_api_HistogramDisplaySettings", plots: List["scout_chartdefinition_api_HistogramPlot"], numeric_bucket_strategy: Optional["scout_compute_api_NumericHistogramBucketStrategy"] = None, title: Optional[str] = None, value_axis: Optional["scout_chartdefinition_api_ValueAxis"] = None) -> None:
        self._plots = plots
        self._title = title
        self._display_settings = display_settings
        self._numeric_bucket_strategy = numeric_bucket_strategy
        self._value_axis = value_axis

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_HistogramPlot"]:
        return self._plots

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def display_settings(self) -> "scout_chartdefinition_api_HistogramDisplaySettings":
        return self._display_settings

    @builtins.property
    def numeric_bucket_strategy(self) -> Optional["scout_compute_api_NumericHistogramBucketStrategy"]:
        return self._numeric_bucket_strategy

    @builtins.property
    def value_axis(self) -> Optional["scout_chartdefinition_api_ValueAxis"]:
        return self._value_axis


scout_chartdefinition_api_HistogramChartDefinitionV1.__name__ = "HistogramChartDefinitionV1"
scout_chartdefinition_api_HistogramChartDefinitionV1.__qualname__ = "HistogramChartDefinitionV1"
scout_chartdefinition_api_HistogramChartDefinitionV1.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramDisplaySettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'stacked': ConjureFieldDefinition('stacked', bool),
            'sort': ConjureFieldDefinition('sort', scout_chartdefinition_api_HistogramSortOrder)
        }

    __slots__: List[str] = ['_stacked', '_sort']

    def __init__(self, sort: "scout_chartdefinition_api_HistogramSortOrder", stacked: bool) -> None:
        self._stacked = stacked
        self._sort = sort

    @builtins.property
    def stacked(self) -> bool:
        return self._stacked

    @builtins.property
    def sort(self) -> "scout_chartdefinition_api_HistogramSortOrder":
        return self._sort


scout_chartdefinition_api_HistogramDisplaySettings.__name__ = "HistogramDisplaySettings"
scout_chartdefinition_api_HistogramDisplaySettings.__qualname__ = "HistogramDisplaySettings"
scout_chartdefinition_api_HistogramDisplaySettings.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'color': ConjureFieldDefinition('color', scout_api_HexColor)
        }

    __slots__: List[str] = ['_variable_name', '_enabled', '_color']

    def __init__(self, color: str, variable_name: str, enabled: Optional[bool] = None) -> None:
        self._variable_name = variable_name
        self._enabled = enabled
        self._color = color

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def color(self) -> str:
        return self._color


scout_chartdefinition_api_HistogramPlot.__name__ = "HistogramPlot"
scout_chartdefinition_api_HistogramPlot.__qualname__ = "HistogramPlot"
scout_chartdefinition_api_HistogramPlot.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramSortOrder(ConjureEnumType):
    """
    The order in which the histogram should be sorted.
Default is VALUE_ASCENDING.
    """

    VALUE_ASCENDING = 'VALUE_ASCENDING'
    '''VALUE_ASCENDING'''
    VALUE_DESCENDING = 'VALUE_DESCENDING'
    '''VALUE_DESCENDING'''
    FREQUENCY_ASCENDING = 'FREQUENCY_ASCENDING'
    '''FREQUENCY_ASCENDING'''
    FREQUENCY_DESCENDING = 'FREQUENCY_DESCENDING'
    '''FREQUENCY_DESCENDING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_HistogramSortOrder.__name__ = "HistogramSortOrder"
scout_chartdefinition_api_HistogramSortOrder.__qualname__ = "HistogramSortOrder"
scout_chartdefinition_api_HistogramSortOrder.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineStyle(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_LineStyleV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_LineStyleV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_LineStyleV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_LineStyleV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_LineStyleVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_LineStyleVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_LineStyle.__name__ = "LineStyle"
scout_chartdefinition_api_LineStyle.__qualname__ = "LineStyle"
scout_chartdefinition_api_LineStyle.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineStyleVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_LineStyleV1") -> Any:
        pass


scout_chartdefinition_api_LineStyleVisitor.__name__ = "LineStyleVisitor"
scout_chartdefinition_api_LineStyleVisitor.__qualname__ = "LineStyleVisitor"
scout_chartdefinition_api_LineStyleVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineStyleV1(ConjureEnumType):

    SOLID = 'SOLID'
    '''SOLID'''
    DASH = 'DASH'
    '''DASH'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_LineStyleV1.__name__ = "LineStyleV1"
scout_chartdefinition_api_LineStyleV1.__qualname__ = "LineStyleV1"
scout_chartdefinition_api_LineStyleV1.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineThreshold(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', float),
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str]),
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_ThresholdLineStyle)
        }

    __slots__: List[str] = ['_value', '_label', '_color', '_line_style']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_ThresholdLineStyle", value: float, label: Optional[str] = None) -> None:
        self._value = value
        self._label = label
        self._color = color
        self._line_style = line_style

    @builtins.property
    def value(self) -> float:
        return self._value

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_ThresholdLineStyle":
        return self._line_style


scout_chartdefinition_api_LineThreshold.__name__ = "LineThreshold"
scout_chartdefinition_api_LineThreshold.__qualname__ = "LineThreshold"
scout_chartdefinition_api_LineThreshold.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineThresholdGroup(ConjureBeanType):
    """
    Line thresholds are used to mark values or demarcate regions along a single axis.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'shading_config': ConjureFieldDefinition('shadingConfig', scout_chartdefinition_api_ThresholdShadingConfig),
            'lines': ConjureFieldDefinition('lines', List[scout_chartdefinition_api_LineThreshold]),
            'default_fill': ConjureFieldDefinition('defaultFill', OptionalTypeWrapper[scout_chartdefinition_api_DefaultFill])
        }

    __slots__: List[str] = ['_shading_config', '_lines', '_default_fill']

    def __init__(self, lines: List["scout_chartdefinition_api_LineThreshold"], shading_config: "scout_chartdefinition_api_ThresholdShadingConfig", default_fill: Optional["scout_chartdefinition_api_DefaultFill"] = None) -> None:
        self._shading_config = shading_config
        self._lines = lines
        self._default_fill = default_fill

    @builtins.property
    def shading_config(self) -> "scout_chartdefinition_api_ThresholdShadingConfig":
        return self._shading_config

    @builtins.property
    def lines(self) -> List["scout_chartdefinition_api_LineThreshold"]:
        return self._lines

    @builtins.property
    def default_fill(self) -> Optional["scout_chartdefinition_api_DefaultFill"]:
        """
        To supplement a set of line thresholds, the default fill configures how the remaining space (either
above or below) should be colored. Transparent if empty.
        """
        return self._default_fill


scout_chartdefinition_api_LineThresholdGroup.__name__ = "LineThresholdGroup"
scout_chartdefinition_api_LineThresholdGroup.__qualname__ = "LineThresholdGroup"
scout_chartdefinition_api_LineThresholdGroup.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericBarGaugeVisualisation(ConjureBeanType):
    """
    The settings for a bar gauge visualisation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'low_threshold': ConjureFieldDefinition('lowThreshold', float),
            'high_threshold': ConjureFieldDefinition('highThreshold', float)
        }

    __slots__: List[str] = ['_low_threshold', '_high_threshold']

    def __init__(self, high_threshold: float, low_threshold: float) -> None:
        self._low_threshold = low_threshold
        self._high_threshold = high_threshold

    @builtins.property
    def low_threshold(self) -> float:
        return self._low_threshold

    @builtins.property
    def high_threshold(self) -> float:
        return self._high_threshold


scout_chartdefinition_api_NumericBarGaugeVisualisation.__name__ = "NumericBarGaugeVisualisation"
scout_chartdefinition_api_NumericBarGaugeVisualisation.__qualname__ = "NumericBarGaugeVisualisation"
scout_chartdefinition_api_NumericBarGaugeVisualisation.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericRawVisualisation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_NumericRawVisualisation.__name__ = "NumericRawVisualisation"
scout_chartdefinition_api_NumericRawVisualisation.__qualname__ = "NumericRawVisualisation"
scout_chartdefinition_api_NumericRawVisualisation.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericValueChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'visualisation': ConjureFieldDefinition('visualisation', scout_chartdefinition_api_NumericValueVisualisation)
        }

    __slots__: List[str] = ['_variable_name', '_visualisation']

    def __init__(self, variable_name: str, visualisation: "scout_chartdefinition_api_NumericValueVisualisation") -> None:
        self._variable_name = variable_name
        self._visualisation = visualisation

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def visualisation(self) -> "scout_chartdefinition_api_NumericValueVisualisation":
        return self._visualisation


scout_chartdefinition_api_NumericValueChannel.__name__ = "NumericValueChannel"
scout_chartdefinition_api_NumericValueChannel.__qualname__ = "NumericValueChannel"
scout_chartdefinition_api_NumericValueChannel.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericValueVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_NumericRawVisualisation"] = None
    _bar_gauge: Optional["scout_chartdefinition_api_NumericBarGaugeVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_NumericRawVisualisation),
            'bar_gauge': ConjureFieldDefinition('barGauge', scout_chartdefinition_api_NumericBarGaugeVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_NumericRawVisualisation"] = None,
            bar_gauge: Optional["scout_chartdefinition_api_NumericBarGaugeVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (bar_gauge is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if bar_gauge is not None:
                self._bar_gauge = bar_gauge
                self._type = 'barGauge'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'barGauge':
            if bar_gauge is None:
                raise ValueError('a union value must not be None')
            self._bar_gauge = bar_gauge
            self._type = 'barGauge'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_NumericRawVisualisation"]:
        return self._raw

    @builtins.property
    def bar_gauge(self) -> Optional["scout_chartdefinition_api_NumericBarGaugeVisualisation"]:
        return self._bar_gauge

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_NumericValueVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_NumericValueVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'barGauge' and self.bar_gauge is not None:
            return visitor._bar_gauge(self.bar_gauge)


scout_chartdefinition_api_NumericValueVisualisation.__name__ = "NumericValueVisualisation"
scout_chartdefinition_api_NumericValueVisualisation.__qualname__ = "NumericValueVisualisation"
scout_chartdefinition_api_NumericValueVisualisation.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericValueVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_NumericRawVisualisation") -> Any:
        pass

    @abstractmethod
    def _bar_gauge(self, bar_gauge: "scout_chartdefinition_api_NumericBarGaugeVisualisation") -> Any:
        pass


scout_chartdefinition_api_NumericValueVisualisationVisitor.__name__ = "NumericValueVisualisationVisitor"
scout_chartdefinition_api_NumericValueVisualisationVisitor.__qualname__ = "NumericValueVisualisationVisitor"
scout_chartdefinition_api_NumericValueVisualisationVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeRawVisualisation(ConjureBeanType):
    """
    The settings for a raw range visualisation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'range_color': ConjureFieldDefinition('rangeColor', OptionalTypeWrapper[scout_api_HexColor]),
            'no_range_color': ConjureFieldDefinition('noRangeColor', OptionalTypeWrapper[scout_api_HexColor])
        }

    __slots__: List[str] = ['_range_color', '_no_range_color']

    def __init__(self, no_range_color: Optional[str] = None, range_color: Optional[str] = None) -> None:
        self._range_color = range_color
        self._no_range_color = no_range_color

    @builtins.property
    def range_color(self) -> Optional[str]:
        return self._range_color

    @builtins.property
    def no_range_color(self) -> Optional[str]:
        return self._no_range_color


scout_chartdefinition_api_RangeRawVisualisation.__name__ = "RangeRawVisualisation"
scout_chartdefinition_api_RangeRawVisualisation.__qualname__ = "RangeRawVisualisation"
scout_chartdefinition_api_RangeRawVisualisation.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeValueChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'visualisation': ConjureFieldDefinition('visualisation', scout_chartdefinition_api_RangeValueVisualisation)
        }

    __slots__: List[str] = ['_variable_name', '_visualisation']

    def __init__(self, variable_name: str, visualisation: "scout_chartdefinition_api_RangeValueVisualisation") -> None:
        self._variable_name = variable_name
        self._visualisation = visualisation

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def visualisation(self) -> "scout_chartdefinition_api_RangeValueVisualisation":
        return self._visualisation


scout_chartdefinition_api_RangeValueChannel.__name__ = "RangeValueChannel"
scout_chartdefinition_api_RangeValueChannel.__qualname__ = "RangeValueChannel"
scout_chartdefinition_api_RangeValueChannel.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeValueVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_RangeRawVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_RangeRawVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_RangeRawVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_RangeRawVisualisation"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_RangeValueVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_RangeValueVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_chartdefinition_api_RangeValueVisualisation.__name__ = "RangeValueVisualisation"
scout_chartdefinition_api_RangeValueVisualisation.__qualname__ = "RangeValueVisualisation"
scout_chartdefinition_api_RangeValueVisualisation.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeValueVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_RangeRawVisualisation") -> Any:
        pass


scout_chartdefinition_api_RangeValueVisualisationVisitor.__name__ = "RangeValueVisualisationVisitor"
scout_chartdefinition_api_RangeValueVisualisationVisitor.__qualname__ = "RangeValueVisualisationVisitor"
scout_chartdefinition_api_RangeValueVisualisationVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ThresholdLineStyle(ConjureEnumType):

    DOTTED = 'DOTTED'
    '''DOTTED'''
    SOLID = 'SOLID'
    '''SOLID'''
    NONE = 'NONE'
    '''NONE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_ThresholdLineStyle.__name__ = "ThresholdLineStyle"
scout_chartdefinition_api_ThresholdLineStyle.__qualname__ = "ThresholdLineStyle"
scout_chartdefinition_api_ThresholdLineStyle.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ThresholdShadingConfig(ConjureEnumType):
    """
    Specifies how areas of a plot should be shaded in relation to the defined threshold lines. Will eventually
include other shading configurations, like a buffer zone.
    """

    ABOVE = 'ABOVE'
    '''ABOVE'''
    BELOW = 'BELOW'
    '''BELOW'''
    NONE = 'NONE'
    '''NONE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_ThresholdShadingConfig.__name__ = "ThresholdShadingConfig"
scout_chartdefinition_api_ThresholdShadingConfig.__qualname__ = "ThresholdShadingConfig"
scout_chartdefinition_api_ThresholdShadingConfig.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_TimeSeriesChartDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_TimeSeriesChartDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_TimeSeriesChartDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_TimeSeriesChartDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_TimeSeriesChartDefinition.__name__ = "TimeSeriesChartDefinition"
scout_chartdefinition_api_TimeSeriesChartDefinition.__qualname__ = "TimeSeriesChartDefinition"
scout_chartdefinition_api_TimeSeriesChartDefinition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_TimeSeriesChartDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor.__name__ = "TimeSeriesChartDefinitionVisitor"
scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor.__qualname__ = "TimeSeriesChartDefinitionVisitor"
scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rows': ConjureFieldDefinition('rows', List[scout_chartdefinition_api_TimeSeriesRow]),
            'comparison_run_groups': ConjureFieldDefinition('comparisonRunGroups', List[scout_comparisonrun_api_ComparisonRunGroup]),
            'events': ConjureFieldDefinition('events', List[scout_chartdefinition_api_Event]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'value_axes': ConjureFieldDefinition('valueAxes', List[scout_chartdefinition_api_ValueAxis]),
            'thresholds': ConjureFieldDefinition('thresholds', OptionalTypeWrapper[List[scout_chartdefinition_api_AxisThresholdVisualization]])
        }

    __slots__: List[str] = ['_rows', '_comparison_run_groups', '_events', '_title', '_value_axes', '_thresholds']

    def __init__(self, comparison_run_groups: List["scout_comparisonrun_api_ComparisonRunGroup"], events: List["scout_chartdefinition_api_Event"], rows: List["scout_chartdefinition_api_TimeSeriesRow"], value_axes: List["scout_chartdefinition_api_ValueAxis"], thresholds: Optional[List["scout_chartdefinition_api_AxisThresholdVisualization"]] = None, title: Optional[str] = None) -> None:
        self._rows = rows
        self._comparison_run_groups = comparison_run_groups
        self._events = events
        self._title = title
        self._value_axes = value_axes
        self._thresholds = thresholds

    @builtins.property
    def rows(self) -> List["scout_chartdefinition_api_TimeSeriesRow"]:
        return self._rows

    @builtins.property
    def comparison_run_groups(self) -> List["scout_comparisonrun_api_ComparisonRunGroup"]:
        return self._comparison_run_groups

    @builtins.property
    def events(self) -> List["scout_chartdefinition_api_Event"]:
        return self._events

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def value_axes(self) -> List["scout_chartdefinition_api_ValueAxis"]:
        return self._value_axes

    @builtins.property
    def thresholds(self) -> Optional[List["scout_chartdefinition_api_AxisThresholdVisualization"]]:
        return self._thresholds


scout_chartdefinition_api_TimeSeriesChartDefinitionV1.__name__ = "TimeSeriesChartDefinitionV1"
scout_chartdefinition_api_TimeSeriesChartDefinitionV1.__qualname__ = "TimeSeriesChartDefinitionV1"
scout_chartdefinition_api_TimeSeriesChartDefinitionV1.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'y_axis_id': ConjureFieldDefinition('yAxisId', scout_chartdefinition_api_AxisId),
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_LineStyle)
        }

    __slots__: List[str] = ['_variable_name', '_enabled', '_y_axis_id', '_color', '_line_style']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_LineStyle", variable_name: str, y_axis_id: str, enabled: Optional[bool] = None) -> None:
        self._variable_name = variable_name
        self._enabled = enabled
        self._y_axis_id = y_axis_id
        self._color = color
        self._line_style = line_style

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def y_axis_id(self) -> str:
        return self._y_axis_id

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_LineStyle":
        return self._line_style


scout_chartdefinition_api_TimeSeriesPlot.__name__ = "TimeSeriesPlot"
scout_chartdefinition_api_TimeSeriesPlot.__qualname__ = "TimeSeriesPlot"
scout_chartdefinition_api_TimeSeriesPlot.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesRow(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_TimeSeriesPlot]),
            'row_flex_size': ConjureFieldDefinition('rowFlexSize', float)
        }

    __slots__: List[str] = ['_title', '_plots', '_row_flex_size']

    def __init__(self, plots: List["scout_chartdefinition_api_TimeSeriesPlot"], row_flex_size: float, title: Optional[str] = None) -> None:
        self._title = title
        self._plots = plots
        self._row_flex_size = row_flex_size

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_TimeSeriesPlot"]:
        return self._plots

    @builtins.property
    def row_flex_size(self) -> float:
        return self._row_flex_size


scout_chartdefinition_api_TimeSeriesRow.__name__ = "TimeSeriesRow"
scout_chartdefinition_api_TimeSeriesRow.__qualname__ = "TimeSeriesRow"
scout_chartdefinition_api_TimeSeriesRow.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueAxis(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', str),
            'title': ConjureFieldDefinition('title', str),
            'display_options': ConjureFieldDefinition('displayOptions', scout_chartdefinition_api_AxisDisplayOptions),
            'range': ConjureFieldDefinition('range', scout_chartdefinition_api_AxisRange),
            'limit': ConjureFieldDefinition('limit', scout_chartdefinition_api_AxisRange),
            'position': ConjureFieldDefinition('position', scout_chartdefinition_api_AxisPosition),
            'domain_type': ConjureFieldDefinition('domainType', scout_chartdefinition_api_AxisDomainType)
        }

    __slots__: List[str] = ['_id', '_title', '_display_options', '_range', '_limit', '_position', '_domain_type']

    def __init__(self, display_options: "scout_chartdefinition_api_AxisDisplayOptions", domain_type: "scout_chartdefinition_api_AxisDomainType", id: str, limit: "scout_chartdefinition_api_AxisRange", position: "scout_chartdefinition_api_AxisPosition", range: "scout_chartdefinition_api_AxisRange", title: str) -> None:
        self._id = id
        self._title = title
        self._display_options = display_options
        self._range = range
        self._limit = limit
        self._position = position
        self._domain_type = domain_type

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def display_options(self) -> "scout_chartdefinition_api_AxisDisplayOptions":
        return self._display_options

    @builtins.property
    def range(self) -> "scout_chartdefinition_api_AxisRange":
        return self._range

    @builtins.property
    def limit(self) -> "scout_chartdefinition_api_AxisRange":
        return self._limit

    @builtins.property
    def position(self) -> "scout_chartdefinition_api_AxisPosition":
        return self._position

    @builtins.property
    def domain_type(self) -> "scout_chartdefinition_api_AxisDomainType":
        return self._domain_type


scout_chartdefinition_api_ValueAxis.__name__ = "ValueAxis"
scout_chartdefinition_api_ValueAxis.__qualname__ = "ValueAxis"
scout_chartdefinition_api_ValueAxis.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableChannel(ConjureUnionType):
    _numeric: Optional["scout_chartdefinition_api_NumericValueChannel"] = None
    _enum: Optional["scout_chartdefinition_api_EnumValueChannel"] = None
    _range: Optional["scout_chartdefinition_api_RangeValueChannel"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', scout_chartdefinition_api_NumericValueChannel),
            'enum': ConjureFieldDefinition('enum', scout_chartdefinition_api_EnumValueChannel),
            'range': ConjureFieldDefinition('range', scout_chartdefinition_api_RangeValueChannel)
        }

    def __init__(
            self,
            numeric: Optional["scout_chartdefinition_api_NumericValueChannel"] = None,
            enum: Optional["scout_chartdefinition_api_EnumValueChannel"] = None,
            range: Optional["scout_chartdefinition_api_RangeValueChannel"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) + (enum is not None) + (range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if range is not None:
                self._range = range
                self._type = 'range'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'range':
            if range is None:
                raise ValueError('a union value must not be None')
            self._range = range
            self._type = 'range'

    @builtins.property
    def numeric(self) -> Optional["scout_chartdefinition_api_NumericValueChannel"]:
        return self._numeric

    @builtins.property
    def enum(self) -> Optional["scout_chartdefinition_api_EnumValueChannel"]:
        return self._enum

    @builtins.property
    def range(self) -> Optional["scout_chartdefinition_api_RangeValueChannel"]:
        return self._range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ValueTableChannelVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ValueTableChannelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'range' and self.range is not None:
            return visitor._range(self.range)


scout_chartdefinition_api_ValueTableChannel.__name__ = "ValueTableChannel"
scout_chartdefinition_api_ValueTableChannel.__qualname__ = "ValueTableChannel"
scout_chartdefinition_api_ValueTableChannel.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableChannelVisitor:

    @abstractmethod
    def _numeric(self, numeric: "scout_chartdefinition_api_NumericValueChannel") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_chartdefinition_api_EnumValueChannel") -> Any:
        pass

    @abstractmethod
    def _range(self, range: "scout_chartdefinition_api_RangeValueChannel") -> Any:
        pass


scout_chartdefinition_api_ValueTableChannelVisitor.__name__ = "ValueTableChannelVisitor"
scout_chartdefinition_api_ValueTableChannelVisitor.__qualname__ = "ValueTableChannelVisitor"
scout_chartdefinition_api_ValueTableChannelVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_ValueTableDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_ValueTableDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_ValueTableDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_ValueTableDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ValueTableDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ValueTableDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_ValueTableDefinition.__name__ = "ValueTableDefinition"
scout_chartdefinition_api_ValueTableDefinition.__qualname__ = "ValueTableDefinition"
scout_chartdefinition_api_ValueTableDefinition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_ValueTableDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_ValueTableDefinitionVisitor.__name__ = "ValueTableDefinitionVisitor"
scout_chartdefinition_api_ValueTableDefinitionVisitor.__qualname__ = "ValueTableDefinitionVisitor"
scout_chartdefinition_api_ValueTableDefinitionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'channels': ConjureFieldDefinition('channels', List[scout_chartdefinition_api_ValueTableChannel])
        }

    __slots__: List[str] = ['_title', '_channels']

    def __init__(self, channels: List["scout_chartdefinition_api_ValueTableChannel"], title: Optional[str] = None) -> None:
        self._title = title
        self._channels = channels

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def channels(self) -> List["scout_chartdefinition_api_ValueTableChannel"]:
        """
        Each channel to be displayed. Based on the data type, the visualisation
options and settings will be different.
        """
        return self._channels


scout_chartdefinition_api_ValueTableDefinitionV1.__name__ = "ValueTableDefinitionV1"
scout_chartdefinition_api_ValueTableDefinitionV1.__qualname__ = "ValueTableDefinitionV1"
scout_chartdefinition_api_ValueTableDefinitionV1.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueToColorMap(ConjureUnionType):
    """Specifies an assignment of colors across several values."""
    _numeric: Optional[Dict[str, float]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', Dict[scout_api_HexColor, float])
        }

    def __init__(
            self,
            numeric: Optional[Dict[str, float]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'

    @builtins.property
    def numeric(self) -> Optional[Dict[str, float]]:
        return self._numeric

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ValueToColorMapVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ValueToColorMapVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)


scout_chartdefinition_api_ValueToColorMap.__name__ = "ValueToColorMap"
scout_chartdefinition_api_ValueToColorMap.__qualname__ = "ValueToColorMap"
scout_chartdefinition_api_ValueToColorMap.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueToColorMapVisitor:

    @abstractmethod
    def _numeric(self, numeric: Dict[str, float]) -> Any:
        pass


scout_chartdefinition_api_ValueToColorMapVisitor.__name__ = "ValueToColorMapVisitor"
scout_chartdefinition_api_ValueToColorMapVisitor.__qualname__ = "ValueToColorMapVisitor"
scout_chartdefinition_api_ValueToColorMapVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VideoVizDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_VideoVizDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_VideoVizDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_VideoVizDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_VideoVizDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_VideoVizDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_VideoVizDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_VideoVizDefinition.__name__ = "VideoVizDefinition"
scout_chartdefinition_api_VideoVizDefinition.__qualname__ = "VideoVizDefinition"
scout_chartdefinition_api_VideoVizDefinition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VideoVizDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_VideoVizDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_VideoVizDefinitionVisitor.__name__ = "VideoVizDefinitionVisitor"
scout_chartdefinition_api_VideoVizDefinitionVisitor.__qualname__ = "VideoVizDefinitionVisitor"
scout_chartdefinition_api_VideoVizDefinitionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VideoVizDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'events': ConjureFieldDefinition('events', List[scout_chartdefinition_api_Event]),
            'comparison_run_groups': ConjureFieldDefinition('comparisonRunGroups', List[scout_comparisonrun_api_ComparisonRunGroup]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'ref_name': ConjureFieldDefinition('refName', OptionalTypeWrapper[scout_chartdefinition_api_DataSourceRefName])
        }

    __slots__: List[str] = ['_events', '_comparison_run_groups', '_title', '_ref_name']

    def __init__(self, comparison_run_groups: List["scout_comparisonrun_api_ComparisonRunGroup"], events: List["scout_chartdefinition_api_Event"], ref_name: Optional[str] = None, title: Optional[str] = None) -> None:
        self._events = events
        self._comparison_run_groups = comparison_run_groups
        self._title = title
        self._ref_name = ref_name

    @builtins.property
    def events(self) -> List["scout_chartdefinition_api_Event"]:
        return self._events

    @builtins.property
    def comparison_run_groups(self) -> List["scout_comparisonrun_api_ComparisonRunGroup"]:
        return self._comparison_run_groups

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def ref_name(self) -> Optional[str]:
        return self._ref_name


scout_chartdefinition_api_VideoVizDefinitionV1.__name__ = "VideoVizDefinitionV1"
scout_chartdefinition_api_VideoVizDefinitionV1.__qualname__ = "VideoVizDefinitionV1"
scout_chartdefinition_api_VideoVizDefinitionV1.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VizDefinition(ConjureUnionType):
    _time_series: Optional["scout_chartdefinition_api_TimeSeriesChartDefinition"] = None
    _cartesian: Optional["scout_chartdefinition_api_CartesianChartDefinition"] = None
    _frequency: Optional["scout_chartdefinition_api_FrequencyChartDefinition"] = None
    _histogram: Optional["scout_chartdefinition_api_HistogramChartDefinition"] = None
    _video: Optional["scout_chartdefinition_api_VideoVizDefinition"] = None
    _value_table: Optional["scout_chartdefinition_api_ValueTableDefinition"] = None
    _geo: Optional["scout_chartdefinition_api_GeoVizDefinition"] = None
    _checklist: Optional["scout_chartdefinition_api_ChecklistChartDefinition"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_series': ConjureFieldDefinition('timeSeries', scout_chartdefinition_api_TimeSeriesChartDefinition),
            'cartesian': ConjureFieldDefinition('cartesian', scout_chartdefinition_api_CartesianChartDefinition),
            'frequency': ConjureFieldDefinition('frequency', scout_chartdefinition_api_FrequencyChartDefinition),
            'histogram': ConjureFieldDefinition('histogram', scout_chartdefinition_api_HistogramChartDefinition),
            'video': ConjureFieldDefinition('video', scout_chartdefinition_api_VideoVizDefinition),
            'value_table': ConjureFieldDefinition('valueTable', scout_chartdefinition_api_ValueTableDefinition),
            'geo': ConjureFieldDefinition('geo', scout_chartdefinition_api_GeoVizDefinition),
            'checklist': ConjureFieldDefinition('checklist', scout_chartdefinition_api_ChecklistChartDefinition)
        }

    def __init__(
            self,
            time_series: Optional["scout_chartdefinition_api_TimeSeriesChartDefinition"] = None,
            cartesian: Optional["scout_chartdefinition_api_CartesianChartDefinition"] = None,
            frequency: Optional["scout_chartdefinition_api_FrequencyChartDefinition"] = None,
            histogram: Optional["scout_chartdefinition_api_HistogramChartDefinition"] = None,
            video: Optional["scout_chartdefinition_api_VideoVizDefinition"] = None,
            value_table: Optional["scout_chartdefinition_api_ValueTableDefinition"] = None,
            geo: Optional["scout_chartdefinition_api_GeoVizDefinition"] = None,
            checklist: Optional["scout_chartdefinition_api_ChecklistChartDefinition"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (time_series is not None) + (cartesian is not None) + (frequency is not None) + (histogram is not None) + (video is not None) + (value_table is not None) + (geo is not None) + (checklist is not None) != 1:
                raise ValueError('a union must contain a single member')

            if time_series is not None:
                self._time_series = time_series
                self._type = 'timeSeries'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if frequency is not None:
                self._frequency = frequency
                self._type = 'frequency'
            if histogram is not None:
                self._histogram = histogram
                self._type = 'histogram'
            if video is not None:
                self._video = video
                self._type = 'video'
            if value_table is not None:
                self._value_table = value_table
                self._type = 'valueTable'
            if geo is not None:
                self._geo = geo
                self._type = 'geo'
            if checklist is not None:
                self._checklist = checklist
                self._type = 'checklist'

        elif type_of_union == 'timeSeries':
            if time_series is None:
                raise ValueError('a union value must not be None')
            self._time_series = time_series
            self._type = 'timeSeries'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'frequency':
            if frequency is None:
                raise ValueError('a union value must not be None')
            self._frequency = frequency
            self._type = 'frequency'
        elif type_of_union == 'histogram':
            if histogram is None:
                raise ValueError('a union value must not be None')
            self._histogram = histogram
            self._type = 'histogram'
        elif type_of_union == 'video':
            if video is None:
                raise ValueError('a union value must not be None')
            self._video = video
            self._type = 'video'
        elif type_of_union == 'valueTable':
            if value_table is None:
                raise ValueError('a union value must not be None')
            self._value_table = value_table
            self._type = 'valueTable'
        elif type_of_union == 'geo':
            if geo is None:
                raise ValueError('a union value must not be None')
            self._geo = geo
            self._type = 'geo'
        elif type_of_union == 'checklist':
            if checklist is None:
                raise ValueError('a union value must not be None')
            self._checklist = checklist
            self._type = 'checklist'

    @builtins.property
    def time_series(self) -> Optional["scout_chartdefinition_api_TimeSeriesChartDefinition"]:
        return self._time_series

    @builtins.property
    def cartesian(self) -> Optional["scout_chartdefinition_api_CartesianChartDefinition"]:
        return self._cartesian

    @builtins.property
    def frequency(self) -> Optional["scout_chartdefinition_api_FrequencyChartDefinition"]:
        return self._frequency

    @builtins.property
    def histogram(self) -> Optional["scout_chartdefinition_api_HistogramChartDefinition"]:
        return self._histogram

    @builtins.property
    def video(self) -> Optional["scout_chartdefinition_api_VideoVizDefinition"]:
        return self._video

    @builtins.property
    def value_table(self) -> Optional["scout_chartdefinition_api_ValueTableDefinition"]:
        return self._value_table

    @builtins.property
    def geo(self) -> Optional["scout_chartdefinition_api_GeoVizDefinition"]:
        return self._geo

    @builtins.property
    def checklist(self) -> Optional["scout_chartdefinition_api_ChecklistChartDefinition"]:
        return self._checklist

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_VizDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_VizDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timeSeries' and self.time_series is not None:
            return visitor._time_series(self.time_series)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'frequency' and self.frequency is not None:
            return visitor._frequency(self.frequency)
        if self._type == 'histogram' and self.histogram is not None:
            return visitor._histogram(self.histogram)
        if self._type == 'video' and self.video is not None:
            return visitor._video(self.video)
        if self._type == 'valueTable' and self.value_table is not None:
            return visitor._value_table(self.value_table)
        if self._type == 'geo' and self.geo is not None:
            return visitor._geo(self.geo)
        if self._type == 'checklist' and self.checklist is not None:
            return visitor._checklist(self.checklist)


scout_chartdefinition_api_VizDefinition.__name__ = "VizDefinition"
scout_chartdefinition_api_VizDefinition.__qualname__ = "VizDefinition"
scout_chartdefinition_api_VizDefinition.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VizDefinitionVisitor:

    @abstractmethod
    def _time_series(self, time_series: "scout_chartdefinition_api_TimeSeriesChartDefinition") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_chartdefinition_api_CartesianChartDefinition") -> Any:
        pass

    @abstractmethod
    def _frequency(self, frequency: "scout_chartdefinition_api_FrequencyChartDefinition") -> Any:
        pass

    @abstractmethod
    def _histogram(self, histogram: "scout_chartdefinition_api_HistogramChartDefinition") -> Any:
        pass

    @abstractmethod
    def _video(self, video: "scout_chartdefinition_api_VideoVizDefinition") -> Any:
        pass

    @abstractmethod
    def _value_table(self, value_table: "scout_chartdefinition_api_ValueTableDefinition") -> Any:
        pass

    @abstractmethod
    def _geo(self, geo: "scout_chartdefinition_api_GeoVizDefinition") -> Any:
        pass

    @abstractmethod
    def _checklist(self, checklist: "scout_chartdefinition_api_ChecklistChartDefinition") -> Any:
        pass


scout_chartdefinition_api_VizDefinitionVisitor.__name__ = "VizDefinitionVisitor"
scout_chartdefinition_api_VizDefinitionVisitor.__qualname__ = "VizDefinitionVisitor"
scout_chartdefinition_api_VizDefinitionVisitor.__module__ = "scout_service_api.scout_chartdefinition_api"


class scout_checklistexecution_api_AssetStreamConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'notification_configurations': ConjureFieldDefinition('notificationConfigurations', List[scout_integrations_api_NotificationConfiguration]),
            'stream_delay': ConjureFieldDefinition('streamDelay', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_notification_configurations', '_stream_delay']

    def __init__(self, notification_configurations: List["scout_integrations_api_NotificationConfiguration"], stream_delay: "scout_run_api_Duration") -> None:
        self._notification_configurations = notification_configurations
        self._stream_delay = stream_delay

    @builtins.property
    def notification_configurations(self) -> List["scout_integrations_api_NotificationConfiguration"]:
        return self._notification_configurations

    @builtins.property
    def stream_delay(self) -> "scout_run_api_Duration":
        return self._stream_delay


scout_checklistexecution_api_AssetStreamConfiguration.__name__ = "AssetStreamConfiguration"
scout_checklistexecution_api_AssetStreamConfiguration.__qualname__ = "AssetStreamConfiguration"
scout_checklistexecution_api_AssetStreamConfiguration.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_BatchChecklistLiveStatusRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[scout_checklistexecution_api_ChecklistLiveStatusRequest]),
            'computation_range': ConjureFieldDefinition('computationRange', OptionalTypeWrapper[scout_checklistexecution_api_ComputationRange])
        }

    __slots__: List[str] = ['_requests', '_computation_range']

    def __init__(self, requests: List["scout_checklistexecution_api_ChecklistLiveStatusRequest"], computation_range: Optional["scout_checklistexecution_api_ComputationRange"] = None) -> None:
        self._requests = requests
        self._computation_range = computation_range

    @builtins.property
    def requests(self) -> List["scout_checklistexecution_api_ChecklistLiveStatusRequest"]:
        return self._requests

    @builtins.property
    def computation_range(self) -> Optional["scout_checklistexecution_api_ComputationRange"]:
        """
        The time range over which status and last failure were calculated. Failures outside of this time range
will not be included in the results. If not specified, defaults to evaluating from now minus sixty minutes to now.
        """
        return self._computation_range


scout_checklistexecution_api_BatchChecklistLiveStatusRequest.__name__ = "BatchChecklistLiveStatusRequest"
scout_checklistexecution_api_BatchChecklistLiveStatusRequest.__qualname__ = "BatchChecklistLiveStatusRequest"
scout_checklistexecution_api_BatchChecklistLiveStatusRequest.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_BatchChecklistLiveStatusResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'computation_range': ConjureFieldDefinition('computationRange', scout_checklistexecution_api_ComputationRange),
            'checklist_results': ConjureFieldDefinition('checklistResults', List[scout_checklistexecution_api_ChecklistLiveStatusResponse])
        }

    __slots__: List[str] = ['_computation_range', '_checklist_results']

    def __init__(self, checklist_results: List["scout_checklistexecution_api_ChecklistLiveStatusResponse"], computation_range: "scout_checklistexecution_api_ComputationRange") -> None:
        self._computation_range = computation_range
        self._checklist_results = checklist_results

    @builtins.property
    def computation_range(self) -> "scout_checklistexecution_api_ComputationRange":
        """
        The time range over which status and last failure were calculated. Failures outside of this time range
will not be included in the results.
        """
        return self._computation_range

    @builtins.property
    def checklist_results(self) -> List["scout_checklistexecution_api_ChecklistLiveStatusResponse"]:
        return self._checklist_results


scout_checklistexecution_api_BatchChecklistLiveStatusResponse.__name__ = "BatchChecklistLiveStatusResponse"
scout_checklistexecution_api_BatchChecklistLiveStatusResponse.__qualname__ = "BatchChecklistLiveStatusResponse"
scout_checklistexecution_api_BatchChecklistLiveStatusResponse.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_CheckLiveStatusResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'result': ConjureFieldDefinition('result', scout_checklistexecution_api_CheckLiveStatusResult),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'check_implementation_index': ConjureFieldDefinition('checkImplementationIndex', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_result', '_check_rid', '_check_implementation_index']

    def __init__(self, check_rid: str, result: "scout_checklistexecution_api_CheckLiveStatusResult", check_implementation_index: Optional[int] = None) -> None:
        self._result = result
        self._check_rid = check_rid
        self._check_implementation_index = check_implementation_index

    @builtins.property
    def result(self) -> "scout_checklistexecution_api_CheckLiveStatusResult":
        return self._result

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def check_implementation_index(self) -> Optional[int]:
        """
        Checks can define a single range computation which can evaluate over multiple implementations of a context.
The check implementation index will correspond to the implementation index of the check condition.
        """
        return self._check_implementation_index


scout_checklistexecution_api_CheckLiveStatusResponse.__name__ = "CheckLiveStatusResponse"
scout_checklistexecution_api_CheckLiveStatusResponse.__qualname__ = "CheckLiveStatusResponse"
scout_checklistexecution_api_CheckLiveStatusResponse.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_CheckLiveStatusResult(ConjureUnionType):
    _computed: Optional["scout_checklistexecution_api_ComputedResult"] = None
    _not_computable: Optional["scout_checklistexecution_api_NotComputable"] = None
    _failed_to_resolve: Optional["scout_checklistexecution_api_FailedToResolve"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'computed': ConjureFieldDefinition('computed', scout_checklistexecution_api_ComputedResult),
            'not_computable': ConjureFieldDefinition('notComputable', scout_checklistexecution_api_NotComputable),
            'failed_to_resolve': ConjureFieldDefinition('failedToResolve', scout_checklistexecution_api_FailedToResolve)
        }

    def __init__(
            self,
            computed: Optional["scout_checklistexecution_api_ComputedResult"] = None,
            not_computable: Optional["scout_checklistexecution_api_NotComputable"] = None,
            failed_to_resolve: Optional["scout_checklistexecution_api_FailedToResolve"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (computed is not None) + (not_computable is not None) + (failed_to_resolve is not None) != 1:
                raise ValueError('a union must contain a single member')

            if computed is not None:
                self._computed = computed
                self._type = 'computed'
            if not_computable is not None:
                self._not_computable = not_computable
                self._type = 'notComputable'
            if failed_to_resolve is not None:
                self._failed_to_resolve = failed_to_resolve
                self._type = 'failedToResolve'

        elif type_of_union == 'computed':
            if computed is None:
                raise ValueError('a union value must not be None')
            self._computed = computed
            self._type = 'computed'
        elif type_of_union == 'notComputable':
            if not_computable is None:
                raise ValueError('a union value must not be None')
            self._not_computable = not_computable
            self._type = 'notComputable'
        elif type_of_union == 'failedToResolve':
            if failed_to_resolve is None:
                raise ValueError('a union value must not be None')
            self._failed_to_resolve = failed_to_resolve
            self._type = 'failedToResolve'

    @builtins.property
    def computed(self) -> Optional["scout_checklistexecution_api_ComputedResult"]:
        return self._computed

    @builtins.property
    def not_computable(self) -> Optional["scout_checklistexecution_api_NotComputable"]:
        """
        The check cannot be computed in a streaming context. This would be returned if an overly expensive
computation was attempted, such as checking the rolling median over the last year of data.
        """
        return self._not_computable

    @builtins.property
    def failed_to_resolve(self) -> Optional["scout_checklistexecution_api_FailedToResolve"]:
        """
        The checklist cannot be applied to the data sources.
        """
        return self._failed_to_resolve

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checklistexecution_api_CheckLiveStatusResultVisitor):
            raise ValueError('{} is not an instance of scout_checklistexecution_api_CheckLiveStatusResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'computed' and self.computed is not None:
            return visitor._computed(self.computed)
        if self._type == 'notComputable' and self.not_computable is not None:
            return visitor._not_computable(self.not_computable)
        if self._type == 'failedToResolve' and self.failed_to_resolve is not None:
            return visitor._failed_to_resolve(self.failed_to_resolve)


scout_checklistexecution_api_CheckLiveStatusResult.__name__ = "CheckLiveStatusResult"
scout_checklistexecution_api_CheckLiveStatusResult.__qualname__ = "CheckLiveStatusResult"
scout_checklistexecution_api_CheckLiveStatusResult.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_CheckLiveStatusResultVisitor:

    @abstractmethod
    def _computed(self, computed: "scout_checklistexecution_api_ComputedResult") -> Any:
        pass

    @abstractmethod
    def _not_computable(self, not_computable: "scout_checklistexecution_api_NotComputable") -> Any:
        pass

    @abstractmethod
    def _failed_to_resolve(self, failed_to_resolve: "scout_checklistexecution_api_FailedToResolve") -> Any:
        pass


scout_checklistexecution_api_CheckLiveStatusResultVisitor.__name__ = "CheckLiveStatusResultVisitor"
scout_checklistexecution_api_CheckLiveStatusResultVisitor.__qualname__ = "CheckLiveStatusResultVisitor"
scout_checklistexecution_api_CheckLiveStatusResultVisitor.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_CheckStatus(ConjureUnionType):
    _pass_: Optional["scout_checklistexecution_api_Pass"] = None
    _fail: Optional["scout_checklistexecution_api_Fail"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pass_': ConjureFieldDefinition('pass', scout_checklistexecution_api_Pass),
            'fail': ConjureFieldDefinition('fail', scout_checklistexecution_api_Fail)
        }

    def __init__(
            self,
            pass_: Optional["scout_checklistexecution_api_Pass"] = None,
            fail: Optional["scout_checklistexecution_api_Fail"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pass_ is not None) + (fail is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pass_ is not None:
                self._pass_ = pass_
                self._type = 'pass'
            if fail is not None:
                self._fail = fail
                self._type = 'fail'

        elif type_of_union == 'pass':
            if pass_ is None:
                raise ValueError('a union value must not be None')
            self._pass_ = pass_
            self._type = 'pass'
        elif type_of_union == 'fail':
            if fail is None:
                raise ValueError('a union value must not be None')
            self._fail = fail
            self._type = 'fail'

    @builtins.property
    def pass_(self) -> Optional["scout_checklistexecution_api_Pass"]:
        """
        The check was evaluated and is currently in state PASS.
        """
        return self._pass_

    @builtins.property
    def fail(self) -> Optional["scout_checklistexecution_api_Fail"]:
        """
        The check was evaluated and is currently in state FAIL.
        """
        return self._fail

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checklistexecution_api_CheckStatusVisitor):
            raise ValueError('{} is not an instance of scout_checklistexecution_api_CheckStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pass' and self.pass_ is not None:
            return visitor._pass(self.pass_)
        if self._type == 'fail' and self.fail is not None:
            return visitor._fail(self.fail)


scout_checklistexecution_api_CheckStatus.__name__ = "CheckStatus"
scout_checklistexecution_api_CheckStatus.__qualname__ = "CheckStatus"
scout_checklistexecution_api_CheckStatus.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_CheckStatusVisitor:

    @abstractmethod
    def _pass(self, pass_: "scout_checklistexecution_api_Pass") -> Any:
        pass

    @abstractmethod
    def _fail(self, fail: "scout_checklistexecution_api_Fail") -> Any:
        pass


scout_checklistexecution_api_CheckStatusVisitor.__name__ = "CheckStatusVisitor"
scout_checklistexecution_api_CheckStatusVisitor.__qualname__ = "CheckStatusVisitor"
scout_checklistexecution_api_CheckStatusVisitor.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChecklistExecutionService(Service):
    """
    The Checklist Execution Service checks the status of checklist executions.
    """

    def checklist_live_status(self, auth_header: str, request: "scout_checklistexecution_api_BatchChecklistLiveStatusRequest") -> "scout_checklistexecution_api_BatchChecklistLiveStatusResponse":
        """
        For each request, get the current status and last failing time (if possible) for
every automatic check against the given run.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/checklist-execution/checklist-live-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checklistexecution_api_BatchChecklistLiveStatusResponse, self._return_none_for_unknown_union_types)

    def execute_streaming_checklist(self, auth_header: str, request: "scout_checklistexecution_api_ExecuteChecklistForAssetsRequest") -> None:
        """
        Triggers a checklist to run continuously against assets. Returns a ChecklistAlreadyRunning error if the
checklist is already running for the given asset.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/checklist-execution/execute-streaming-checklist'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def list_streaming_checklist(self, auth_header: str) -> List[str]:
        """
        Lists all running streaming checklists.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/scout/v2/checklist-execution/list-streaming-checklists'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_rids_api_ChecklistRid], self._return_none_for_unknown_union_types)

    def get_streaming_checklist(self, auth_header: str, checklist_rid: str) -> "scout_checklistexecution_api_StreamingChecklistInfo":
        """
        Retrieves information about a streaming checklist using the provided checklistRid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'checklistRid': checklist_rid,
        }

        _json: Any = None

        _path = '/scout/v2/checklist-execution/get-streaming-checklist/{checklistRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checklistexecution_api_StreamingChecklistInfo, self._return_none_for_unknown_union_types)

    def stop_streaming_checklist(self, auth_header: str, checklist_rid: str) -> None:
        """
        Stops the execution of a streaming checklist on all assets.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'checklistRid': checklist_rid,
        }

        _json: Any = None

        _path = '/scout/v2/checklist-execution/stop-streaming-checklist/{checklistRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def stop_streaming_checklist_for_assets(self, auth_header: str, request: "scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest") -> None:
        """
        Stops the execution of a streaming checklist for a given set of assets.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/checklist-execution/stop-streaming-checklist-for-assets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def reload_streaming_checklist(self, auth_header: str, checklist_rid: str) -> None:
        """
        Reloads the state of the streaming checklist for the given checklistRid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'checklistRid': checklist_rid,
        }

        _json: Any = None

        _path = '/scout/v2/checklist-execution/reload-streaming-checklist/{checklistRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_checklistexecution_api_ChecklistExecutionService.__name__ = "ChecklistExecutionService"
scout_checklistexecution_api_ChecklistExecutionService.__qualname__ = "ChecklistExecutionService"
scout_checklistexecution_api_ChecklistExecutionService.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChecklistLiveStatusRequest(ConjureBeanType):
    """
    If commit not is provided, the latest commit on main will be used.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'commit': ConjureFieldDefinition('commit', OptionalTypeWrapper[scout_versioning_api_CommitId]),
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid)
        }

    __slots__: List[str] = ['_checklist_rid', '_commit', '_run_rid']

    def __init__(self, checklist_rid: str, run_rid: str, commit: Optional[str] = None) -> None:
        self._checklist_rid = checklist_rid
        self._commit = commit
        self._run_rid = run_rid

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def commit(self) -> Optional[str]:
        return self._commit

    @builtins.property
    def run_rid(self) -> str:
        return self._run_rid


scout_checklistexecution_api_ChecklistLiveStatusRequest.__name__ = "ChecklistLiveStatusRequest"
scout_checklistexecution_api_ChecklistLiveStatusRequest.__qualname__ = "ChecklistLiveStatusRequest"
scout_checklistexecution_api_ChecklistLiveStatusRequest.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChecklistLiveStatusResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'check_results': ConjureFieldDefinition('checkResults', List[scout_checklistexecution_api_CheckLiveStatusResponse])
        }

    __slots__: List[str] = ['_checklist_rid', '_check_results']

    def __init__(self, check_results: List["scout_checklistexecution_api_CheckLiveStatusResponse"], checklist_rid: str) -> None:
        self._checklist_rid = checklist_rid
        self._check_results = check_results

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def check_results(self) -> List["scout_checklistexecution_api_CheckLiveStatusResponse"]:
        return self._check_results


scout_checklistexecution_api_ChecklistLiveStatusResponse.__name__ = "ChecklistLiveStatusResponse"
scout_checklistexecution_api_ChecklistLiveStatusResponse.__qualname__ = "ChecklistLiveStatusResponse"
scout_checklistexecution_api_ChecklistLiveStatusResponse.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ComputationRange(ConjureBeanType):
    """
    The time range over which status and last failure were calculated. Failures outside of this time range
will not be included in the results.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp)
        }

    __slots__: List[str] = ['_start', '_end']

    def __init__(self, end: "api_Timestamp", start: "api_Timestamp") -> None:
        self._start = start
        self._end = end

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end


scout_checklistexecution_api_ComputationRange.__name__ = "ComputationRange"
scout_checklistexecution_api_ComputationRange.__qualname__ = "ComputationRange"
scout_checklistexecution_api_ComputationRange.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ComputedResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'status': ConjureFieldDefinition('status', scout_checklistexecution_api_CheckStatus),
            'last_failure': ConjureFieldDefinition('lastFailure', scout_checklistexecution_api_LastFailure)
        }

    __slots__: List[str] = ['_status', '_last_failure']

    def __init__(self, last_failure: "scout_checklistexecution_api_LastFailure", status: "scout_checklistexecution_api_CheckStatus") -> None:
        self._status = status
        self._last_failure = last_failure

    @builtins.property
    def status(self) -> "scout_checklistexecution_api_CheckStatus":
        """
        The current status of a check at the time it was evaluated.
        """
        return self._status

    @builtins.property
    def last_failure(self) -> "scout_checklistexecution_api_LastFailure":
        """
        If computed, represents the last time the check failed.
Can also represent that the last failure hasn't been computed, or is currently being computed.
If the check is currently failing, the current failure is returned.
        """
        return self._last_failure


scout_checklistexecution_api_ComputedResult.__name__ = "ComputedResult"
scout_checklistexecution_api_ComputedResult.__qualname__ = "ComputedResult"
scout_checklistexecution_api_ComputedResult.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Computing(ConjureBeanType):
    """
    The result is currently being computed.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_Computing.__name__ = "Computing"
scout_checklistexecution_api_Computing.__qualname__ = "Computing"
scout_checklistexecution_api_Computing.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ExecuteChecklistForAssetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist': ConjureFieldDefinition('checklist', scout_rids_api_ChecklistRid),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid]),
            'notification_configurations': ConjureFieldDefinition('notificationConfigurations', List[scout_integrations_api_NotificationConfiguration]),
            'stream_delay': ConjureFieldDefinition('streamDelay', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_checklist', '_assets', '_notification_configurations', '_stream_delay']

    def __init__(self, assets: List[str], checklist: str, notification_configurations: List["scout_integrations_api_NotificationConfiguration"], stream_delay: "scout_run_api_Duration") -> None:
        self._checklist = checklist
        self._assets = assets
        self._notification_configurations = notification_configurations
        self._stream_delay = stream_delay

    @builtins.property
    def checklist(self) -> str:
        return self._checklist

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets

    @builtins.property
    def notification_configurations(self) -> List["scout_integrations_api_NotificationConfiguration"]:
        """
        If provided, checklist violations will be sent to the specified integrations.
        """
        return self._notification_configurations

    @builtins.property
    def stream_delay(self) -> "scout_run_api_Duration":
        """
        Delays the execution of the streaming checklist. This is useful for when data is delayed.
        """
        return self._stream_delay


scout_checklistexecution_api_ExecuteChecklistForAssetsRequest.__name__ = "ExecuteChecklistForAssetsRequest"
scout_checklistexecution_api_ExecuteChecklistForAssetsRequest.__qualname__ = "ExecuteChecklistForAssetsRequest"
scout_checklistexecution_api_ExecuteChecklistForAssetsRequest.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Fail(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_Fail.__name__ = "Fail"
scout_checklistexecution_api_Fail.__qualname__ = "Fail"
scout_checklistexecution_api_Fail.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_FailedToResolve(ConjureBeanType):
    """
    The checklist cannot be applied to the data sources.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', str)
        }

    __slots__: List[str] = ['_variable_name']

    def __init__(self, variable_name: str) -> None:
        self._variable_name = variable_name

    @builtins.property
    def variable_name(self) -> str:
        """
        The variable name that couldn't be resolved to a series.
        """
        return self._variable_name


scout_checklistexecution_api_FailedToResolve.__name__ = "FailedToResolve"
scout_checklistexecution_api_FailedToResolve.__qualname__ = "FailedToResolve"
scout_checklistexecution_api_FailedToResolve.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Failure(ConjureBeanType):
    """
    The time range where a check was failing.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', OptionalTypeWrapper[api_Timestamp]),
            'end_exclusive': ConjureFieldDefinition('endExclusive', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive']

    def __init__(self, end_exclusive: Optional["api_Timestamp"] = None, start_inclusive: Optional["api_Timestamp"] = None) -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive

    @builtins.property
    def start_inclusive(self) -> Optional["api_Timestamp"]:
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> Optional["api_Timestamp"]:
        return self._end_exclusive


scout_checklistexecution_api_Failure.__name__ = "Failure"
scout_checklistexecution_api_Failure.__qualname__ = "Failure"
scout_checklistexecution_api_Failure.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_LastFailure(ConjureUnionType):
    _not_computed: Optional["scout_checklistexecution_api_NotComputed"] = None
    _computing: Optional["scout_checklistexecution_api_Computing"] = None
    _no_previous_failure: Optional["scout_checklistexecution_api_NoPreviousFailure"] = None
    _failure: Optional["scout_checklistexecution_api_Failure"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'not_computed': ConjureFieldDefinition('notComputed', scout_checklistexecution_api_NotComputed),
            'computing': ConjureFieldDefinition('computing', scout_checklistexecution_api_Computing),
            'no_previous_failure': ConjureFieldDefinition('noPreviousFailure', scout_checklistexecution_api_NoPreviousFailure),
            'failure': ConjureFieldDefinition('failure', scout_checklistexecution_api_Failure)
        }

    def __init__(
            self,
            not_computed: Optional["scout_checklistexecution_api_NotComputed"] = None,
            computing: Optional["scout_checklistexecution_api_Computing"] = None,
            no_previous_failure: Optional["scout_checklistexecution_api_NoPreviousFailure"] = None,
            failure: Optional["scout_checklistexecution_api_Failure"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (not_computed is not None) + (computing is not None) + (no_previous_failure is not None) + (failure is not None) != 1:
                raise ValueError('a union must contain a single member')

            if not_computed is not None:
                self._not_computed = not_computed
                self._type = 'notComputed'
            if computing is not None:
                self._computing = computing
                self._type = 'computing'
            if no_previous_failure is not None:
                self._no_previous_failure = no_previous_failure
                self._type = 'noPreviousFailure'
            if failure is not None:
                self._failure = failure
                self._type = 'failure'

        elif type_of_union == 'notComputed':
            if not_computed is None:
                raise ValueError('a union value must not be None')
            self._not_computed = not_computed
            self._type = 'notComputed'
        elif type_of_union == 'computing':
            if computing is None:
                raise ValueError('a union value must not be None')
            self._computing = computing
            self._type = 'computing'
        elif type_of_union == 'noPreviousFailure':
            if no_previous_failure is None:
                raise ValueError('a union value must not be None')
            self._no_previous_failure = no_previous_failure
            self._type = 'noPreviousFailure'
        elif type_of_union == 'failure':
            if failure is None:
                raise ValueError('a union value must not be None')
            self._failure = failure
            self._type = 'failure'

    @builtins.property
    def not_computed(self) -> Optional["scout_checklistexecution_api_NotComputed"]:
        """
        The last failure time has not been computed, and is not currently being computed.
        """
        return self._not_computed

    @builtins.property
    def computing(self) -> Optional["scout_checklistexecution_api_Computing"]:
        """
        The last failure time is currently being computed. This may require evaluating the history
of data for the check, so could be slow depending on the data frequency and lookback period.
        """
        return self._computing

    @builtins.property
    def no_previous_failure(self) -> Optional["scout_checklistexecution_api_NoPreviousFailure"]:
        """
        No previous failure was found for the check.
        """
        return self._no_previous_failure

    @builtins.property
    def failure(self) -> Optional["scout_checklistexecution_api_Failure"]:
        """
        The most recent failure for the check.
        """
        return self._failure

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checklistexecution_api_LastFailureVisitor):
            raise ValueError('{} is not an instance of scout_checklistexecution_api_LastFailureVisitor'.format(visitor.__class__.__name__))
        if self._type == 'notComputed' and self.not_computed is not None:
            return visitor._not_computed(self.not_computed)
        if self._type == 'computing' and self.computing is not None:
            return visitor._computing(self.computing)
        if self._type == 'noPreviousFailure' and self.no_previous_failure is not None:
            return visitor._no_previous_failure(self.no_previous_failure)
        if self._type == 'failure' and self.failure is not None:
            return visitor._failure(self.failure)


scout_checklistexecution_api_LastFailure.__name__ = "LastFailure"
scout_checklistexecution_api_LastFailure.__qualname__ = "LastFailure"
scout_checklistexecution_api_LastFailure.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_LastFailureVisitor:

    @abstractmethod
    def _not_computed(self, not_computed: "scout_checklistexecution_api_NotComputed") -> Any:
        pass

    @abstractmethod
    def _computing(self, computing: "scout_checklistexecution_api_Computing") -> Any:
        pass

    @abstractmethod
    def _no_previous_failure(self, no_previous_failure: "scout_checklistexecution_api_NoPreviousFailure") -> Any:
        pass

    @abstractmethod
    def _failure(self, failure: "scout_checklistexecution_api_Failure") -> Any:
        pass


scout_checklistexecution_api_LastFailureVisitor.__name__ = "LastFailureVisitor"
scout_checklistexecution_api_LastFailureVisitor.__qualname__ = "LastFailureVisitor"
scout_checklistexecution_api_LastFailureVisitor.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_NoPreviousFailure(ConjureBeanType):
    """
    No previous failure was computed for the check.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_NoPreviousFailure.__name__ = "NoPreviousFailure"
scout_checklistexecution_api_NoPreviousFailure.__qualname__ = "NoPreviousFailure"
scout_checklistexecution_api_NoPreviousFailure.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_NotComputable(ConjureBeanType):
    """
    The result cannot be computed in a streaming context.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_message']

    def __init__(self, message: str) -> None:
        self._message = message

    @builtins.property
    def message(self) -> str:
        """
        Why the result couldn't be computed
        """
        return self._message


scout_checklistexecution_api_NotComputable.__name__ = "NotComputable"
scout_checklistexecution_api_NotComputable.__qualname__ = "NotComputable"
scout_checklistexecution_api_NotComputable.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_NotComputed(ConjureBeanType):
    """
    The result has not been computed, and is not currently being computed.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_NotComputed.__name__ = "NotComputed"
scout_checklistexecution_api_NotComputed.__qualname__ = "NotComputed"
scout_checklistexecution_api_NotComputed.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Pass(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_Pass.__name__ = "Pass"
scout_checklistexecution_api_Pass.__qualname__ = "Pass"
scout_checklistexecution_api_Pass.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist': ConjureFieldDefinition('checklist', scout_rids_api_ChecklistRid),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid])
        }

    __slots__: List[str] = ['_checklist', '_assets']

    def __init__(self, assets: List[str], checklist: str) -> None:
        self._checklist = checklist
        self._assets = assets

    @builtins.property
    def checklist(self) -> str:
        return self._checklist

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets


scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest.__name__ = "StopStreamingChecklistForAssetsRequest"
scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest.__qualname__ = "StopStreamingChecklistForAssetsRequest"
scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checklistexecution_api_StreamingChecklistInfo(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'asset_configurations': ConjureFieldDefinition('assetConfigurations', Dict[scout_rids_api_AssetRid, scout_checklistexecution_api_AssetStreamConfiguration])
        }

    __slots__: List[str] = ['_checklist_rid', '_asset_configurations']

    def __init__(self, asset_configurations: Dict[str, "scout_checklistexecution_api_AssetStreamConfiguration"], checklist_rid: str) -> None:
        self._checklist_rid = checklist_rid
        self._asset_configurations = asset_configurations

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def asset_configurations(self) -> Dict[str, "scout_checklistexecution_api_AssetStreamConfiguration"]:
        return self._asset_configurations


scout_checklistexecution_api_StreamingChecklistInfo.__name__ = "StreamingChecklistInfo"
scout_checklistexecution_api_StreamingChecklistInfo.__qualname__ = "StreamingChecklistInfo"
scout_checklistexecution_api_StreamingChecklistInfo.__module__ = "scout_service_api.scout_checklistexecution_api"


class scout_checks_api_ArchiveChecklistsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_rids_api_ChecklistRid])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


scout_checks_api_ArchiveChecklistsRequest.__name__ = "ArchiveChecklistsRequest"
scout_checks_api_ArchiveChecklistsRequest.__qualname__ = "ArchiveChecklistsRequest"
scout_checks_api_ArchiveChecklistsRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_BatchGetChecklistMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_rids_api_ChecklistRid])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


scout_checks_api_BatchGetChecklistMetadataRequest.__name__ = "BatchGetChecklistMetadataRequest"
scout_checks_api_BatchGetChecklistMetadataRequest.__qualname__ = "BatchGetChecklistMetadataRequest"
scout_checks_api_BatchGetChecklistMetadataRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_BatchGetChecklistMetadataResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'metadata': ConjureFieldDefinition('metadata', Dict[scout_rids_api_ChecklistRid, scout_checks_api_ChecklistMetadata])
        }

    __slots__: List[str] = ['_metadata']

    def __init__(self, metadata: Dict[str, "scout_checks_api_ChecklistMetadata"]) -> None:
        self._metadata = metadata

    @builtins.property
    def metadata(self) -> Dict[str, "scout_checks_api_ChecklistMetadata"]:
        return self._metadata


scout_checks_api_BatchGetChecklistMetadataResponse.__name__ = "BatchGetChecklistMetadataResponse"
scout_checks_api_BatchGetChecklistMetadataResponse.__qualname__ = "BatchGetChecklistMetadataResponse"
scout_checks_api_BatchGetChecklistMetadataResponse.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_BatchGetJobReportsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rids': ConjureFieldDefinition('jobRids', List[scout_checks_api_JobRid])
        }

    __slots__: List[str] = ['_job_rids']

    def __init__(self, job_rids: List[str]) -> None:
        self._job_rids = job_rids

    @builtins.property
    def job_rids(self) -> List[str]:
        return self._job_rids


scout_checks_api_BatchGetJobReportsRequest.__name__ = "BatchGetJobReportsRequest"
scout_checks_api_BatchGetJobReportsRequest.__qualname__ = "BatchGetJobReportsRequest"
scout_checks_api_BatchGetJobReportsRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_BatchGetJobReportsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rids_to_job_reports': ConjureFieldDefinition('jobRidsToJobReports', Dict[scout_checks_api_JobRid, scout_checks_api_JobReport])
        }

    __slots__: List[str] = ['_job_rids_to_job_reports']

    def __init__(self, job_rids_to_job_reports: Dict[str, "scout_checks_api_JobReport"]) -> None:
        self._job_rids_to_job_reports = job_rids_to_job_reports

    @builtins.property
    def job_rids_to_job_reports(self) -> Dict[str, "scout_checks_api_JobReport"]:
        return self._job_rids_to_job_reports


scout_checks_api_BatchGetJobReportsResponse.__name__ = "BatchGetJobReportsResponse"
scout_checks_api_BatchGetJobReportsResponse.__qualname__ = "BatchGetJobReportsResponse"
scout_checks_api_BatchGetJobReportsResponse.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_Check(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_CheckRid),
            'check_lineage_rid': ConjureFieldDefinition('checkLineageRid', scout_rids_api_CheckLineageRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'auto_generated_title': ConjureFieldDefinition('autoGeneratedTitle', OptionalTypeWrapper[str]),
            'auto_generated_description': ConjureFieldDefinition('autoGeneratedDescription', OptionalTypeWrapper[str]),
            'priority': ConjureFieldDefinition('priority', scout_checks_api_Priority),
            'chart': ConjureFieldDefinition('chart', OptionalTypeWrapper[scout_rids_api_VersionedChartRid]),
            'condition': ConjureFieldDefinition('condition', OptionalTypeWrapper[scout_checks_api_CheckCondition])
        }

    __slots__: List[str] = ['_rid', '_check_lineage_rid', '_title', '_description', '_auto_generated_title', '_auto_generated_description', '_priority', '_chart', '_condition']

    def __init__(self, check_lineage_rid: str, description: str, priority: "scout_checks_api_Priority", rid: str, title: str, auto_generated_description: Optional[str] = None, auto_generated_title: Optional[str] = None, chart: Optional["scout_rids_api_VersionedChartRid"] = None, condition: Optional["scout_checks_api_CheckCondition"] = None) -> None:
        self._rid = rid
        self._check_lineage_rid = check_lineage_rid
        self._title = title
        self._description = description
        self._auto_generated_title = auto_generated_title
        self._auto_generated_description = auto_generated_description
        self._priority = priority
        self._chart = chart
        self._condition = condition

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def check_lineage_rid(self) -> str:
        return self._check_lineage_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def auto_generated_title(self) -> Optional[str]:
        return self._auto_generated_title

    @builtins.property
    def auto_generated_description(self) -> Optional[str]:
        return self._auto_generated_description

    @builtins.property
    def priority(self) -> "scout_checks_api_Priority":
        return self._priority

    @builtins.property
    def chart(self) -> Optional["scout_rids_api_VersionedChartRid"]:
        return self._chart

    @builtins.property
    def condition(self) -> Optional["scout_checks_api_CheckCondition"]:
        """
        If omitted, this check represents a manual check.
        """
        return self._condition


scout_checks_api_Check.__name__ = "Check"
scout_checks_api_Check.__qualname__ = "Check"
scout_checks_api_Check.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CheckCondition(ConjureUnionType):
    _num_ranges: Optional["scout_checks_api_NumRangesConditionV1"] = None
    _num_ranges_v2: Optional["scout_checks_api_NumRangesConditionV2"] = None
    _num_ranges_v3: Optional["scout_checks_api_NumRangesConditionV3"] = None
    _parameterized_num_ranges_v1: Optional["scout_checks_api_ParameterizedNumRangesConditionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'num_ranges': ConjureFieldDefinition('numRanges', scout_checks_api_NumRangesConditionV1),
            'num_ranges_v2': ConjureFieldDefinition('numRangesV2', scout_checks_api_NumRangesConditionV2),
            'num_ranges_v3': ConjureFieldDefinition('numRangesV3', scout_checks_api_NumRangesConditionV3),
            'parameterized_num_ranges_v1': ConjureFieldDefinition('parameterizedNumRangesV1', scout_checks_api_ParameterizedNumRangesConditionV1)
        }

    def __init__(
            self,
            num_ranges: Optional["scout_checks_api_NumRangesConditionV1"] = None,
            num_ranges_v2: Optional["scout_checks_api_NumRangesConditionV2"] = None,
            num_ranges_v3: Optional["scout_checks_api_NumRangesConditionV3"] = None,
            parameterized_num_ranges_v1: Optional["scout_checks_api_ParameterizedNumRangesConditionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (num_ranges is not None) + (num_ranges_v2 is not None) + (num_ranges_v3 is not None) + (parameterized_num_ranges_v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if num_ranges is not None:
                self._num_ranges = num_ranges
                self._type = 'numRanges'
            if num_ranges_v2 is not None:
                self._num_ranges_v2 = num_ranges_v2
                self._type = 'numRangesV2'
            if num_ranges_v3 is not None:
                self._num_ranges_v3 = num_ranges_v3
                self._type = 'numRangesV3'
            if parameterized_num_ranges_v1 is not None:
                self._parameterized_num_ranges_v1 = parameterized_num_ranges_v1
                self._type = 'parameterizedNumRangesV1'

        elif type_of_union == 'numRanges':
            if num_ranges is None:
                raise ValueError('a union value must not be None')
            self._num_ranges = num_ranges
            self._type = 'numRanges'
        elif type_of_union == 'numRangesV2':
            if num_ranges_v2 is None:
                raise ValueError('a union value must not be None')
            self._num_ranges_v2 = num_ranges_v2
            self._type = 'numRangesV2'
        elif type_of_union == 'numRangesV3':
            if num_ranges_v3 is None:
                raise ValueError('a union value must not be None')
            self._num_ranges_v3 = num_ranges_v3
            self._type = 'numRangesV3'
        elif type_of_union == 'parameterizedNumRangesV1':
            if parameterized_num_ranges_v1 is None:
                raise ValueError('a union value must not be None')
            self._parameterized_num_ranges_v1 = parameterized_num_ranges_v1
            self._type = 'parameterizedNumRangesV1'

    @builtins.property
    def num_ranges(self) -> Optional["scout_checks_api_NumRangesConditionV1"]:
        return self._num_ranges

    @builtins.property
    def num_ranges_v2(self) -> Optional["scout_checks_api_NumRangesConditionV2"]:
        return self._num_ranges_v2

    @builtins.property
    def num_ranges_v3(self) -> Optional["scout_checks_api_NumRangesConditionV3"]:
        return self._num_ranges_v3

    @builtins.property
    def parameterized_num_ranges_v1(self) -> Optional["scout_checks_api_ParameterizedNumRangesConditionV1"]:
        return self._parameterized_num_ranges_v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_CheckConditionVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_CheckConditionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numRanges' and self.num_ranges is not None:
            return visitor._num_ranges(self.num_ranges)
        if self._type == 'numRangesV2' and self.num_ranges_v2 is not None:
            return visitor._num_ranges_v2(self.num_ranges_v2)
        if self._type == 'numRangesV3' and self.num_ranges_v3 is not None:
            return visitor._num_ranges_v3(self.num_ranges_v3)
        if self._type == 'parameterizedNumRangesV1' and self.parameterized_num_ranges_v1 is not None:
            return visitor._parameterized_num_ranges_v1(self.parameterized_num_ranges_v1)


scout_checks_api_CheckCondition.__name__ = "CheckCondition"
scout_checks_api_CheckCondition.__qualname__ = "CheckCondition"
scout_checks_api_CheckCondition.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CheckConditionVisitor:

    @abstractmethod
    def _num_ranges(self, num_ranges: "scout_checks_api_NumRangesConditionV1") -> Any:
        pass

    @abstractmethod
    def _num_ranges_v2(self, num_ranges_v2: "scout_checks_api_NumRangesConditionV2") -> Any:
        pass

    @abstractmethod
    def _num_ranges_v3(self, num_ranges_v3: "scout_checks_api_NumRangesConditionV3") -> Any:
        pass

    @abstractmethod
    def _parameterized_num_ranges_v1(self, parameterized_num_ranges_v1: "scout_checks_api_ParameterizedNumRangesConditionV1") -> Any:
        pass


scout_checks_api_CheckConditionVisitor.__name__ = "CheckConditionVisitor"
scout_checks_api_CheckConditionVisitor.__qualname__ = "CheckConditionVisitor"
scout_checks_api_CheckConditionVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CheckContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_VariableLocator]),
            'sub_function_variables': ConjureFieldDefinition('subFunctionVariables', Dict[scout_compute_api_FunctionReference, scout_checks_api_CheckContext])
        }

    __slots__: List[str] = ['_variables', '_sub_function_variables']

    def __init__(self, sub_function_variables: Dict[str, "scout_checks_api_CheckContext"], variables: Dict[str, "scout_checks_api_VariableLocator"]) -> None:
        self._variables = variables
        self._sub_function_variables = sub_function_variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_VariableLocator"]:
        return self._variables

    @builtins.property
    def sub_function_variables(self) -> Dict[str, "scout_checks_api_CheckContext"]:
        return self._sub_function_variables


scout_checks_api_CheckContext.__name__ = "CheckContext"
scout_checks_api_CheckContext.__qualname__ = "CheckContext"
scout_checks_api_CheckContext.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CheckJobResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'status': ConjureFieldDefinition('status', scout_datareview_api_Status),
            'failures': ConjureFieldDefinition('failures', List[scout_compute_api_Range]),
            'are_failures_decimated': ConjureFieldDefinition('areFailuresDecimated', bool)
        }

    __slots__: List[str] = ['_status', '_failures', '_are_failures_decimated']

    def __init__(self, are_failures_decimated: bool, failures: List["scout_compute_api_Range"], status: "scout_datareview_api_Status") -> None:
        self._status = status
        self._failures = failures
        self._are_failures_decimated = are_failures_decimated

    @builtins.property
    def status(self) -> "scout_datareview_api_Status":
        return self._status

    @builtins.property
    def failures(self) -> List["scout_compute_api_Range"]:
        return self._failures

    @builtins.property
    def are_failures_decimated(self) -> bool:
        return self._are_failures_decimated


scout_checks_api_CheckJobResult.__name__ = "CheckJobResult"
scout_checks_api_CheckJobResult.__qualname__ = "CheckJobResult"
scout_checks_api_CheckJobResult.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CheckJobSpec(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_datareview_api_DataReviewRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[scout_run_api_RunRid]),
            'check_implementation_index': ConjureFieldDefinition('checkImplementationIndex', OptionalTypeWrapper[int]),
            'check_evaluation_rid': ConjureFieldDefinition('checkEvaluationRid', scout_datareview_api_AutomaticCheckEvaluationRid),
            'check_condition': ConjureFieldDefinition('checkCondition', scout_checks_api_CheckCondition),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_data_review_rid', '_check_rid', '_run_rid', '_check_implementation_index', '_check_evaluation_rid', '_check_condition', '_start', '_end', '_context']

    def __init__(self, check_condition: "scout_checks_api_CheckCondition", check_evaluation_rid: str, check_rid: str, context: "scout_compute_api_Context", data_review_rid: str, end: "api_Timestamp", start: "api_Timestamp", check_implementation_index: Optional[int] = None, run_rid: Optional[str] = None) -> None:
        self._data_review_rid = data_review_rid
        self._check_rid = check_rid
        self._run_rid = run_rid
        self._check_implementation_index = check_implementation_index
        self._check_evaluation_rid = check_evaluation_rid
        self._check_condition = check_condition
        self._start = start
        self._end = end
        self._context = context

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def run_rid(self) -> Optional[str]:
        return self._run_rid

    @builtins.property
    def check_implementation_index(self) -> Optional[int]:
        """
        Checks can define a single range computation which can evaluate over multiple implementations of a context.
The check implementation index will correspond to the implementation index of the check condition.
        """
        return self._check_implementation_index

    @builtins.property
    def check_evaluation_rid(self) -> str:
        return self._check_evaluation_rid

    @builtins.property
    def check_condition(self) -> "scout_checks_api_CheckCondition":
        return self._check_condition

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_checks_api_CheckJobSpec.__name__ = "CheckJobSpec"
scout_checks_api_CheckJobSpec.__qualname__ = "CheckJobSpec"
scout_checks_api_CheckJobSpec.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ChecklistEntry(ConjureUnionType):
    _check: Optional["scout_checks_api_Check"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check': ConjureFieldDefinition('check', scout_checks_api_Check)
        }

    def __init__(
            self,
            check: Optional["scout_checks_api_Check"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (check is not None) != 1:
                raise ValueError('a union must contain a single member')

            if check is not None:
                self._check = check
                self._type = 'check'

        elif type_of_union == 'check':
            if check is None:
                raise ValueError('a union value must not be None')
            self._check = check
            self._type = 'check'

    @builtins.property
    def check(self) -> Optional["scout_checks_api_Check"]:
        return self._check

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_ChecklistEntryVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_ChecklistEntryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'check' and self.check is not None:
            return visitor._check(self.check)


scout_checks_api_ChecklistEntry.__name__ = "ChecklistEntry"
scout_checks_api_ChecklistEntry.__qualname__ = "ChecklistEntry"
scout_checks_api_ChecklistEntry.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ChecklistEntryVisitor:

    @abstractmethod
    def _check(self, check: "scout_checks_api_Check") -> Any:
        pass


scout_checks_api_ChecklistEntryVisitor.__name__ = "ChecklistEntryVisitor"
scout_checks_api_ChecklistEntryVisitor.__qualname__ = "ChecklistEntryVisitor"
scout_checks_api_ChecklistEntryVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ChecklistMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'author_rid': ConjureFieldDefinition('authorRid', scout_rids_api_UserRid),
            'assignee_rid': ConjureFieldDefinition('assigneeRid', scout_rids_api_UserRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label]),
            'last_used': ConjureFieldDefinition('lastUsed', OptionalTypeWrapper[str]),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'is_published': ConjureFieldDefinition('isPublished', bool)
        }

    __slots__: List[str] = ['_author_rid', '_assignee_rid', '_title', '_description', '_created_at', '_properties', '_labels', '_last_used', '_is_archived', '_is_published']

    def __init__(self, assignee_rid: str, author_rid: str, created_at: str, description: str, is_archived: bool, is_published: bool, labels: List[str], properties: Dict[str, str], title: str, last_used: Optional[str] = None) -> None:
        self._author_rid = author_rid
        self._assignee_rid = assignee_rid
        self._title = title
        self._description = description
        self._created_at = created_at
        self._properties = properties
        self._labels = labels
        self._last_used = last_used
        self._is_archived = is_archived
        self._is_published = is_published

    @builtins.property
    def author_rid(self) -> str:
        return self._author_rid

    @builtins.property
    def assignee_rid(self) -> str:
        return self._assignee_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def last_used(self) -> Optional[str]:
        return self._last_used

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived

    @builtins.property
    def is_published(self) -> bool:
        return self._is_published


scout_checks_api_ChecklistMetadata.__name__ = "ChecklistMetadata"
scout_checks_api_ChecklistMetadata.__qualname__ = "ChecklistMetadata"
scout_checks_api_ChecklistMetadata.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ChecklistRef(ConjureBeanType):
    """
    A reference to a checklist that may be pinned to a specific commit.
If commit is empty, this refers to "the latest commit on main".
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_ChecklistRid),
            'commit': ConjureFieldDefinition('commit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_rid', '_commit']

    def __init__(self, rid: str, commit: Optional[str] = None) -> None:
        self._rid = rid
        self._commit = commit

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def commit(self) -> Optional[str]:
        return self._commit


scout_checks_api_ChecklistRef.__name__ = "ChecklistRef"
scout_checks_api_ChecklistRef.__qualname__ = "ChecklistRef"
scout_checks_api_ChecklistRef.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ChecklistSearchQuery(ConjureUnionType):
    _and_: Optional[List["scout_checks_api_ChecklistSearchQuery"]] = None
    _or_: Optional[List["scout_checks_api_ChecklistSearchQuery"]] = None
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["scout_run_api_Property"] = None
    _author_rid: Optional[str] = None
    _assignee_rid: Optional[str] = None
    _is_published: Optional[bool] = None
    _not_: Optional["scout_checks_api_ChecklistSearchQuery"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', List[scout_checks_api_ChecklistSearchQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_checks_api_ChecklistSearchQuery]),
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', scout_run_api_Label),
            'property': ConjureFieldDefinition('property', scout_run_api_Property),
            'author_rid': ConjureFieldDefinition('authorRid', scout_rids_api_UserRid),
            'assignee_rid': ConjureFieldDefinition('assigneeRid', scout_rids_api_UserRid),
            'is_published': ConjureFieldDefinition('isPublished', bool),
            'not_': ConjureFieldDefinition('not', scout_checks_api_ChecklistSearchQuery)
        }

    def __init__(
            self,
            and_: Optional[List["scout_checks_api_ChecklistSearchQuery"]] = None,
            or_: Optional[List["scout_checks_api_ChecklistSearchQuery"]] = None,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["scout_run_api_Property"] = None,
            author_rid: Optional[str] = None,
            assignee_rid: Optional[str] = None,
            is_published: Optional[bool] = None,
            not_: Optional["scout_checks_api_ChecklistSearchQuery"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (search_text is not None) + (label is not None) + (property is not None) + (author_rid is not None) + (assignee_rid is not None) + (is_published is not None) + (not_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if author_rid is not None:
                self._author_rid = author_rid
                self._type = 'authorRid'
            if assignee_rid is not None:
                self._assignee_rid = assignee_rid
                self._type = 'assigneeRid'
            if is_published is not None:
                self._is_published = is_published
                self._type = 'isPublished'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'authorRid':
            if author_rid is None:
                raise ValueError('a union value must not be None')
            self._author_rid = author_rid
            self._type = 'authorRid'
        elif type_of_union == 'assigneeRid':
            if assignee_rid is None:
                raise ValueError('a union value must not be None')
            self._assignee_rid = assignee_rid
            self._type = 'assigneeRid'
        elif type_of_union == 'isPublished':
            if is_published is None:
                raise ValueError('a union value must not be None')
            self._is_published = is_published
            self._type = 'isPublished'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'

    @builtins.property
    def and_(self) -> Optional[List["scout_checks_api_ChecklistSearchQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_checks_api_ChecklistSearchQuery"]]:
        return self._or_

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["scout_run_api_Property"]:
        return self._property

    @builtins.property
    def author_rid(self) -> Optional[str]:
        return self._author_rid

    @builtins.property
    def assignee_rid(self) -> Optional[str]:
        return self._assignee_rid

    @builtins.property
    def is_published(self) -> Optional[bool]:
        return self._is_published

    @builtins.property
    def not_(self) -> Optional["scout_checks_api_ChecklistSearchQuery"]:
        return self._not_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_ChecklistSearchQueryVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_ChecklistSearchQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'authorRid' and self.author_rid is not None:
            return visitor._author_rid(self.author_rid)
        if self._type == 'assigneeRid' and self.assignee_rid is not None:
            return visitor._assignee_rid(self.assignee_rid)
        if self._type == 'isPublished' and self.is_published is not None:
            return visitor._is_published(self.is_published)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)


scout_checks_api_ChecklistSearchQuery.__name__ = "ChecklistSearchQuery"
scout_checks_api_ChecklistSearchQuery.__qualname__ = "ChecklistSearchQuery"
scout_checks_api_ChecklistSearchQuery.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ChecklistSearchQueryVisitor:

    @abstractmethod
    def _and(self, and_: List["scout_checks_api_ChecklistSearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_checks_api_ChecklistSearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_run_api_Property") -> Any:
        pass

    @abstractmethod
    def _author_rid(self, author_rid: str) -> Any:
        pass

    @abstractmethod
    def _assignee_rid(self, assignee_rid: str) -> Any:
        pass

    @abstractmethod
    def _is_published(self, is_published: bool) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_checks_api_ChecklistSearchQuery") -> Any:
        pass


scout_checks_api_ChecklistSearchQueryVisitor.__name__ = "ChecklistSearchQueryVisitor"
scout_checks_api_ChecklistSearchQueryVisitor.__qualname__ = "ChecklistSearchQueryVisitor"
scout_checks_api_ChecklistSearchQueryVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ChecklistService(Service):
    """
    The Checklist Service is responsible for managing checklists and checks.
A checklist is a collection of checks and functions that can be executed against a set of data sources.
    """

    def create(self, auth_header: str, request: "scout_checks_api_CreateChecklistRequest") -> "scout_checks_api_VersionedChecklist":
        """
        Creates a new checklist with the provided checks and functions.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/checklists'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def commit(self, auth_header: str, checklist_rid: str, request: "scout_checks_api_CommitChecklistRequest", branch: Optional[str] = None) -> "scout_checks_api_VersionedChecklist":
        """
        Creates a permanent commit with a commit message. 
Throws if the checklist or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you commit to an archived checklist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': branch,
        }

        _path_params: Dict[str, Any] = {
            'checklistRid': checklist_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/checklists/{checklistRid}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def save_working_state(self, auth_header: str, checklist_rid: str, request: "scout_checks_api_SaveChecklistRequest", branch: Optional[str] = None) -> "scout_checks_api_VersionedChecklist":
        """
        Creates a commit that may be compacted, e.g cleaned up and not exist anymore.
Throws if the checklist or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you save to an archived checklist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': branch,
        }

        _path_params: Dict[str, Any] = {
            'checklistRid': checklist_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/checklists/{checklistRid}/save-working-state'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def merge_to_main(self, auth_header: str, checklist_rid: str, request: "scout_checks_api_MergeToMainRequest") -> "scout_checks_api_VersionedChecklist":
        """
        Merges the given branch to the "main" branch.
Throws if the checklist or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you merge with an archived checklist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'checklistRid': checklist_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/checklists/{checklistRid}/merge-to-main'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def update_data_source_ref_names(self, auth_header: str, checklist_rid: str, ref_name_updates: Dict[str, str], branch: Optional[str] = None) -> "scout_checks_api_VersionedChecklist":
        """
        Updates the data source ref names for all checks within a checklist.
Throws if the checklist doesn't exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': branch,
        }

        _path_params: Dict[str, Any] = {
            'checklistRid': checklist_rid,
        }

        _json: Any = ConjureEncoder().default(ref_name_updates)

        _path = '/scout/v1/checklists/{checklistRid}/update-ref-names'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "scout_checks_api_UpdateChecklistMetadataRequest", rid: str) -> "scout_checks_api_ChecklistMetadata":
        """
        Updates the metadata of a checklist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/checklists/{rid}/update-metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_ChecklistMetadata, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, rid: str, branch: Optional[str] = None, commit: Optional[str] = None) -> "scout_checks_api_VersionedChecklist":
        """
        Specify at most one of (branch, commit).
If neither is specified, branch = "main" is the default.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': branch,
            'commit': commit,
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v1/checklists/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, checklist_refs: List["scout_checks_api_PinnedChecklistRef"] = None) -> List["scout_checks_api_VersionedChecklist"]:
        """
        Returns the pinned commit for each provided checklist reference.
        """
        checklist_refs = checklist_refs if checklist_refs is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(checklist_refs)

        _path = '/scout/v1/checklists/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_checks_api_VersionedChecklist], self._return_none_for_unknown_union_types)

    def batch_get_metadata(self, auth_header: str, request: "scout_checks_api_BatchGetChecklistMetadataRequest") -> "scout_checks_api_BatchGetChecklistMetadataResponse":
        """
        Returns the metadata for each provided checklist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/checklists/batch-get-metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_BatchGetChecklistMetadataResponse, self._return_none_for_unknown_union_types)

    def search(self, auth_header: str, request: "scout_checks_api_SearchChecklistsRequest") -> "scout_checks_api_VersionedChecklistPage":
        """
        Results will be the latest commit on main for each checklist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/checklists/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklistPage, self._return_none_for_unknown_union_types)

    def archive(self, auth_header: str, request: "scout_checks_api_ArchiveChecklistsRequest") -> None:
        """
        Archives the provided checklists.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/checklists/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, request: "scout_checks_api_UnarchiveChecklistsRequest") -> None:
        """
        Unarchives the provided checklists.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/checklists/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_check(self, auth_header: str, rid: str) -> "scout_checks_api_Check":
        """
        Returns the check with the given rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v1/checklists/check/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_Check, self._return_none_for_unknown_union_types)

    def batch_get_checks(self, auth_header: str, rids: List[str] = None) -> List["scout_checks_api_Check"]:
        """
        Returns the checks with the given rids.
        """
        rids = rids if rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(rids)

        _path = '/scout/v1/checklists/check/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_checks_api_Check], self._return_none_for_unknown_union_types)

    def get_all_labels_and_properties(self, auth_header: str) -> "scout_checks_api_GetAllLabelsAndPropertiesResponse":
        """
        Returns all labels and properties.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/scout/v1/checklists/get-all-labels-properties'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_GetAllLabelsAndPropertiesResponse, self._return_none_for_unknown_union_types)


scout_checks_api_ChecklistService.__name__ = "ChecklistService"
scout_checks_api_ChecklistService.__qualname__ = "ChecklistService"
scout_checks_api_ChecklistService.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ChecklistVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_VariableName),
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'value': ConjureFieldDefinition('value', scout_checks_api_VariableLocator)
        }

    __slots__: List[str] = ['_name', '_display_name', '_value']

    def __init__(self, name: str, value: "scout_checks_api_VariableLocator", display_name: Optional[str] = None) -> None:
        self._name = name
        self._display_name = display_name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def value(self) -> "scout_checks_api_VariableLocator":
        return self._value


scout_checks_api_ChecklistVariable.__name__ = "ChecklistVariable"
scout_checks_api_ChecklistVariable.__qualname__ = "ChecklistVariable"
scout_checks_api_ChecklistVariable.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CommitChecklistRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'commit_message': ConjureFieldDefinition('commitMessage', str),
            'checks': ConjureFieldDefinition('checks', List[scout_checks_api_UpdateChecklistEntryRequest]),
            'functions': ConjureFieldDefinition('functions', Dict[scout_compute_api_FunctionReference, scout_checks_api_UpdateFunctionEntryRequest]),
            'checklist_variables': ConjureFieldDefinition('checklistVariables', List[scout_checks_api_UnresolvedChecklistVariable]),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_commit_message', '_checks', '_functions', '_checklist_variables', '_latest_commit']

    def __init__(self, checklist_variables: List["scout_checks_api_UnresolvedChecklistVariable"], checks: List["scout_checks_api_UpdateChecklistEntryRequest"], commit_message: str, functions: Dict[str, "scout_checks_api_UpdateFunctionEntryRequest"], latest_commit: Optional[str] = None) -> None:
        self._commit_message = commit_message
        self._checks = checks
        self._functions = functions
        self._checklist_variables = checklist_variables
        self._latest_commit = latest_commit

    @builtins.property
    def commit_message(self) -> str:
        return self._commit_message

    @builtins.property
    def checks(self) -> List["scout_checks_api_UpdateChecklistEntryRequest"]:
        return self._checks

    @builtins.property
    def functions(self) -> Dict[str, "scout_checks_api_UpdateFunctionEntryRequest"]:
        """
        The keys of the map are references that can be used for checks to reference functions in the same request, before the function RIDs have been created.
        """
        return self._functions

    @builtins.property
    def checklist_variables(self) -> List["scout_checks_api_UnresolvedChecklistVariable"]:
        """
        Variables that can be used in checks and functions. Variables are resolved in order of declaration.
If variable `a` depends on variable `b`, then `b` must be defined before `a` in the list.
        """
        return self._checklist_variables

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        """
        If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit


scout_checks_api_CommitChecklistRequest.__name__ = "CommitChecklistRequest"
scout_checks_api_CommitChecklistRequest.__qualname__ = "CommitChecklistRequest"
scout_checks_api_CommitChecklistRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_Completed(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'result': ConjureFieldDefinition('result', scout_checks_api_JobResult),
            'execution_start_time': ConjureFieldDefinition('executionStartTime', str),
            'execution_end_time': ConjureFieldDefinition('executionEndTime', str)
        }

    __slots__: List[str] = ['_result', '_execution_start_time', '_execution_end_time']

    def __init__(self, execution_end_time: str, execution_start_time: str, result: "scout_checks_api_JobResult") -> None:
        self._result = result
        self._execution_start_time = execution_start_time
        self._execution_end_time = execution_end_time

    @builtins.property
    def result(self) -> "scout_checks_api_JobResult":
        return self._result

    @builtins.property
    def execution_start_time(self) -> str:
        return self._execution_start_time

    @builtins.property
    def execution_end_time(self) -> str:
        return self._execution_end_time


scout_checks_api_Completed.__name__ = "Completed"
scout_checks_api_Completed.__qualname__ = "Completed"
scout_checks_api_Completed.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ComputeNodeWithContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_node': ConjureFieldDefinition('seriesNode', scout_compute_api_ComputeNode),
            'context': ConjureFieldDefinition('context', scout_checks_api_CheckContext)
        }

    __slots__: List[str] = ['_series_node', '_context']

    def __init__(self, context: "scout_checks_api_CheckContext", series_node: "scout_compute_api_ComputeNode") -> None:
        self._series_node = series_node
        self._context = context

    @builtins.property
    def series_node(self) -> "scout_compute_api_ComputeNode":
        return self._series_node

    @builtins.property
    def context(self) -> "scout_checks_api_CheckContext":
        return self._context


scout_checks_api_ComputeNodeWithContext.__name__ = "ComputeNodeWithContext"
scout_checks_api_ComputeNodeWithContext.__qualname__ = "ComputeNodeWithContext"
scout_checks_api_ComputeNodeWithContext.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CreateCheckRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_lineage_rid': ConjureFieldDefinition('checkLineageRid', OptionalTypeWrapper[str]),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'auto_generated_title': ConjureFieldDefinition('autoGeneratedTitle', OptionalTypeWrapper[str]),
            'auto_generated_description': ConjureFieldDefinition('autoGeneratedDescription', OptionalTypeWrapper[str]),
            'priority': ConjureFieldDefinition('priority', scout_checks_api_Priority),
            'chart': ConjureFieldDefinition('chart', OptionalTypeWrapper[scout_rids_api_VersionedChartRid]),
            'condition': ConjureFieldDefinition('condition', OptionalTypeWrapper[scout_checks_api_UnresolvedCheckCondition])
        }

    __slots__: List[str] = ['_check_lineage_rid', '_title', '_description', '_auto_generated_title', '_auto_generated_description', '_priority', '_chart', '_condition']

    def __init__(self, description: str, priority: "scout_checks_api_Priority", title: str, auto_generated_description: Optional[str] = None, auto_generated_title: Optional[str] = None, chart: Optional["scout_rids_api_VersionedChartRid"] = None, check_lineage_rid: Optional[str] = None, condition: Optional["scout_checks_api_UnresolvedCheckCondition"] = None) -> None:
        self._check_lineage_rid = check_lineage_rid
        self._title = title
        self._description = description
        self._auto_generated_title = auto_generated_title
        self._auto_generated_description = auto_generated_description
        self._priority = priority
        self._chart = chart
        self._condition = condition

    @builtins.property
    def check_lineage_rid(self) -> Optional[str]:
        """
        Identifies the lineage of checks this check belongs to. If not specified, a new lineage will be created.
This is named checkLineageRid for historical reasons but is actually a UUID.
        """
        return self._check_lineage_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def auto_generated_title(self) -> Optional[str]:
        return self._auto_generated_title

    @builtins.property
    def auto_generated_description(self) -> Optional[str]:
        return self._auto_generated_description

    @builtins.property
    def priority(self) -> "scout_checks_api_Priority":
        return self._priority

    @builtins.property
    def chart(self) -> Optional["scout_rids_api_VersionedChartRid"]:
        return self._chart

    @builtins.property
    def condition(self) -> Optional["scout_checks_api_UnresolvedCheckCondition"]:
        """
        If omitted, this check represents a manual check.
        """
        return self._condition


scout_checks_api_CreateCheckRequest.__name__ = "CreateCheckRequest"
scout_checks_api_CreateCheckRequest.__qualname__ = "CreateCheckRequest"
scout_checks_api_CreateCheckRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CreateChecklistEntryRequest(ConjureUnionType):
    _create_check: Optional["scout_checks_api_CreateCheckRequest"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'create_check': ConjureFieldDefinition('createCheck', scout_checks_api_CreateCheckRequest)
        }

    def __init__(
            self,
            create_check: Optional["scout_checks_api_CreateCheckRequest"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (create_check is not None) != 1:
                raise ValueError('a union must contain a single member')

            if create_check is not None:
                self._create_check = create_check
                self._type = 'createCheck'

        elif type_of_union == 'createCheck':
            if create_check is None:
                raise ValueError('a union value must not be None')
            self._create_check = create_check
            self._type = 'createCheck'

    @builtins.property
    def create_check(self) -> Optional["scout_checks_api_CreateCheckRequest"]:
        return self._create_check

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_CreateChecklistEntryRequestVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_CreateChecklistEntryRequestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'createCheck' and self.create_check is not None:
            return visitor._create_check(self.create_check)


scout_checks_api_CreateChecklistEntryRequest.__name__ = "CreateChecklistEntryRequest"
scout_checks_api_CreateChecklistEntryRequest.__qualname__ = "CreateChecklistEntryRequest"
scout_checks_api_CreateChecklistEntryRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CreateChecklistEntryRequestVisitor:

    @abstractmethod
    def _create_check(self, create_check: "scout_checks_api_CreateCheckRequest") -> Any:
        pass


scout_checks_api_CreateChecklistEntryRequestVisitor.__name__ = "CreateChecklistEntryRequestVisitor"
scout_checks_api_CreateChecklistEntryRequestVisitor.__qualname__ = "CreateChecklistEntryRequestVisitor"
scout_checks_api_CreateChecklistEntryRequestVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CreateChecklistRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'commit_message': ConjureFieldDefinition('commitMessage', str),
            'assignee_rid': ConjureFieldDefinition('assigneeRid', scout_rids_api_UserRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'functions': ConjureFieldDefinition('functions', Dict[scout_compute_api_FunctionReference, scout_checks_api_CreateFunctionRequest]),
            'checks': ConjureFieldDefinition('checks', List[scout_checks_api_CreateChecklistEntryRequest]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label]),
            'checklist_variables': ConjureFieldDefinition('checklistVariables', List[scout_checks_api_UnresolvedChecklistVariable]),
            'is_published': ConjureFieldDefinition('isPublished', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_commit_message', '_assignee_rid', '_title', '_description', '_functions', '_checks', '_properties', '_labels', '_checklist_variables', '_is_published']

    def __init__(self, assignee_rid: str, checklist_variables: List["scout_checks_api_UnresolvedChecklistVariable"], checks: List["scout_checks_api_CreateChecklistEntryRequest"], commit_message: str, description: str, functions: Dict[str, "scout_checks_api_CreateFunctionRequest"], labels: List[str], properties: Dict[str, str], title: str, is_published: Optional[bool] = None) -> None:
        self._commit_message = commit_message
        self._assignee_rid = assignee_rid
        self._title = title
        self._description = description
        self._functions = functions
        self._checks = checks
        self._properties = properties
        self._labels = labels
        self._checklist_variables = checklist_variables
        self._is_published = is_published

    @builtins.property
    def commit_message(self) -> str:
        return self._commit_message

    @builtins.property
    def assignee_rid(self) -> str:
        return self._assignee_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def functions(self) -> Dict[str, "scout_checks_api_CreateFunctionRequest"]:
        """
        The keys of the map are references that can be used for checks to reference functions in the same request, before the function RIDs have been created.
        """
        return self._functions

    @builtins.property
    def checks(self) -> List["scout_checks_api_CreateChecklistEntryRequest"]:
        return self._checks

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def checklist_variables(self) -> List["scout_checks_api_UnresolvedChecklistVariable"]:
        """
        Variables that can be used in checks and functions. Variables are resolved in order of declaration.
If variable `a` depends on variable `b`, then `b` must be defined before `a` in the list.
        """
        return self._checklist_variables

    @builtins.property
    def is_published(self) -> Optional[bool]:
        """
        Default value is true.
        """
        return self._is_published


scout_checks_api_CreateChecklistRequest.__name__ = "CreateChecklistRequest"
scout_checks_api_CreateChecklistRequest.__qualname__ = "CreateChecklistRequest"
scout_checks_api_CreateChecklistRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_CreateFunctionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'function_lineage_rid': ConjureFieldDefinition('functionLineageRid', OptionalTypeWrapper[scout_rids_api_FunctionLineageRid]),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'auto_generated_title': ConjureFieldDefinition('autoGeneratedTitle', OptionalTypeWrapper[str]),
            'auto_generated_description': ConjureFieldDefinition('autoGeneratedDescription', OptionalTypeWrapper[str]),
            'node': ConjureFieldDefinition('node', scout_checks_api_FunctionNode)
        }

    __slots__: List[str] = ['_function_lineage_rid', '_title', '_description', '_auto_generated_title', '_auto_generated_description', '_node']

    def __init__(self, description: str, node: "scout_checks_api_FunctionNode", title: str, auto_generated_description: Optional[str] = None, auto_generated_title: Optional[str] = None, function_lineage_rid: Optional[str] = None) -> None:
        self._function_lineage_rid = function_lineage_rid
        self._title = title
        self._description = description
        self._auto_generated_title = auto_generated_title
        self._auto_generated_description = auto_generated_description
        self._node = node

    @builtins.property
    def function_lineage_rid(self) -> Optional[str]:
        """
        Identifies the lineage of functions this function belongs to. If not specified, a new lineage will be created.
        """
        return self._function_lineage_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def auto_generated_title(self) -> Optional[str]:
        return self._auto_generated_title

    @builtins.property
    def auto_generated_description(self) -> Optional[str]:
        return self._auto_generated_description

    @builtins.property
    def node(self) -> "scout_checks_api_FunctionNode":
        return self._node


scout_checks_api_CreateFunctionRequest.__name__ = "CreateFunctionRequest"
scout_checks_api_CreateFunctionRequest.__qualname__ = "CreateFunctionRequest"
scout_checks_api_CreateFunctionRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_DeprecatedCheckJobSpec(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_datareview_api_DataReviewRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'check_evaluation_rid': ConjureFieldDefinition('checkEvaluationRid', scout_datareview_api_AutomaticCheckEvaluationRid),
            'check_condition': ConjureFieldDefinition('checkCondition', scout_checks_api_CheckCondition),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'context': ConjureFieldDefinition('context', scout_compute_api_deprecated_Context)
        }

    __slots__: List[str] = ['_data_review_rid', '_check_rid', '_check_evaluation_rid', '_check_condition', '_start', '_end', '_context']

    def __init__(self, check_condition: "scout_checks_api_CheckCondition", check_evaluation_rid: str, check_rid: str, context: "scout_compute_api_deprecated_Context", data_review_rid: str, end: "api_Timestamp", start: "api_Timestamp") -> None:
        self._data_review_rid = data_review_rid
        self._check_rid = check_rid
        self._check_evaluation_rid = check_evaluation_rid
        self._check_condition = check_condition
        self._start = start
        self._end = end
        self._context = context

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def check_evaluation_rid(self) -> str:
        return self._check_evaluation_rid

    @builtins.property
    def check_condition(self) -> "scout_checks_api_CheckCondition":
        return self._check_condition

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def context(self) -> "scout_compute_api_deprecated_Context":
        return self._context


scout_checks_api_DeprecatedCheckJobSpec.__name__ = "DeprecatedCheckJobSpec"
scout_checks_api_DeprecatedCheckJobSpec.__qualname__ = "DeprecatedCheckJobSpec"
scout_checks_api_DeprecatedCheckJobSpec.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_Failed(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'failure_message': ConjureFieldDefinition('failureMessage', OptionalTypeWrapper[str]),
            'execution_start_time': ConjureFieldDefinition('executionStartTime', OptionalTypeWrapper[str]),
            'execution_end_time': ConjureFieldDefinition('executionEndTime', str)
        }

    __slots__: List[str] = ['_failure_message', '_execution_start_time', '_execution_end_time']

    def __init__(self, execution_end_time: str, execution_start_time: Optional[str] = None, failure_message: Optional[str] = None) -> None:
        self._failure_message = failure_message
        self._execution_start_time = execution_start_time
        self._execution_end_time = execution_end_time

    @builtins.property
    def failure_message(self) -> Optional[str]:
        return self._failure_message

    @builtins.property
    def execution_start_time(self) -> Optional[str]:
        return self._execution_start_time

    @builtins.property
    def execution_end_time(self) -> str:
        return self._execution_end_time


scout_checks_api_Failed.__name__ = "Failed"
scout_checks_api_Failed.__qualname__ = "Failed"
scout_checks_api_Failed.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_Function(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_FunctionRid),
            'function_lineage_rid': ConjureFieldDefinition('functionLineageRid', scout_rids_api_FunctionLineageRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'auto_generated_title': ConjureFieldDefinition('autoGeneratedTitle', OptionalTypeWrapper[str]),
            'auto_generated_description': ConjureFieldDefinition('autoGeneratedDescription', OptionalTypeWrapper[str]),
            'function_node': ConjureFieldDefinition('functionNode', scout_checks_api_FunctionNode)
        }

    __slots__: List[str] = ['_rid', '_function_lineage_rid', '_title', '_description', '_auto_generated_title', '_auto_generated_description', '_function_node']

    def __init__(self, description: str, function_lineage_rid: str, function_node: "scout_checks_api_FunctionNode", rid: str, title: str, auto_generated_description: Optional[str] = None, auto_generated_title: Optional[str] = None) -> None:
        self._rid = rid
        self._function_lineage_rid = function_lineage_rid
        self._title = title
        self._description = description
        self._auto_generated_title = auto_generated_title
        self._auto_generated_description = auto_generated_description
        self._function_node = function_node

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def function_lineage_rid(self) -> str:
        return self._function_lineage_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def auto_generated_title(self) -> Optional[str]:
        return self._auto_generated_title

    @builtins.property
    def auto_generated_description(self) -> Optional[str]:
        return self._auto_generated_description

    @builtins.property
    def function_node(self) -> "scout_checks_api_FunctionNode":
        return self._function_node


scout_checks_api_Function.__name__ = "Function"
scout_checks_api_Function.__qualname__ = "Function"
scout_checks_api_Function.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_FunctionNode(ConjureUnionType):
    _enum: Optional["scout_compute_api_EnumSeriesNode"] = None
    _numeric: Optional["scout_compute_api_NumericSeriesNode"] = None
    _ranges: Optional["scout_compute_api_RangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumSeriesNode),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericSeriesNode),
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangesNode)
        }

    def __init__(
            self,
            enum: Optional["scout_compute_api_EnumSeriesNode"] = None,
            numeric: Optional["scout_compute_api_NumericSeriesNode"] = None,
            ranges: Optional["scout_compute_api_RangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (enum is not None) + (numeric is not None) + (ranges is not None) != 1:
                raise ValueError('a union must contain a single member')

            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'

        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumSeriesNode"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericSeriesNode"]:
        return self._numeric

    @builtins.property
    def ranges(self) -> Optional["scout_compute_api_RangesNode"]:
        return self._ranges

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_FunctionNodeVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_FunctionNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)


scout_checks_api_FunctionNode.__name__ = "FunctionNode"
scout_checks_api_FunctionNode.__qualname__ = "FunctionNode"
scout_checks_api_FunctionNode.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_FunctionNodeVisitor:

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_api_RangesNode") -> Any:
        pass


scout_checks_api_FunctionNodeVisitor.__name__ = "FunctionNodeVisitor"
scout_checks_api_FunctionNodeVisitor.__qualname__ = "FunctionNodeVisitor"
scout_checks_api_FunctionNodeVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_GetAllLabelsAndPropertiesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, List[scout_run_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_checks_api_GetAllLabelsAndPropertiesResponse.__name__ = "GetAllLabelsAndPropertiesResponse"
scout_checks_api_GetAllLabelsAndPropertiesResponse.__qualname__ = "GetAllLabelsAndPropertiesResponse"
scout_checks_api_GetAllLabelsAndPropertiesResponse.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_InProgress(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checks_api_InProgress.__name__ = "InProgress"
scout_checks_api_InProgress.__qualname__ = "InProgress"
scout_checks_api_InProgress.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_JobReport(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_status': ConjureFieldDefinition('jobStatus', scout_checks_api_JobStatus),
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid),
            'submitted_at': ConjureFieldDefinition('submittedAt', str)
        }

    __slots__: List[str] = ['_job_status', '_job_rid', '_submitted_at']

    def __init__(self, job_rid: str, job_status: "scout_checks_api_JobStatus", submitted_at: str) -> None:
        self._job_status = job_status
        self._job_rid = job_rid
        self._submitted_at = submitted_at

    @builtins.property
    def job_status(self) -> "scout_checks_api_JobStatus":
        return self._job_status

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid

    @builtins.property
    def submitted_at(self) -> str:
        return self._submitted_at


scout_checks_api_JobReport.__name__ = "JobReport"
scout_checks_api_JobReport.__qualname__ = "JobReport"
scout_checks_api_JobReport.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_JobResult(ConjureUnionType):
    _check_job_result: Optional["scout_checks_api_CheckJobResult"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_job_result': ConjureFieldDefinition('checkJobResult', scout_checks_api_CheckJobResult)
        }

    def __init__(
            self,
            check_job_result: Optional["scout_checks_api_CheckJobResult"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (check_job_result is not None) != 1:
                raise ValueError('a union must contain a single member')

            if check_job_result is not None:
                self._check_job_result = check_job_result
                self._type = 'checkJobResult'

        elif type_of_union == 'checkJobResult':
            if check_job_result is None:
                raise ValueError('a union value must not be None')
            self._check_job_result = check_job_result
            self._type = 'checkJobResult'

    @builtins.property
    def check_job_result(self) -> Optional["scout_checks_api_CheckJobResult"]:
        return self._check_job_result

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_JobResultVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_JobResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'checkJobResult' and self.check_job_result is not None:
            return visitor._check_job_result(self.check_job_result)


scout_checks_api_JobResult.__name__ = "JobResult"
scout_checks_api_JobResult.__qualname__ = "JobResult"
scout_checks_api_JobResult.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_JobResultVisitor:

    @abstractmethod
    def _check_job_result(self, check_job_result: "scout_checks_api_CheckJobResult") -> Any:
        pass


scout_checks_api_JobResultVisitor.__name__ = "JobResultVisitor"
scout_checks_api_JobResultVisitor.__qualname__ = "JobResultVisitor"
scout_checks_api_JobResultVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_JobSpec(ConjureUnionType):
    _check: Optional["scout_checks_api_DeprecatedCheckJobSpec"] = None
    _check_v2: Optional["scout_checks_api_CheckJobSpec"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check': ConjureFieldDefinition('check', scout_checks_api_DeprecatedCheckJobSpec),
            'check_v2': ConjureFieldDefinition('checkV2', scout_checks_api_CheckJobSpec)
        }

    def __init__(
            self,
            check: Optional["scout_checks_api_DeprecatedCheckJobSpec"] = None,
            check_v2: Optional["scout_checks_api_CheckJobSpec"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (check is not None) + (check_v2 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if check is not None:
                self._check = check
                self._type = 'check'
            if check_v2 is not None:
                self._check_v2 = check_v2
                self._type = 'checkV2'

        elif type_of_union == 'check':
            if check is None:
                raise ValueError('a union value must not be None')
            self._check = check
            self._type = 'check'
        elif type_of_union == 'checkV2':
            if check_v2 is None:
                raise ValueError('a union value must not be None')
            self._check_v2 = check_v2
            self._type = 'checkV2'

    @builtins.property
    def check(self) -> Optional["scout_checks_api_DeprecatedCheckJobSpec"]:
        return self._check

    @builtins.property
    def check_v2(self) -> Optional["scout_checks_api_CheckJobSpec"]:
        return self._check_v2

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_JobSpecVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_JobSpecVisitor'.format(visitor.__class__.__name__))
        if self._type == 'check' and self.check is not None:
            return visitor._check(self.check)
        if self._type == 'checkV2' and self.check_v2 is not None:
            return visitor._check_v2(self.check_v2)


scout_checks_api_JobSpec.__name__ = "JobSpec"
scout_checks_api_JobSpec.__qualname__ = "JobSpec"
scout_checks_api_JobSpec.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_JobSpecVisitor:

    @abstractmethod
    def _check(self, check: "scout_checks_api_DeprecatedCheckJobSpec") -> Any:
        pass

    @abstractmethod
    def _check_v2(self, check_v2: "scout_checks_api_CheckJobSpec") -> Any:
        pass


scout_checks_api_JobSpecVisitor.__name__ = "JobSpecVisitor"
scout_checks_api_JobSpecVisitor.__qualname__ = "JobSpecVisitor"
scout_checks_api_JobSpecVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_JobStatus(ConjureUnionType):
    _in_progress: Optional["scout_checks_api_InProgress"] = None
    _completed: Optional["scout_checks_api_Completed"] = None
    _failed: Optional["scout_checks_api_Failed"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'in_progress': ConjureFieldDefinition('inProgress', scout_checks_api_InProgress),
            'completed': ConjureFieldDefinition('completed', scout_checks_api_Completed),
            'failed': ConjureFieldDefinition('failed', scout_checks_api_Failed)
        }

    def __init__(
            self,
            in_progress: Optional["scout_checks_api_InProgress"] = None,
            completed: Optional["scout_checks_api_Completed"] = None,
            failed: Optional["scout_checks_api_Failed"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (in_progress is not None) + (completed is not None) + (failed is not None) != 1:
                raise ValueError('a union must contain a single member')

            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'
            if completed is not None:
                self._completed = completed
                self._type = 'completed'
            if failed is not None:
                self._failed = failed
                self._type = 'failed'

        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'
        elif type_of_union == 'completed':
            if completed is None:
                raise ValueError('a union value must not be None')
            self._completed = completed
            self._type = 'completed'
        elif type_of_union == 'failed':
            if failed is None:
                raise ValueError('a union value must not be None')
            self._failed = failed
            self._type = 'failed'

    @builtins.property
    def in_progress(self) -> Optional["scout_checks_api_InProgress"]:
        return self._in_progress

    @builtins.property
    def completed(self) -> Optional["scout_checks_api_Completed"]:
        return self._completed

    @builtins.property
    def failed(self) -> Optional["scout_checks_api_Failed"]:
        return self._failed

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_JobStatusVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_JobStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)
        if self._type == 'completed' and self.completed is not None:
            return visitor._completed(self.completed)
        if self._type == 'failed' and self.failed is not None:
            return visitor._failed(self.failed)


scout_checks_api_JobStatus.__name__ = "JobStatus"
scout_checks_api_JobStatus.__qualname__ = "JobStatus"
scout_checks_api_JobStatus.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_JobStatusVisitor:

    @abstractmethod
    def _in_progress(self, in_progress: "scout_checks_api_InProgress") -> Any:
        pass

    @abstractmethod
    def _completed(self, completed: "scout_checks_api_Completed") -> Any:
        pass

    @abstractmethod
    def _failed(self, failed: "scout_checks_api_Failed") -> Any:
        pass


scout_checks_api_JobStatusVisitor.__name__ = "JobStatusVisitor"
scout_checks_api_JobStatusVisitor.__qualname__ = "JobStatusVisitor"
scout_checks_api_JobStatusVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_MergeToMainRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'branch_name': ConjureFieldDefinition('branchName', scout_versioning_api_BranchName),
            'message': ConjureFieldDefinition('message', str),
            'latest_commit_on_main': ConjureFieldDefinition('latestCommitOnMain', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_branch_name', '_message', '_latest_commit_on_main']

    def __init__(self, branch_name: str, message: str, latest_commit_on_main: Optional[str] = None) -> None:
        self._branch_name = branch_name
        self._message = message
        self._latest_commit_on_main = latest_commit_on_main

    @builtins.property
    def branch_name(self) -> str:
        """
        If "main", the request will throw.
        """
        return self._branch_name

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def latest_commit_on_main(self) -> Optional[str]:
        """
        If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit_on_main


scout_checks_api_MergeToMainRequest.__name__ = "MergeToMainRequest"
scout_checks_api_MergeToMainRequest.__qualname__ = "MergeToMainRequest"
scout_checks_api_MergeToMainRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_NumRangesConditionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_deprecated_RangesNode),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_api_ChannelLocator])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables']

    def __init__(self, function_spec: Any, operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_deprecated_RangesNode", threshold: int, variables: Dict[str, "scout_api_ChannelLocator"]) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_deprecated_RangesNode":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_api_ChannelLocator"]:
        return self._variables


scout_checks_api_NumRangesConditionV1.__name__ = "NumRangesConditionV1"
scout_checks_api_NumRangesConditionV1.__qualname__ = "NumRangesConditionV1"
scout_checks_api_NumRangesConditionV1.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_NumRangesConditionV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_deprecated_RangesNode),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_VariableLocator])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables']

    def __init__(self, function_spec: Any, operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_deprecated_RangesNode", threshold: int, variables: Dict[str, "scout_checks_api_VariableLocator"]) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_deprecated_RangesNode":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_VariableLocator"]:
        return self._variables


scout_checks_api_NumRangesConditionV2.__name__ = "NumRangesConditionV2"
scout_checks_api_NumRangesConditionV2.__qualname__ = "NumRangesConditionV2"
scout_checks_api_NumRangesConditionV2.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_NumRangesConditionV3(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangesNode),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_VariableLocator]),
            'function_variables': ConjureFieldDefinition('functionVariables', Dict[scout_compute_api_FunctionReference, scout_checks_api_CheckContext])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables', '_function_variables']

    def __init__(self, function_spec: Any, function_variables: Dict[str, "scout_checks_api_CheckContext"], operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_RangesNode", threshold: int, variables: Dict[str, "scout_checks_api_VariableLocator"]) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables
        self._function_variables = function_variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangesNode":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_VariableLocator"]:
        return self._variables

    @builtins.property
    def function_variables(self) -> Dict[str, "scout_checks_api_CheckContext"]:
        """
        The variables to be passed into functions referenced by the check condition. The function reference key
should match the FunctionReference in the function node definition.
        """
        return self._function_variables


scout_checks_api_NumRangesConditionV3.__name__ = "NumRangesConditionV3"
scout_checks_api_NumRangesConditionV3.__qualname__ = "NumRangesConditionV3"
scout_checks_api_NumRangesConditionV3.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_ParameterizedNumRangesConditionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangesNode),
            'implementations': ConjureFieldDefinition('implementations', List[scout_checks_api_CheckContext])
        }

    __slots__: List[str] = ['_ranges', '_implementations']

    def __init__(self, implementations: List["scout_checks_api_CheckContext"], ranges: "scout_compute_api_RangesNode") -> None:
        self._ranges = ranges
        self._implementations = implementations

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangesNode":
        return self._ranges

    @builtins.property
    def implementations(self) -> List["scout_checks_api_CheckContext"]:
        """
        Each permutation of check context in the list will be executed as a new a stand-alone check. Violations
produced will be associated with the context of the index.
        """
        return self._implementations


scout_checks_api_ParameterizedNumRangesConditionV1.__name__ = "ParameterizedNumRangesConditionV1"
scout_checks_api_ParameterizedNumRangesConditionV1.__qualname__ = "ParameterizedNumRangesConditionV1"
scout_checks_api_ParameterizedNumRangesConditionV1.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_PinnedChecklistRef(ConjureBeanType):
    """
    A reference to a checklist that is pinned to a specific commit.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_ChecklistRid),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_CommitId)
        }

    __slots__: List[str] = ['_rid', '_commit']

    def __init__(self, commit: str, rid: str) -> None:
        self._rid = rid
        self._commit = commit

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def commit(self) -> str:
        return self._commit


scout_checks_api_PinnedChecklistRef.__name__ = "PinnedChecklistRef"
scout_checks_api_PinnedChecklistRef.__qualname__ = "PinnedChecklistRef"
scout_checks_api_PinnedChecklistRef.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_Priority(ConjureEnumType):

    P0 = 'P0'
    '''P0'''
    P1 = 'P1'
    '''P1'''
    P2 = 'P2'
    '''P2'''
    P3 = 'P3'
    '''P3'''
    P4 = 'P4'
    '''P4'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_checks_api_Priority.__name__ = "Priority"
scout_checks_api_Priority.__qualname__ = "Priority"
scout_checks_api_Priority.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_SaveChecklistRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checks': ConjureFieldDefinition('checks', List[scout_checks_api_UpdateChecklistEntryRequest]),
            'functions': ConjureFieldDefinition('functions', Dict[scout_compute_api_FunctionReference, scout_checks_api_UpdateFunctionEntryRequest]),
            'checklist_variables': ConjureFieldDefinition('checklistVariables', List[scout_checks_api_UnresolvedChecklistVariable]),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_checks', '_functions', '_checklist_variables', '_latest_commit']

    def __init__(self, checklist_variables: List["scout_checks_api_UnresolvedChecklistVariable"], checks: List["scout_checks_api_UpdateChecklistEntryRequest"], functions: Dict[str, "scout_checks_api_UpdateFunctionEntryRequest"], latest_commit: Optional[str] = None) -> None:
        self._checks = checks
        self._functions = functions
        self._checklist_variables = checklist_variables
        self._latest_commit = latest_commit

    @builtins.property
    def checks(self) -> List["scout_checks_api_UpdateChecklistEntryRequest"]:
        return self._checks

    @builtins.property
    def functions(self) -> Dict[str, "scout_checks_api_UpdateFunctionEntryRequest"]:
        """
        The keys of the map are references that can be used for checks to reference functions in the same request, before the function RIDs have been created.
        """
        return self._functions

    @builtins.property
    def checklist_variables(self) -> List["scout_checks_api_UnresolvedChecklistVariable"]:
        """
        Variables that can be used in checks and functions. Variables are resolved in order of declaration.
If variable `a` depends on variable `b`, then `b` must be defined before `a` in the list.
        """
        return self._checklist_variables

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        """
        If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit


scout_checks_api_SaveChecklistRequest.__name__ = "SaveChecklistRequest"
scout_checks_api_SaveChecklistRequest.__qualname__ = "SaveChecklistRequest"
scout_checks_api_SaveChecklistRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_SearchChecklistsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_checks_api_ChecklistSearchQuery),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[scout_checks_api_SortOptions]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[scout_rids_api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_query', '_sort_by', '_next_page_token', '_page_size', '_archived_statuses']

    def __init__(self, query: "scout_checks_api_ChecklistSearchQuery", archived_statuses: Optional[List["scout_rids_api_ArchivedStatus"]] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None, sort_by: Optional["scout_checks_api_SortOptions"] = None) -> None:
        self._query = query
        self._sort_by = sort_by
        self._next_page_token = next_page_token
        self._page_size = page_size
        self._archived_statuses = archived_statuses

    @builtins.property
    def query(self) -> "scout_checks_api_ChecklistSearchQuery":
        return self._query

    @builtins.property
    def sort_by(self) -> Optional["scout_checks_api_SortOptions"]:
        """
        If not present, will sort by LAST_USED in descending order.
        """
        return self._sort_by

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 100. Will throw if larger than 1000.
        """
        return self._page_size

    @builtins.property
    def archived_statuses(self) -> Optional[List["scout_rids_api_ArchivedStatus"]]:
        """
        Default search status is NOT_ARCHIVED if none are provided. Allows for including archived checklists in search.
        """
        return self._archived_statuses


scout_checks_api_SearchChecklistsRequest.__name__ = "SearchChecklistsRequest"
scout_checks_api_SearchChecklistsRequest.__qualname__ = "SearchChecklistsRequest"
scout_checks_api_SearchChecklistsRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_SortField(ConjureEnumType):

    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    LAST_USED = 'LAST_USED'
    '''LAST_USED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_checks_api_SortField.__name__ = "SortField"
scout_checks_api_SortField.__qualname__ = "SortField"
scout_checks_api_SortField.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_checks_api_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_checks_api_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_checks_api_SortField":
        return self._field


scout_checks_api_SortOptions.__name__ = "SortOptions"
scout_checks_api_SortOptions.__qualname__ = "SortOptions"
scout_checks_api_SortOptions.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_SubmitJobsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'jobs_to_execute': ConjureFieldDefinition('jobsToExecute', List[scout_checks_api_JobSpec])
        }

    __slots__: List[str] = ['_jobs_to_execute']

    def __init__(self, jobs_to_execute: List["scout_checks_api_JobSpec"]) -> None:
        self._jobs_to_execute = jobs_to_execute

    @builtins.property
    def jobs_to_execute(self) -> List["scout_checks_api_JobSpec"]:
        return self._jobs_to_execute


scout_checks_api_SubmitJobsRequest.__name__ = "SubmitJobsRequest"
scout_checks_api_SubmitJobsRequest.__qualname__ = "SubmitJobsRequest"
scout_checks_api_SubmitJobsRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_SubmitJobsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'jobs': ConjureFieldDefinition('jobs', List[scout_checks_api_SubmittedJob])
        }

    __slots__: List[str] = ['_jobs']

    def __init__(self, jobs: List["scout_checks_api_SubmittedJob"]) -> None:
        self._jobs = jobs

    @builtins.property
    def jobs(self) -> List["scout_checks_api_SubmittedJob"]:
        return self._jobs


scout_checks_api_SubmitJobsResponse.__name__ = "SubmitJobsResponse"
scout_checks_api_SubmitJobsResponse.__qualname__ = "SubmitJobsResponse"
scout_checks_api_SubmitJobsResponse.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_SubmittedJob(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid),
            'job_spec': ConjureFieldDefinition('jobSpec', scout_checks_api_JobSpec)
        }

    __slots__: List[str] = ['_job_rid', '_job_spec']

    def __init__(self, job_rid: str, job_spec: "scout_checks_api_JobSpec") -> None:
        self._job_rid = job_rid
        self._job_spec = job_spec

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid

    @builtins.property
    def job_spec(self) -> "scout_checks_api_JobSpec":
        return self._job_spec


scout_checks_api_SubmittedJob.__name__ = "SubmittedJob"
scout_checks_api_SubmittedJob.__qualname__ = "SubmittedJob"
scout_checks_api_SubmittedJob.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_TimestampLocator(ConjureEnumType):

    RUN_START = 'RUN_START'
    '''RUN_START'''
    RUN_END = 'RUN_END'
    '''RUN_END'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_checks_api_TimestampLocator.__name__ = "TimestampLocator"
scout_checks_api_TimestampLocator.__qualname__ = "TimestampLocator"
scout_checks_api_TimestampLocator.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnarchiveChecklistsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_rids_api_ChecklistRid])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


scout_checks_api_UnarchiveChecklistsRequest.__name__ = "UnarchiveChecklistsRequest"
scout_checks_api_UnarchiveChecklistsRequest.__qualname__ = "UnarchiveChecklistsRequest"
scout_checks_api_UnarchiveChecklistsRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedCheckCondition(ConjureUnionType):
    _num_ranges_v2: Optional["scout_checks_api_UnresolvedNumRangesConditionV2"] = None
    _num_ranges_v3: Optional["scout_checks_api_UnresolvedNumRangesConditionV3"] = None
    _parameterized_num_ranges_v1: Optional["scout_checks_api_UnresolvedParameterizedNumRangesConditionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'num_ranges_v2': ConjureFieldDefinition('numRangesV2', scout_checks_api_UnresolvedNumRangesConditionV2),
            'num_ranges_v3': ConjureFieldDefinition('numRangesV3', scout_checks_api_UnresolvedNumRangesConditionV3),
            'parameterized_num_ranges_v1': ConjureFieldDefinition('parameterizedNumRangesV1', scout_checks_api_UnresolvedParameterizedNumRangesConditionV1)
        }

    def __init__(
            self,
            num_ranges_v2: Optional["scout_checks_api_UnresolvedNumRangesConditionV2"] = None,
            num_ranges_v3: Optional["scout_checks_api_UnresolvedNumRangesConditionV3"] = None,
            parameterized_num_ranges_v1: Optional["scout_checks_api_UnresolvedParameterizedNumRangesConditionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (num_ranges_v2 is not None) + (num_ranges_v3 is not None) + (parameterized_num_ranges_v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if num_ranges_v2 is not None:
                self._num_ranges_v2 = num_ranges_v2
                self._type = 'numRangesV2'
            if num_ranges_v3 is not None:
                self._num_ranges_v3 = num_ranges_v3
                self._type = 'numRangesV3'
            if parameterized_num_ranges_v1 is not None:
                self._parameterized_num_ranges_v1 = parameterized_num_ranges_v1
                self._type = 'parameterizedNumRangesV1'

        elif type_of_union == 'numRangesV2':
            if num_ranges_v2 is None:
                raise ValueError('a union value must not be None')
            self._num_ranges_v2 = num_ranges_v2
            self._type = 'numRangesV2'
        elif type_of_union == 'numRangesV3':
            if num_ranges_v3 is None:
                raise ValueError('a union value must not be None')
            self._num_ranges_v3 = num_ranges_v3
            self._type = 'numRangesV3'
        elif type_of_union == 'parameterizedNumRangesV1':
            if parameterized_num_ranges_v1 is None:
                raise ValueError('a union value must not be None')
            self._parameterized_num_ranges_v1 = parameterized_num_ranges_v1
            self._type = 'parameterizedNumRangesV1'

    @builtins.property
    def num_ranges_v2(self) -> Optional["scout_checks_api_UnresolvedNumRangesConditionV2"]:
        return self._num_ranges_v2

    @builtins.property
    def num_ranges_v3(self) -> Optional["scout_checks_api_UnresolvedNumRangesConditionV3"]:
        return self._num_ranges_v3

    @builtins.property
    def parameterized_num_ranges_v1(self) -> Optional["scout_checks_api_UnresolvedParameterizedNumRangesConditionV1"]:
        return self._parameterized_num_ranges_v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_UnresolvedCheckConditionVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_UnresolvedCheckConditionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numRangesV2' and self.num_ranges_v2 is not None:
            return visitor._num_ranges_v2(self.num_ranges_v2)
        if self._type == 'numRangesV3' and self.num_ranges_v3 is not None:
            return visitor._num_ranges_v3(self.num_ranges_v3)
        if self._type == 'parameterizedNumRangesV1' and self.parameterized_num_ranges_v1 is not None:
            return visitor._parameterized_num_ranges_v1(self.parameterized_num_ranges_v1)


scout_checks_api_UnresolvedCheckCondition.__name__ = "UnresolvedCheckCondition"
scout_checks_api_UnresolvedCheckCondition.__qualname__ = "UnresolvedCheckCondition"
scout_checks_api_UnresolvedCheckCondition.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedCheckConditionVisitor:

    @abstractmethod
    def _num_ranges_v2(self, num_ranges_v2: "scout_checks_api_UnresolvedNumRangesConditionV2") -> Any:
        pass

    @abstractmethod
    def _num_ranges_v3(self, num_ranges_v3: "scout_checks_api_UnresolvedNumRangesConditionV3") -> Any:
        pass

    @abstractmethod
    def _parameterized_num_ranges_v1(self, parameterized_num_ranges_v1: "scout_checks_api_UnresolvedParameterizedNumRangesConditionV1") -> Any:
        pass


scout_checks_api_UnresolvedCheckConditionVisitor.__name__ = "UnresolvedCheckConditionVisitor"
scout_checks_api_UnresolvedCheckConditionVisitor.__qualname__ = "UnresolvedCheckConditionVisitor"
scout_checks_api_UnresolvedCheckConditionVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedChecklistVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_VariableName),
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'value': ConjureFieldDefinition('value', scout_checks_api_UnresolvedVariableLocator)
        }

    __slots__: List[str] = ['_name', '_display_name', '_value']

    def __init__(self, name: str, value: "scout_checks_api_UnresolvedVariableLocator", display_name: Optional[str] = None) -> None:
        self._name = name
        self._display_name = display_name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def value(self) -> "scout_checks_api_UnresolvedVariableLocator":
        return self._value


scout_checks_api_UnresolvedChecklistVariable.__name__ = "UnresolvedChecklistVariable"
scout_checks_api_UnresolvedChecklistVariable.__qualname__ = "UnresolvedChecklistVariable"
scout_checks_api_UnresolvedChecklistVariable.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedComputeNodeWithContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_node': ConjureFieldDefinition('seriesNode', scout_compute_api_ComputeNode),
            'context': ConjureFieldDefinition('context', scout_checks_api_UnresolvedVariables)
        }

    __slots__: List[str] = ['_series_node', '_context']

    def __init__(self, context: "scout_checks_api_UnresolvedVariables", series_node: "scout_compute_api_ComputeNode") -> None:
        self._series_node = series_node
        self._context = context

    @builtins.property
    def series_node(self) -> "scout_compute_api_ComputeNode":
        return self._series_node

    @builtins.property
    def context(self) -> "scout_checks_api_UnresolvedVariables":
        return self._context


scout_checks_api_UnresolvedComputeNodeWithContext.__name__ = "UnresolvedComputeNodeWithContext"
scout_checks_api_UnresolvedComputeNodeWithContext.__qualname__ = "UnresolvedComputeNodeWithContext"
scout_checks_api_UnresolvedComputeNodeWithContext.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedNumRangesConditionV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_deprecated_RangesNode),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_UnresolvedVariableLocator])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables']

    def __init__(self, function_spec: Any, operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_deprecated_RangesNode", threshold: int, variables: Dict[str, "scout_checks_api_UnresolvedVariableLocator"]) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_deprecated_RangesNode":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_UnresolvedVariableLocator"]:
        return self._variables


scout_checks_api_UnresolvedNumRangesConditionV2.__name__ = "UnresolvedNumRangesConditionV2"
scout_checks_api_UnresolvedNumRangesConditionV2.__qualname__ = "UnresolvedNumRangesConditionV2"
scout_checks_api_UnresolvedNumRangesConditionV2.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedNumRangesConditionV3(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangesNode),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_UnresolvedVariableLocator]),
            'function_variables': ConjureFieldDefinition('functionVariables', Dict[scout_compute_api_FunctionReference, scout_checks_api_UnresolvedVariables])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables', '_function_variables']

    def __init__(self, function_spec: Any, function_variables: Dict[str, "scout_checks_api_UnresolvedVariables"], operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_RangesNode", threshold: int, variables: Dict[str, "scout_checks_api_UnresolvedVariableLocator"]) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables
        self._function_variables = function_variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangesNode":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_UnresolvedVariableLocator"]:
        """
        Default overrides for the variables used in the check condition. These variables can be overridden
at checklist execution time.
        """
        return self._variables

    @builtins.property
    def function_variables(self) -> Dict[str, "scout_checks_api_UnresolvedVariables"]:
        """
        The variables to be passed into functions referenced by the check condition. The function reference key
should match the FunctionReference in the function node definition. These variables can be overridden
at checklist execution time.
        """
        return self._function_variables


scout_checks_api_UnresolvedNumRangesConditionV3.__name__ = "UnresolvedNumRangesConditionV3"
scout_checks_api_UnresolvedNumRangesConditionV3.__qualname__ = "UnresolvedNumRangesConditionV3"
scout_checks_api_UnresolvedNumRangesConditionV3.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedParameterizedNumRangesConditionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangesNode),
            'implementations': ConjureFieldDefinition('implementations', List[scout_checks_api_UnresolvedVariables])
        }

    __slots__: List[str] = ['_ranges', '_implementations']

    def __init__(self, implementations: List["scout_checks_api_UnresolvedVariables"], ranges: "scout_compute_api_RangesNode") -> None:
        self._ranges = ranges
        self._implementations = implementations

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangesNode":
        return self._ranges

    @builtins.property
    def implementations(self) -> List["scout_checks_api_UnresolvedVariables"]:
        """
        Each permutation of check context in the list will be executed as a new a stand-alone check. Violations
produced will be associated with the context of the index.
        """
        return self._implementations


scout_checks_api_UnresolvedParameterizedNumRangesConditionV1.__name__ = "UnresolvedParameterizedNumRangesConditionV1"
scout_checks_api_UnresolvedParameterizedNumRangesConditionV1.__qualname__ = "UnresolvedParameterizedNumRangesConditionV1"
scout_checks_api_UnresolvedParameterizedNumRangesConditionV1.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedVariableLocator(ConjureUnionType):
    _checklist_function: Optional[str] = None
    _checklist_variable: Optional[str] = None
    _compute_node: Optional["scout_checks_api_UnresolvedComputeNodeWithContext"] = None
    _series: Optional["scout_api_ChannelLocator"] = None
    _timestamp: Optional["scout_checks_api_TimestampLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_function': ConjureFieldDefinition('checklistFunction', scout_compute_api_FunctionReference),
            'checklist_variable': ConjureFieldDefinition('checklistVariable', scout_compute_api_VariableName),
            'compute_node': ConjureFieldDefinition('computeNode', scout_checks_api_UnresolvedComputeNodeWithContext),
            'series': ConjureFieldDefinition('series', scout_api_ChannelLocator),
            'timestamp': ConjureFieldDefinition('timestamp', scout_checks_api_TimestampLocator)
        }

    def __init__(
            self,
            checklist_function: Optional[str] = None,
            checklist_variable: Optional[str] = None,
            compute_node: Optional["scout_checks_api_UnresolvedComputeNodeWithContext"] = None,
            series: Optional["scout_api_ChannelLocator"] = None,
            timestamp: Optional["scout_checks_api_TimestampLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (checklist_function is not None) + (checklist_variable is not None) + (compute_node is not None) + (series is not None) + (timestamp is not None) != 1:
                raise ValueError('a union must contain a single member')

            if checklist_function is not None:
                self._checklist_function = checklist_function
                self._type = 'checklistFunction'
            if checklist_variable is not None:
                self._checklist_variable = checklist_variable
                self._type = 'checklistVariable'
            if compute_node is not None:
                self._compute_node = compute_node
                self._type = 'computeNode'
            if series is not None:
                self._series = series
                self._type = 'series'
            if timestamp is not None:
                self._timestamp = timestamp
                self._type = 'timestamp'

        elif type_of_union == 'checklistFunction':
            if checklist_function is None:
                raise ValueError('a union value must not be None')
            self._checklist_function = checklist_function
            self._type = 'checklistFunction'
        elif type_of_union == 'checklistVariable':
            if checklist_variable is None:
                raise ValueError('a union value must not be None')
            self._checklist_variable = checklist_variable
            self._type = 'checklistVariable'
        elif type_of_union == 'computeNode':
            if compute_node is None:
                raise ValueError('a union value must not be None')
            self._compute_node = compute_node
            self._type = 'computeNode'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'timestamp':
            if timestamp is None:
                raise ValueError('a union value must not be None')
            self._timestamp = timestamp
            self._type = 'timestamp'

    @builtins.property
    def checklist_function(self) -> Optional[str]:
        return self._checklist_function

    @builtins.property
    def checklist_variable(self) -> Optional[str]:
        """
        A pointer to a variable in the checklist.
        """
        return self._checklist_variable

    @builtins.property
    def compute_node(self) -> Optional["scout_checks_api_UnresolvedComputeNodeWithContext"]:
        return self._compute_node

    @builtins.property
    def series(self) -> Optional["scout_api_ChannelLocator"]:
        return self._series

    @builtins.property
    def timestamp(self) -> Optional["scout_checks_api_TimestampLocator"]:
        return self._timestamp

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_UnresolvedVariableLocatorVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_UnresolvedVariableLocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'checklistFunction' and self.checklist_function is not None:
            return visitor._checklist_function(self.checklist_function)
        if self._type == 'checklistVariable' and self.checklist_variable is not None:
            return visitor._checklist_variable(self.checklist_variable)
        if self._type == 'computeNode' and self.compute_node is not None:
            return visitor._compute_node(self.compute_node)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'timestamp' and self.timestamp is not None:
            return visitor._timestamp(self.timestamp)


scout_checks_api_UnresolvedVariableLocator.__name__ = "UnresolvedVariableLocator"
scout_checks_api_UnresolvedVariableLocator.__qualname__ = "UnresolvedVariableLocator"
scout_checks_api_UnresolvedVariableLocator.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedVariableLocatorVisitor:

    @abstractmethod
    def _checklist_function(self, checklist_function: str) -> Any:
        pass

    @abstractmethod
    def _checklist_variable(self, checklist_variable: str) -> Any:
        pass

    @abstractmethod
    def _compute_node(self, compute_node: "scout_checks_api_UnresolvedComputeNodeWithContext") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_api_ChannelLocator") -> Any:
        pass

    @abstractmethod
    def _timestamp(self, timestamp: "scout_checks_api_TimestampLocator") -> Any:
        pass


scout_checks_api_UnresolvedVariableLocatorVisitor.__name__ = "UnresolvedVariableLocatorVisitor"
scout_checks_api_UnresolvedVariableLocatorVisitor.__qualname__ = "UnresolvedVariableLocatorVisitor"
scout_checks_api_UnresolvedVariableLocatorVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UnresolvedVariables(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_UnresolvedVariableLocator]),
            'sub_function_variables': ConjureFieldDefinition('subFunctionVariables', Dict[scout_compute_api_FunctionReference, scout_checks_api_UnresolvedVariables])
        }

    __slots__: List[str] = ['_variables', '_sub_function_variables']

    def __init__(self, sub_function_variables: Dict[str, "scout_checks_api_UnresolvedVariables"], variables: Dict[str, "scout_checks_api_UnresolvedVariableLocator"]) -> None:
        self._variables = variables
        self._sub_function_variables = sub_function_variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_UnresolvedVariableLocator"]:
        return self._variables

    @builtins.property
    def sub_function_variables(self) -> Dict[str, "scout_checks_api_UnresolvedVariables"]:
        return self._sub_function_variables


scout_checks_api_UnresolvedVariables.__name__ = "UnresolvedVariables"
scout_checks_api_UnresolvedVariables.__qualname__ = "UnresolvedVariables"
scout_checks_api_UnresolvedVariables.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UpdateChecklistEntryRequest(ConjureUnionType):
    _create_check: Optional["scout_checks_api_CreateCheckRequest"] = None
    _check: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'create_check': ConjureFieldDefinition('createCheck', scout_checks_api_CreateCheckRequest),
            'check': ConjureFieldDefinition('check', scout_rids_api_CheckRid)
        }

    def __init__(
            self,
            create_check: Optional["scout_checks_api_CreateCheckRequest"] = None,
            check: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (create_check is not None) + (check is not None) != 1:
                raise ValueError('a union must contain a single member')

            if create_check is not None:
                self._create_check = create_check
                self._type = 'createCheck'
            if check is not None:
                self._check = check
                self._type = 'check'

        elif type_of_union == 'createCheck':
            if create_check is None:
                raise ValueError('a union value must not be None')
            self._create_check = create_check
            self._type = 'createCheck'
        elif type_of_union == 'check':
            if check is None:
                raise ValueError('a union value must not be None')
            self._check = check
            self._type = 'check'

    @builtins.property
    def create_check(self) -> Optional["scout_checks_api_CreateCheckRequest"]:
        return self._create_check

    @builtins.property
    def check(self) -> Optional[str]:
        return self._check

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_UpdateChecklistEntryRequestVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_UpdateChecklistEntryRequestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'createCheck' and self.create_check is not None:
            return visitor._create_check(self.create_check)
        if self._type == 'check' and self.check is not None:
            return visitor._check(self.check)


scout_checks_api_UpdateChecklistEntryRequest.__name__ = "UpdateChecklistEntryRequest"
scout_checks_api_UpdateChecklistEntryRequest.__qualname__ = "UpdateChecklistEntryRequest"
scout_checks_api_UpdateChecklistEntryRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UpdateChecklistEntryRequestVisitor:

    @abstractmethod
    def _create_check(self, create_check: "scout_checks_api_CreateCheckRequest") -> Any:
        pass

    @abstractmethod
    def _check(self, check: str) -> Any:
        pass


scout_checks_api_UpdateChecklistEntryRequestVisitor.__name__ = "UpdateChecklistEntryRequestVisitor"
scout_checks_api_UpdateChecklistEntryRequestVisitor.__qualname__ = "UpdateChecklistEntryRequestVisitor"
scout_checks_api_UpdateChecklistEntryRequestVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UpdateChecklistMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'assignee_rid': ConjureFieldDefinition('assigneeRid', OptionalTypeWrapper[scout_rids_api_UserRid]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[scout_run_api_Label]]),
            'is_published': ConjureFieldDefinition('isPublished', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_assignee_rid', '_title', '_description', '_properties', '_labels', '_is_published']

    def __init__(self, assignee_rid: Optional[str] = None, description: Optional[str] = None, is_published: Optional[bool] = None, labels: Optional[List[str]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None) -> None:
        self._assignee_rid = assignee_rid
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._is_published = is_published

    @builtins.property
    def assignee_rid(self) -> Optional[str]:
        return self._assignee_rid

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def is_published(self) -> Optional[bool]:
        return self._is_published


scout_checks_api_UpdateChecklistMetadataRequest.__name__ = "UpdateChecklistMetadataRequest"
scout_checks_api_UpdateChecklistMetadataRequest.__qualname__ = "UpdateChecklistMetadataRequest"
scout_checks_api_UpdateChecklistMetadataRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UpdateFunctionEntryRequest(ConjureUnionType):
    _create_function: Optional["scout_checks_api_CreateFunctionRequest"] = None
    _function: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'create_function': ConjureFieldDefinition('createFunction', scout_checks_api_CreateFunctionRequest),
            'function': ConjureFieldDefinition('function', scout_rids_api_FunctionRid)
        }

    def __init__(
            self,
            create_function: Optional["scout_checks_api_CreateFunctionRequest"] = None,
            function: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (create_function is not None) + (function is not None) != 1:
                raise ValueError('a union must contain a single member')

            if create_function is not None:
                self._create_function = create_function
                self._type = 'createFunction'
            if function is not None:
                self._function = function
                self._type = 'function'

        elif type_of_union == 'createFunction':
            if create_function is None:
                raise ValueError('a union value must not be None')
            self._create_function = create_function
            self._type = 'createFunction'
        elif type_of_union == 'function':
            if function is None:
                raise ValueError('a union value must not be None')
            self._function = function
            self._type = 'function'

    @builtins.property
    def create_function(self) -> Optional["scout_checks_api_CreateFunctionRequest"]:
        return self._create_function

    @builtins.property
    def function(self) -> Optional[str]:
        return self._function

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_UpdateFunctionEntryRequestVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_UpdateFunctionEntryRequestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'createFunction' and self.create_function is not None:
            return visitor._create_function(self.create_function)
        if self._type == 'function' and self.function is not None:
            return visitor._function(self.function)


scout_checks_api_UpdateFunctionEntryRequest.__name__ = "UpdateFunctionEntryRequest"
scout_checks_api_UpdateFunctionEntryRequest.__qualname__ = "UpdateFunctionEntryRequest"
scout_checks_api_UpdateFunctionEntryRequest.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_UpdateFunctionEntryRequestVisitor:

    @abstractmethod
    def _create_function(self, create_function: "scout_checks_api_CreateFunctionRequest") -> Any:
        pass

    @abstractmethod
    def _function(self, function: str) -> Any:
        pass


scout_checks_api_UpdateFunctionEntryRequestVisitor.__name__ = "UpdateFunctionEntryRequestVisitor"
scout_checks_api_UpdateFunctionEntryRequestVisitor.__qualname__ = "UpdateFunctionEntryRequestVisitor"
scout_checks_api_UpdateFunctionEntryRequestVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_VariableLocator(ConjureUnionType):
    _checklist_variable: Optional[str] = None
    _compute_node: Optional["scout_checks_api_ComputeNodeWithContext"] = None
    _function_rid: Optional[str] = None
    _series: Optional["scout_api_ChannelLocator"] = None
    _timestamp: Optional["scout_checks_api_TimestampLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_variable': ConjureFieldDefinition('checklistVariable', scout_compute_api_VariableName),
            'compute_node': ConjureFieldDefinition('computeNode', scout_checks_api_ComputeNodeWithContext),
            'function_rid': ConjureFieldDefinition('functionRid', scout_rids_api_FunctionRid),
            'series': ConjureFieldDefinition('series', scout_api_ChannelLocator),
            'timestamp': ConjureFieldDefinition('timestamp', scout_checks_api_TimestampLocator)
        }

    def __init__(
            self,
            checklist_variable: Optional[str] = None,
            compute_node: Optional["scout_checks_api_ComputeNodeWithContext"] = None,
            function_rid: Optional[str] = None,
            series: Optional["scout_api_ChannelLocator"] = None,
            timestamp: Optional["scout_checks_api_TimestampLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (checklist_variable is not None) + (compute_node is not None) + (function_rid is not None) + (series is not None) + (timestamp is not None) != 1:
                raise ValueError('a union must contain a single member')

            if checklist_variable is not None:
                self._checklist_variable = checklist_variable
                self._type = 'checklistVariable'
            if compute_node is not None:
                self._compute_node = compute_node
                self._type = 'computeNode'
            if function_rid is not None:
                self._function_rid = function_rid
                self._type = 'functionRid'
            if series is not None:
                self._series = series
                self._type = 'series'
            if timestamp is not None:
                self._timestamp = timestamp
                self._type = 'timestamp'

        elif type_of_union == 'checklistVariable':
            if checklist_variable is None:
                raise ValueError('a union value must not be None')
            self._checklist_variable = checklist_variable
            self._type = 'checklistVariable'
        elif type_of_union == 'computeNode':
            if compute_node is None:
                raise ValueError('a union value must not be None')
            self._compute_node = compute_node
            self._type = 'computeNode'
        elif type_of_union == 'functionRid':
            if function_rid is None:
                raise ValueError('a union value must not be None')
            self._function_rid = function_rid
            self._type = 'functionRid'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'timestamp':
            if timestamp is None:
                raise ValueError('a union value must not be None')
            self._timestamp = timestamp
            self._type = 'timestamp'

    @builtins.property
    def checklist_variable(self) -> Optional[str]:
        """
        A pointer to a checklist level variable.
        """
        return self._checklist_variable

    @builtins.property
    def compute_node(self) -> Optional["scout_checks_api_ComputeNodeWithContext"]:
        return self._compute_node

    @builtins.property
    def function_rid(self) -> Optional[str]:
        return self._function_rid

    @builtins.property
    def series(self) -> Optional["scout_api_ChannelLocator"]:
        return self._series

    @builtins.property
    def timestamp(self) -> Optional["scout_checks_api_TimestampLocator"]:
        return self._timestamp

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_VariableLocatorVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_VariableLocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'checklistVariable' and self.checklist_variable is not None:
            return visitor._checklist_variable(self.checklist_variable)
        if self._type == 'computeNode' and self.compute_node is not None:
            return visitor._compute_node(self.compute_node)
        if self._type == 'functionRid' and self.function_rid is not None:
            return visitor._function_rid(self.function_rid)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'timestamp' and self.timestamp is not None:
            return visitor._timestamp(self.timestamp)


scout_checks_api_VariableLocator.__name__ = "VariableLocator"
scout_checks_api_VariableLocator.__qualname__ = "VariableLocator"
scout_checks_api_VariableLocator.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_VariableLocatorVisitor:

    @abstractmethod
    def _checklist_variable(self, checklist_variable: str) -> Any:
        pass

    @abstractmethod
    def _compute_node(self, compute_node: "scout_checks_api_ComputeNodeWithContext") -> Any:
        pass

    @abstractmethod
    def _function_rid(self, function_rid: str) -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_api_ChannelLocator") -> Any:
        pass

    @abstractmethod
    def _timestamp(self, timestamp: "scout_checks_api_TimestampLocator") -> Any:
        pass


scout_checks_api_VariableLocatorVisitor.__name__ = "VariableLocatorVisitor"
scout_checks_api_VariableLocatorVisitor.__qualname__ = "VariableLocatorVisitor"
scout_checks_api_VariableLocatorVisitor.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_VersionedChecklist(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_ChecklistRid),
            'metadata': ConjureFieldDefinition('metadata', scout_checks_api_ChecklistMetadata),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_Commit),
            'functions': ConjureFieldDefinition('functions', List[scout_checks_api_Function]),
            'checks': ConjureFieldDefinition('checks', List[scout_checks_api_ChecklistEntry]),
            'checklist_variables': ConjureFieldDefinition('checklistVariables', List[scout_checks_api_ChecklistVariable])
        }

    __slots__: List[str] = ['_rid', '_metadata', '_commit', '_functions', '_checks', '_checklist_variables']

    def __init__(self, checklist_variables: List["scout_checks_api_ChecklistVariable"], checks: List["scout_checks_api_ChecklistEntry"], commit: "scout_versioning_api_Commit", functions: List["scout_checks_api_Function"], metadata: "scout_checks_api_ChecklistMetadata", rid: str) -> None:
        self._rid = rid
        self._metadata = metadata
        self._commit = commit
        self._functions = functions
        self._checks = checks
        self._checklist_variables = checklist_variables

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def metadata(self) -> "scout_checks_api_ChecklistMetadata":
        return self._metadata

    @builtins.property
    def commit(self) -> "scout_versioning_api_Commit":
        return self._commit

    @builtins.property
    def functions(self) -> List["scout_checks_api_Function"]:
        """
        A list of functions that are available to be used by checks in this checklist.
        """
        return self._functions

    @builtins.property
    def checks(self) -> List["scout_checks_api_ChecklistEntry"]:
        return self._checks

    @builtins.property
    def checklist_variables(self) -> List["scout_checks_api_ChecklistVariable"]:
        """
        Variables that can be used in checks and functions. Variables are resolved in order of declaration.
If variable `a` depends on variable `b`, then `b` must be defined before `a` in the list.
        """
        return self._checklist_variables


scout_checks_api_VersionedChecklist.__name__ = "VersionedChecklist"
scout_checks_api_VersionedChecklist.__qualname__ = "VersionedChecklist"
scout_checks_api_VersionedChecklist.__module__ = "scout_service_api.scout_checks_api"


class scout_checks_api_VersionedChecklistPage(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'values': ConjureFieldDefinition('values', List[scout_checks_api_VersionedChecklist]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_values', '_next_page_token']

    def __init__(self, values: List["scout_checks_api_VersionedChecklist"], next_page_token: Optional[str] = None) -> None:
        self._values = values
        self._next_page_token = next_page_token

    @builtins.property
    def values(self) -> List["scout_checks_api_VersionedChecklist"]:
        return self._values

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_checks_api_VersionedChecklistPage.__name__ = "VersionedChecklistPage"
scout_checks_api_VersionedChecklistPage.__qualname__ = "VersionedChecklistPage"
scout_checks_api_VersionedChecklistPage.__module__ = "scout_service_api.scout_checks_api"


class scout_comparisonnotebook_api_AggregationType(ConjureUnionType):
    _max: Optional["scout_comparisonnotebook_api_Max"] = None
    _min: Optional["scout_comparisonnotebook_api_Min"] = None
    _mean: Optional["scout_comparisonnotebook_api_Mean"] = None
    _standard_deviation: Optional["scout_comparisonnotebook_api_StandardDeviation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'max': ConjureFieldDefinition('max', scout_comparisonnotebook_api_Max),
            'min': ConjureFieldDefinition('min', scout_comparisonnotebook_api_Min),
            'mean': ConjureFieldDefinition('mean', scout_comparisonnotebook_api_Mean),
            'standard_deviation': ConjureFieldDefinition('standardDeviation', scout_comparisonnotebook_api_StandardDeviation)
        }

    def __init__(
            self,
            max: Optional["scout_comparisonnotebook_api_Max"] = None,
            min: Optional["scout_comparisonnotebook_api_Min"] = None,
            mean: Optional["scout_comparisonnotebook_api_Mean"] = None,
            standard_deviation: Optional["scout_comparisonnotebook_api_StandardDeviation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (max is not None) + (min is not None) + (mean is not None) + (standard_deviation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if max is not None:
                self._max = max
                self._type = 'max'
            if min is not None:
                self._min = min
                self._type = 'min'
            if mean is not None:
                self._mean = mean
                self._type = 'mean'
            if standard_deviation is not None:
                self._standard_deviation = standard_deviation
                self._type = 'standardDeviation'

        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'mean':
            if mean is None:
                raise ValueError('a union value must not be None')
            self._mean = mean
            self._type = 'mean'
        elif type_of_union == 'standardDeviation':
            if standard_deviation is None:
                raise ValueError('a union value must not be None')
            self._standard_deviation = standard_deviation
            self._type = 'standardDeviation'

    @builtins.property
    def max(self) -> Optional["scout_comparisonnotebook_api_Max"]:
        return self._max

    @builtins.property
    def min(self) -> Optional["scout_comparisonnotebook_api_Min"]:
        return self._min

    @builtins.property
    def mean(self) -> Optional["scout_comparisonnotebook_api_Mean"]:
        return self._mean

    @builtins.property
    def standard_deviation(self) -> Optional["scout_comparisonnotebook_api_StandardDeviation"]:
        return self._standard_deviation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_AggregationTypeVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_AggregationTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'mean' and self.mean is not None:
            return visitor._mean(self.mean)
        if self._type == 'standardDeviation' and self.standard_deviation is not None:
            return visitor._standard_deviation(self.standard_deviation)


scout_comparisonnotebook_api_AggregationType.__name__ = "AggregationType"
scout_comparisonnotebook_api_AggregationType.__qualname__ = "AggregationType"
scout_comparisonnotebook_api_AggregationType.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_AggregationTypeVisitor:

    @abstractmethod
    def _max(self, max: "scout_comparisonnotebook_api_Max") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_comparisonnotebook_api_Min") -> Any:
        pass

    @abstractmethod
    def _mean(self, mean: "scout_comparisonnotebook_api_Mean") -> Any:
        pass

    @abstractmethod
    def _standard_deviation(self, standard_deviation: "scout_comparisonnotebook_api_StandardDeviation") -> Any:
        pass


scout_comparisonnotebook_api_AggregationTypeVisitor.__name__ = "AggregationTypeVisitor"
scout_comparisonnotebook_api_AggregationTypeVisitor.__qualname__ = "AggregationTypeVisitor"
scout_comparisonnotebook_api_AggregationTypeVisitor.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ChannelVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'variable_name': ConjureFieldDefinition('variableName', scout_comparisonnotebook_api_VariableName),
            'value': ConjureFieldDefinition('value', scout_comparisonnotebook_api_ComputeNodeWithContext),
            'data_scope': ConjureFieldDefinition('dataScope', scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScope)
        }

    __slots__: List[str] = ['_display_name', '_variable_name', '_value', '_data_scope']

    def __init__(self, data_scope: "scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScope", value: "scout_comparisonnotebook_api_ComputeNodeWithContext", variable_name: str, display_name: Optional[str] = None) -> None:
        self._display_name = display_name
        self._variable_name = variable_name
        self._value = value
        self._data_scope = data_scope

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def value(self) -> "scout_comparisonnotebook_api_ComputeNodeWithContext":
        return self._value

    @builtins.property
    def data_scope(self) -> "scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScope":
        return self._data_scope


scout_comparisonnotebook_api_ChannelVariable.__name__ = "ChannelVariable"
scout_comparisonnotebook_api_ChannelVariable.__qualname__ = "ChannelVariable"
scout_comparisonnotebook_api_ChannelVariable.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableColumn(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'locator': ConjureFieldDefinition('locator', scout_comparisonnotebook_api_VariableLocator),
            'visualization_options': ConjureFieldDefinition('visualizationOptions', scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions)
        }

    __slots__: List[str] = ['_title', '_locator', '_visualization_options']

    def __init__(self, locator: "scout_comparisonnotebook_api_VariableLocator", visualization_options: "scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions", title: Optional[str] = None) -> None:
        self._title = title
        self._locator = locator
        self._visualization_options = visualization_options

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def locator(self) -> "scout_comparisonnotebook_api_VariableLocator":
        return self._locator

    @builtins.property
    def visualization_options(self) -> "scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions":
        return self._visualization_options


scout_comparisonnotebook_api_ComparisonTableColumn.__name__ = "ComparisonTableColumn"
scout_comparisonnotebook_api_ComparisonTableColumn.__qualname__ = "ComparisonTableColumn"
scout_comparisonnotebook_api_ComparisonTableColumn.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableColumnOptions(ConjureEnumType):

    AXIS = 'AXIS'
    '''AXIS'''
    BARS = 'BARS'
    '''BARS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_comparisonnotebook_api_ComparisonTableColumnOptions.__name__ = "ComparisonTableColumnOptions"
scout_comparisonnotebook_api_ComparisonTableColumnOptions.__qualname__ = "ComparisonTableColumnOptions"
scout_comparisonnotebook_api_ComparisonTableColumnOptions.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'format': ConjureFieldDefinition('format', scout_comparisonnotebook_api_ComparisonTableColumnOptions)
        }

    __slots__: List[str] = ['_format']

    def __init__(self, format: "scout_comparisonnotebook_api_ComparisonTableColumnOptions") -> None:
        self._format = format

    @builtins.property
    def format(self) -> "scout_comparisonnotebook_api_ComparisonTableColumnOptions":
        return self._format


scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions.__name__ = "ComparisonTableColumnVisualizationOptions"
scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions.__qualname__ = "ComparisonTableColumnVisualizationOptions"
scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableDefinition(ConjureUnionType):
    _v1: Optional["scout_comparisonnotebook_api_ComparisonTableDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_comparisonnotebook_api_ComparisonTableDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_comparisonnotebook_api_ComparisonTableDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_comparisonnotebook_api_ComparisonTableDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_comparisonnotebook_api_ComparisonTableDefinition.__name__ = "ComparisonTableDefinition"
scout_comparisonnotebook_api_ComparisonTableDefinition.__qualname__ = "ComparisonTableDefinition"
scout_comparisonnotebook_api_ComparisonTableDefinition.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_comparisonnotebook_api_ComparisonTableDefinitionV1") -> Any:
        pass


scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor.__name__ = "ComparisonTableDefinitionVisitor"
scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor.__qualname__ = "ComparisonTableDefinitionVisitor"
scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'range_aggregations': ConjureFieldDefinition('rangeAggregations', List[scout_comparisonnotebook_api_VariableName]),
            'visualization_options': ConjureFieldDefinition('visualizationOptions', scout_comparisonnotebook_api_ComparisonTableVisualizationOptions),
            'columns': ConjureFieldDefinition('columns', List[scout_comparisonnotebook_api_ComparisonTableColumn])
        }

    __slots__: List[str] = ['_title', '_range_aggregations', '_visualization_options', '_columns']

    def __init__(self, columns: List["scout_comparisonnotebook_api_ComparisonTableColumn"], range_aggregations: List[str], visualization_options: "scout_comparisonnotebook_api_ComparisonTableVisualizationOptions", title: Optional[str] = None) -> None:
        self._title = title
        self._range_aggregations = range_aggregations
        self._visualization_options = visualization_options
        self._columns = columns

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def range_aggregations(self) -> List[str]:
        return self._range_aggregations

    @builtins.property
    def visualization_options(self) -> "scout_comparisonnotebook_api_ComparisonTableVisualizationOptions":
        return self._visualization_options

    @builtins.property
    def columns(self) -> List["scout_comparisonnotebook_api_ComparisonTableColumn"]:
        return self._columns


scout_comparisonnotebook_api_ComparisonTableDefinitionV1.__name__ = "ComparisonTableDefinitionV1"
scout_comparisonnotebook_api_ComparisonTableDefinitionV1.__qualname__ = "ComparisonTableDefinitionV1"
scout_comparisonnotebook_api_ComparisonTableDefinitionV1.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableVisualizationOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'aggregation_colors': ConjureFieldDefinition('aggregationColors', Dict[scout_comparisonnotebook_api_VariableName, scout_api_HexColor])
        }

    __slots__: List[str] = ['_aggregation_colors']

    def __init__(self, aggregation_colors: Dict[str, str]) -> None:
        self._aggregation_colors = aggregation_colors

    @builtins.property
    def aggregation_colors(self) -> Dict[str, str]:
        return self._aggregation_colors


scout_comparisonnotebook_api_ComparisonTableVisualizationOptions.__name__ = "ComparisonTableVisualizationOptions"
scout_comparisonnotebook_api_ComparisonTableVisualizationOptions.__qualname__ = "ComparisonTableVisualizationOptions"
scout_comparisonnotebook_api_ComparisonTableVisualizationOptions.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonWorkbookContent(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_variables': ConjureFieldDefinition('channelVariables', scout_comparisonnotebook_api_ComparisonChannelVariableMap),
            'charts': ConjureFieldDefinition('charts', scout_comparisonnotebook_api_ComparisonChartDefinitionMap),
            'visualizations': ConjureFieldDefinition('visualizations', scout_comparisonnotebook_api_ComparisonVizDefinitionMap)
        }

    __slots__: List[str] = ['_channel_variables', '_charts', '_visualizations']

    def __init__(self, channel_variables: Dict[str, "scout_comparisonnotebook_api_ChannelVariable"], charts: Dict[str, "scout_comparisonnotebook_api_VizDefinition"], visualizations: Dict[str, "scout_comparisonnotebook_api_VizDefinition"]) -> None:
        self._channel_variables = channel_variables
        self._charts = charts
        self._visualizations = visualizations

    @builtins.property
    def channel_variables(self) -> Dict[str, "scout_comparisonnotebook_api_ChannelVariable"]:
        return self._channel_variables

    @builtins.property
    def charts(self) -> Dict[str, "scout_comparisonnotebook_api_VizDefinition"]:
        return self._charts

    @builtins.property
    def visualizations(self) -> Dict[str, "scout_comparisonnotebook_api_VizDefinition"]:
        """
        empty for now. All visualizations are still being returned in charts.
        """
        return self._visualizations


scout_comparisonnotebook_api_ComparisonWorkbookContent.__name__ = "ComparisonWorkbookContent"
scout_comparisonnotebook_api_ComparisonWorkbookContent.__qualname__ = "ComparisonWorkbookContent"
scout_comparisonnotebook_api_ComparisonWorkbookContent.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonWorkbookContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_comparisonnotebook_api_VariableName, scout_comparisonnotebook_api_VariableLocator])
        }

    __slots__: List[str] = ['_variables']

    def __init__(self, variables: Dict[str, "scout_comparisonnotebook_api_VariableLocator"]) -> None:
        self._variables = variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_comparisonnotebook_api_VariableLocator"]:
        return self._variables


scout_comparisonnotebook_api_ComparisonWorkbookContext.__name__ = "ComparisonWorkbookContext"
scout_comparisonnotebook_api_ComparisonWorkbookContext.__qualname__ = "ComparisonWorkbookContext"
scout_comparisonnotebook_api_ComparisonWorkbookContext.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScope(ConjureUnionType):
    _runs: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'runs': ConjureFieldDefinition('runs', List[scout_run_api_RunRid])
        }

    def __init__(
            self,
            runs: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (runs is not None) != 1:
                raise ValueError('a union must contain a single member')

            if runs is not None:
                self._runs = runs
                self._type = 'runs'

        elif type_of_union == 'runs':
            if runs is None:
                raise ValueError('a union value must not be None')
            self._runs = runs
            self._type = 'runs'

    @builtins.property
    def runs(self) -> Optional[List[str]]:
        return self._runs

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScopeVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScopeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'runs' and self.runs is not None:
            return visitor._runs(self.runs)


scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScope.__name__ = "ComparisonWorkbookVariableDataScope"
scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScope.__qualname__ = "ComparisonWorkbookVariableDataScope"
scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScope.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScopeVisitor:

    @abstractmethod
    def _runs(self, runs: List[str]) -> Any:
        pass


scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScopeVisitor.__name__ = "ComparisonWorkbookVariableDataScopeVisitor"
scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScopeVisitor.__qualname__ = "ComparisonWorkbookVariableDataScopeVisitor"
scout_comparisonnotebook_api_ComparisonWorkbookVariableDataScopeVisitor.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComputeNodeWithContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'compute_node': ConjureFieldDefinition('computeNode', scout_compute_api_ComputeNode),
            'context': ConjureFieldDefinition('context', scout_comparisonnotebook_api_ComparisonWorkbookContext),
            'supplemental_context': ConjureFieldDefinition('supplementalContext', scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext)
        }

    __slots__: List[str] = ['_compute_node', '_context', '_supplemental_context']

    def __init__(self, compute_node: "scout_compute_api_ComputeNode", context: "scout_comparisonnotebook_api_ComparisonWorkbookContext", supplemental_context: "scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext") -> None:
        self._compute_node = compute_node
        self._context = context
        self._supplemental_context = supplemental_context

    @builtins.property
    def compute_node(self) -> "scout_compute_api_ComputeNode":
        return self._compute_node

    @builtins.property
    def context(self) -> "scout_comparisonnotebook_api_ComparisonWorkbookContext":
        return self._context

    @builtins.property
    def supplemental_context(self) -> "scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext":
        return self._supplemental_context


scout_comparisonnotebook_api_ComputeNodeWithContext.__name__ = "ComputeNodeWithContext"
scout_comparisonnotebook_api_ComputeNodeWithContext.__qualname__ = "ComputeNodeWithContext"
scout_comparisonnotebook_api_ComputeNodeWithContext.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_Max(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_Max.__name__ = "Max"
scout_comparisonnotebook_api_Max.__qualname__ = "Max"
scout_comparisonnotebook_api_Max.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_Mean(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_Mean.__name__ = "Mean"
scout_comparisonnotebook_api_Mean.__qualname__ = "Mean"
scout_comparisonnotebook_api_Mean.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_Min(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_Min.__name__ = "Min"
scout_comparisonnotebook_api_Min.__qualname__ = "Min"
scout_comparisonnotebook_api_Min.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_RangeAggregationContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables_to_aggregate': ConjureFieldDefinition('variablesToAggregate', List[scout_comparisonnotebook_api_VariableWithAggregation])
        }

    __slots__: List[str] = ['_variables_to_aggregate']

    def __init__(self, variables_to_aggregate: List["scout_comparisonnotebook_api_VariableWithAggregation"]) -> None:
        self._variables_to_aggregate = variables_to_aggregate

    @builtins.property
    def variables_to_aggregate(self) -> List["scout_comparisonnotebook_api_VariableWithAggregation"]:
        return self._variables_to_aggregate


scout_comparisonnotebook_api_RangeAggregationContext.__name__ = "RangeAggregationContext"
scout_comparisonnotebook_api_RangeAggregationContext.__qualname__ = "RangeAggregationContext"
scout_comparisonnotebook_api_RangeAggregationContext.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_StandardDeviation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_StandardDeviation.__name__ = "StandardDeviation"
scout_comparisonnotebook_api_StandardDeviation.__qualname__ = "StandardDeviation"
scout_comparisonnotebook_api_StandardDeviation.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext(ConjureUnionType):
    """This is used to allow variables to specify additional context that does not fit well into the general shape of
a compute node. For example, a range aggregation variable represents a bulk computation across several inputs,
whose context is specified here instead."""
    _none: Optional["scout_rids_api_Empty"] = None
    _range_aggregation: Optional["scout_comparisonnotebook_api_RangeAggregationContext"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'none': ConjureFieldDefinition('none', scout_rids_api_Empty),
            'range_aggregation': ConjureFieldDefinition('rangeAggregation', scout_comparisonnotebook_api_RangeAggregationContext)
        }

    def __init__(
            self,
            none: Optional["scout_rids_api_Empty"] = None,
            range_aggregation: Optional["scout_comparisonnotebook_api_RangeAggregationContext"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (none is not None) + (range_aggregation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if none is not None:
                self._none = none
                self._type = 'none'
            if range_aggregation is not None:
                self._range_aggregation = range_aggregation
                self._type = 'rangeAggregation'

        elif type_of_union == 'none':
            if none is None:
                raise ValueError('a union value must not be None')
            self._none = none
            self._type = 'none'
        elif type_of_union == 'rangeAggregation':
            if range_aggregation is None:
                raise ValueError('a union value must not be None')
            self._range_aggregation = range_aggregation
            self._type = 'rangeAggregation'

    @builtins.property
    def none(self) -> Optional["scout_rids_api_Empty"]:
        return self._none

    @builtins.property
    def range_aggregation(self) -> Optional["scout_comparisonnotebook_api_RangeAggregationContext"]:
        return self._range_aggregation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor'.format(visitor.__class__.__name__))
        if self._type == 'none' and self.none is not None:
            return visitor._none(self.none)
        if self._type == 'rangeAggregation' and self.range_aggregation is not None:
            return visitor._range_aggregation(self.range_aggregation)


scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext.__name__ = "SupplementalComparisonWorkbookContext"
scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext.__qualname__ = "SupplementalComparisonWorkbookContext"
scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor:

    @abstractmethod
    def _none(self, none: "scout_rids_api_Empty") -> Any:
        pass

    @abstractmethod
    def _range_aggregation(self, range_aggregation: "scout_comparisonnotebook_api_RangeAggregationContext") -> Any:
        pass


scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor.__name__ = "SupplementalComparisonWorkbookContextVisitor"
scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor.__qualname__ = "SupplementalComparisonWorkbookContextVisitor"
scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VariableLocator(ConjureUnionType):
    _comparison_workbook_variable: Optional[str] = None
    _series: Optional["scout_api_ChannelLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comparison_workbook_variable': ConjureFieldDefinition('comparisonWorkbookVariable', scout_comparisonnotebook_api_VariableName),
            'series': ConjureFieldDefinition('series', scout_api_ChannelLocator)
        }

    def __init__(
            self,
            comparison_workbook_variable: Optional[str] = None,
            series: Optional["scout_api_ChannelLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (comparison_workbook_variable is not None) + (series is not None) != 1:
                raise ValueError('a union must contain a single member')

            if comparison_workbook_variable is not None:
                self._comparison_workbook_variable = comparison_workbook_variable
                self._type = 'comparisonWorkbookVariable'
            if series is not None:
                self._series = series
                self._type = 'series'

        elif type_of_union == 'comparisonWorkbookVariable':
            if comparison_workbook_variable is None:
                raise ValueError('a union value must not be None')
            self._comparison_workbook_variable = comparison_workbook_variable
            self._type = 'comparisonWorkbookVariable'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'

    @builtins.property
    def comparison_workbook_variable(self) -> Optional[str]:
        return self._comparison_workbook_variable

    @builtins.property
    def series(self) -> Optional["scout_api_ChannelLocator"]:
        return self._series

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_VariableLocatorVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_VariableLocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'comparisonWorkbookVariable' and self.comparison_workbook_variable is not None:
            return visitor._comparison_workbook_variable(self.comparison_workbook_variable)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)


scout_comparisonnotebook_api_VariableLocator.__name__ = "VariableLocator"
scout_comparisonnotebook_api_VariableLocator.__qualname__ = "VariableLocator"
scout_comparisonnotebook_api_VariableLocator.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VariableLocatorVisitor:

    @abstractmethod
    def _comparison_workbook_variable(self, comparison_workbook_variable: str) -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_api_ChannelLocator") -> Any:
        pass


scout_comparisonnotebook_api_VariableLocatorVisitor.__name__ = "VariableLocatorVisitor"
scout_comparisonnotebook_api_VariableLocatorVisitor.__qualname__ = "VariableLocatorVisitor"
scout_comparisonnotebook_api_VariableLocatorVisitor.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VariableWithAggregation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'locator': ConjureFieldDefinition('locator', scout_comparisonnotebook_api_VariableLocator),
            'aggregation_type': ConjureFieldDefinition('aggregationType', scout_comparisonnotebook_api_AggregationType)
        }

    __slots__: List[str] = ['_locator', '_aggregation_type']

    def __init__(self, aggregation_type: "scout_comparisonnotebook_api_AggregationType", locator: "scout_comparisonnotebook_api_VariableLocator") -> None:
        self._locator = locator
        self._aggregation_type = aggregation_type

    @builtins.property
    def locator(self) -> "scout_comparisonnotebook_api_VariableLocator":
        return self._locator

    @builtins.property
    def aggregation_type(self) -> "scout_comparisonnotebook_api_AggregationType":
        return self._aggregation_type


scout_comparisonnotebook_api_VariableWithAggregation.__name__ = "VariableWithAggregation"
scout_comparisonnotebook_api_VariableWithAggregation.__qualname__ = "VariableWithAggregation"
scout_comparisonnotebook_api_VariableWithAggregation.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VizDefinition(ConjureUnionType):
    _table: Optional["scout_comparisonnotebook_api_ComparisonTableDefinition"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', scout_comparisonnotebook_api_ComparisonTableDefinition)
        }

    def __init__(
            self,
            table: Optional["scout_comparisonnotebook_api_ComparisonTableDefinition"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (table is not None) != 1:
                raise ValueError('a union must contain a single member')

            if table is not None:
                self._table = table
                self._type = 'table'

        elif type_of_union == 'table':
            if table is None:
                raise ValueError('a union value must not be None')
            self._table = table
            self._type = 'table'

    @builtins.property
    def table(self) -> Optional["scout_comparisonnotebook_api_ComparisonTableDefinition"]:
        return self._table

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_VizDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_VizDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'table' and self.table is not None:
            return visitor._table(self.table)


scout_comparisonnotebook_api_VizDefinition.__name__ = "VizDefinition"
scout_comparisonnotebook_api_VizDefinition.__qualname__ = "VizDefinition"
scout_comparisonnotebook_api_VizDefinition.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VizDefinitionVisitor:

    @abstractmethod
    def _table(self, table: "scout_comparisonnotebook_api_ComparisonTableDefinition") -> Any:
        pass


scout_comparisonnotebook_api_VizDefinitionVisitor.__name__ = "VizDefinitionVisitor"
scout_comparisonnotebook_api_VizDefinitionVisitor.__qualname__ = "VizDefinitionVisitor"
scout_comparisonnotebook_api_VizDefinitionVisitor.__module__ = "scout_service_api.scout_comparisonnotebook_api"


class scout_comparisonrun_api_ComparisonRun(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid),
            'enabled': ConjureFieldDefinition('enabled', bool),
            'offset_override': ConjureFieldDefinition('offsetOverride', OptionalTypeWrapper[scout_comparisonrun_api_Offset])
        }

    __slots__: List[str] = ['_run_rid', '_enabled', '_offset_override']

    def __init__(self, enabled: bool, run_rid: str, offset_override: Optional["scout_comparisonrun_api_Offset"] = None) -> None:
        self._run_rid = run_rid
        self._enabled = enabled
        self._offset_override = offset_override

    @builtins.property
    def run_rid(self) -> str:
        return self._run_rid

    @builtins.property
    def enabled(self) -> bool:
        return self._enabled

    @builtins.property
    def offset_override(self) -> Optional["scout_comparisonrun_api_Offset"]:
        return self._offset_override


scout_comparisonrun_api_ComparisonRun.__name__ = "ComparisonRun"
scout_comparisonrun_api_ComparisonRun.__qualname__ = "ComparisonRun"
scout_comparisonrun_api_ComparisonRun.__module__ = "scout_service_api.scout_comparisonrun_api"


class scout_comparisonrun_api_ComparisonRunGroup(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'name': ConjureFieldDefinition('name', str),
            'offset': ConjureFieldDefinition('offset', scout_comparisonrun_api_Offset),
            'offset_anchor': ConjureFieldDefinition('offsetAnchor', scout_comparisonrun_api_OffsetAnchor),
            'runs': ConjureFieldDefinition('runs', List[scout_comparisonrun_api_ComparisonRun]),
            'color': ConjureFieldDefinition('color', OptionalTypeWrapper[scout_api_HexColor])
        }

    __slots__: List[str] = ['_uuid', '_name', '_offset', '_offset_anchor', '_runs', '_color']

    def __init__(self, name: str, offset: "scout_comparisonrun_api_Offset", offset_anchor: "scout_comparisonrun_api_OffsetAnchor", runs: List["scout_comparisonrun_api_ComparisonRun"], uuid: str, color: Optional[str] = None) -> None:
        self._uuid = uuid
        self._name = name
        self._offset = offset
        self._offset_anchor = offset_anchor
        self._runs = runs
        self._color = color

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def offset(self) -> "scout_comparisonrun_api_Offset":
        return self._offset

    @builtins.property
    def offset_anchor(self) -> "scout_comparisonrun_api_OffsetAnchor":
        return self._offset_anchor

    @builtins.property
    def runs(self) -> List["scout_comparisonrun_api_ComparisonRun"]:
        return self._runs

    @builtins.property
    def color(self) -> Optional[str]:
        return self._color


scout_comparisonrun_api_ComparisonRunGroup.__name__ = "ComparisonRunGroup"
scout_comparisonrun_api_ComparisonRunGroup.__qualname__ = "ComparisonRunGroup"
scout_comparisonrun_api_ComparisonRunGroup.__module__ = "scout_service_api.scout_comparisonrun_api"


class scout_comparisonrun_api_Offset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', int),
            'unit': ConjureFieldDefinition('unit', scout_compute_api_TimeUnit)
        }

    __slots__: List[str] = ['_value', '_unit']

    def __init__(self, unit: "scout_compute_api_TimeUnit", value: int) -> None:
        self._value = value
        self._unit = unit

    @builtins.property
    def value(self) -> int:
        return self._value

    @builtins.property
    def unit(self) -> "scout_compute_api_TimeUnit":
        return self._unit


scout_comparisonrun_api_Offset.__name__ = "Offset"
scout_comparisonrun_api_Offset.__qualname__ = "Offset"
scout_comparisonrun_api_Offset.__module__ = "scout_service_api.scout_comparisonrun_api"


class scout_comparisonrun_api_OffsetAnchor(ConjureUnionType):
    _run: Optional["scout_comparisonrun_api_OffsetRunAnchor"] = None
    _series: Optional["scout_comparisonrun_api_OffsetSeriesAnchor"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run': ConjureFieldDefinition('run', scout_comparisonrun_api_OffsetRunAnchor),
            'series': ConjureFieldDefinition('series', scout_comparisonrun_api_OffsetSeriesAnchor)
        }

    def __init__(
            self,
            run: Optional["scout_comparisonrun_api_OffsetRunAnchor"] = None,
            series: Optional["scout_comparisonrun_api_OffsetSeriesAnchor"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (run is not None) + (series is not None) != 1:
                raise ValueError('a union must contain a single member')

            if run is not None:
                self._run = run
                self._type = 'run'
            if series is not None:
                self._series = series
                self._type = 'series'

        elif type_of_union == 'run':
            if run is None:
                raise ValueError('a union value must not be None')
            self._run = run
            self._type = 'run'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'

    @builtins.property
    def run(self) -> Optional["scout_comparisonrun_api_OffsetRunAnchor"]:
        return self._run

    @builtins.property
    def series(self) -> Optional["scout_comparisonrun_api_OffsetSeriesAnchor"]:
        return self._series

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonrun_api_OffsetAnchorVisitor):
            raise ValueError('{} is not an instance of scout_comparisonrun_api_OffsetAnchorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'run' and self.run is not None:
            return visitor._run(self.run)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)


scout_comparisonrun_api_OffsetAnchor.__name__ = "OffsetAnchor"
scout_comparisonrun_api_OffsetAnchor.__qualname__ = "OffsetAnchor"
scout_comparisonrun_api_OffsetAnchor.__module__ = "scout_service_api.scout_comparisonrun_api"


class scout_comparisonrun_api_OffsetAnchorVisitor:

    @abstractmethod
    def _run(self, run: "scout_comparisonrun_api_OffsetRunAnchor") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_comparisonrun_api_OffsetSeriesAnchor") -> Any:
        pass


scout_comparisonrun_api_OffsetAnchorVisitor.__name__ = "OffsetAnchorVisitor"
scout_comparisonrun_api_OffsetAnchorVisitor.__qualname__ = "OffsetAnchorVisitor"
scout_comparisonrun_api_OffsetAnchorVisitor.__module__ = "scout_service_api.scout_comparisonrun_api"


class scout_comparisonrun_api_OffsetRunAnchor(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonrun_api_OffsetRunAnchor.__name__ = "OffsetRunAnchor"
scout_comparisonrun_api_OffsetRunAnchor.__qualname__ = "OffsetRunAnchor"
scout_comparisonrun_api_OffsetRunAnchor.__module__ = "scout_service_api.scout_comparisonrun_api"


class scout_comparisonrun_api_OffsetSeriesAnchor(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_variable': ConjureFieldDefinition('seriesVariable', scout_channelvariables_api_ChannelVariableName)
        }

    __slots__: List[str] = ['_series_variable']

    def __init__(self, series_variable: str) -> None:
        self._series_variable = series_variable

    @builtins.property
    def series_variable(self) -> str:
        return self._series_variable


scout_comparisonrun_api_OffsetSeriesAnchor.__name__ = "OffsetSeriesAnchor"
scout_comparisonrun_api_OffsetSeriesAnchor.__qualname__ = "OffsetSeriesAnchor"
scout_comparisonrun_api_OffsetSeriesAnchor.__module__ = "scout_service_api.scout_comparisonrun_api"


class scout_compute_api_AfterPersistenceWindow(ConjureBeanType):
    """
    The first point in the output range will be the first point after the condition has been true
for the min duration and min points.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_AfterPersistenceWindow.__name__ = "AfterPersistenceWindow"
scout_compute_api_AfterPersistenceWindow.__qualname__ = "AfterPersistenceWindow"
scout_compute_api_AfterPersistenceWindow.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_AggregateEnumSeriesNode(ConjureBeanType):
    """
    Aggregates values with duplicate timestamps in the input series values into a single value using the specified aggregation function.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_EnumAggregationFunction)
        }

    __slots__: List[str] = ['_input', '_function']

    def __init__(self, function: "scout_compute_api_EnumAggregationFunction", input: "scout_compute_api_EnumSeriesNode") -> None:
        self._input = input
        self._function = function

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_EnumAggregationFunction":
        return self._function


scout_compute_api_AggregateEnumSeriesNode.__name__ = "AggregateEnumSeriesNode"
scout_compute_api_AggregateEnumSeriesNode.__qualname__ = "AggregateEnumSeriesNode"
scout_compute_api_AggregateEnumSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_AggregateNumericSeriesNode(ConjureBeanType):
    """
    Aggregates values with duplicate timestamps in the input series values into a single value using the specified aggregation function.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_NumericAggregationFunction)
        }

    __slots__: List[str] = ['_input', '_function']

    def __init__(self, function: "scout_compute_api_NumericAggregationFunction", input: "scout_compute_api_NumericSeriesNode") -> None:
        self._input = input
        self._function = function

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_NumericAggregationFunction":
        return self._function


scout_compute_api_AggregateNumericSeriesNode.__name__ = "AggregateNumericSeriesNode"
scout_compute_api_AggregateNumericSeriesNode.__qualname__ = "AggregateNumericSeriesNode"
scout_compute_api_AggregateNumericSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_AllowNegativeValues(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_AllowNegativeValues.__name__ = "AllowNegativeValues"
scout_compute_api_AllowNegativeValues.__qualname__ = "AllowNegativeValues"
scout_compute_api_AllowNegativeValues.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_LocalVariableName, scout_compute_api_NumericSeriesNode]),
            'expression': ConjureFieldDefinition('expression', str),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_expression', '_interpolation_configuration']

    def __init__(self, expression: str, inputs: Dict[str, "scout_compute_api_NumericSeriesNode"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._expression = expression
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def expression(self) -> str:
        return self._expression

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """
        Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_ArithmeticSeriesNode.__name__ = "ArithmeticSeriesNode"
scout_compute_api_ArithmeticSeriesNode.__qualname__ = "ArithmeticSeriesNode"
scout_compute_api_ArithmeticSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_Average(ConjureBeanType):
    """
    A average that gives the same weight to each observation inside the time window
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Average.__name__ = "Average"
scout_compute_api_Average.__qualname__ = "Average"
scout_compute_api_Average.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BinaryArithmeticOperation(ConjureEnumType):

    ATAN2 = 'ATAN2'
    '''ATAN2'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_BinaryArithmeticOperation.__name__ = "BinaryArithmeticOperation"
scout_compute_api_BinaryArithmeticOperation.__qualname__ = "BinaryArithmeticOperation"
scout_compute_api_BinaryArithmeticOperation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BinaryArithmeticSeriesNode(ConjureBeanType):
    """
    Applies a point-wise transformation to a pair of series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input1': ConjureFieldDefinition('input1', scout_compute_api_NumericSeriesNode),
            'input2': ConjureFieldDefinition('input2', scout_compute_api_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_BinaryArithmeticOperation),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_input1', '_input2', '_operation', '_interpolation_configuration']

    def __init__(self, input1: "scout_compute_api_NumericSeriesNode", input2: "scout_compute_api_NumericSeriesNode", operation: "scout_compute_api_BinaryArithmeticOperation", interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._input1 = input1
        self._input2 = input2
        self._operation = operation
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def input1(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input1

    @builtins.property
    def input2(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input2

    @builtins.property
    def operation(self) -> "scout_compute_api_BinaryArithmeticOperation":
        return self._operation

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """
        Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_BinaryArithmeticSeriesNode.__name__ = "BinaryArithmeticSeriesNode"
scout_compute_api_BinaryArithmeticSeriesNode.__qualname__ = "BinaryArithmeticSeriesNode"
scout_compute_api_BinaryArithmeticSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BitAndFunction(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operand': ConjureFieldDefinition('operand', int)
        }

    __slots__: List[str] = ['_operand']

    def __init__(self, operand: int) -> None:
        self._operand = operand

    @builtins.property
    def operand(self) -> int:
        return self._operand


scout_compute_api_BitAndFunction.__name__ = "BitAndFunction"
scout_compute_api_BitAndFunction.__qualname__ = "BitAndFunction"
scout_compute_api_BitAndFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BitOperationFunction(ConjureUnionType):
    _and_: Optional["scout_compute_api_BitAndFunction"] = None
    _or_: Optional["scout_compute_api_BitOrFunction"] = None
    _xor: Optional["scout_compute_api_BitXorFunction"] = None
    _bit_test: Optional["scout_compute_api_BitTestFunction"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', scout_compute_api_BitAndFunction),
            'or_': ConjureFieldDefinition('or', scout_compute_api_BitOrFunction),
            'xor': ConjureFieldDefinition('xor', scout_compute_api_BitXorFunction),
            'bit_test': ConjureFieldDefinition('bitTest', scout_compute_api_BitTestFunction)
        }

    def __init__(
            self,
            and_: Optional["scout_compute_api_BitAndFunction"] = None,
            or_: Optional["scout_compute_api_BitOrFunction"] = None,
            xor: Optional["scout_compute_api_BitXorFunction"] = None,
            bit_test: Optional["scout_compute_api_BitTestFunction"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (xor is not None) + (bit_test is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if xor is not None:
                self._xor = xor
                self._type = 'xor'
            if bit_test is not None:
                self._bit_test = bit_test
                self._type = 'bitTest'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'xor':
            if xor is None:
                raise ValueError('a union value must not be None')
            self._xor = xor
            self._type = 'xor'
        elif type_of_union == 'bitTest':
            if bit_test is None:
                raise ValueError('a union value must not be None')
            self._bit_test = bit_test
            self._type = 'bitTest'

    @builtins.property
    def and_(self) -> Optional["scout_compute_api_BitAndFunction"]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional["scout_compute_api_BitOrFunction"]:
        return self._or_

    @builtins.property
    def xor(self) -> Optional["scout_compute_api_BitXorFunction"]:
        return self._xor

    @builtins.property
    def bit_test(self) -> Optional["scout_compute_api_BitTestFunction"]:
        return self._bit_test

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_BitOperationFunctionVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_BitOperationFunctionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'xor' and self.xor is not None:
            return visitor._xor(self.xor)
        if self._type == 'bitTest' and self.bit_test is not None:
            return visitor._bit_test(self.bit_test)


scout_compute_api_BitOperationFunction.__name__ = "BitOperationFunction"
scout_compute_api_BitOperationFunction.__qualname__ = "BitOperationFunction"
scout_compute_api_BitOperationFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BitOperationFunctionVisitor:

    @abstractmethod
    def _and(self, and_: "scout_compute_api_BitAndFunction") -> Any:
        pass

    @abstractmethod
    def _or(self, or_: "scout_compute_api_BitOrFunction") -> Any:
        pass

    @abstractmethod
    def _xor(self, xor: "scout_compute_api_BitXorFunction") -> Any:
        pass

    @abstractmethod
    def _bit_test(self, bit_test: "scout_compute_api_BitTestFunction") -> Any:
        pass


scout_compute_api_BitOperationFunctionVisitor.__name__ = "BitOperationFunctionVisitor"
scout_compute_api_BitOperationFunctionVisitor.__qualname__ = "BitOperationFunctionVisitor"
scout_compute_api_BitOperationFunctionVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BitOperationSeriesNode(ConjureBeanType):
    """
    Casts input series values to long before applying the bitwise operation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_BitOperationFunction)
        }

    __slots__: List[str] = ['_input', '_function']

    def __init__(self, function: "scout_compute_api_BitOperationFunction", input: "scout_compute_api_NumericSeriesNode") -> None:
        self._input = input
        self._function = function

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_BitOperationFunction":
        return self._function


scout_compute_api_BitOperationSeriesNode.__name__ = "BitOperationSeriesNode"
scout_compute_api_BitOperationSeriesNode.__qualname__ = "BitOperationSeriesNode"
scout_compute_api_BitOperationSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BitOrFunction(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operand': ConjureFieldDefinition('operand', int)
        }

    __slots__: List[str] = ['_operand']

    def __init__(self, operand: int) -> None:
        self._operand = operand

    @builtins.property
    def operand(self) -> int:
        return self._operand


scout_compute_api_BitOrFunction.__name__ = "BitOrFunction"
scout_compute_api_BitOrFunction.__qualname__ = "BitOrFunction"
scout_compute_api_BitOrFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BitTestFunction(ConjureBeanType):
    """
    Returns the bit at the specified index, where the right-most bit has index 0.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'index': ConjureFieldDefinition('index', int)
        }

    __slots__: List[str] = ['_index']

    def __init__(self, index: int) -> None:
        self._index = index

    @builtins.property
    def index(self) -> int:
        return self._index


scout_compute_api_BitTestFunction.__name__ = "BitTestFunction"
scout_compute_api_BitTestFunction.__qualname__ = "BitTestFunction"
scout_compute_api_BitTestFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BitXorFunction(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operand': ConjureFieldDefinition('operand', int)
        }

    __slots__: List[str] = ['_operand']

    def __init__(self, operand: int) -> None:
        self._operand = operand

    @builtins.property
    def operand(self) -> int:
        return self._operand


scout_compute_api_BitXorFunction.__name__ = "BitXorFunction"
scout_compute_api_BitXorFunction.__qualname__ = "BitXorFunction"
scout_compute_api_BitXorFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BucketedCartesianPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_CartesianBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_compute_api_CartesianBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_compute_api_CartesianBucket"]:
        return self._buckets


scout_compute_api_BucketedCartesianPlot.__name__ = "BucketedCartesianPlot"
scout_compute_api_BucketedCartesianPlot.__qualname__ = "BucketedCartesianPlot"
scout_compute_api_BucketedCartesianPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BucketedEnumPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_EnumBucket]),
            'categories': ConjureFieldDefinition('categories', List[str])
        }

    __slots__: List[str] = ['_timestamps', '_buckets', '_categories']

    def __init__(self, buckets: List["scout_compute_api_EnumBucket"], categories: List[str], timestamps: List["api_Timestamp"]) -> None:
        self._timestamps = timestamps
        self._buckets = buckets
        self._categories = categories

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        """
        The end of the bucket, exclusive.
        """
        return self._timestamps

    @builtins.property
    def buckets(self) -> List["scout_compute_api_EnumBucket"]:
        return self._buckets

    @builtins.property
    def categories(self) -> List[str]:
        return self._categories


scout_compute_api_BucketedEnumPlot.__name__ = "BucketedEnumPlot"
scout_compute_api_BucketedEnumPlot.__qualname__ = "BucketedEnumPlot"
scout_compute_api_BucketedEnumPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BucketedGeoPlot(ConjureUnionType):
    _time_based: Optional["scout_compute_api_TimeBucketedGeoPlot"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_based': ConjureFieldDefinition('timeBased', scout_compute_api_TimeBucketedGeoPlot)
        }

    def __init__(
            self,
            time_based: Optional["scout_compute_api_TimeBucketedGeoPlot"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (time_based is not None) != 1:
                raise ValueError('a union must contain a single member')

            if time_based is not None:
                self._time_based = time_based
                self._type = 'timeBased'

        elif type_of_union == 'timeBased':
            if time_based is None:
                raise ValueError('a union value must not be None')
            self._time_based = time_based
            self._type = 'timeBased'

    @builtins.property
    def time_based(self) -> Optional["scout_compute_api_TimeBucketedGeoPlot"]:
        return self._time_based

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_BucketedGeoPlotVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_BucketedGeoPlotVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timeBased' and self.time_based is not None:
            return visitor._time_based(self.time_based)


scout_compute_api_BucketedGeoPlot.__name__ = "BucketedGeoPlot"
scout_compute_api_BucketedGeoPlot.__qualname__ = "BucketedGeoPlot"
scout_compute_api_BucketedGeoPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BucketedGeoPlotVisitor:

    @abstractmethod
    def _time_based(self, time_based: "scout_compute_api_TimeBucketedGeoPlot") -> Any:
        pass


scout_compute_api_BucketedGeoPlotVisitor.__name__ = "BucketedGeoPlotVisitor"
scout_compute_api_BucketedGeoPlotVisitor.__qualname__ = "BucketedGeoPlotVisitor"
scout_compute_api_BucketedGeoPlotVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_BucketedNumericPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_NumericBucket])
        }

    __slots__: List[str] = ['_timestamps', '_buckets']

    def __init__(self, buckets: List["scout_compute_api_NumericBucket"], timestamps: List["api_Timestamp"]) -> None:
        self._timestamps = timestamps
        self._buckets = buckets

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        """
        The end of the bucket, exclusive.
        """
        return self._timestamps

    @builtins.property
    def buckets(self) -> List["scout_compute_api_NumericBucket"]:
        return self._buckets


scout_compute_api_BucketedNumericPlot.__name__ = "BucketedNumericPlot"
scout_compute_api_BucketedNumericPlot.__qualname__ = "BucketedNumericPlot"
scout_compute_api_BucketedNumericPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_CartesianBounds(ConjureBeanType):
    """
    Min/max bounds of an XY Cartesian plot, inclusive.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', scout_compute_api_DoubleConstant),
            'max_x': ConjureFieldDefinition('maxX', scout_compute_api_DoubleConstant),
            'min_y': ConjureFieldDefinition('minY', scout_compute_api_DoubleConstant),
            'max_y': ConjureFieldDefinition('maxY', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y']

    def __init__(self, max_x: "scout_compute_api_DoubleConstant", max_y: "scout_compute_api_DoubleConstant", min_x: "scout_compute_api_DoubleConstant", min_y: "scout_compute_api_DoubleConstant") -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y

    @builtins.property
    def min_x(self) -> "scout_compute_api_DoubleConstant":
        return self._min_x

    @builtins.property
    def max_x(self) -> "scout_compute_api_DoubleConstant":
        return self._max_x

    @builtins.property
    def min_y(self) -> "scout_compute_api_DoubleConstant":
        return self._min_y

    @builtins.property
    def max_y(self) -> "scout_compute_api_DoubleConstant":
        return self._max_y


scout_compute_api_CartesianBounds.__name__ = "CartesianBounds"
scout_compute_api_CartesianBounds.__qualname__ = "CartesianBounds"
scout_compute_api_CartesianBounds.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_CartesianBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', float),
            'max_x': ConjureFieldDefinition('maxX', float),
            'min_y': ConjureFieldDefinition('minY', float),
            'max_y': ConjureFieldDefinition('maxY', float),
            'min_timestamp': ConjureFieldDefinition('minTimestamp', api_Timestamp),
            'max_timestamp': ConjureFieldDefinition('maxTimestamp', api_Timestamp),
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y', '_min_timestamp', '_max_timestamp', '_count']

    def __init__(self, count: int, max_timestamp: "api_Timestamp", max_x: float, max_y: float, min_timestamp: "api_Timestamp", min_x: float, min_y: float) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y
        self._min_timestamp = min_timestamp
        self._max_timestamp = max_timestamp
        self._count = count

    @builtins.property
    def min_x(self) -> float:
        return self._min_x

    @builtins.property
    def max_x(self) -> float:
        return self._max_x

    @builtins.property
    def min_y(self) -> float:
        return self._min_y

    @builtins.property
    def max_y(self) -> float:
        return self._max_y

    @builtins.property
    def min_timestamp(self) -> "api_Timestamp":
        return self._min_timestamp

    @builtins.property
    def max_timestamp(self) -> "api_Timestamp":
        return self._max_timestamp

    @builtins.property
    def count(self) -> int:
        return self._count


scout_compute_api_CartesianBucket.__name__ = "CartesianBucket"
scout_compute_api_CartesianBucket.__qualname__ = "CartesianBucket"
scout_compute_api_CartesianBucket.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_CartesianNode(ConjureUnionType):
    _scatter: Optional["scout_compute_api_ScatterNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter': ConjureFieldDefinition('scatter', scout_compute_api_ScatterNode)
        }

    def __init__(
            self,
            scatter: Optional["scout_compute_api_ScatterNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (scatter is not None) != 1:
                raise ValueError('a union must contain a single member')

            if scatter is not None:
                self._scatter = scatter
                self._type = 'scatter'

        elif type_of_union == 'scatter':
            if scatter is None:
                raise ValueError('a union value must not be None')
            self._scatter = scatter
            self._type = 'scatter'

    @builtins.property
    def scatter(self) -> Optional["scout_compute_api_ScatterNode"]:
        return self._scatter

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_CartesianNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_CartesianNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'scatter' and self.scatter is not None:
            return visitor._scatter(self.scatter)


scout_compute_api_CartesianNode.__name__ = "CartesianNode"
scout_compute_api_CartesianNode.__qualname__ = "CartesianNode"
scout_compute_api_CartesianNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_CartesianNodeVisitor:

    @abstractmethod
    def _scatter(self, scatter: "scout_compute_api_ScatterNode") -> Any:
        pass


scout_compute_api_CartesianNodeVisitor.__name__ = "CartesianNodeVisitor"
scout_compute_api_CartesianNodeVisitor.__qualname__ = "CartesianNodeVisitor"
scout_compute_api_CartesianNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_CartesianPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'x_values': ConjureFieldDefinition('xValues', List[float]),
            'y_values': ConjureFieldDefinition('yValues', List[float])
        }

    __slots__: List[str] = ['_timestamps', '_x_values', '_y_values']

    def __init__(self, timestamps: List["api_Timestamp"], x_values: List[float], y_values: List[float]) -> None:
        self._timestamps = timestamps
        self._x_values = x_values
        self._y_values = y_values

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        return self._timestamps

    @builtins.property
    def x_values(self) -> List[float]:
        return self._x_values

    @builtins.property
    def y_values(self) -> List[float]:
        return self._y_values


scout_compute_api_CartesianPlot.__name__ = "CartesianPlot"
scout_compute_api_CartesianPlot.__qualname__ = "CartesianPlot"
scout_compute_api_CartesianPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_CartesianUnitResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_api_UnitResult),
            'y': ConjureFieldDefinition('y', scout_compute_api_UnitResult)
        }

    __slots__: List[str] = ['_x', '_y']

    def __init__(self, x: "scout_compute_api_UnitResult", y: "scout_compute_api_UnitResult") -> None:
        self._x = x
        self._y = y

    @builtins.property
    def x(self) -> "scout_compute_api_UnitResult":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_api_UnitResult":
        return self._y


scout_compute_api_CartesianUnitResult.__name__ = "CartesianUnitResult"
scout_compute_api_CartesianUnitResult.__qualname__ = "CartesianUnitResult"
scout_compute_api_CartesianUnitResult.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_CompactEnumPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', int)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: int) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> int:
        return self._value


scout_compute_api_CompactEnumPoint.__name__ = "CompactEnumPoint"
scout_compute_api_CompactEnumPoint.__qualname__ = "CompactEnumPoint"
scout_compute_api_CompactEnumPoint.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputableNode(ConjureUnionType):
    _ranges: Optional["scout_compute_api_SummarizeRangesNode"] = None
    _series: Optional["scout_compute_api_SummarizeSeriesNode"] = None
    _value: Optional["scout_compute_api_SelectValueNode"] = None
    _cartesian: Optional["scout_compute_api_SummarizeCartesianNode"] = None
    _frequency: Optional["scout_compute_api_FrequencyDomainNode"] = None
    _histogram: Optional["scout_compute_api_HistogramNode"] = None
    _geo: Optional["scout_compute_api_SummarizeGeoNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_SummarizeRangesNode),
            'series': ConjureFieldDefinition('series', scout_compute_api_SummarizeSeriesNode),
            'value': ConjureFieldDefinition('value', scout_compute_api_SelectValueNode),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_api_SummarizeCartesianNode),
            'frequency': ConjureFieldDefinition('frequency', scout_compute_api_FrequencyDomainNode),
            'histogram': ConjureFieldDefinition('histogram', scout_compute_api_HistogramNode),
            'geo': ConjureFieldDefinition('geo', scout_compute_api_SummarizeGeoNode)
        }

    def __init__(
            self,
            ranges: Optional["scout_compute_api_SummarizeRangesNode"] = None,
            series: Optional["scout_compute_api_SummarizeSeriesNode"] = None,
            value: Optional["scout_compute_api_SelectValueNode"] = None,
            cartesian: Optional["scout_compute_api_SummarizeCartesianNode"] = None,
            frequency: Optional["scout_compute_api_FrequencyDomainNode"] = None,
            histogram: Optional["scout_compute_api_HistogramNode"] = None,
            geo: Optional["scout_compute_api_SummarizeGeoNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (ranges is not None) + (series is not None) + (value is not None) + (cartesian is not None) + (frequency is not None) + (histogram is not None) + (geo is not None) != 1:
                raise ValueError('a union must contain a single member')

            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'
            if series is not None:
                self._series = series
                self._type = 'series'
            if value is not None:
                self._value = value
                self._type = 'value'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if frequency is not None:
                self._frequency = frequency
                self._type = 'frequency'
            if histogram is not None:
                self._histogram = histogram
                self._type = 'histogram'
            if geo is not None:
                self._geo = geo
                self._type = 'geo'

        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'frequency':
            if frequency is None:
                raise ValueError('a union value must not be None')
            self._frequency = frequency
            self._type = 'frequency'
        elif type_of_union == 'histogram':
            if histogram is None:
                raise ValueError('a union value must not be None')
            self._histogram = histogram
            self._type = 'histogram'
        elif type_of_union == 'geo':
            if geo is None:
                raise ValueError('a union value must not be None')
            self._geo = geo
            self._type = 'geo'

    @builtins.property
    def ranges(self) -> Optional["scout_compute_api_SummarizeRangesNode"]:
        return self._ranges

    @builtins.property
    def series(self) -> Optional["scout_compute_api_SummarizeSeriesNode"]:
        return self._series

    @builtins.property
    def value(self) -> Optional["scout_compute_api_SelectValueNode"]:
        return self._value

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_api_SummarizeCartesianNode"]:
        return self._cartesian

    @builtins.property
    def frequency(self) -> Optional["scout_compute_api_FrequencyDomainNode"]:
        return self._frequency

    @builtins.property
    def histogram(self) -> Optional["scout_compute_api_HistogramNode"]:
        return self._histogram

    @builtins.property
    def geo(self) -> Optional["scout_compute_api_SummarizeGeoNode"]:
        return self._geo

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ComputableNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ComputableNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'frequency' and self.frequency is not None:
            return visitor._frequency(self.frequency)
        if self._type == 'histogram' and self.histogram is not None:
            return visitor._histogram(self.histogram)
        if self._type == 'geo' and self.geo is not None:
            return visitor._geo(self.geo)


scout_compute_api_ComputableNode.__name__ = "ComputableNode"
scout_compute_api_ComputableNode.__qualname__ = "ComputableNode"
scout_compute_api_ComputableNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputableNodeVisitor:

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_api_SummarizeRangesNode") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_compute_api_SummarizeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value(self, value: "scout_compute_api_SelectValueNode") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_api_SummarizeCartesianNode") -> Any:
        pass

    @abstractmethod
    def _frequency(self, frequency: "scout_compute_api_FrequencyDomainNode") -> Any:
        pass

    @abstractmethod
    def _histogram(self, histogram: "scout_compute_api_HistogramNode") -> Any:
        pass

    @abstractmethod
    def _geo(self, geo: "scout_compute_api_SummarizeGeoNode") -> Any:
        pass


scout_compute_api_ComputableNodeVisitor.__name__ = "ComputableNodeVisitor"
scout_compute_api_ComputableNodeVisitor.__qualname__ = "ComputableNodeVisitor"
scout_compute_api_ComputableNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeNode(ConjureUnionType):
    _enum: Optional["scout_compute_api_EnumSeriesNode"] = None
    _numeric: Optional["scout_compute_api_NumericSeriesNode"] = None
    _ranges: Optional["scout_compute_api_RangesNode"] = None
    _raw: Optional["scout_compute_api_RawUntypedSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumSeriesNode),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericSeriesNode),
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangesNode),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_RawUntypedSeriesNode)
        }

    def __init__(
            self,
            enum: Optional["scout_compute_api_EnumSeriesNode"] = None,
            numeric: Optional["scout_compute_api_NumericSeriesNode"] = None,
            ranges: Optional["scout_compute_api_RangesNode"] = None,
            raw: Optional["scout_compute_api_RawUntypedSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (enum is not None) + (numeric is not None) + (ranges is not None) + (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumSeriesNode"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericSeriesNode"]:
        return self._numeric

    @builtins.property
    def ranges(self) -> Optional["scout_compute_api_RangesNode"]:
        return self._ranges

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_RawUntypedSeriesNode"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ComputeNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ComputeNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_compute_api_ComputeNode.__name__ = "ComputeNode"
scout_compute_api_ComputeNode.__qualname__ = "ComputeNode"
scout_compute_api_ComputeNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeNodeVisitor:

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_api_RangesNode") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_RawUntypedSeriesNode") -> Any:
        pass


scout_compute_api_ComputeNodeVisitor.__name__ = "ComputeNodeVisitor"
scout_compute_api_ComputeNodeVisitor.__qualname__ = "ComputeNodeVisitor"
scout_compute_api_ComputeNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeNodeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_ComputableNode),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_node', '_start', '_end', '_context']

    def __init__(self, context: "scout_compute_api_Context", end: "api_Timestamp", node: "scout_compute_api_ComputableNode", start: "api_Timestamp") -> None:
        self._node = node
        self._start = start
        self._end = end
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_ComputableNode":
        return self._node

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_compute_api_ComputeNodeRequest.__name__ = "ComputeNodeRequest"
scout_compute_api_ComputeNodeRequest.__qualname__ = "ComputeNodeRequest"
scout_compute_api_ComputeNodeRequest.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeNodeResponse(ConjureUnionType):
    _numeric: Optional["scout_compute_api_NumericPlot"] = None
    _bucketed_numeric: Optional["scout_compute_api_BucketedNumericPlot"] = None
    _range: Optional[List["scout_compute_api_Range"]] = None
    _ranges_summary: Optional["scout_compute_api_RangesSummary"] = None
    _enum: Optional["scout_compute_api_EnumPlot"] = None
    _bucketed_enum: Optional["scout_compute_api_BucketedEnumPlot"] = None
    _cartesian: Optional["scout_compute_api_CartesianPlot"] = None
    _bucketed_cartesian: Optional["scout_compute_api_BucketedCartesianPlot"] = None
    _bucketed_geo: Optional["scout_compute_api_BucketedGeoPlot"] = None
    _enum_point: Optional[Optional["scout_compute_api_EnumPoint"]] = None
    _numeric_point: Optional[Optional["scout_compute_api_NumericPoint"]] = None
    _range_value: Optional[Optional["scout_compute_api_Range"]] = None
    _frequency_domain: Optional["scout_compute_api_FrequencyDomainPlot"] = None
    _numeric_histogram: Optional["scout_compute_api_NumericHistogramPlot"] = None
    _enum_histogram: Optional["scout_compute_api_EnumHistogramPlot"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericPlot),
            'bucketed_numeric': ConjureFieldDefinition('bucketedNumeric', scout_compute_api_BucketedNumericPlot),
            'range': ConjureFieldDefinition('range', List[scout_compute_api_Range]),
            'ranges_summary': ConjureFieldDefinition('rangesSummary', scout_compute_api_RangesSummary),
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumPlot),
            'bucketed_enum': ConjureFieldDefinition('bucketedEnum', scout_compute_api_BucketedEnumPlot),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_api_CartesianPlot),
            'bucketed_cartesian': ConjureFieldDefinition('bucketedCartesian', scout_compute_api_BucketedCartesianPlot),
            'bucketed_geo': ConjureFieldDefinition('bucketedGeo', scout_compute_api_BucketedGeoPlot),
            'enum_point': ConjureFieldDefinition('enumPoint', OptionalTypeWrapper[scout_compute_api_EnumPoint]),
            'numeric_point': ConjureFieldDefinition('numericPoint', OptionalTypeWrapper[scout_compute_api_NumericPoint]),
            'range_value': ConjureFieldDefinition('rangeValue', OptionalTypeWrapper[scout_compute_api_Range]),
            'frequency_domain': ConjureFieldDefinition('frequencyDomain', scout_compute_api_FrequencyDomainPlot),
            'numeric_histogram': ConjureFieldDefinition('numericHistogram', scout_compute_api_NumericHistogramPlot),
            'enum_histogram': ConjureFieldDefinition('enumHistogram', scout_compute_api_EnumHistogramPlot)
        }

    def __init__(
            self,
            numeric: Optional["scout_compute_api_NumericPlot"] = None,
            bucketed_numeric: Optional["scout_compute_api_BucketedNumericPlot"] = None,
            range: Optional[List["scout_compute_api_Range"]] = None,
            ranges_summary: Optional["scout_compute_api_RangesSummary"] = None,
            enum: Optional["scout_compute_api_EnumPlot"] = None,
            bucketed_enum: Optional["scout_compute_api_BucketedEnumPlot"] = None,
            cartesian: Optional["scout_compute_api_CartesianPlot"] = None,
            bucketed_cartesian: Optional["scout_compute_api_BucketedCartesianPlot"] = None,
            bucketed_geo: Optional["scout_compute_api_BucketedGeoPlot"] = None,
            enum_point: Optional[Optional["scout_compute_api_EnumPoint"]] = None,
            numeric_point: Optional[Optional["scout_compute_api_NumericPoint"]] = None,
            range_value: Optional[Optional["scout_compute_api_Range"]] = None,
            frequency_domain: Optional["scout_compute_api_FrequencyDomainPlot"] = None,
            numeric_histogram: Optional["scout_compute_api_NumericHistogramPlot"] = None,
            enum_histogram: Optional["scout_compute_api_EnumHistogramPlot"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) + (bucketed_numeric is not None) + (range is not None) + (ranges_summary is not None) + (enum is not None) + (bucketed_enum is not None) + (cartesian is not None) + (bucketed_cartesian is not None) + (bucketed_geo is not None) + (enum_point is not None) + (numeric_point is not None) + (range_value is not None) + (frequency_domain is not None) + (numeric_histogram is not None) + (enum_histogram is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if bucketed_numeric is not None:
                self._bucketed_numeric = bucketed_numeric
                self._type = 'bucketedNumeric'
            if range is not None:
                self._range = range
                self._type = 'range'
            if ranges_summary is not None:
                self._ranges_summary = ranges_summary
                self._type = 'rangesSummary'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if bucketed_enum is not None:
                self._bucketed_enum = bucketed_enum
                self._type = 'bucketedEnum'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if bucketed_cartesian is not None:
                self._bucketed_cartesian = bucketed_cartesian
                self._type = 'bucketedCartesian'
            if bucketed_geo is not None:
                self._bucketed_geo = bucketed_geo
                self._type = 'bucketedGeo'
            if enum_point is not None:
                self._enum_point = enum_point
                self._type = 'enumPoint'
            if numeric_point is not None:
                self._numeric_point = numeric_point
                self._type = 'numericPoint'
            if range_value is not None:
                self._range_value = range_value
                self._type = 'rangeValue'
            if frequency_domain is not None:
                self._frequency_domain = frequency_domain
                self._type = 'frequencyDomain'
            if numeric_histogram is not None:
                self._numeric_histogram = numeric_histogram
                self._type = 'numericHistogram'
            if enum_histogram is not None:
                self._enum_histogram = enum_histogram
                self._type = 'enumHistogram'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'bucketedNumeric':
            if bucketed_numeric is None:
                raise ValueError('a union value must not be None')
            self._bucketed_numeric = bucketed_numeric
            self._type = 'bucketedNumeric'
        elif type_of_union == 'range':
            if range is None:
                raise ValueError('a union value must not be None')
            self._range = range
            self._type = 'range'
        elif type_of_union == 'rangesSummary':
            if ranges_summary is None:
                raise ValueError('a union value must not be None')
            self._ranges_summary = ranges_summary
            self._type = 'rangesSummary'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'bucketedEnum':
            if bucketed_enum is None:
                raise ValueError('a union value must not be None')
            self._bucketed_enum = bucketed_enum
            self._type = 'bucketedEnum'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'bucketedCartesian':
            if bucketed_cartesian is None:
                raise ValueError('a union value must not be None')
            self._bucketed_cartesian = bucketed_cartesian
            self._type = 'bucketedCartesian'
        elif type_of_union == 'bucketedGeo':
            if bucketed_geo is None:
                raise ValueError('a union value must not be None')
            self._bucketed_geo = bucketed_geo
            self._type = 'bucketedGeo'
        elif type_of_union == 'enumPoint':
            if enum_point is None:
                raise ValueError('a union value must not be None')
            self._enum_point = enum_point
            self._type = 'enumPoint'
        elif type_of_union == 'numericPoint':
            if numeric_point is None:
                raise ValueError('a union value must not be None')
            self._numeric_point = numeric_point
            self._type = 'numericPoint'
        elif type_of_union == 'rangeValue':
            if range_value is None:
                raise ValueError('a union value must not be None')
            self._range_value = range_value
            self._type = 'rangeValue'
        elif type_of_union == 'frequencyDomain':
            if frequency_domain is None:
                raise ValueError('a union value must not be None')
            self._frequency_domain = frequency_domain
            self._type = 'frequencyDomain'
        elif type_of_union == 'numericHistogram':
            if numeric_histogram is None:
                raise ValueError('a union value must not be None')
            self._numeric_histogram = numeric_histogram
            self._type = 'numericHistogram'
        elif type_of_union == 'enumHistogram':
            if enum_histogram is None:
                raise ValueError('a union value must not be None')
            self._enum_histogram = enum_histogram
            self._type = 'enumHistogram'

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericPlot"]:
        return self._numeric

    @builtins.property
    def bucketed_numeric(self) -> Optional["scout_compute_api_BucketedNumericPlot"]:
        return self._bucketed_numeric

    @builtins.property
    def range(self) -> Optional[List["scout_compute_api_Range"]]:
        return self._range

    @builtins.property
    def ranges_summary(self) -> Optional["scout_compute_api_RangesSummary"]:
        return self._ranges_summary

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumPlot"]:
        return self._enum

    @builtins.property
    def bucketed_enum(self) -> Optional["scout_compute_api_BucketedEnumPlot"]:
        return self._bucketed_enum

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_api_CartesianPlot"]:
        return self._cartesian

    @builtins.property
    def bucketed_cartesian(self) -> Optional["scout_compute_api_BucketedCartesianPlot"]:
        return self._bucketed_cartesian

    @builtins.property
    def bucketed_geo(self) -> Optional["scout_compute_api_BucketedGeoPlot"]:
        return self._bucketed_geo

    @builtins.property
    def enum_point(self) -> Optional[Optional["scout_compute_api_EnumPoint"]]:
        return self._enum_point

    @builtins.property
    def numeric_point(self) -> Optional[Optional["scout_compute_api_NumericPoint"]]:
        return self._numeric_point

    @builtins.property
    def range_value(self) -> Optional[Optional["scout_compute_api_Range"]]:
        return self._range_value

    @builtins.property
    def frequency_domain(self) -> Optional["scout_compute_api_FrequencyDomainPlot"]:
        return self._frequency_domain

    @builtins.property
    def numeric_histogram(self) -> Optional["scout_compute_api_NumericHistogramPlot"]:
        return self._numeric_histogram

    @builtins.property
    def enum_histogram(self) -> Optional["scout_compute_api_EnumHistogramPlot"]:
        return self._enum_histogram

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ComputeNodeResponseVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ComputeNodeResponseVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'bucketedNumeric' and self.bucketed_numeric is not None:
            return visitor._bucketed_numeric(self.bucketed_numeric)
        if self._type == 'range' and self.range is not None:
            return visitor._range(self.range)
        if self._type == 'rangesSummary' and self.ranges_summary is not None:
            return visitor._ranges_summary(self.ranges_summary)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'bucketedEnum' and self.bucketed_enum is not None:
            return visitor._bucketed_enum(self.bucketed_enum)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'bucketedCartesian' and self.bucketed_cartesian is not None:
            return visitor._bucketed_cartesian(self.bucketed_cartesian)
        if self._type == 'bucketedGeo' and self.bucketed_geo is not None:
            return visitor._bucketed_geo(self.bucketed_geo)
        if self._type == 'enumPoint' and self.enum_point is not None:
            return visitor._enum_point(self.enum_point)
        if self._type == 'numericPoint' and self.numeric_point is not None:
            return visitor._numeric_point(self.numeric_point)
        if self._type == 'rangeValue' and self.range_value is not None:
            return visitor._range_value(self.range_value)
        if self._type == 'frequencyDomain' and self.frequency_domain is not None:
            return visitor._frequency_domain(self.frequency_domain)
        if self._type == 'numericHistogram' and self.numeric_histogram is not None:
            return visitor._numeric_histogram(self.numeric_histogram)
        if self._type == 'enumHistogram' and self.enum_histogram is not None:
            return visitor._enum_histogram(self.enum_histogram)


scout_compute_api_ComputeNodeResponse.__name__ = "ComputeNodeResponse"
scout_compute_api_ComputeNodeResponse.__qualname__ = "ComputeNodeResponse"
scout_compute_api_ComputeNodeResponse.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeNodeResponseVisitor:

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_numeric(self, bucketed_numeric: "scout_compute_api_BucketedNumericPlot") -> Any:
        pass

    @abstractmethod
    def _range(self, range: List["scout_compute_api_Range"]) -> Any:
        pass

    @abstractmethod
    def _ranges_summary(self, ranges_summary: "scout_compute_api_RangesSummary") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_enum(self, bucketed_enum: "scout_compute_api_BucketedEnumPlot") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_api_CartesianPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_cartesian(self, bucketed_cartesian: "scout_compute_api_BucketedCartesianPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_geo(self, bucketed_geo: "scout_compute_api_BucketedGeoPlot") -> Any:
        pass

    @abstractmethod
    def _enum_point(self, enum_point: Optional["scout_compute_api_EnumPoint"]) -> Any:
        pass

    @abstractmethod
    def _numeric_point(self, numeric_point: Optional["scout_compute_api_NumericPoint"]) -> Any:
        pass

    @abstractmethod
    def _range_value(self, range_value: Optional["scout_compute_api_Range"]) -> Any:
        pass

    @abstractmethod
    def _frequency_domain(self, frequency_domain: "scout_compute_api_FrequencyDomainPlot") -> Any:
        pass

    @abstractmethod
    def _numeric_histogram(self, numeric_histogram: "scout_compute_api_NumericHistogramPlot") -> Any:
        pass

    @abstractmethod
    def _enum_histogram(self, enum_histogram: "scout_compute_api_EnumHistogramPlot") -> Any:
        pass


scout_compute_api_ComputeNodeResponseVisitor.__name__ = "ComputeNodeResponseVisitor"
scout_compute_api_ComputeNodeResponseVisitor.__qualname__ = "ComputeNodeResponseVisitor"
scout_compute_api_ComputeNodeResponseVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeNodeWithContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_node': ConjureFieldDefinition('seriesNode', scout_compute_api_ComputeNode),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_series_node', '_context']

    def __init__(self, context: "scout_compute_api_Context", series_node: "scout_compute_api_ComputeNode") -> None:
        self._series_node = series_node
        self._context = context

    @builtins.property
    def series_node(self) -> "scout_compute_api_ComputeNode":
        return self._series_node

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_compute_api_ComputeNodeWithContext.__name__ = "ComputeNodeWithContext"
scout_compute_api_ComputeNodeWithContext.__qualname__ = "ComputeNodeWithContext"
scout_compute_api_ComputeNodeWithContext.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeService(Service):
    """
    The Compute Service provides the ability to compute the output of compute graphs.
    """

    def compute(self, auth_header: str, request: "scout_compute_api_ComputeNodeRequest") -> "scout_compute_api_ComputeNodeResponse":
        """
        Computes the output of the compute graph specified by a ComputeNodeRequest.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/compute/v2/compute'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_api_ComputeNodeResponse, self._return_none_for_unknown_union_types)

    def parameterized_compute(self, auth_header: str, request: "scout_compute_api_ParameterizedComputeNodeRequest") -> "scout_compute_api_ParameterizedComputeNodeResponse":
        """
        Computes the output of the compute graph specified by a ParameterizedComputeNodeRequest. A parameterized 
compute request supports multiple values for a single variable, supplied by the ParameterizedContext.
Results are returned in the same order of the request.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/compute/v2/compute/parameterized'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_api_ParameterizedComputeNodeResponse, self._return_none_for_unknown_union_types)

    def compute_units(self, auth_header: str, request: "scout_compute_api_ComputeUnitsRequest") -> "scout_compute_api_ComputeUnitResult":
        """
        Returns the resulting unit for the output of a compute graph. If the resulting unit is equivalent to exactly
one existing unit in the system, it will be returned (for example, a series in Coulombs divided by a series
in Volts will return an output of Farads). If the output does not have units (for example, a range output,)
the unit result will return noUnitAvailable, and if the computation was not successful, corresponding errors
are returned.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/compute/v2/compute/units'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_api_ComputeUnitResult, self._return_none_for_unknown_union_types)


scout_compute_api_ComputeService.__name__ = "ComputeService"
scout_compute_api_ComputeService.__qualname__ = "ComputeService"
scout_compute_api_ComputeService.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeUnitResult(ConjureUnionType):
    _single: Optional["scout_compute_api_UnitResult"] = None
    _cartesian: Optional["scout_compute_api_CartesianUnitResult"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'single': ConjureFieldDefinition('single', scout_compute_api_UnitResult),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_api_CartesianUnitResult)
        }

    def __init__(
            self,
            single: Optional["scout_compute_api_UnitResult"] = None,
            cartesian: Optional["scout_compute_api_CartesianUnitResult"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (single is not None) + (cartesian is not None) != 1:
                raise ValueError('a union must contain a single member')

            if single is not None:
                self._single = single
                self._type = 'single'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'

        elif type_of_union == 'single':
            if single is None:
                raise ValueError('a union value must not be None')
            self._single = single
            self._type = 'single'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'

    @builtins.property
    def single(self) -> Optional["scout_compute_api_UnitResult"]:
        return self._single

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_api_CartesianUnitResult"]:
        return self._cartesian

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ComputeUnitResultVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ComputeUnitResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'single' and self.single is not None:
            return visitor._single(self.single)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)


scout_compute_api_ComputeUnitResult.__name__ = "ComputeUnitResult"
scout_compute_api_ComputeUnitResult.__qualname__ = "ComputeUnitResult"
scout_compute_api_ComputeUnitResult.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeUnitResultVisitor:

    @abstractmethod
    def _single(self, single: "scout_compute_api_UnitResult") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_api_CartesianUnitResult") -> Any:
        pass


scout_compute_api_ComputeUnitResultVisitor.__name__ = "ComputeUnitResultVisitor"
scout_compute_api_ComputeUnitResultVisitor.__qualname__ = "ComputeUnitResultVisitor"
scout_compute_api_ComputeUnitResultVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ComputeUnitsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_ComputableNode),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_node', '_context']

    def __init__(self, context: "scout_compute_api_Context", node: "scout_compute_api_ComputableNode") -> None:
        self._node = node
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_ComputableNode":
        return self._node

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_compute_api_ComputeUnitsRequest.__name__ = "ComputeUnitsRequest"
scout_compute_api_ComputeUnitsRequest.__qualname__ = "ComputeUnitsRequest"
scout_compute_api_ComputeUnitsRequest.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_Context(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_compute_api_VariableValue]),
            'function_variables': ConjureFieldDefinition('functionVariables', Dict[scout_compute_api_FunctionReference, scout_compute_api_FunctionVariables])
        }

    __slots__: List[str] = ['_variables', '_function_variables']

    def __init__(self, function_variables: Dict[str, "scout_compute_api_FunctionVariables"], variables: Dict[str, "scout_compute_api_VariableValue"]) -> None:
        self._variables = variables
        self._function_variables = function_variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_compute_api_VariableValue"]:
        return self._variables

    @builtins.property
    def function_variables(self) -> Dict[str, "scout_compute_api_FunctionVariables"]:
        """
        Map of function references to their variables. The function reference is defined in the FunctionNode definition.
If a function references another function, the variables for the referenced function should be in the
subFunctionVariables field of the FunctionVariables.
        """
        return self._function_variables


scout_compute_api_Context.__name__ = "Context"
scout_compute_api_Context.__qualname__ = "Context"
scout_compute_api_Context.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_Count(ConjureBeanType):
    """
    The number of points inside the time window
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Count.__name__ = "Count"
scout_compute_api_Count.__qualname__ = "Count"
scout_compute_api_Count.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_CumulativeSumSeriesNode(ConjureBeanType):
    """
    Calculates the running total of the series values.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', scout_compute_api_TimestampConstant)
        }

    __slots__: List[str] = ['_input', '_start_timestamp']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", start_timestamp: "scout_compute_api_TimestampConstant") -> None:
        self._input = input
        self._start_timestamp = start_timestamp

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_timestamp(self) -> "scout_compute_api_TimestampConstant":
        return self._start_timestamp


scout_compute_api_CumulativeSumSeriesNode.__name__ = "CumulativeSumSeriesNode"
scout_compute_api_CumulativeSumSeriesNode.__qualname__ = "CumulativeSumSeriesNode"
scout_compute_api_CumulativeSumSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_DerivativeSeriesNode(ConjureBeanType):
    """
    Calculates the rate of change between subsequent points.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[scout_compute_api_TimeUnit]),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_time_unit', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None, time_unit: Optional["scout_compute_api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["scout_compute_api_TimeUnit"]:
        """
        Time unit used to calculate the derivative. Defaults to seconds if not specified.
        """
        return self._time_unit

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        """
        Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified.
        """
        return self._negative_values_configuration


scout_compute_api_DerivativeSeriesNode.__name__ = "DerivativeSeriesNode"
scout_compute_api_DerivativeSeriesNode.__qualname__ = "DerivativeSeriesNode"
scout_compute_api_DerivativeSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_DoubleConstant(ConjureUnionType):
    _literal: Optional[float] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', float),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional[float] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional[float]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_DoubleConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_DoubleConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_DoubleConstant.__name__ = "DoubleConstant"
scout_compute_api_DoubleConstant.__qualname__ = "DoubleConstant"
scout_compute_api_DoubleConstant.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_DoubleConstantVisitor:

    @abstractmethod
    def _literal(self, literal: float) -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_DoubleConstantVisitor.__name__ = "DoubleConstantVisitor"
scout_compute_api_DoubleConstantVisitor.__qualname__ = "DoubleConstantVisitor"
scout_compute_api_DoubleConstantVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_DurationConstant(ConjureUnionType):
    _literal: Optional["scout_run_api_Duration"] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', scout_run_api_Duration),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional["scout_run_api_Duration"] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional["scout_run_api_Duration"]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_DurationConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_DurationConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_DurationConstant.__name__ = "DurationConstant"
scout_compute_api_DurationConstant.__qualname__ = "DurationConstant"
scout_compute_api_DurationConstant.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_DurationConstantVisitor:

    @abstractmethod
    def _literal(self, literal: "scout_run_api_Duration") -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_DurationConstantVisitor.__name__ = "DurationConstantVisitor"
scout_compute_api_DurationConstantVisitor.__qualname__ = "DurationConstantVisitor"
scout_compute_api_DurationConstantVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_Empty(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Empty.__name__ = "Empty"
scout_compute_api_Empty.__qualname__ = "Empty"
scout_compute_api_Empty.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumAggregationFunction(ConjureEnumType):

    MIN = 'MIN'
    '''MIN'''
    MAX = 'MAX'
    '''MAX'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_EnumAggregationFunction.__name__ = "EnumAggregationFunction"
scout_compute_api_EnumAggregationFunction.__qualname__ = "EnumAggregationFunction"
scout_compute_api_EnumAggregationFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'histogram': ConjureFieldDefinition('histogram', Dict[int, int]),
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_api_CompactEnumPoint),
            'last_point': ConjureFieldDefinition('lastPoint', OptionalTypeWrapper[scout_compute_api_CompactEnumPoint])
        }

    __slots__: List[str] = ['_histogram', '_first_point', '_last_point']

    def __init__(self, first_point: "scout_compute_api_CompactEnumPoint", histogram: Dict[int, int], last_point: Optional["scout_compute_api_CompactEnumPoint"] = None) -> None:
        self._histogram = histogram
        self._first_point = first_point
        self._last_point = last_point

    @builtins.property
    def histogram(self) -> Dict[int, int]:
        """
        The map of values within the bucket to their frequency.
        """
        return self._histogram

    @builtins.property
    def first_point(self) -> "scout_compute_api_CompactEnumPoint":
        return self._first_point

    @builtins.property
    def last_point(self) -> Optional["scout_compute_api_CompactEnumPoint"]:
        """
        Will be empty if the bucket only has a single point.
        """
        return self._last_point


scout_compute_api_EnumBucket.__name__ = "EnumBucket"
scout_compute_api_EnumBucket.__qualname__ = "EnumBucket"
scout_compute_api_EnumBucket.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumFilterOperator(ConjureEnumType):

    IS_IN = 'IS_IN'
    '''IS_IN'''
    IS_NOT_IN = 'IS_NOT_IN'
    '''IS_NOT_IN'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_EnumFilterOperator.__name__ = "EnumFilterOperator"
scout_compute_api_EnumFilterOperator.__qualname__ = "EnumFilterOperator"
scout_compute_api_EnumFilterOperator.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumFilterRangesNode(ConjureBeanType):
    """
    Produces a list of ranges for which the filter condition is satisfied.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeriesNode),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_EnumFilterOperator),
            'values': ConjureFieldDefinition('values', scout_compute_api_StringSetConstant),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_operator', '_values', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_EnumSeriesNode", operator: "scout_compute_api_EnumFilterOperator", values: "scout_compute_api_StringSetConstant", persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._operator = operator
        self._values = values
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def operator(self) -> "scout_compute_api_EnumFilterOperator":
        return self._operator

    @builtins.property
    def values(self) -> "scout_compute_api_StringSetConstant":
        return self._values

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_EnumFilterRangesNode.__name__ = "EnumFilterRangesNode"
scout_compute_api_EnumFilterRangesNode.__qualname__ = "EnumFilterRangesNode"
scout_compute_api_EnumFilterRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumFilterTransformationSeriesNode(ConjureBeanType):
    """
    Outputs the values of the enum plot value within the ranges specified by a ranges node
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeriesNode),
            'filter': ConjureFieldDefinition('filter', scout_compute_api_RangesNode)
        }

    __slots__: List[str] = ['_input', '_filter']

    def __init__(self, filter: "scout_compute_api_RangesNode", input: "scout_compute_api_EnumSeriesNode") -> None:
        self._input = input
        self._filter = filter

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def filter(self) -> "scout_compute_api_RangesNode":
        return self._filter


scout_compute_api_EnumFilterTransformationSeriesNode.__name__ = "EnumFilterTransformationSeriesNode"
scout_compute_api_EnumFilterTransformationSeriesNode.__qualname__ = "EnumFilterTransformationSeriesNode"
scout_compute_api_EnumFilterTransformationSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumHistogramBucket(ConjureBeanType):
    """
    A bucket in an enum histogram representing all the counts
for a specific enumerated value, across all input series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', str),
            'counts_by_channel': ConjureFieldDefinition('countsByChannel', Dict[scout_compute_api_VariableName, scout_compute_api_HistogramChannelCount])
        }

    __slots__: List[str] = ['_value', '_counts_by_channel']

    def __init__(self, counts_by_channel: Dict[str, "scout_compute_api_HistogramChannelCount"], value: str) -> None:
        self._value = value
        self._counts_by_channel = counts_by_channel

    @builtins.property
    def value(self) -> str:
        """
        The value of the enum as a string
        """
        return self._value

    @builtins.property
    def counts_by_channel(self) -> Dict[str, "scout_compute_api_HistogramChannelCount"]:
        return self._counts_by_channel


scout_compute_api_EnumHistogramBucket.__name__ = "EnumHistogramBucket"
scout_compute_api_EnumHistogramBucket.__qualname__ = "EnumHistogramBucket"
scout_compute_api_EnumHistogramBucket.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumHistogramNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_VariableName, scout_compute_api_EnumSeriesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: Dict[str, "scout_compute_api_EnumSeriesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_api_EnumSeriesNode"]:
        return self._inputs


scout_compute_api_EnumHistogramNode.__name__ = "EnumHistogramNode"
scout_compute_api_EnumHistogramNode.__qualname__ = "EnumHistogramNode"
scout_compute_api_EnumHistogramNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumHistogramPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_EnumHistogramBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_compute_api_EnumHistogramBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_compute_api_EnumHistogramBucket"]:
        return self._buckets


scout_compute_api_EnumHistogramPlot.__name__ = "EnumHistogramPlot"
scout_compute_api_EnumHistogramPlot.__qualname__ = "EnumHistogramPlot"
scout_compute_api_EnumHistogramPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'values': ConjureFieldDefinition('values', List[int]),
            'categories': ConjureFieldDefinition('categories', List[str])
        }

    __slots__: List[str] = ['_timestamps', '_values', '_categories']

    def __init__(self, categories: List[str], timestamps: List["api_Timestamp"], values: List[int]) -> None:
        self._timestamps = timestamps
        self._values = values
        self._categories = categories

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        return self._timestamps

    @builtins.property
    def values(self) -> List[int]:
        return self._values

    @builtins.property
    def categories(self) -> List[str]:
        return self._categories


scout_compute_api_EnumPlot.__name__ = "EnumPlot"
scout_compute_api_EnumPlot.__qualname__ = "EnumPlot"
scout_compute_api_EnumPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: str) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> str:
        return self._value


scout_compute_api_EnumPoint.__name__ = "EnumPoint"
scout_compute_api_EnumPoint.__qualname__ = "EnumPoint"
scout_compute_api_EnumPoint.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumResampleSeriesNode(ConjureBeanType):
    """
    Resamples the input series to a new resolution using interpolation.
Outputs data for timestamps corresponding to the defined frequency. Based on interpolation strategy,
determines range of timestamps to output data for and interpolates values where necessary.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeriesNode),
            'resample_configuration': ConjureFieldDefinition('resampleConfiguration', scout_compute_api_ResampleConfiguration)
        }

    __slots__: List[str] = ['_input', '_resample_configuration']

    def __init__(self, input: "scout_compute_api_EnumSeriesNode", resample_configuration: "scout_compute_api_ResampleConfiguration") -> None:
        self._input = input
        self._resample_configuration = resample_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def resample_configuration(self) -> "scout_compute_api_ResampleConfiguration":
        """
        The interval at which to resample the series and interpolation strategy
        """
        return self._resample_configuration


scout_compute_api_EnumResampleSeriesNode.__name__ = "EnumResampleSeriesNode"
scout_compute_api_EnumResampleSeriesNode.__qualname__ = "EnumResampleSeriesNode"
scout_compute_api_EnumResampleSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumSeriesEqualityRangesNode(ConjureBeanType):
    """
    Produces a list of ranges for which provided enum series are all equal (or are not all equal).
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_EnumSeriesNode]),
            'equality_operator': ConjureFieldDefinition('equalityOperator', scout_compute_api_EqualityOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_input', '_equality_operator', '_persistence_window_configuration', '_interpolation_configuration']

    def __init__(self, equality_operator: "scout_compute_api_EqualityOperator", input: List["scout_compute_api_EnumSeriesNode"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None, persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._equality_operator = equality_operator
        self._persistence_window_configuration = persistence_window_configuration
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def input(self) -> List["scout_compute_api_EnumSeriesNode"]:
        return self._input

    @builtins.property
    def equality_operator(self) -> "scout_compute_api_EqualityOperator":
        return self._equality_operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """
        Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_EnumSeriesEqualityRangesNode.__name__ = "EnumSeriesEqualityRangesNode"
scout_compute_api_EnumSeriesEqualityRangesNode.__qualname__ = "EnumSeriesEqualityRangesNode"
scout_compute_api_EnumSeriesEqualityRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumSeriesFunction(ConjureBeanType):
    """
    A function reference that outputs an enum series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'function_reference': ConjureFieldDefinition('functionReference', scout_compute_api_FunctionReference),
            'function_identifier': ConjureFieldDefinition('functionIdentifier', scout_compute_api_FunctionVariable)
        }

    __slots__: List[str] = ['_function_reference', '_function_identifier']

    def __init__(self, function_identifier: "scout_compute_api_FunctionVariable", function_reference: str) -> None:
        self._function_reference = function_reference
        self._function_identifier = function_identifier

    @builtins.property
    def function_reference(self) -> str:
        """
        A reference to identify the function node for substituting variables used within the function.
        """
        return self._function_reference

    @builtins.property
    def function_identifier(self) -> "scout_compute_api_FunctionVariable":
        """
        The variable that needs to be substituted with the function RID.
        """
        return self._function_identifier


scout_compute_api_EnumSeriesFunction.__name__ = "EnumSeriesFunction"
scout_compute_api_EnumSeriesFunction.__qualname__ = "EnumSeriesFunction"
scout_compute_api_EnumSeriesFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumSeriesNode(ConjureUnionType):
    _aggregate: Optional["scout_compute_api_AggregateEnumSeriesNode"] = None
    _function: Optional["scout_compute_api_EnumSeriesFunction"] = None
    _raw: Optional["scout_compute_api_RawEnumSeriesNode"] = None
    _resample: Optional["scout_compute_api_EnumResampleSeriesNode"] = None
    _time_range_filter: Optional["scout_compute_api_EnumTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_api_EnumTimeShiftSeriesNode"] = None
    _union: Optional["scout_compute_api_EnumUnionSeriesNode"] = None
    _filter_transformation: Optional["scout_compute_api_EnumFilterTransformationSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'aggregate': ConjureFieldDefinition('aggregate', scout_compute_api_AggregateEnumSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_EnumSeriesFunction),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_RawEnumSeriesNode),
            'resample': ConjureFieldDefinition('resample', scout_compute_api_EnumResampleSeriesNode),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_api_EnumTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_api_EnumTimeShiftSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_api_EnumUnionSeriesNode),
            'filter_transformation': ConjureFieldDefinition('filterTransformation', scout_compute_api_EnumFilterTransformationSeriesNode)
        }

    def __init__(
            self,
            aggregate: Optional["scout_compute_api_AggregateEnumSeriesNode"] = None,
            function: Optional["scout_compute_api_EnumSeriesFunction"] = None,
            raw: Optional["scout_compute_api_RawEnumSeriesNode"] = None,
            resample: Optional["scout_compute_api_EnumResampleSeriesNode"] = None,
            time_range_filter: Optional["scout_compute_api_EnumTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_api_EnumTimeShiftSeriesNode"] = None,
            union: Optional["scout_compute_api_EnumUnionSeriesNode"] = None,
            filter_transformation: Optional["scout_compute_api_EnumFilterTransformationSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (aggregate is not None) + (function is not None) + (raw is not None) + (resample is not None) + (time_range_filter is not None) + (time_shift is not None) + (union is not None) + (filter_transformation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if aggregate is not None:
                self._aggregate = aggregate
                self._type = 'aggregate'
            if function is not None:
                self._function = function
                self._type = 'function'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if resample is not None:
                self._resample = resample
                self._type = 'resample'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if union is not None:
                self._union = union
                self._type = 'union'
            if filter_transformation is not None:
                self._filter_transformation = filter_transformation
                self._type = 'filterTransformation'

        elif type_of_union == 'aggregate':
            if aggregate is None:
                raise ValueError('a union value must not be None')
            self._aggregate = aggregate
            self._type = 'aggregate'
        elif type_of_union == 'function':
            if function is None:
                raise ValueError('a union value must not be None')
            self._function = function
            self._type = 'function'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'resample':
            if resample is None:
                raise ValueError('a union value must not be None')
            self._resample = resample
            self._type = 'resample'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'filterTransformation':
            if filter_transformation is None:
                raise ValueError('a union value must not be None')
            self._filter_transformation = filter_transformation
            self._type = 'filterTransformation'

    @builtins.property
    def aggregate(self) -> Optional["scout_compute_api_AggregateEnumSeriesNode"]:
        return self._aggregate

    @builtins.property
    def function(self) -> Optional["scout_compute_api_EnumSeriesFunction"]:
        return self._function

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_RawEnumSeriesNode"]:
        return self._raw

    @builtins.property
    def resample(self) -> Optional["scout_compute_api_EnumResampleSeriesNode"]:
        return self._resample

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_api_EnumTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_api_EnumTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def union(self) -> Optional["scout_compute_api_EnumUnionSeriesNode"]:
        return self._union

    @builtins.property
    def filter_transformation(self) -> Optional["scout_compute_api_EnumFilterTransformationSeriesNode"]:
        return self._filter_transformation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_EnumSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_EnumSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'aggregate' and self.aggregate is not None:
            return visitor._aggregate(self.aggregate)
        if self._type == 'function' and self.function is not None:
            return visitor._function(self.function)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'resample' and self.resample is not None:
            return visitor._resample(self.resample)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'filterTransformation' and self.filter_transformation is not None:
            return visitor._filter_transformation(self.filter_transformation)


scout_compute_api_EnumSeriesNode.__name__ = "EnumSeriesNode"
scout_compute_api_EnumSeriesNode.__qualname__ = "EnumSeriesNode"
scout_compute_api_EnumSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumSeriesNodeVisitor:

    @abstractmethod
    def _aggregate(self, aggregate: "scout_compute_api_AggregateEnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _function(self, function: "scout_compute_api_EnumSeriesFunction") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_RawEnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _resample(self, resample: "scout_compute_api_EnumResampleSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_api_EnumTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_api_EnumTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_api_EnumUnionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _filter_transformation(self, filter_transformation: "scout_compute_api_EnumFilterTransformationSeriesNode") -> Any:
        pass


scout_compute_api_EnumSeriesNodeVisitor.__name__ = "EnumSeriesNodeVisitor"
scout_compute_api_EnumSeriesNodeVisitor.__qualname__ = "EnumSeriesNodeVisitor"
scout_compute_api_EnumSeriesNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumTimeRangeFilterSeriesNode(ConjureBeanType):
    """
    Filters the series to points within the specified time range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[scout_compute_api_TimestampConstant]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_compute_api_TimestampConstant])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_api_EnumSeriesNode", end_time: Optional["scout_compute_api_TimestampConstant"] = None, start_time: Optional["scout_compute_api_TimestampConstant"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """
        Represents the start time (inclusive) of the time range.
        """
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """
        Represents the end time (inclusive) of the time range.
        """
        return self._end_time


scout_compute_api_EnumTimeRangeFilterSeriesNode.__name__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_api_EnumTimeRangeFilterSeriesNode.__qualname__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_api_EnumTimeRangeFilterSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_compute_api_DurationConstant)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_compute_api_DurationConstant", input: "scout_compute_api_EnumSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_compute_api_DurationConstant":
        return self._duration


scout_compute_api_EnumTimeShiftSeriesNode.__name__ = "EnumTimeShiftSeriesNode"
scout_compute_api_EnumTimeShiftSeriesNode.__qualname__ = "EnumTimeShiftSeriesNode"
scout_compute_api_EnumTimeShiftSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumUnionOperation(ConjureEnumType):

    THROW = 'THROW'
    '''THROW'''
    MAX = 'MAX'
    '''MAX'''
    MIN = 'MIN'
    '''MIN'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_EnumUnionOperation.__name__ = "EnumUnionOperation"
scout_compute_api_EnumUnionOperation.__qualname__ = "EnumUnionOperation"
scout_compute_api_EnumUnionOperation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EnumUnionSeriesNode(ConjureBeanType):
    """
    Combines multiple enum series together and outputs a single series. The strategy to merge input values
with the same timestamp together is specified in the operation field.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_EnumSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_EnumUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_api_EnumSeriesNode"], operation: "scout_compute_api_EnumUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_api_EnumSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_EnumUnionOperation":
        """
        The strategy to merge points with duplicate timestamps.
        """
        return self._operation


scout_compute_api_EnumUnionSeriesNode.__name__ = "EnumUnionSeriesNode"
scout_compute_api_EnumUnionSeriesNode.__qualname__ = "EnumUnionSeriesNode"
scout_compute_api_EnumUnionSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_EqualityOperator(ConjureEnumType):

    ALL_EQUAL = 'ALL_EQUAL'
    '''ALL_EQUAL'''
    NOT_ALL_EQUAL = 'NOT_ALL_EQUAL'
    '''NOT_ALL_EQUAL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_EqualityOperator.__name__ = "EqualityOperator"
scout_compute_api_EqualityOperator.__qualname__ = "EqualityOperator"
scout_compute_api_EqualityOperator.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ErrorResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_type': ConjureFieldDefinition('errorType', scout_compute_api_ErrorType),
            'code': ConjureFieldDefinition('code', scout_compute_api_ErrorCode)
        }

    __slots__: List[str] = ['_error_type', '_code']

    def __init__(self, code: int, error_type: str) -> None:
        self._error_type = error_type
        self._code = code

    @builtins.property
    def error_type(self) -> str:
        return self._error_type

    @builtins.property
    def code(self) -> int:
        return self._code


scout_compute_api_ErrorResult.__name__ = "ErrorResult"
scout_compute_api_ErrorResult.__qualname__ = "ErrorResult"
scout_compute_api_ErrorResult.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ExcludeNegativeValues(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_ExcludeNegativeValues.__name__ = "ExcludeNegativeValues"
scout_compute_api_ExcludeNegativeValues.__qualname__ = "ExcludeNegativeValues"
scout_compute_api_ExcludeNegativeValues.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ExponentialAverage(ConjureBeanType):
    """
    An exponentially decaying average
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_ExponentialAverage.__name__ = "ExponentialAverage"
scout_compute_api_ExponentialAverage.__qualname__ = "ExponentialAverage"
scout_compute_api_ExponentialAverage.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_FftNode(ConjureBeanType):
    """
    Returns the single sided amplitude spectrum of the input series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input


scout_compute_api_FftNode.__name__ = "FftNode"
scout_compute_api_FftNode.__qualname__ = "FftNode"
scout_compute_api_FftNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_FirstPointMatchingCondition(ConjureBeanType):
    """
    The first point in the output range will be the first point where the condition evaluates to true.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_FirstPointMatchingCondition.__name__ = "FirstPointMatchingCondition"
scout_compute_api_FirstPointMatchingCondition.__qualname__ = "FirstPointMatchingCondition"
scout_compute_api_FirstPointMatchingCondition.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ForwardFillInterpolation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'interpolation_radius': ConjureFieldDefinition('interpolationRadius', scout_compute_api_DurationConstant)
        }

    __slots__: List[str] = ['_interpolation_radius']

    def __init__(self, interpolation_radius: "scout_compute_api_DurationConstant") -> None:
        self._interpolation_radius = interpolation_radius

    @builtins.property
    def interpolation_radius(self) -> "scout_compute_api_DurationConstant":
        return self._interpolation_radius


scout_compute_api_ForwardFillInterpolation.__name__ = "ForwardFillInterpolation"
scout_compute_api_ForwardFillInterpolation.__qualname__ = "ForwardFillInterpolation"
scout_compute_api_ForwardFillInterpolation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ForwardFillResampleInterpolationConfiguration(ConjureBeanType):
    """
    Forward fill interpolation for resampling. Rounds the earliest and latest timestamp up to the nearest interval
multiple and generates timestamps at the given interval between the new earliest and latest timestamps.
For every timestamp in the resampled timestamps, takes the last known value before the timestamp as the value.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_ForwardFillResampleInterpolationConfiguration.__name__ = "ForwardFillResampleInterpolationConfiguration"
scout_compute_api_ForwardFillResampleInterpolationConfiguration.__qualname__ = "ForwardFillResampleInterpolationConfiguration"
scout_compute_api_ForwardFillResampleInterpolationConfiguration.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_FrequencyDomainNode(ConjureUnionType):
    _fft: Optional["scout_compute_api_FftNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fft': ConjureFieldDefinition('fft', scout_compute_api_FftNode)
        }

    def __init__(
            self,
            fft: Optional["scout_compute_api_FftNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fft is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fft is not None:
                self._fft = fft
                self._type = 'fft'

        elif type_of_union == 'fft':
            if fft is None:
                raise ValueError('a union value must not be None')
            self._fft = fft
            self._type = 'fft'

    @builtins.property
    def fft(self) -> Optional["scout_compute_api_FftNode"]:
        return self._fft

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_FrequencyDomainNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_FrequencyDomainNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'fft' and self.fft is not None:
            return visitor._fft(self.fft)


scout_compute_api_FrequencyDomainNode.__name__ = "FrequencyDomainNode"
scout_compute_api_FrequencyDomainNode.__qualname__ = "FrequencyDomainNode"
scout_compute_api_FrequencyDomainNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_FrequencyDomainNodeVisitor:

    @abstractmethod
    def _fft(self, fft: "scout_compute_api_FftNode") -> Any:
        pass


scout_compute_api_FrequencyDomainNodeVisitor.__name__ = "FrequencyDomainNodeVisitor"
scout_compute_api_FrequencyDomainNodeVisitor.__qualname__ = "FrequencyDomainNodeVisitor"
scout_compute_api_FrequencyDomainNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_FrequencyDomainPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'frequencies': ConjureFieldDefinition('frequencies', List[float]),
            'amplitudes': ConjureFieldDefinition('amplitudes', List[float])
        }

    __slots__: List[str] = ['_frequencies', '_amplitudes']

    def __init__(self, amplitudes: List[float], frequencies: List[float]) -> None:
        self._frequencies = frequencies
        self._amplitudes = amplitudes

    @builtins.property
    def frequencies(self) -> List[float]:
        return self._frequencies

    @builtins.property
    def amplitudes(self) -> List[float]:
        return self._amplitudes


scout_compute_api_FrequencyDomainPlot.__name__ = "FrequencyDomainPlot"
scout_compute_api_FrequencyDomainPlot.__qualname__ = "FrequencyDomainPlot"
scout_compute_api_FrequencyDomainPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_FunctionVariable(ConjureUnionType):
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_FunctionVariableVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_FunctionVariableVisitor'.format(visitor.__class__.__name__))
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_FunctionVariable.__name__ = "FunctionVariable"
scout_compute_api_FunctionVariable.__qualname__ = "FunctionVariable"
scout_compute_api_FunctionVariable.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_FunctionVariableVisitor:

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_FunctionVariableVisitor.__name__ = "FunctionVariableVisitor"
scout_compute_api_FunctionVariableVisitor.__qualname__ = "FunctionVariableVisitor"
scout_compute_api_FunctionVariableVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_FunctionVariables(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_compute_api_VariableValue]),
            'sub_function_variables': ConjureFieldDefinition('subFunctionVariables', Dict[scout_compute_api_FunctionReference, scout_compute_api_FunctionVariables])
        }

    __slots__: List[str] = ['_variables', '_sub_function_variables']

    def __init__(self, sub_function_variables: Dict[str, "scout_compute_api_FunctionVariables"], variables: Dict[str, "scout_compute_api_VariableValue"]) -> None:
        self._variables = variables
        self._sub_function_variables = sub_function_variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_compute_api_VariableValue"]:
        return self._variables

    @builtins.property
    def sub_function_variables(self) -> Dict[str, "scout_compute_api_FunctionVariables"]:
        return self._sub_function_variables


scout_compute_api_FunctionVariables.__name__ = "FunctionVariables"
scout_compute_api_FunctionVariables.__qualname__ = "FunctionVariables"
scout_compute_api_FunctionVariables.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_GeoNode(ConjureUnionType):
    _lat_long_geo_node: Optional["scout_compute_api_LatLongGeoNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'lat_long_geo_node': ConjureFieldDefinition('latLongGeoNode', scout_compute_api_LatLongGeoNode)
        }

    def __init__(
            self,
            lat_long_geo_node: Optional["scout_compute_api_LatLongGeoNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (lat_long_geo_node is not None) != 1:
                raise ValueError('a union must contain a single member')

            if lat_long_geo_node is not None:
                self._lat_long_geo_node = lat_long_geo_node
                self._type = 'latLongGeoNode'

        elif type_of_union == 'latLongGeoNode':
            if lat_long_geo_node is None:
                raise ValueError('a union value must not be None')
            self._lat_long_geo_node = lat_long_geo_node
            self._type = 'latLongGeoNode'

    @builtins.property
    def lat_long_geo_node(self) -> Optional["scout_compute_api_LatLongGeoNode"]:
        return self._lat_long_geo_node

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_GeoNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_GeoNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'latLongGeoNode' and self.lat_long_geo_node is not None:
            return visitor._lat_long_geo_node(self.lat_long_geo_node)


scout_compute_api_GeoNode.__name__ = "GeoNode"
scout_compute_api_GeoNode.__qualname__ = "GeoNode"
scout_compute_api_GeoNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_GeoNodeVisitor:

    @abstractmethod
    def _lat_long_geo_node(self, lat_long_geo_node: "scout_compute_api_LatLongGeoNode") -> Any:
        pass


scout_compute_api_GeoNodeVisitor.__name__ = "GeoNodeVisitor"
scout_compute_api_GeoNodeVisitor.__qualname__ = "GeoNodeVisitor"
scout_compute_api_GeoNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_GeoNodeSummaryStrategy(ConjureUnionType):
    _temporal: Optional["scout_compute_api_GeoNodeTemporalSummary"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'temporal': ConjureFieldDefinition('temporal', scout_compute_api_GeoNodeTemporalSummary)
        }

    def __init__(
            self,
            temporal: Optional["scout_compute_api_GeoNodeTemporalSummary"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (temporal is not None) != 1:
                raise ValueError('a union must contain a single member')

            if temporal is not None:
                self._temporal = temporal
                self._type = 'temporal'

        elif type_of_union == 'temporal':
            if temporal is None:
                raise ValueError('a union value must not be None')
            self._temporal = temporal
            self._type = 'temporal'

    @builtins.property
    def temporal(self) -> Optional["scout_compute_api_GeoNodeTemporalSummary"]:
        return self._temporal

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_GeoNodeSummaryStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_GeoNodeSummaryStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'temporal' and self.temporal is not None:
            return visitor._temporal(self.temporal)


scout_compute_api_GeoNodeSummaryStrategy.__name__ = "GeoNodeSummaryStrategy"
scout_compute_api_GeoNodeSummaryStrategy.__qualname__ = "GeoNodeSummaryStrategy"
scout_compute_api_GeoNodeSummaryStrategy.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_GeoNodeSummaryStrategyVisitor:

    @abstractmethod
    def _temporal(self, temporal: "scout_compute_api_GeoNodeTemporalSummary") -> Any:
        pass


scout_compute_api_GeoNodeSummaryStrategyVisitor.__name__ = "GeoNodeSummaryStrategyVisitor"
scout_compute_api_GeoNodeSummaryStrategyVisitor.__qualname__ = "GeoNodeSummaryStrategyVisitor"
scout_compute_api_GeoNodeSummaryStrategyVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_GeoNodeTemporalSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resolution': ConjureFieldDefinition('resolution', int)
        }

    __slots__: List[str] = ['_resolution']

    def __init__(self, resolution: int) -> None:
        self._resolution = resolution

    @builtins.property
    def resolution(self) -> int:
        return self._resolution


scout_compute_api_GeoNodeTemporalSummary.__name__ = "GeoNodeTemporalSummary"
scout_compute_api_GeoNodeTemporalSummary.__qualname__ = "GeoNodeTemporalSummary"
scout_compute_api_GeoNodeTemporalSummary.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_GeoPoint(ConjureUnionType):
    """Represents a geographic point. Flexible to handle multiple types of geographic coordinate systems."""
    _lat_long: Optional["scout_compute_api_LatLongPoint"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'lat_long': ConjureFieldDefinition('latLong', scout_compute_api_LatLongPoint)
        }

    def __init__(
            self,
            lat_long: Optional["scout_compute_api_LatLongPoint"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (lat_long is not None) != 1:
                raise ValueError('a union must contain a single member')

            if lat_long is not None:
                self._lat_long = lat_long
                self._type = 'latLong'

        elif type_of_union == 'latLong':
            if lat_long is None:
                raise ValueError('a union value must not be None')
            self._lat_long = lat_long
            self._type = 'latLong'

    @builtins.property
    def lat_long(self) -> Optional["scout_compute_api_LatLongPoint"]:
        return self._lat_long

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_GeoPointVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_GeoPointVisitor'.format(visitor.__class__.__name__))
        if self._type == 'latLong' and self.lat_long is not None:
            return visitor._lat_long(self.lat_long)


scout_compute_api_GeoPoint.__name__ = "GeoPoint"
scout_compute_api_GeoPoint.__qualname__ = "GeoPoint"
scout_compute_api_GeoPoint.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_GeoPointVisitor:

    @abstractmethod
    def _lat_long(self, lat_long: "scout_compute_api_LatLongPoint") -> Any:
        pass


scout_compute_api_GeoPointVisitor.__name__ = "GeoPointVisitor"
scout_compute_api_GeoPointVisitor.__qualname__ = "GeoPointVisitor"
scout_compute_api_GeoPointVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_GeoPointWithTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', scout_compute_api_GeoPoint)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: "scout_compute_api_GeoPoint") -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> "scout_compute_api_GeoPoint":
        return self._value


scout_compute_api_GeoPointWithTimestamp.__name__ = "GeoPointWithTimestamp"
scout_compute_api_GeoPointWithTimestamp.__qualname__ = "GeoPointWithTimestamp"
scout_compute_api_GeoPointWithTimestamp.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_GeoTimeBucket(ConjureBeanType):
    """
    Summary of a time-based bucket of geo points.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'mean': ConjureFieldDefinition('mean', scout_compute_api_GeoPoint),
            'count': ConjureFieldDefinition('count', int),
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_api_GeoPointWithTimestamp),
            'last_point': ConjureFieldDefinition('lastPoint', OptionalTypeWrapper[scout_compute_api_GeoPointWithTimestamp])
        }

    __slots__: List[str] = ['_mean', '_count', '_first_point', '_last_point']

    def __init__(self, count: int, first_point: "scout_compute_api_GeoPointWithTimestamp", mean: "scout_compute_api_GeoPoint", last_point: Optional["scout_compute_api_GeoPointWithTimestamp"] = None) -> None:
        self._mean = mean
        self._count = count
        self._first_point = first_point
        self._last_point = last_point

    @builtins.property
    def mean(self) -> "scout_compute_api_GeoPoint":
        """
        The mean value of the GeoPoints in the bucket.
        """
        return self._mean

    @builtins.property
    def count(self) -> int:
        """
        The number of GeoPoints in the bucket.
        """
        return self._count

    @builtins.property
    def first_point(self) -> "scout_compute_api_GeoPointWithTimestamp":
        """
        The first GeoPoint in the bucket.
        """
        return self._first_point

    @builtins.property
    def last_point(self) -> Optional["scout_compute_api_GeoPointWithTimestamp"]:
        """
        The last GeoPoint in the bucket. Will be empty if the bucket only has a single point.
        """
        return self._last_point


scout_compute_api_GeoTimeBucket.__name__ = "GeoTimeBucket"
scout_compute_api_GeoTimeBucket.__qualname__ = "GeoTimeBucket"
scout_compute_api_GeoTimeBucket.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_HistogramChannelCount(ConjureBeanType):
    """
    The count of the value in the bucket for the specific channel.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_count']

    def __init__(self, count: int) -> None:
        self._count = count

    @builtins.property
    def count(self) -> int:
        return self._count


scout_compute_api_HistogramChannelCount.__name__ = "HistogramChannelCount"
scout_compute_api_HistogramChannelCount.__qualname__ = "HistogramChannelCount"
scout_compute_api_HistogramChannelCount.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_HistogramNode(ConjureUnionType):
    _numeric: Optional["scout_compute_api_NumericHistogramNode"] = None
    _enum: Optional["scout_compute_api_EnumHistogramNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericHistogramNode),
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumHistogramNode)
        }

    def __init__(
            self,
            numeric: Optional["scout_compute_api_NumericHistogramNode"] = None,
            enum: Optional["scout_compute_api_EnumHistogramNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) + (enum is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericHistogramNode"]:
        return self._numeric

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumHistogramNode"]:
        return self._enum

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_HistogramNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_HistogramNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)


scout_compute_api_HistogramNode.__name__ = "HistogramNode"
scout_compute_api_HistogramNode.__qualname__ = "HistogramNode"
scout_compute_api_HistogramNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_HistogramNodeVisitor:

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericHistogramNode") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumHistogramNode") -> Any:
        pass


scout_compute_api_HistogramNodeVisitor.__name__ = "HistogramNodeVisitor"
scout_compute_api_HistogramNodeVisitor.__qualname__ = "HistogramNodeVisitor"
scout_compute_api_HistogramNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_IncompatibleUnitOperation(ConjureBeanType):
    """
    Attempted an incompatible operation of units.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operation': ConjureFieldDefinition('operation', scout_compute_api_UnitOperation),
            'units': ConjureFieldDefinition('units', List[scout_units_api_UnitSymbol])
        }

    __slots__: List[str] = ['_operation', '_units']

    def __init__(self, operation: "scout_compute_api_UnitOperation", units: List[str]) -> None:
        self._operation = operation
        self._units = units

    @builtins.property
    def operation(self) -> "scout_compute_api_UnitOperation":
        return self._operation

    @builtins.property
    def units(self) -> List[str]:
        return self._units


scout_compute_api_IncompatibleUnitOperation.__name__ = "IncompatibleUnitOperation"
scout_compute_api_IncompatibleUnitOperation.__qualname__ = "IncompatibleUnitOperation"
scout_compute_api_IncompatibleUnitOperation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_IntegerConstant(ConjureUnionType):
    _literal: Optional[int] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', int),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional[int] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional[int]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_IntegerConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_IntegerConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_IntegerConstant.__name__ = "IntegerConstant"
scout_compute_api_IntegerConstant.__qualname__ = "IntegerConstant"
scout_compute_api_IntegerConstant.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_IntegerConstantVisitor:

    @abstractmethod
    def _literal(self, literal: int) -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_IntegerConstantVisitor.__name__ = "IntegerConstantVisitor"
scout_compute_api_IntegerConstantVisitor.__qualname__ = "IntegerConstantVisitor"
scout_compute_api_IntegerConstantVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_IntegralSeriesNode(ConjureBeanType):
    """
    Calculates the running sum of the area underneath a series using the trapezoidal rule.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', scout_compute_api_TimestampConstant),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[scout_compute_api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_start_timestamp', '_time_unit']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", start_timestamp: "scout_compute_api_TimestampConstant", time_unit: Optional["scout_compute_api_TimeUnit"] = None) -> None:
        self._input = input
        self._start_timestamp = start_timestamp
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_timestamp(self) -> "scout_compute_api_TimestampConstant":
        return self._start_timestamp

    @builtins.property
    def time_unit(self) -> Optional["scout_compute_api_TimeUnit"]:
        """
        Time unit used to calculate the integral. Defaults to seconds if not specified.
        """
        return self._time_unit


scout_compute_api_IntegralSeriesNode.__name__ = "IntegralSeriesNode"
scout_compute_api_IntegralSeriesNode.__qualname__ = "IntegralSeriesNode"
scout_compute_api_IntegralSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_InterpolationConfiguration(ConjureUnionType):
    _forward_fill_interpolation: Optional["scout_compute_api_ForwardFillInterpolation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'forward_fill_interpolation': ConjureFieldDefinition('forwardFillInterpolation', scout_compute_api_ForwardFillInterpolation)
        }

    def __init__(
            self,
            forward_fill_interpolation: Optional["scout_compute_api_ForwardFillInterpolation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (forward_fill_interpolation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if forward_fill_interpolation is not None:
                self._forward_fill_interpolation = forward_fill_interpolation
                self._type = 'forwardFillInterpolation'

        elif type_of_union == 'forwardFillInterpolation':
            if forward_fill_interpolation is None:
                raise ValueError('a union value must not be None')
            self._forward_fill_interpolation = forward_fill_interpolation
            self._type = 'forwardFillInterpolation'

    @builtins.property
    def forward_fill_interpolation(self) -> Optional["scout_compute_api_ForwardFillInterpolation"]:
        return self._forward_fill_interpolation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_InterpolationConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_InterpolationConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'forwardFillInterpolation' and self.forward_fill_interpolation is not None:
            return visitor._forward_fill_interpolation(self.forward_fill_interpolation)


scout_compute_api_InterpolationConfiguration.__name__ = "InterpolationConfiguration"
scout_compute_api_InterpolationConfiguration.__qualname__ = "InterpolationConfiguration"
scout_compute_api_InterpolationConfiguration.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_InterpolationConfigurationVisitor:

    @abstractmethod
    def _forward_fill_interpolation(self, forward_fill_interpolation: "scout_compute_api_ForwardFillInterpolation") -> Any:
        pass


scout_compute_api_InterpolationConfigurationVisitor.__name__ = "InterpolationConfigurationVisitor"
scout_compute_api_InterpolationConfigurationVisitor.__qualname__ = "InterpolationConfigurationVisitor"
scout_compute_api_InterpolationConfigurationVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_IntersectRangesNode(ConjureBeanType):
    """
    The FE should try to pass in inputs in the order in which they should be
evaluated for optimization's sake. Alternatively, we can let the user select
preconditions which they know to be cheaper to compute, which we will evaluate
first.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_api_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_api_RangesNode"]:
        return self._inputs


scout_compute_api_IntersectRangesNode.__name__ = "IntersectRangesNode"
scout_compute_api_IntersectRangesNode.__qualname__ = "IntersectRangesNode"
scout_compute_api_IntersectRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_LatLongBounds(ConjureBeanType):
    """
    The bounds of a lat long geographic area. Represented by the southwest and northeast corners 
of a rectangle, inclusive.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'south_west': ConjureFieldDefinition('southWest', scout_compute_api_LatLongPoint),
            'north_east': ConjureFieldDefinition('northEast', scout_compute_api_LatLongPoint)
        }

    __slots__: List[str] = ['_south_west', '_north_east']

    def __init__(self, north_east: "scout_compute_api_LatLongPoint", south_west: "scout_compute_api_LatLongPoint") -> None:
        self._south_west = south_west
        self._north_east = north_east

    @builtins.property
    def south_west(self) -> "scout_compute_api_LatLongPoint":
        return self._south_west

    @builtins.property
    def north_east(self) -> "scout_compute_api_LatLongPoint":
        return self._north_east


scout_compute_api_LatLongBounds.__name__ = "LatLongBounds"
scout_compute_api_LatLongBounds.__qualname__ = "LatLongBounds"
scout_compute_api_LatLongBounds.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_LatLongGeoNode(ConjureBeanType):
    """
    A geo node derived from a lat and long series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'latitude': ConjureFieldDefinition('latitude', scout_compute_api_NumericSeriesNode),
            'longitude': ConjureFieldDefinition('longitude', scout_compute_api_NumericSeriesNode),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_api_LatLongBounds])
        }

    __slots__: List[str] = ['_latitude', '_longitude', '_bounds']

    def __init__(self, latitude: "scout_compute_api_NumericSeriesNode", longitude: "scout_compute_api_NumericSeriesNode", bounds: Optional["scout_compute_api_LatLongBounds"] = None) -> None:
        self._latitude = latitude
        self._longitude = longitude
        self._bounds = bounds

    @builtins.property
    def latitude(self) -> "scout_compute_api_NumericSeriesNode":
        return self._latitude

    @builtins.property
    def longitude(self) -> "scout_compute_api_NumericSeriesNode":
        return self._longitude

    @builtins.property
    def bounds(self) -> Optional["scout_compute_api_LatLongBounds"]:
        return self._bounds


scout_compute_api_LatLongGeoNode.__name__ = "LatLongGeoNode"
scout_compute_api_LatLongGeoNode.__qualname__ = "LatLongGeoNode"
scout_compute_api_LatLongGeoNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_LatLongPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'latitude': ConjureFieldDefinition('latitude', float),
            'longitude': ConjureFieldDefinition('longitude', float)
        }

    __slots__: List[str] = ['_latitude', '_longitude']

    def __init__(self, latitude: float, longitude: float) -> None:
        self._latitude = latitude
        self._longitude = longitude

    @builtins.property
    def latitude(self) -> float:
        return self._latitude

    @builtins.property
    def longitude(self) -> float:
        return self._longitude


scout_compute_api_LatLongPoint.__name__ = "LatLongPoint"
scout_compute_api_LatLongPoint.__qualname__ = "LatLongPoint"
scout_compute_api_LatLongPoint.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_MaxSeriesNode(ConjureBeanType):
    """
    For every timestamp specified in the input series, outputs a value that is the maximum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeriesNode"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """
        Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_MaxSeriesNode.__name__ = "MaxSeriesNode"
scout_compute_api_MaxSeriesNode.__qualname__ = "MaxSeriesNode"
scout_compute_api_MaxSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_Maximum(ConjureBeanType):
    """
    The maximum value of points inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Maximum.__name__ = "Maximum"
scout_compute_api_Maximum.__qualname__ = "Maximum"
scout_compute_api_Maximum.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_MeanSeriesNode(ConjureBeanType):
    """
    For every timestamp specified in the input series, outputs a value that is the mean for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeriesNode"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """
        Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_MeanSeriesNode.__name__ = "MeanSeriesNode"
scout_compute_api_MeanSeriesNode.__qualname__ = "MeanSeriesNode"
scout_compute_api_MeanSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_MinMaxThresholdOperator(ConjureEnumType):

    OUTSIDE_BOUNDS = 'OUTSIDE_BOUNDS'
    '''OUTSIDE_BOUNDS'''
    OUTSIDE_OR_EQUAL_TO_BOUNDS = 'OUTSIDE_OR_EQUAL_TO_BOUNDS'
    '''OUTSIDE_OR_EQUAL_TO_BOUNDS'''
    INSIDE_BOUNDS = 'INSIDE_BOUNDS'
    '''INSIDE_BOUNDS'''
    INSIDE_OR_EQUAL_TO_BOUNDS = 'INSIDE_OR_EQUAL_TO_BOUNDS'
    '''INSIDE_OR_EQUAL_TO_BOUNDS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_MinMaxThresholdOperator.__name__ = "MinMaxThresholdOperator"
scout_compute_api_MinMaxThresholdOperator.__qualname__ = "MinMaxThresholdOperator"
scout_compute_api_MinMaxThresholdOperator.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_MinMaxThresholdRangesNode(ConjureBeanType):
    """
    Produces a list of ranges for which the threshold condition is satisfied.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'lower_bound': ConjureFieldDefinition('lowerBound', scout_compute_api_DoubleConstant),
            'upper_bound': ConjureFieldDefinition('upperBound', scout_compute_api_DoubleConstant),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_MinMaxThresholdOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_lower_bound', '_upper_bound', '_operator', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", lower_bound: "scout_compute_api_DoubleConstant", operator: "scout_compute_api_MinMaxThresholdOperator", upper_bound: "scout_compute_api_DoubleConstant", persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._lower_bound = lower_bound
        self._upper_bound = upper_bound
        self._operator = operator
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def lower_bound(self) -> "scout_compute_api_DoubleConstant":
        return self._lower_bound

    @builtins.property
    def upper_bound(self) -> "scout_compute_api_DoubleConstant":
        return self._upper_bound

    @builtins.property
    def operator(self) -> "scout_compute_api_MinMaxThresholdOperator":
        return self._operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_MinMaxThresholdRangesNode.__name__ = "MinMaxThresholdRangesNode"
scout_compute_api_MinMaxThresholdRangesNode.__qualname__ = "MinMaxThresholdRangesNode"
scout_compute_api_MinMaxThresholdRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_MinSeriesNode(ConjureBeanType):
    """
    For every timestamp specified in the input series, outputs a value that is the minimum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeriesNode"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """
        Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_MinSeriesNode.__name__ = "MinSeriesNode"
scout_compute_api_MinSeriesNode.__qualname__ = "MinSeriesNode"
scout_compute_api_MinSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_Minimum(ConjureBeanType):
    """
    The minimum value of points inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Minimum.__name__ = "Minimum"
scout_compute_api_Minimum.__qualname__ = "Minimum"
scout_compute_api_Minimum.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NegativeValueConfiguration(ConjureUnionType):
    _allow_negative_values: Optional["scout_compute_api_AllowNegativeValues"] = None
    _set_negative_values_to_zero: Optional["scout_compute_api_SetNegativeValuesToZero"] = None
    _exclude_negative_values: Optional["scout_compute_api_ExcludeNegativeValues"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'allow_negative_values': ConjureFieldDefinition('allowNegativeValues', scout_compute_api_AllowNegativeValues),
            'set_negative_values_to_zero': ConjureFieldDefinition('setNegativeValuesToZero', scout_compute_api_SetNegativeValuesToZero),
            'exclude_negative_values': ConjureFieldDefinition('excludeNegativeValues', scout_compute_api_ExcludeNegativeValues)
        }

    def __init__(
            self,
            allow_negative_values: Optional["scout_compute_api_AllowNegativeValues"] = None,
            set_negative_values_to_zero: Optional["scout_compute_api_SetNegativeValuesToZero"] = None,
            exclude_negative_values: Optional["scout_compute_api_ExcludeNegativeValues"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (allow_negative_values is not None) + (set_negative_values_to_zero is not None) + (exclude_negative_values is not None) != 1:
                raise ValueError('a union must contain a single member')

            if allow_negative_values is not None:
                self._allow_negative_values = allow_negative_values
                self._type = 'allowNegativeValues'
            if set_negative_values_to_zero is not None:
                self._set_negative_values_to_zero = set_negative_values_to_zero
                self._type = 'setNegativeValuesToZero'
            if exclude_negative_values is not None:
                self._exclude_negative_values = exclude_negative_values
                self._type = 'excludeNegativeValues'

        elif type_of_union == 'allowNegativeValues':
            if allow_negative_values is None:
                raise ValueError('a union value must not be None')
            self._allow_negative_values = allow_negative_values
            self._type = 'allowNegativeValues'
        elif type_of_union == 'setNegativeValuesToZero':
            if set_negative_values_to_zero is None:
                raise ValueError('a union value must not be None')
            self._set_negative_values_to_zero = set_negative_values_to_zero
            self._type = 'setNegativeValuesToZero'
        elif type_of_union == 'excludeNegativeValues':
            if exclude_negative_values is None:
                raise ValueError('a union value must not be None')
            self._exclude_negative_values = exclude_negative_values
            self._type = 'excludeNegativeValues'

    @builtins.property
    def allow_negative_values(self) -> Optional["scout_compute_api_AllowNegativeValues"]:
        """
        Include negative output values
        """
        return self._allow_negative_values

    @builtins.property
    def set_negative_values_to_zero(self) -> Optional["scout_compute_api_SetNegativeValuesToZero"]:
        """
        Set negative output values to zero
        """
        return self._set_negative_values_to_zero

    @builtins.property
    def exclude_negative_values(self) -> Optional["scout_compute_api_ExcludeNegativeValues"]:
        """
        Exclude points with negative output values
        """
        return self._exclude_negative_values

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_NegativeValueConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_NegativeValueConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'allowNegativeValues' and self.allow_negative_values is not None:
            return visitor._allow_negative_values(self.allow_negative_values)
        if self._type == 'setNegativeValuesToZero' and self.set_negative_values_to_zero is not None:
            return visitor._set_negative_values_to_zero(self.set_negative_values_to_zero)
        if self._type == 'excludeNegativeValues' and self.exclude_negative_values is not None:
            return visitor._exclude_negative_values(self.exclude_negative_values)


scout_compute_api_NegativeValueConfiguration.__name__ = "NegativeValueConfiguration"
scout_compute_api_NegativeValueConfiguration.__qualname__ = "NegativeValueConfiguration"
scout_compute_api_NegativeValueConfiguration.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NegativeValueConfigurationVisitor:

    @abstractmethod
    def _allow_negative_values(self, allow_negative_values: "scout_compute_api_AllowNegativeValues") -> Any:
        pass

    @abstractmethod
    def _set_negative_values_to_zero(self, set_negative_values_to_zero: "scout_compute_api_SetNegativeValuesToZero") -> Any:
        pass

    @abstractmethod
    def _exclude_negative_values(self, exclude_negative_values: "scout_compute_api_ExcludeNegativeValues") -> Any:
        pass


scout_compute_api_NegativeValueConfigurationVisitor.__name__ = "NegativeValueConfigurationVisitor"
scout_compute_api_NegativeValueConfigurationVisitor.__qualname__ = "NegativeValueConfigurationVisitor"
scout_compute_api_NegativeValueConfigurationVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NotRangesNode(ConjureBeanType):
    """
    The not ranges node will invert the ranges, filling the negative space in time.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_RangesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_api_RangesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_api_RangesNode":
        return self._input


scout_compute_api_NotRangesNode.__name__ = "NotRangesNode"
scout_compute_api_NotRangesNode.__qualname__ = "NotRangesNode"
scout_compute_api_NotRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericAggregationFunction(ConjureEnumType):

    SUM = 'SUM'
    '''SUM'''
    MEAN = 'MEAN'
    '''MEAN'''
    MIN = 'MIN'
    '''MIN'''
    MAX = 'MAX'
    '''MAX'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_NumericAggregationFunction.__name__ = "NumericAggregationFunction"
scout_compute_api_NumericAggregationFunction.__qualname__ = "NumericAggregationFunction"
scout_compute_api_NumericAggregationFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min': ConjureFieldDefinition('min', float),
            'max': ConjureFieldDefinition('max', float),
            'mean': ConjureFieldDefinition('mean', float),
            'count': ConjureFieldDefinition('count', int),
            'variance': ConjureFieldDefinition('variance', float),
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_api_NumericPoint),
            'last_point': ConjureFieldDefinition('lastPoint', OptionalTypeWrapper[scout_compute_api_NumericPoint])
        }

    __slots__: List[str] = ['_min', '_max', '_mean', '_count', '_variance', '_first_point', '_last_point']

    def __init__(self, count: int, first_point: "scout_compute_api_NumericPoint", max: float, mean: float, min: float, variance: float, last_point: Optional["scout_compute_api_NumericPoint"] = None) -> None:
        self._min = min
        self._max = max
        self._mean = mean
        self._count = count
        self._variance = variance
        self._first_point = first_point
        self._last_point = last_point

    @builtins.property
    def min(self) -> float:
        return self._min

    @builtins.property
    def max(self) -> float:
        return self._max

    @builtins.property
    def mean(self) -> float:
        return self._mean

    @builtins.property
    def count(self) -> int:
        return self._count

    @builtins.property
    def variance(self) -> float:
        """
        The population variance of the bucket. If the bucket has only one value, this will be 0.
        """
        return self._variance

    @builtins.property
    def first_point(self) -> "scout_compute_api_NumericPoint":
        return self._first_point

    @builtins.property
    def last_point(self) -> Optional["scout_compute_api_NumericPoint"]:
        """
        Will be empty if the bucket only has a single point.
        """
        return self._last_point


scout_compute_api_NumericBucket.__name__ = "NumericBucket"
scout_compute_api_NumericBucket.__qualname__ = "NumericBucket"
scout_compute_api_NumericBucket.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericFilterTransformationSeriesNode(ConjureBeanType):
    """
    Outputs the values of the numeric plot value within the ranges specified by a ranges node
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'filter': ConjureFieldDefinition('filter', scout_compute_api_RangesNode)
        }

    __slots__: List[str] = ['_input', '_filter']

    def __init__(self, filter: "scout_compute_api_RangesNode", input: "scout_compute_api_NumericSeriesNode") -> None:
        self._input = input
        self._filter = filter

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def filter(self) -> "scout_compute_api_RangesNode":
        return self._filter


scout_compute_api_NumericFilterTransformationSeriesNode.__name__ = "NumericFilterTransformationSeriesNode"
scout_compute_api_NumericFilterTransformationSeriesNode.__qualname__ = "NumericFilterTransformationSeriesNode"
scout_compute_api_NumericFilterTransformationSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericHistogramBucket(ConjureBeanType):
    """
    A bucket in a numeric histogram representing a range of values,
and the counts of values in that range across all input series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'lower_bound': ConjureFieldDefinition('lowerBound', float),
            'upper_bound': ConjureFieldDefinition('upperBound', float),
            'counts_by_channel': ConjureFieldDefinition('countsByChannel', Dict[scout_compute_api_VariableName, scout_compute_api_HistogramChannelCount]),
            'buckets': ConjureFieldDefinition('buckets', Dict[scout_compute_api_VariableName, scout_compute_api_HistogramChannelCount])
        }

    __slots__: List[str] = ['_lower_bound', '_upper_bound', '_counts_by_channel', '_buckets']

    def __init__(self, buckets: Dict[str, "scout_compute_api_HistogramChannelCount"], counts_by_channel: Dict[str, "scout_compute_api_HistogramChannelCount"], lower_bound: float, upper_bound: float) -> None:
        self._lower_bound = lower_bound
        self._upper_bound = upper_bound
        self._counts_by_channel = counts_by_channel
        self._buckets = buckets

    @builtins.property
    def lower_bound(self) -> float:
        """
        The lower bound of the bucket, inclusive
        """
        return self._lower_bound

    @builtins.property
    def upper_bound(self) -> float:
        """
        The upper bound of the bucket, exclusive
        """
        return self._upper_bound

    @builtins.property
    def counts_by_channel(self) -> Dict[str, "scout_compute_api_HistogramChannelCount"]:
        return self._counts_by_channel

    @builtins.property
    def buckets(self) -> Dict[str, "scout_compute_api_HistogramChannelCount"]:
        return self._buckets


scout_compute_api_NumericHistogramBucket.__name__ = "NumericHistogramBucket"
scout_compute_api_NumericHistogramBucket.__qualname__ = "NumericHistogramBucket"
scout_compute_api_NumericHistogramBucket.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericHistogramBucketStrategy(ConjureUnionType):
    _bucket_count: Optional["scout_compute_api_IntegerConstant"] = None
    _bucket_width_and_offset: Optional["scout_compute_api_NumericHistogramBucketWidthAndOffset"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket_count': ConjureFieldDefinition('bucketCount', scout_compute_api_IntegerConstant),
            'bucket_width_and_offset': ConjureFieldDefinition('bucketWidthAndOffset', scout_compute_api_NumericHistogramBucketWidthAndOffset)
        }

    def __init__(
            self,
            bucket_count: Optional["scout_compute_api_IntegerConstant"] = None,
            bucket_width_and_offset: Optional["scout_compute_api_NumericHistogramBucketWidthAndOffset"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (bucket_count is not None) + (bucket_width_and_offset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if bucket_count is not None:
                self._bucket_count = bucket_count
                self._type = 'bucketCount'
            if bucket_width_and_offset is not None:
                self._bucket_width_and_offset = bucket_width_and_offset
                self._type = 'bucketWidthAndOffset'

        elif type_of_union == 'bucketCount':
            if bucket_count is None:
                raise ValueError('a union value must not be None')
            self._bucket_count = bucket_count
            self._type = 'bucketCount'
        elif type_of_union == 'bucketWidthAndOffset':
            if bucket_width_and_offset is None:
                raise ValueError('a union value must not be None')
            self._bucket_width_and_offset = bucket_width_and_offset
            self._type = 'bucketWidthAndOffset'

    @builtins.property
    def bucket_count(self) -> Optional["scout_compute_api_IntegerConstant"]:
        """
        The number of buckets to use in the histogram. Width is automatically calculated from the range
of the input series, with the lower and upper bounds of the histogram being multiples of the width.
        """
        return self._bucket_count

    @builtins.property
    def bucket_width_and_offset(self) -> Optional["scout_compute_api_NumericHistogramBucketWidthAndOffset"]:
        return self._bucket_width_and_offset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_NumericHistogramBucketStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_NumericHistogramBucketStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'bucketCount' and self.bucket_count is not None:
            return visitor._bucket_count(self.bucket_count)
        if self._type == 'bucketWidthAndOffset' and self.bucket_width_and_offset is not None:
            return visitor._bucket_width_and_offset(self.bucket_width_and_offset)


scout_compute_api_NumericHistogramBucketStrategy.__name__ = "NumericHistogramBucketStrategy"
scout_compute_api_NumericHistogramBucketStrategy.__qualname__ = "NumericHistogramBucketStrategy"
scout_compute_api_NumericHistogramBucketStrategy.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericHistogramBucketStrategyVisitor:

    @abstractmethod
    def _bucket_count(self, bucket_count: "scout_compute_api_IntegerConstant") -> Any:
        pass

    @abstractmethod
    def _bucket_width_and_offset(self, bucket_width_and_offset: "scout_compute_api_NumericHistogramBucketWidthAndOffset") -> Any:
        pass


scout_compute_api_NumericHistogramBucketStrategyVisitor.__name__ = "NumericHistogramBucketStrategyVisitor"
scout_compute_api_NumericHistogramBucketStrategyVisitor.__qualname__ = "NumericHistogramBucketStrategyVisitor"
scout_compute_api_NumericHistogramBucketStrategyVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericHistogramBucketWidthAndOffset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'width': ConjureFieldDefinition('width', scout_compute_api_DoubleConstant),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_compute_api_DoubleConstant])
        }

    __slots__: List[str] = ['_width', '_offset']

    def __init__(self, width: "scout_compute_api_DoubleConstant", offset: Optional["scout_compute_api_DoubleConstant"] = None) -> None:
        self._width = width
        self._offset = offset

    @builtins.property
    def width(self) -> "scout_compute_api_DoubleConstant":
        """
        The width of each bucket. If offset is not specified, the left and right bounds of each bucket
are multiples of the width. If offset is specified, the left and right bounds of each bucket are
shifted right by the offset value.
        """
        return self._width

    @builtins.property
    def offset(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """
        The rightward shift to apply to the left and right bounds of each bucket. If not specified, 
the offset will be 0. The offset must be non-negative.
        """
        return self._offset


scout_compute_api_NumericHistogramBucketWidthAndOffset.__name__ = "NumericHistogramBucketWidthAndOffset"
scout_compute_api_NumericHistogramBucketWidthAndOffset.__qualname__ = "NumericHistogramBucketWidthAndOffset"
scout_compute_api_NumericHistogramBucketWidthAndOffset.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericHistogramNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_VariableName, scout_compute_api_NumericSeriesNode]),
            'bucket_strategy': ConjureFieldDefinition('bucketStrategy', OptionalTypeWrapper[scout_compute_api_NumericHistogramBucketStrategy])
        }

    __slots__: List[str] = ['_inputs', '_bucket_strategy']

    def __init__(self, inputs: Dict[str, "scout_compute_api_NumericSeriesNode"], bucket_strategy: Optional["scout_compute_api_NumericHistogramBucketStrategy"] = None) -> None:
        self._inputs = inputs
        self._bucket_strategy = bucket_strategy

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def bucket_strategy(self) -> Optional["scout_compute_api_NumericHistogramBucketStrategy"]:
        return self._bucket_strategy


scout_compute_api_NumericHistogramNode.__name__ = "NumericHistogramNode"
scout_compute_api_NumericHistogramNode.__qualname__ = "NumericHistogramNode"
scout_compute_api_NumericHistogramNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericHistogramPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_NumericHistogramBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_compute_api_NumericHistogramBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_compute_api_NumericHistogramBucket"]:
        return self._buckets


scout_compute_api_NumericHistogramPlot.__name__ = "NumericHistogramPlot"
scout_compute_api_NumericHistogramPlot.__qualname__ = "NumericHistogramPlot"
scout_compute_api_NumericHistogramPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'values': ConjureFieldDefinition('values', List[float])
        }

    __slots__: List[str] = ['_timestamps', '_values']

    def __init__(self, timestamps: List["api_Timestamp"], values: List[float]) -> None:
        self._timestamps = timestamps
        self._values = values

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        return self._timestamps

    @builtins.property
    def values(self) -> List[float]:
        return self._values


scout_compute_api_NumericPlot.__name__ = "NumericPlot"
scout_compute_api_NumericPlot.__qualname__ = "NumericPlot"
scout_compute_api_NumericPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', float)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: float) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> float:
        return self._value


scout_compute_api_NumericPoint.__name__ = "NumericPoint"
scout_compute_api_NumericPoint.__qualname__ = "NumericPoint"
scout_compute_api_NumericPoint.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericResampleSeriesNode(ConjureBeanType):
    """
    Resamples the input series to a new resolution using interpolation.
Outputs data for timestamps corresponding to the defined frequency. Based on interpolation strategy,
determines range of timestamps to output data for and interpolates values where necessary.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'resample_configuration': ConjureFieldDefinition('resampleConfiguration', scout_compute_api_ResampleConfiguration)
        }

    __slots__: List[str] = ['_input', '_resample_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", resample_configuration: "scout_compute_api_ResampleConfiguration") -> None:
        self._input = input
        self._resample_configuration = resample_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def resample_configuration(self) -> "scout_compute_api_ResampleConfiguration":
        """
        The interpolation strategy and interval at which to resample the series
        """
        return self._resample_configuration


scout_compute_api_NumericResampleSeriesNode.__name__ = "NumericResampleSeriesNode"
scout_compute_api_NumericResampleSeriesNode.__qualname__ = "NumericResampleSeriesNode"
scout_compute_api_NumericResampleSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericSeriesFunction(ConjureBeanType):
    """
    A function reference that outputs a numeric series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'function_reference': ConjureFieldDefinition('functionReference', scout_compute_api_FunctionReference),
            'function_identifier': ConjureFieldDefinition('functionIdentifier', scout_compute_api_FunctionVariable)
        }

    __slots__: List[str] = ['_function_reference', '_function_identifier']

    def __init__(self, function_identifier: "scout_compute_api_FunctionVariable", function_reference: str) -> None:
        self._function_reference = function_reference
        self._function_identifier = function_identifier

    @builtins.property
    def function_reference(self) -> str:
        """
        A reference to identify the function node for substituting variables used within the function.
        """
        return self._function_reference

    @builtins.property
    def function_identifier(self) -> "scout_compute_api_FunctionVariable":
        """
        The variable that needs to be substituted with the function RID.
        """
        return self._function_identifier


scout_compute_api_NumericSeriesFunction.__name__ = "NumericSeriesFunction"
scout_compute_api_NumericSeriesFunction.__qualname__ = "NumericSeriesFunction"
scout_compute_api_NumericSeriesFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericSeriesNode(ConjureUnionType):
    _aggregate: Optional["scout_compute_api_AggregateNumericSeriesNode"] = None
    _arithmetic: Optional["scout_compute_api_ArithmeticSeriesNode"] = None
    _bit_operation: Optional["scout_compute_api_BitOperationSeriesNode"] = None
    _cumulative_sum: Optional["scout_compute_api_CumulativeSumSeriesNode"] = None
    _derivative: Optional["scout_compute_api_DerivativeSeriesNode"] = None
    _function: Optional["scout_compute_api_NumericSeriesFunction"] = None
    _integral: Optional["scout_compute_api_IntegralSeriesNode"] = None
    _max: Optional["scout_compute_api_MaxSeriesNode"] = None
    _mean: Optional["scout_compute_api_MeanSeriesNode"] = None
    _min: Optional["scout_compute_api_MinSeriesNode"] = None
    _offset: Optional["scout_compute_api_OffsetSeriesNode"] = None
    _product: Optional["scout_compute_api_ProductSeriesNode"] = None
    _raw: Optional["scout_compute_api_RawNumericSeriesNode"] = None
    _resample: Optional["scout_compute_api_NumericResampleSeriesNode"] = None
    _rolling_operation: Optional["scout_compute_api_RollingOperationSeriesNode"] = None
    _sum: Optional["scout_compute_api_SumSeriesNode"] = None
    _scale: Optional["scout_compute_api_ScaleSeriesNode"] = None
    _time_difference: Optional["scout_compute_api_TimeDifferenceSeriesNode"] = None
    _time_range_filter: Optional["scout_compute_api_NumericTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_api_NumericTimeShiftSeriesNode"] = None
    _unary_arithmetic: Optional["scout_compute_api_UnaryArithmeticSeriesNode"] = None
    _binary_arithmetic: Optional["scout_compute_api_BinaryArithmeticSeriesNode"] = None
    _union: Optional["scout_compute_api_NumericUnionSeriesNode"] = None
    _unit_conversion: Optional["scout_compute_api_UnitConversionSeriesNode"] = None
    _value_difference: Optional["scout_compute_api_ValueDifferenceSeriesNode"] = None
    _filter_transformation: Optional["scout_compute_api_NumericFilterTransformationSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'aggregate': ConjureFieldDefinition('aggregate', scout_compute_api_AggregateNumericSeriesNode),
            'arithmetic': ConjureFieldDefinition('arithmetic', scout_compute_api_ArithmeticSeriesNode),
            'bit_operation': ConjureFieldDefinition('bitOperation', scout_compute_api_BitOperationSeriesNode),
            'cumulative_sum': ConjureFieldDefinition('cumulativeSum', scout_compute_api_CumulativeSumSeriesNode),
            'derivative': ConjureFieldDefinition('derivative', scout_compute_api_DerivativeSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_NumericSeriesFunction),
            'integral': ConjureFieldDefinition('integral', scout_compute_api_IntegralSeriesNode),
            'max': ConjureFieldDefinition('max', scout_compute_api_MaxSeriesNode),
            'mean': ConjureFieldDefinition('mean', scout_compute_api_MeanSeriesNode),
            'min': ConjureFieldDefinition('min', scout_compute_api_MinSeriesNode),
            'offset': ConjureFieldDefinition('offset', scout_compute_api_OffsetSeriesNode),
            'product': ConjureFieldDefinition('product', scout_compute_api_ProductSeriesNode),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_RawNumericSeriesNode),
            'resample': ConjureFieldDefinition('resample', scout_compute_api_NumericResampleSeriesNode),
            'rolling_operation': ConjureFieldDefinition('rollingOperation', scout_compute_api_RollingOperationSeriesNode),
            'sum': ConjureFieldDefinition('sum', scout_compute_api_SumSeriesNode),
            'scale': ConjureFieldDefinition('scale', scout_compute_api_ScaleSeriesNode),
            'time_difference': ConjureFieldDefinition('timeDifference', scout_compute_api_TimeDifferenceSeriesNode),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_api_NumericTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_api_NumericTimeShiftSeriesNode),
            'unary_arithmetic': ConjureFieldDefinition('unaryArithmetic', scout_compute_api_UnaryArithmeticSeriesNode),
            'binary_arithmetic': ConjureFieldDefinition('binaryArithmetic', scout_compute_api_BinaryArithmeticSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_api_NumericUnionSeriesNode),
            'unit_conversion': ConjureFieldDefinition('unitConversion', scout_compute_api_UnitConversionSeriesNode),
            'value_difference': ConjureFieldDefinition('valueDifference', scout_compute_api_ValueDifferenceSeriesNode),
            'filter_transformation': ConjureFieldDefinition('filterTransformation', scout_compute_api_NumericFilterTransformationSeriesNode)
        }

    def __init__(
            self,
            aggregate: Optional["scout_compute_api_AggregateNumericSeriesNode"] = None,
            arithmetic: Optional["scout_compute_api_ArithmeticSeriesNode"] = None,
            bit_operation: Optional["scout_compute_api_BitOperationSeriesNode"] = None,
            cumulative_sum: Optional["scout_compute_api_CumulativeSumSeriesNode"] = None,
            derivative: Optional["scout_compute_api_DerivativeSeriesNode"] = None,
            function: Optional["scout_compute_api_NumericSeriesFunction"] = None,
            integral: Optional["scout_compute_api_IntegralSeriesNode"] = None,
            max: Optional["scout_compute_api_MaxSeriesNode"] = None,
            mean: Optional["scout_compute_api_MeanSeriesNode"] = None,
            min: Optional["scout_compute_api_MinSeriesNode"] = None,
            offset: Optional["scout_compute_api_OffsetSeriesNode"] = None,
            product: Optional["scout_compute_api_ProductSeriesNode"] = None,
            raw: Optional["scout_compute_api_RawNumericSeriesNode"] = None,
            resample: Optional["scout_compute_api_NumericResampleSeriesNode"] = None,
            rolling_operation: Optional["scout_compute_api_RollingOperationSeriesNode"] = None,
            sum: Optional["scout_compute_api_SumSeriesNode"] = None,
            scale: Optional["scout_compute_api_ScaleSeriesNode"] = None,
            time_difference: Optional["scout_compute_api_TimeDifferenceSeriesNode"] = None,
            time_range_filter: Optional["scout_compute_api_NumericTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_api_NumericTimeShiftSeriesNode"] = None,
            unary_arithmetic: Optional["scout_compute_api_UnaryArithmeticSeriesNode"] = None,
            binary_arithmetic: Optional["scout_compute_api_BinaryArithmeticSeriesNode"] = None,
            union: Optional["scout_compute_api_NumericUnionSeriesNode"] = None,
            unit_conversion: Optional["scout_compute_api_UnitConversionSeriesNode"] = None,
            value_difference: Optional["scout_compute_api_ValueDifferenceSeriesNode"] = None,
            filter_transformation: Optional["scout_compute_api_NumericFilterTransformationSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (aggregate is not None) + (arithmetic is not None) + (bit_operation is not None) + (cumulative_sum is not None) + (derivative is not None) + (function is not None) + (integral is not None) + (max is not None) + (mean is not None) + (min is not None) + (offset is not None) + (product is not None) + (raw is not None) + (resample is not None) + (rolling_operation is not None) + (sum is not None) + (scale is not None) + (time_difference is not None) + (time_range_filter is not None) + (time_shift is not None) + (unary_arithmetic is not None) + (binary_arithmetic is not None) + (union is not None) + (unit_conversion is not None) + (value_difference is not None) + (filter_transformation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if aggregate is not None:
                self._aggregate = aggregate
                self._type = 'aggregate'
            if arithmetic is not None:
                self._arithmetic = arithmetic
                self._type = 'arithmetic'
            if bit_operation is not None:
                self._bit_operation = bit_operation
                self._type = 'bitOperation'
            if cumulative_sum is not None:
                self._cumulative_sum = cumulative_sum
                self._type = 'cumulativeSum'
            if derivative is not None:
                self._derivative = derivative
                self._type = 'derivative'
            if function is not None:
                self._function = function
                self._type = 'function'
            if integral is not None:
                self._integral = integral
                self._type = 'integral'
            if max is not None:
                self._max = max
                self._type = 'max'
            if mean is not None:
                self._mean = mean
                self._type = 'mean'
            if min is not None:
                self._min = min
                self._type = 'min'
            if offset is not None:
                self._offset = offset
                self._type = 'offset'
            if product is not None:
                self._product = product
                self._type = 'product'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if resample is not None:
                self._resample = resample
                self._type = 'resample'
            if rolling_operation is not None:
                self._rolling_operation = rolling_operation
                self._type = 'rollingOperation'
            if sum is not None:
                self._sum = sum
                self._type = 'sum'
            if scale is not None:
                self._scale = scale
                self._type = 'scale'
            if time_difference is not None:
                self._time_difference = time_difference
                self._type = 'timeDifference'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if unary_arithmetic is not None:
                self._unary_arithmetic = unary_arithmetic
                self._type = 'unaryArithmetic'
            if binary_arithmetic is not None:
                self._binary_arithmetic = binary_arithmetic
                self._type = 'binaryArithmetic'
            if union is not None:
                self._union = union
                self._type = 'union'
            if unit_conversion is not None:
                self._unit_conversion = unit_conversion
                self._type = 'unitConversion'
            if value_difference is not None:
                self._value_difference = value_difference
                self._type = 'valueDifference'
            if filter_transformation is not None:
                self._filter_transformation = filter_transformation
                self._type = 'filterTransformation'

        elif type_of_union == 'aggregate':
            if aggregate is None:
                raise ValueError('a union value must not be None')
            self._aggregate = aggregate
            self._type = 'aggregate'
        elif type_of_union == 'arithmetic':
            if arithmetic is None:
                raise ValueError('a union value must not be None')
            self._arithmetic = arithmetic
            self._type = 'arithmetic'
        elif type_of_union == 'bitOperation':
            if bit_operation is None:
                raise ValueError('a union value must not be None')
            self._bit_operation = bit_operation
            self._type = 'bitOperation'
        elif type_of_union == 'cumulativeSum':
            if cumulative_sum is None:
                raise ValueError('a union value must not be None')
            self._cumulative_sum = cumulative_sum
            self._type = 'cumulativeSum'
        elif type_of_union == 'derivative':
            if derivative is None:
                raise ValueError('a union value must not be None')
            self._derivative = derivative
            self._type = 'derivative'
        elif type_of_union == 'function':
            if function is None:
                raise ValueError('a union value must not be None')
            self._function = function
            self._type = 'function'
        elif type_of_union == 'integral':
            if integral is None:
                raise ValueError('a union value must not be None')
            self._integral = integral
            self._type = 'integral'
        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'mean':
            if mean is None:
                raise ValueError('a union value must not be None')
            self._mean = mean
            self._type = 'mean'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'offset':
            if offset is None:
                raise ValueError('a union value must not be None')
            self._offset = offset
            self._type = 'offset'
        elif type_of_union == 'product':
            if product is None:
                raise ValueError('a union value must not be None')
            self._product = product
            self._type = 'product'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'resample':
            if resample is None:
                raise ValueError('a union value must not be None')
            self._resample = resample
            self._type = 'resample'
        elif type_of_union == 'rollingOperation':
            if rolling_operation is None:
                raise ValueError('a union value must not be None')
            self._rolling_operation = rolling_operation
            self._type = 'rollingOperation'
        elif type_of_union == 'sum':
            if sum is None:
                raise ValueError('a union value must not be None')
            self._sum = sum
            self._type = 'sum'
        elif type_of_union == 'scale':
            if scale is None:
                raise ValueError('a union value must not be None')
            self._scale = scale
            self._type = 'scale'
        elif type_of_union == 'timeDifference':
            if time_difference is None:
                raise ValueError('a union value must not be None')
            self._time_difference = time_difference
            self._type = 'timeDifference'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'unaryArithmetic':
            if unary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._unary_arithmetic = unary_arithmetic
            self._type = 'unaryArithmetic'
        elif type_of_union == 'binaryArithmetic':
            if binary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._binary_arithmetic = binary_arithmetic
            self._type = 'binaryArithmetic'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'unitConversion':
            if unit_conversion is None:
                raise ValueError('a union value must not be None')
            self._unit_conversion = unit_conversion
            self._type = 'unitConversion'
        elif type_of_union == 'valueDifference':
            if value_difference is None:
                raise ValueError('a union value must not be None')
            self._value_difference = value_difference
            self._type = 'valueDifference'
        elif type_of_union == 'filterTransformation':
            if filter_transformation is None:
                raise ValueError('a union value must not be None')
            self._filter_transformation = filter_transformation
            self._type = 'filterTransformation'

    @builtins.property
    def aggregate(self) -> Optional["scout_compute_api_AggregateNumericSeriesNode"]:
        return self._aggregate

    @builtins.property
    def arithmetic(self) -> Optional["scout_compute_api_ArithmeticSeriesNode"]:
        return self._arithmetic

    @builtins.property
    def bit_operation(self) -> Optional["scout_compute_api_BitOperationSeriesNode"]:
        return self._bit_operation

    @builtins.property
    def cumulative_sum(self) -> Optional["scout_compute_api_CumulativeSumSeriesNode"]:
        return self._cumulative_sum

    @builtins.property
    def derivative(self) -> Optional["scout_compute_api_DerivativeSeriesNode"]:
        return self._derivative

    @builtins.property
    def function(self) -> Optional["scout_compute_api_NumericSeriesFunction"]:
        return self._function

    @builtins.property
    def integral(self) -> Optional["scout_compute_api_IntegralSeriesNode"]:
        return self._integral

    @builtins.property
    def max(self) -> Optional["scout_compute_api_MaxSeriesNode"]:
        return self._max

    @builtins.property
    def mean(self) -> Optional["scout_compute_api_MeanSeriesNode"]:
        return self._mean

    @builtins.property
    def min(self) -> Optional["scout_compute_api_MinSeriesNode"]:
        return self._min

    @builtins.property
    def offset(self) -> Optional["scout_compute_api_OffsetSeriesNode"]:
        return self._offset

    @builtins.property
    def product(self) -> Optional["scout_compute_api_ProductSeriesNode"]:
        return self._product

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_RawNumericSeriesNode"]:
        return self._raw

    @builtins.property
    def resample(self) -> Optional["scout_compute_api_NumericResampleSeriesNode"]:
        return self._resample

    @builtins.property
    def rolling_operation(self) -> Optional["scout_compute_api_RollingOperationSeriesNode"]:
        return self._rolling_operation

    @builtins.property
    def sum(self) -> Optional["scout_compute_api_SumSeriesNode"]:
        return self._sum

    @builtins.property
    def scale(self) -> Optional["scout_compute_api_ScaleSeriesNode"]:
        return self._scale

    @builtins.property
    def time_difference(self) -> Optional["scout_compute_api_TimeDifferenceSeriesNode"]:
        return self._time_difference

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_api_NumericTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_api_NumericTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def unary_arithmetic(self) -> Optional["scout_compute_api_UnaryArithmeticSeriesNode"]:
        return self._unary_arithmetic

    @builtins.property
    def binary_arithmetic(self) -> Optional["scout_compute_api_BinaryArithmeticSeriesNode"]:
        return self._binary_arithmetic

    @builtins.property
    def union(self) -> Optional["scout_compute_api_NumericUnionSeriesNode"]:
        return self._union

    @builtins.property
    def unit_conversion(self) -> Optional["scout_compute_api_UnitConversionSeriesNode"]:
        return self._unit_conversion

    @builtins.property
    def value_difference(self) -> Optional["scout_compute_api_ValueDifferenceSeriesNode"]:
        return self._value_difference

    @builtins.property
    def filter_transformation(self) -> Optional["scout_compute_api_NumericFilterTransformationSeriesNode"]:
        return self._filter_transformation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_NumericSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_NumericSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'aggregate' and self.aggregate is not None:
            return visitor._aggregate(self.aggregate)
        if self._type == 'arithmetic' and self.arithmetic is not None:
            return visitor._arithmetic(self.arithmetic)
        if self._type == 'bitOperation' and self.bit_operation is not None:
            return visitor._bit_operation(self.bit_operation)
        if self._type == 'cumulativeSum' and self.cumulative_sum is not None:
            return visitor._cumulative_sum(self.cumulative_sum)
        if self._type == 'derivative' and self.derivative is not None:
            return visitor._derivative(self.derivative)
        if self._type == 'function' and self.function is not None:
            return visitor._function(self.function)
        if self._type == 'integral' and self.integral is not None:
            return visitor._integral(self.integral)
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'mean' and self.mean is not None:
            return visitor._mean(self.mean)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'offset' and self.offset is not None:
            return visitor._offset(self.offset)
        if self._type == 'product' and self.product is not None:
            return visitor._product(self.product)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'resample' and self.resample is not None:
            return visitor._resample(self.resample)
        if self._type == 'rollingOperation' and self.rolling_operation is not None:
            return visitor._rolling_operation(self.rolling_operation)
        if self._type == 'sum' and self.sum is not None:
            return visitor._sum(self.sum)
        if self._type == 'scale' and self.scale is not None:
            return visitor._scale(self.scale)
        if self._type == 'timeDifference' and self.time_difference is not None:
            return visitor._time_difference(self.time_difference)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'unaryArithmetic' and self.unary_arithmetic is not None:
            return visitor._unary_arithmetic(self.unary_arithmetic)
        if self._type == 'binaryArithmetic' and self.binary_arithmetic is not None:
            return visitor._binary_arithmetic(self.binary_arithmetic)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'unitConversion' and self.unit_conversion is not None:
            return visitor._unit_conversion(self.unit_conversion)
        if self._type == 'valueDifference' and self.value_difference is not None:
            return visitor._value_difference(self.value_difference)
        if self._type == 'filterTransformation' and self.filter_transformation is not None:
            return visitor._filter_transformation(self.filter_transformation)


scout_compute_api_NumericSeriesNode.__name__ = "NumericSeriesNode"
scout_compute_api_NumericSeriesNode.__qualname__ = "NumericSeriesNode"
scout_compute_api_NumericSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericSeriesNodeVisitor:

    @abstractmethod
    def _aggregate(self, aggregate: "scout_compute_api_AggregateNumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _arithmetic(self, arithmetic: "scout_compute_api_ArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _bit_operation(self, bit_operation: "scout_compute_api_BitOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _cumulative_sum(self, cumulative_sum: "scout_compute_api_CumulativeSumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _derivative(self, derivative: "scout_compute_api_DerivativeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _function(self, function: "scout_compute_api_NumericSeriesFunction") -> Any:
        pass

    @abstractmethod
    def _integral(self, integral: "scout_compute_api_IntegralSeriesNode") -> Any:
        pass

    @abstractmethod
    def _max(self, max: "scout_compute_api_MaxSeriesNode") -> Any:
        pass

    @abstractmethod
    def _mean(self, mean: "scout_compute_api_MeanSeriesNode") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_compute_api_MinSeriesNode") -> Any:
        pass

    @abstractmethod
    def _offset(self, offset: "scout_compute_api_OffsetSeriesNode") -> Any:
        pass

    @abstractmethod
    def _product(self, product: "scout_compute_api_ProductSeriesNode") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_RawNumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _resample(self, resample: "scout_compute_api_NumericResampleSeriesNode") -> Any:
        pass

    @abstractmethod
    def _rolling_operation(self, rolling_operation: "scout_compute_api_RollingOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _sum(self, sum: "scout_compute_api_SumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _scale(self, scale: "scout_compute_api_ScaleSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_difference(self, time_difference: "scout_compute_api_TimeDifferenceSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_api_NumericTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_api_NumericTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _unary_arithmetic(self, unary_arithmetic: "scout_compute_api_UnaryArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _binary_arithmetic(self, binary_arithmetic: "scout_compute_api_BinaryArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_api_NumericUnionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _unit_conversion(self, unit_conversion: "scout_compute_api_UnitConversionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value_difference(self, value_difference: "scout_compute_api_ValueDifferenceSeriesNode") -> Any:
        pass

    @abstractmethod
    def _filter_transformation(self, filter_transformation: "scout_compute_api_NumericFilterTransformationSeriesNode") -> Any:
        pass


scout_compute_api_NumericSeriesNodeVisitor.__name__ = "NumericSeriesNodeVisitor"
scout_compute_api_NumericSeriesNodeVisitor.__qualname__ = "NumericSeriesNodeVisitor"
scout_compute_api_NumericSeriesNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericTimeRangeFilterSeriesNode(ConjureBeanType):
    """
    Filters the series to points within the specified time range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[scout_compute_api_TimestampConstant]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_compute_api_TimestampConstant])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", end_time: Optional["scout_compute_api_TimestampConstant"] = None, start_time: Optional["scout_compute_api_TimestampConstant"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """
        Represents the start time (inclusive) of the time range.
        """
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """
        Represents the end time (inclusive) of the time range.
        """
        return self._end_time


scout_compute_api_NumericTimeRangeFilterSeriesNode.__name__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_api_NumericTimeRangeFilterSeriesNode.__qualname__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_api_NumericTimeRangeFilterSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_compute_api_DurationConstant)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_compute_api_DurationConstant", input: "scout_compute_api_NumericSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_compute_api_DurationConstant":
        return self._duration


scout_compute_api_NumericTimeShiftSeriesNode.__name__ = "NumericTimeShiftSeriesNode"
scout_compute_api_NumericTimeShiftSeriesNode.__qualname__ = "NumericTimeShiftSeriesNode"
scout_compute_api_NumericTimeShiftSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericUnionOperation(ConjureEnumType):

    MIN = 'MIN'
    '''MIN'''
    MAX = 'MAX'
    '''MAX'''
    MEAN = 'MEAN'
    '''MEAN'''
    SUM = 'SUM'
    '''SUM'''
    THROW = 'THROW'
    '''THROW'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_NumericUnionOperation.__name__ = "NumericUnionOperation"
scout_compute_api_NumericUnionOperation.__qualname__ = "NumericUnionOperation"
scout_compute_api_NumericUnionOperation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_NumericUnionSeriesNode(ConjureBeanType):
    """
    Combines multiple numeric series together and outputs a single series. If the same timestamp is duplicated in
multiple input series, the output series will contain a single point with this timestamp. The strategy to
merge input values with the same timestamp together is specified in the operation field.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_NumericSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_NumericUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_api_NumericSeriesNode"], operation: "scout_compute_api_NumericUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_api_NumericSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_NumericUnionOperation":
        """
        The strategy to merge points with duplicate timestamps.
        """
        return self._operation


scout_compute_api_NumericUnionSeriesNode.__name__ = "NumericUnionSeriesNode"
scout_compute_api_NumericUnionSeriesNode.__qualname__ = "NumericUnionSeriesNode"
scout_compute_api_NumericUnionSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_OffsetSeriesNode(ConjureBeanType):
    """
    For every timestamp specified in the input series, offset it by a constant factor.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'scalar': ConjureFieldDefinition('scalar', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_input', '_scalar']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", scalar: "scout_compute_api_DoubleConstant") -> None:
        self._input = input
        self._scalar = scalar

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def scalar(self) -> "scout_compute_api_DoubleConstant":
        """
        The constant to add to each point
        """
        return self._scalar


scout_compute_api_OffsetSeriesNode.__name__ = "OffsetSeriesNode"
scout_compute_api_OffsetSeriesNode.__qualname__ = "OffsetSeriesNode"
scout_compute_api_OffsetSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_OnChangeRangesNode(ConjureBeanType):
    """
    Produces a list of ranges for each point that has a different value to the previous point.
A range will have identical start and end times.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_SeriesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_api_SeriesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_api_SeriesNode":
        return self._input


scout_compute_api_OnChangeRangesNode.__name__ = "OnChangeRangesNode"
scout_compute_api_OnChangeRangesNode.__qualname__ = "OnChangeRangesNode"
scout_compute_api_OnChangeRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_OutputRangeStart(ConjureUnionType):
    _first_point_matching_condition: Optional["scout_compute_api_FirstPointMatchingCondition"] = None
    _after_persistence_window: Optional["scout_compute_api_AfterPersistenceWindow"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'first_point_matching_condition': ConjureFieldDefinition('firstPointMatchingCondition', scout_compute_api_FirstPointMatchingCondition),
            'after_persistence_window': ConjureFieldDefinition('afterPersistenceWindow', scout_compute_api_AfterPersistenceWindow)
        }

    def __init__(
            self,
            first_point_matching_condition: Optional["scout_compute_api_FirstPointMatchingCondition"] = None,
            after_persistence_window: Optional["scout_compute_api_AfterPersistenceWindow"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (first_point_matching_condition is not None) + (after_persistence_window is not None) != 1:
                raise ValueError('a union must contain a single member')

            if first_point_matching_condition is not None:
                self._first_point_matching_condition = first_point_matching_condition
                self._type = 'firstPointMatchingCondition'
            if after_persistence_window is not None:
                self._after_persistence_window = after_persistence_window
                self._type = 'afterPersistenceWindow'

        elif type_of_union == 'firstPointMatchingCondition':
            if first_point_matching_condition is None:
                raise ValueError('a union value must not be None')
            self._first_point_matching_condition = first_point_matching_condition
            self._type = 'firstPointMatchingCondition'
        elif type_of_union == 'afterPersistenceWindow':
            if after_persistence_window is None:
                raise ValueError('a union value must not be None')
            self._after_persistence_window = after_persistence_window
            self._type = 'afterPersistenceWindow'

    @builtins.property
    def first_point_matching_condition(self) -> Optional["scout_compute_api_FirstPointMatchingCondition"]:
        """
        The first point in the output range will be the first point where the condition evaluates to true.
        """
        return self._first_point_matching_condition

    @builtins.property
    def after_persistence_window(self) -> Optional["scout_compute_api_AfterPersistenceWindow"]:
        """
        The output range will contain points where the condition has been true
for at least the min duration and min points.
        """
        return self._after_persistence_window

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_OutputRangeStartVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_OutputRangeStartVisitor'.format(visitor.__class__.__name__))
        if self._type == 'firstPointMatchingCondition' and self.first_point_matching_condition is not None:
            return visitor._first_point_matching_condition(self.first_point_matching_condition)
        if self._type == 'afterPersistenceWindow' and self.after_persistence_window is not None:
            return visitor._after_persistence_window(self.after_persistence_window)


scout_compute_api_OutputRangeStart.__name__ = "OutputRangeStart"
scout_compute_api_OutputRangeStart.__qualname__ = "OutputRangeStart"
scout_compute_api_OutputRangeStart.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_OutputRangeStartVisitor:

    @abstractmethod
    def _first_point_matching_condition(self, first_point_matching_condition: "scout_compute_api_FirstPointMatchingCondition") -> Any:
        pass

    @abstractmethod
    def _after_persistence_window(self, after_persistence_window: "scout_compute_api_AfterPersistenceWindow") -> Any:
        pass


scout_compute_api_OutputRangeStartVisitor.__name__ = "OutputRangeStartVisitor"
scout_compute_api_OutputRangeStartVisitor.__qualname__ = "OutputRangeStartVisitor"
scout_compute_api_OutputRangeStartVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ParameterInput(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_compute_api_VariableValue]),
            'function_variables': ConjureFieldDefinition('functionVariables', Dict[scout_compute_api_FunctionReference, scout_compute_api_FunctionVariables]),
            'time_range': ConjureFieldDefinition('timeRange', OptionalTypeWrapper[scout_compute_api_Range])
        }

    __slots__: List[str] = ['_variables', '_function_variables', '_time_range']

    def __init__(self, function_variables: Dict[str, "scout_compute_api_FunctionVariables"], variables: Dict[str, "scout_compute_api_VariableValue"], time_range: Optional["scout_compute_api_Range"] = None) -> None:
        self._variables = variables
        self._function_variables = function_variables
        self._time_range = time_range

    @builtins.property
    def variables(self) -> Dict[str, "scout_compute_api_VariableValue"]:
        return self._variables

    @builtins.property
    def function_variables(self) -> Dict[str, "scout_compute_api_FunctionVariables"]:
        """
        Map of function references to their variables. The function reference is defined in the FunctionNode definition.
If a function references another function, the variables for the referenced function should be in the
subFunctionVariables field of the FunctionVariables.
        """
        return self._function_variables

    @builtins.property
    def time_range(self) -> Optional["scout_compute_api_Range"]:
        """
        Overrides the start and end time of the compute request. If either the start or end are not present, we
default back to the start/end specified in the request.
        """
        return self._time_range


scout_compute_api_ParameterInput.__name__ = "ParameterInput"
scout_compute_api_ParameterInput.__qualname__ = "ParameterInput"
scout_compute_api_ParameterInput.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ParameterizedComputeNodeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_ComputableNode),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context),
            'parameterized_context': ConjureFieldDefinition('parameterizedContext', scout_compute_api_ParameterizedContext)
        }

    __slots__: List[str] = ['_node', '_start', '_end', '_context', '_parameterized_context']

    def __init__(self, context: "scout_compute_api_Context", end: "api_Timestamp", node: "scout_compute_api_ComputableNode", parameterized_context: "scout_compute_api_ParameterizedContext", start: "api_Timestamp") -> None:
        self._node = node
        self._start = start
        self._end = end
        self._context = context
        self._parameterized_context = parameterized_context

    @builtins.property
    def node(self) -> "scout_compute_api_ComputableNode":
        return self._node

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context

    @builtins.property
    def parameterized_context(self) -> "scout_compute_api_ParameterizedContext":
        """
        Specifies how certain variables should be parameterized. If a variable name appears in both the context
and the parameterized context, it will be treated as parameterized.
        """
        return self._parameterized_context


scout_compute_api_ParameterizedComputeNodeRequest.__name__ = "ParameterizedComputeNodeRequest"
scout_compute_api_ParameterizedComputeNodeRequest.__qualname__ = "ParameterizedComputeNodeRequest"
scout_compute_api_ParameterizedComputeNodeRequest.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ParameterizedComputeNodeResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_compute_api_ParameterizedComputeNodeResult])
        }

    __slots__: List[str] = ['_results']

    def __init__(self, results: List["scout_compute_api_ParameterizedComputeNodeResult"]) -> None:
        self._results = results

    @builtins.property
    def results(self) -> List["scout_compute_api_ParameterizedComputeNodeResult"]:
        return self._results


scout_compute_api_ParameterizedComputeNodeResponse.__name__ = "ParameterizedComputeNodeResponse"
scout_compute_api_ParameterizedComputeNodeResponse.__qualname__ = "ParameterizedComputeNodeResponse"
scout_compute_api_ParameterizedComputeNodeResponse.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ParameterizedComputeNodeResult(ConjureUnionType):
    _success: Optional["scout_compute_api_ComputeNodeResponse"] = None
    _error: Optional["scout_compute_api_ErrorResult"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_compute_api_ComputeNodeResponse),
            'error': ConjureFieldDefinition('error', scout_compute_api_ErrorResult)
        }

    def __init__(
            self,
            success: Optional["scout_compute_api_ComputeNodeResponse"] = None,
            error: Optional["scout_compute_api_ErrorResult"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'

    @builtins.property
    def success(self) -> Optional["scout_compute_api_ComputeNodeResponse"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["scout_compute_api_ErrorResult"]:
        return self._error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ParameterizedComputeNodeResultVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ParameterizedComputeNodeResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)


scout_compute_api_ParameterizedComputeNodeResult.__name__ = "ParameterizedComputeNodeResult"
scout_compute_api_ParameterizedComputeNodeResult.__qualname__ = "ParameterizedComputeNodeResult"
scout_compute_api_ParameterizedComputeNodeResult.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ParameterizedComputeNodeResultVisitor:

    @abstractmethod
    def _success(self, success: "scout_compute_api_ComputeNodeResponse") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "scout_compute_api_ErrorResult") -> Any:
        pass


scout_compute_api_ParameterizedComputeNodeResultVisitor.__name__ = "ParameterizedComputeNodeResultVisitor"
scout_compute_api_ParameterizedComputeNodeResultVisitor.__qualname__ = "ParameterizedComputeNodeResultVisitor"
scout_compute_api_ParameterizedComputeNodeResultVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ParameterizedContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'parameter_inputs': ConjureFieldDefinition('parameterInputs', List[scout_compute_api_ParameterInput])
        }

    __slots__: List[str] = ['_parameter_inputs']

    def __init__(self, parameter_inputs: List["scout_compute_api_ParameterInput"]) -> None:
        self._parameter_inputs = parameter_inputs

    @builtins.property
    def parameter_inputs(self) -> List["scout_compute_api_ParameterInput"]:
        """
        Each parameter input provides a satisfying set of values for the parameterized compute node.
        """
        return self._parameter_inputs


scout_compute_api_ParameterizedContext.__name__ = "ParameterizedContext"
scout_compute_api_ParameterizedContext.__qualname__ = "ParameterizedContext"
scout_compute_api_ParameterizedContext.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_PeakRangesNode(ConjureBeanType):
    """
    Produces a list of ranges for each point that is greater than its neighbors.
Peaks at edges are discarded, and continuous, multivalue, flat peaks will return all values.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'returns_peaks': ConjureFieldDefinition('returnsPeaks', OptionalTypeWrapper[bool]),
            'return_type': ConjureFieldDefinition('returnType', OptionalTypeWrapper[scout_compute_api_PeakType]),
            'minimum_prominence': ConjureFieldDefinition('minimumProminence', OptionalTypeWrapper[scout_compute_api_DoubleConstant])
        }

    __slots__: List[str] = ['_input', '_returns_peaks', '_return_type', '_minimum_prominence']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", minimum_prominence: Optional["scout_compute_api_DoubleConstant"] = None, return_type: Optional["scout_compute_api_PeakType"] = None, returns_peaks: Optional[bool] = None) -> None:
        self._input = input
        self._returns_peaks = returns_peaks
        self._return_type = return_type
        self._minimum_prominence = minimum_prominence

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def returns_peaks(self) -> Optional[bool]:
        """
        True if returning peaks, else troughs.
        """
        return self._returns_peaks

    @builtins.property
    def return_type(self) -> Optional["scout_compute_api_PeakType"]:
        """
        Optional for backcompatibility.
        """
        return self._return_type

    @builtins.property
    def minimum_prominence(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """
        The minimum topographic prominence for an extrema to be returned.
Prominence is the minimum vertical distance needed to travel from an extrema to one of greater magnitude.
        """
        return self._minimum_prominence


scout_compute_api_PeakRangesNode.__name__ = "PeakRangesNode"
scout_compute_api_PeakRangesNode.__qualname__ = "PeakRangesNode"
scout_compute_api_PeakRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_PeakType(ConjureEnumType):

    PEAK = 'PEAK'
    '''PEAK'''
    TROUGH = 'TROUGH'
    '''TROUGH'''
    BOTH = 'BOTH'
    '''BOTH'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_PeakType.__name__ = "PeakType"
scout_compute_api_PeakType.__qualname__ = "PeakType"
scout_compute_api_PeakType.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_PersistenceWindowConfiguration(ConjureBeanType):
    """
    Configures how long a condition has to be true for to output a time range, and what to use as the
start of the output range. For a point to be included in the output time range, both the minPoints and
minDuration conditions must be satisfied.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[scout_compute_api_IntegerConstant]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_compute_api_DurationConstant]),
            'output_range_start': ConjureFieldDefinition('outputRangeStart', scout_compute_api_OutputRangeStart)
        }

    __slots__: List[str] = ['_min_points', '_min_duration', '_output_range_start']

    def __init__(self, output_range_start: "scout_compute_api_OutputRangeStart", min_duration: Optional["scout_compute_api_DurationConstant"] = None, min_points: Optional["scout_compute_api_IntegerConstant"] = None) -> None:
        self._min_points = min_points
        self._min_duration = min_duration
        self._output_range_start = output_range_start

    @builtins.property
    def min_points(self) -> Optional["scout_compute_api_IntegerConstant"]:
        """
        The minimum number of points for which this condition be must satisfied to include the time range in the
output. Must be non-negative. If not present, will default to 1.
        """
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_compute_api_DurationConstant"]:
        """
        The minimum number of points for which this condition must be satisfied to include the time range in the
output. Must be non-negative. If not present, will default to 1 nanosecond.
        """
        return self._min_duration

    @builtins.property
    def output_range_start(self) -> "scout_compute_api_OutputRangeStart":
        """
        Which point to use as the start of the output range. Defaults to firstPointMatchingCondition if not specified.
        """
        return self._output_range_start


scout_compute_api_PersistenceWindowConfiguration.__name__ = "PersistenceWindowConfiguration"
scout_compute_api_PersistenceWindowConfiguration.__qualname__ = "PersistenceWindowConfiguration"
scout_compute_api_PersistenceWindowConfiguration.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ProductSeriesNode(ConjureBeanType):
    """
    For every timestamp specified in the input series, outputs a value that is the product for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeriesNode"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """
        Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_ProductSeriesNode.__name__ = "ProductSeriesNode"
scout_compute_api_ProductSeriesNode.__qualname__ = "ProductSeriesNode"
scout_compute_api_ProductSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_Range(ConjureBeanType):
    """
    The end represents the first timestamp that does not belong to the range. If absent, there is no known
end to the range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', OptionalTypeWrapper[api_Timestamp]),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[api_Timestamp]),
            'value': ConjureFieldDefinition('value', OptionalTypeWrapper[scout_compute_api_RangeValue])
        }

    __slots__: List[str] = ['_start', '_end', '_value']

    def __init__(self, end: Optional["api_Timestamp"] = None, start: Optional["api_Timestamp"] = None, value: Optional["scout_compute_api_RangeValue"] = None) -> None:
        self._start = start
        self._end = end
        self._value = value

    @builtins.property
    def start(self) -> Optional["api_Timestamp"]:
        return self._start

    @builtins.property
    def end(self) -> Optional["api_Timestamp"]:
        return self._end

    @builtins.property
    def value(self) -> Optional["scout_compute_api_RangeValue"]:
        return self._value


scout_compute_api_Range.__name__ = "Range"
scout_compute_api_Range.__qualname__ = "Range"
scout_compute_api_Range.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangeAggregation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'average': ConjureFieldDefinition('average', float),
            'min': ConjureFieldDefinition('min', float),
            'max': ConjureFieldDefinition('max', float),
            'standard_deviation': ConjureFieldDefinition('standardDeviation', float)
        }

    __slots__: List[str] = ['_average', '_min', '_max', '_standard_deviation']

    def __init__(self, average: float, max: float, min: float, standard_deviation: float) -> None:
        self._average = average
        self._min = min
        self._max = max
        self._standard_deviation = standard_deviation

    @builtins.property
    def average(self) -> float:
        return self._average

    @builtins.property
    def min(self) -> float:
        return self._min

    @builtins.property
    def max(self) -> float:
        return self._max

    @builtins.property
    def standard_deviation(self) -> float:
        return self._standard_deviation


scout_compute_api_RangeAggregation.__name__ = "RangeAggregation"
scout_compute_api_RangeAggregation.__qualname__ = "RangeAggregation"
scout_compute_api_RangeAggregation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangeAggregationOperation(ConjureUnionType):
    _average: Optional["scout_compute_api_Average"] = None
    _min: Optional["scout_compute_api_Minimum"] = None
    _max: Optional["scout_compute_api_Maximum"] = None
    _standard_deviation: Optional["scout_compute_api_StandardDeviation"] = None
    _all: Optional["scout_compute_api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'average': ConjureFieldDefinition('average', scout_compute_api_Average),
            'min': ConjureFieldDefinition('min', scout_compute_api_Minimum),
            'max': ConjureFieldDefinition('max', scout_compute_api_Maximum),
            'standard_deviation': ConjureFieldDefinition('standardDeviation', scout_compute_api_StandardDeviation),
            'all': ConjureFieldDefinition('all', scout_compute_api_Empty)
        }

    def __init__(
            self,
            average: Optional["scout_compute_api_Average"] = None,
            min: Optional["scout_compute_api_Minimum"] = None,
            max: Optional["scout_compute_api_Maximum"] = None,
            standard_deviation: Optional["scout_compute_api_StandardDeviation"] = None,
            all: Optional["scout_compute_api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (average is not None) + (min is not None) + (max is not None) + (standard_deviation is not None) + (all is not None) != 1:
                raise ValueError('a union must contain a single member')

            if average is not None:
                self._average = average
                self._type = 'average'
            if min is not None:
                self._min = min
                self._type = 'min'
            if max is not None:
                self._max = max
                self._type = 'max'
            if standard_deviation is not None:
                self._standard_deviation = standard_deviation
                self._type = 'standardDeviation'
            if all is not None:
                self._all = all
                self._type = 'all'

        elif type_of_union == 'average':
            if average is None:
                raise ValueError('a union value must not be None')
            self._average = average
            self._type = 'average'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'standardDeviation':
            if standard_deviation is None:
                raise ValueError('a union value must not be None')
            self._standard_deviation = standard_deviation
            self._type = 'standardDeviation'
        elif type_of_union == 'all':
            if all is None:
                raise ValueError('a union value must not be None')
            self._all = all
            self._type = 'all'

    @builtins.property
    def average(self) -> Optional["scout_compute_api_Average"]:
        return self._average

    @builtins.property
    def min(self) -> Optional["scout_compute_api_Minimum"]:
        return self._min

    @builtins.property
    def max(self) -> Optional["scout_compute_api_Maximum"]:
        return self._max

    @builtins.property
    def standard_deviation(self) -> Optional["scout_compute_api_StandardDeviation"]:
        return self._standard_deviation

    @builtins.property
    def all(self) -> Optional["scout_compute_api_Empty"]:
        return self._all

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_RangeAggregationOperationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_RangeAggregationOperationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'average' and self.average is not None:
            return visitor._average(self.average)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'standardDeviation' and self.standard_deviation is not None:
            return visitor._standard_deviation(self.standard_deviation)
        if self._type == 'all' and self.all is not None:
            return visitor._all(self.all)


scout_compute_api_RangeAggregationOperation.__name__ = "RangeAggregationOperation"
scout_compute_api_RangeAggregationOperation.__qualname__ = "RangeAggregationOperation"
scout_compute_api_RangeAggregationOperation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangeAggregationOperationVisitor:

    @abstractmethod
    def _average(self, average: "scout_compute_api_Average") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_compute_api_Minimum") -> Any:
        pass

    @abstractmethod
    def _max(self, max: "scout_compute_api_Maximum") -> Any:
        pass

    @abstractmethod
    def _standard_deviation(self, standard_deviation: "scout_compute_api_StandardDeviation") -> Any:
        pass

    @abstractmethod
    def _all(self, all: "scout_compute_api_Empty") -> Any:
        pass


scout_compute_api_RangeAggregationOperationVisitor.__name__ = "RangeAggregationOperationVisitor"
scout_compute_api_RangeAggregationOperationVisitor.__qualname__ = "RangeAggregationOperationVisitor"
scout_compute_api_RangeAggregationOperationVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangeSummary(ConjureBeanType):
    """
    Summary of a set of ranges
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'range': ConjureFieldDefinition('range', scout_compute_api_Range),
            'sub_range_count': ConjureFieldDefinition('subRangeCount', int)
        }

    __slots__: List[str] = ['_range', '_sub_range_count']

    def __init__(self, range: "scout_compute_api_Range", sub_range_count: int) -> None:
        self._range = range
        self._sub_range_count = sub_range_count

    @builtins.property
    def range(self) -> "scout_compute_api_Range":
        """
        The range representing the minimum start and maximum end times of the ranges.
        """
        return self._range

    @builtins.property
    def sub_range_count(self) -> int:
        """
        The number of ranges found within this time range.
        """
        return self._sub_range_count


scout_compute_api_RangeSummary.__name__ = "RangeSummary"
scout_compute_api_RangeSummary.__qualname__ = "RangeSummary"
scout_compute_api_RangeSummary.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangeValue(ConjureUnionType):
    _double: Optional[float] = None
    _aggregation: Optional["scout_compute_api_RangeAggregation"] = None
    _no_points_in_range: Optional["scout_compute_api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'double': ConjureFieldDefinition('double', float),
            'aggregation': ConjureFieldDefinition('aggregation', scout_compute_api_RangeAggregation),
            'no_points_in_range': ConjureFieldDefinition('noPointsInRange', scout_compute_api_Empty)
        }

    def __init__(
            self,
            double: Optional[float] = None,
            aggregation: Optional["scout_compute_api_RangeAggregation"] = None,
            no_points_in_range: Optional["scout_compute_api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (double is not None) + (aggregation is not None) + (no_points_in_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if double is not None:
                self._double = double
                self._type = 'double'
            if aggregation is not None:
                self._aggregation = aggregation
                self._type = 'aggregation'
            if no_points_in_range is not None:
                self._no_points_in_range = no_points_in_range
                self._type = 'noPointsInRange'

        elif type_of_union == 'double':
            if double is None:
                raise ValueError('a union value must not be None')
            self._double = double
            self._type = 'double'
        elif type_of_union == 'aggregation':
            if aggregation is None:
                raise ValueError('a union value must not be None')
            self._aggregation = aggregation
            self._type = 'aggregation'
        elif type_of_union == 'noPointsInRange':
            if no_points_in_range is None:
                raise ValueError('a union value must not be None')
            self._no_points_in_range = no_points_in_range
            self._type = 'noPointsInRange'

    @builtins.property
    def double(self) -> Optional[float]:
        return self._double

    @builtins.property
    def aggregation(self) -> Optional["scout_compute_api_RangeAggregation"]:
        return self._aggregation

    @builtins.property
    def no_points_in_range(self) -> Optional["scout_compute_api_Empty"]:
        return self._no_points_in_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_RangeValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_RangeValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'double' and self.double is not None:
            return visitor._double(self.double)
        if self._type == 'aggregation' and self.aggregation is not None:
            return visitor._aggregation(self.aggregation)
        if self._type == 'noPointsInRange' and self.no_points_in_range is not None:
            return visitor._no_points_in_range(self.no_points_in_range)


scout_compute_api_RangeValue.__name__ = "RangeValue"
scout_compute_api_RangeValue.__qualname__ = "RangeValue"
scout_compute_api_RangeValue.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangeValueVisitor:

    @abstractmethod
    def _double(self, double: float) -> Any:
        pass

    @abstractmethod
    def _aggregation(self, aggregation: "scout_compute_api_RangeAggregation") -> Any:
        pass

    @abstractmethod
    def _no_points_in_range(self, no_points_in_range: "scout_compute_api_Empty") -> Any:
        pass


scout_compute_api_RangeValueVisitor.__name__ = "RangeValueVisitor"
scout_compute_api_RangeValueVisitor.__qualname__ = "RangeValueVisitor"
scout_compute_api_RangeValueVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangesFunction(ConjureBeanType):
    """
    A function reference that outputs a ranges series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'function_reference': ConjureFieldDefinition('functionReference', scout_compute_api_FunctionReference),
            'function_identifier': ConjureFieldDefinition('functionIdentifier', scout_compute_api_FunctionVariable)
        }

    __slots__: List[str] = ['_function_reference', '_function_identifier']

    def __init__(self, function_identifier: "scout_compute_api_FunctionVariable", function_reference: str) -> None:
        self._function_reference = function_reference
        self._function_identifier = function_identifier

    @builtins.property
    def function_reference(self) -> str:
        """
        A reference to identify the function node for substituting variables used within the function.
        """
        return self._function_reference

    @builtins.property
    def function_identifier(self) -> "scout_compute_api_FunctionVariable":
        """
        The variable that needs to be substituted with the function RID.
        """
        return self._function_identifier


scout_compute_api_RangesFunction.__name__ = "RangesFunction"
scout_compute_api_RangesFunction.__qualname__ = "RangesFunction"
scout_compute_api_RangesFunction.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangesNode(ConjureUnionType):
    _enum_filter: Optional["scout_compute_api_EnumFilterRangesNode"] = None
    _function: Optional["scout_compute_api_RangesFunction"] = None
    _intersect_range: Optional["scout_compute_api_IntersectRangesNode"] = None
    _not_: Optional["scout_compute_api_NotRangesNode"] = None
    _on_change: Optional["scout_compute_api_OnChangeRangesNode"] = None
    _min_max_threshold: Optional["scout_compute_api_MinMaxThresholdRangesNode"] = None
    _peak: Optional["scout_compute_api_PeakRangesNode"] = None
    _raw: Optional["scout_compute_api_RawRangesNode"] = None
    _series_crossover_ranges_node: Optional["scout_compute_api_SeriesCrossoverRangesNode"] = None
    _series_equality_ranges_node: Optional["scout_compute_api_SeriesEqualityRangesNode"] = None
    _enum_series_equality_ranges_node: Optional["scout_compute_api_EnumSeriesEqualityRangesNode"] = None
    _stale_range: Optional["scout_compute_api_StaleRangesNode"] = None
    _threshold: Optional["scout_compute_api_ThresholdingRangesNode"] = None
    _union_range: Optional["scout_compute_api_UnionRangesNode"] = None
    _range_numeric_aggregation: Optional["scout_compute_api_RangesNumericAggregationNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'enum_filter': ConjureFieldDefinition('enumFilter', scout_compute_api_EnumFilterRangesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_RangesFunction),
            'intersect_range': ConjureFieldDefinition('intersectRange', scout_compute_api_IntersectRangesNode),
            'not_': ConjureFieldDefinition('not', scout_compute_api_NotRangesNode),
            'on_change': ConjureFieldDefinition('onChange', scout_compute_api_OnChangeRangesNode),
            'min_max_threshold': ConjureFieldDefinition('minMaxThreshold', scout_compute_api_MinMaxThresholdRangesNode),
            'peak': ConjureFieldDefinition('peak', scout_compute_api_PeakRangesNode),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_RawRangesNode),
            'series_crossover_ranges_node': ConjureFieldDefinition('seriesCrossoverRangesNode', scout_compute_api_SeriesCrossoverRangesNode),
            'series_equality_ranges_node': ConjureFieldDefinition('seriesEqualityRangesNode', scout_compute_api_SeriesEqualityRangesNode),
            'enum_series_equality_ranges_node': ConjureFieldDefinition('enumSeriesEqualityRangesNode', scout_compute_api_EnumSeriesEqualityRangesNode),
            'stale_range': ConjureFieldDefinition('staleRange', scout_compute_api_StaleRangesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_ThresholdingRangesNode),
            'union_range': ConjureFieldDefinition('unionRange', scout_compute_api_UnionRangesNode),
            'range_numeric_aggregation': ConjureFieldDefinition('rangeNumericAggregation', scout_compute_api_RangesNumericAggregationNode)
        }

    def __init__(
            self,
            enum_filter: Optional["scout_compute_api_EnumFilterRangesNode"] = None,
            function: Optional["scout_compute_api_RangesFunction"] = None,
            intersect_range: Optional["scout_compute_api_IntersectRangesNode"] = None,
            not_: Optional["scout_compute_api_NotRangesNode"] = None,
            on_change: Optional["scout_compute_api_OnChangeRangesNode"] = None,
            min_max_threshold: Optional["scout_compute_api_MinMaxThresholdRangesNode"] = None,
            peak: Optional["scout_compute_api_PeakRangesNode"] = None,
            raw: Optional["scout_compute_api_RawRangesNode"] = None,
            series_crossover_ranges_node: Optional["scout_compute_api_SeriesCrossoverRangesNode"] = None,
            series_equality_ranges_node: Optional["scout_compute_api_SeriesEqualityRangesNode"] = None,
            enum_series_equality_ranges_node: Optional["scout_compute_api_EnumSeriesEqualityRangesNode"] = None,
            stale_range: Optional["scout_compute_api_StaleRangesNode"] = None,
            threshold: Optional["scout_compute_api_ThresholdingRangesNode"] = None,
            union_range: Optional["scout_compute_api_UnionRangesNode"] = None,
            range_numeric_aggregation: Optional["scout_compute_api_RangesNumericAggregationNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (enum_filter is not None) + (function is not None) + (intersect_range is not None) + (not_ is not None) + (on_change is not None) + (min_max_threshold is not None) + (peak is not None) + (raw is not None) + (series_crossover_ranges_node is not None) + (series_equality_ranges_node is not None) + (enum_series_equality_ranges_node is not None) + (stale_range is not None) + (threshold is not None) + (union_range is not None) + (range_numeric_aggregation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if enum_filter is not None:
                self._enum_filter = enum_filter
                self._type = 'enumFilter'
            if function is not None:
                self._function = function
                self._type = 'function'
            if intersect_range is not None:
                self._intersect_range = intersect_range
                self._type = 'intersectRange'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if on_change is not None:
                self._on_change = on_change
                self._type = 'onChange'
            if min_max_threshold is not None:
                self._min_max_threshold = min_max_threshold
                self._type = 'minMaxThreshold'
            if peak is not None:
                self._peak = peak
                self._type = 'peak'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if series_crossover_ranges_node is not None:
                self._series_crossover_ranges_node = series_crossover_ranges_node
                self._type = 'seriesCrossoverRangesNode'
            if series_equality_ranges_node is not None:
                self._series_equality_ranges_node = series_equality_ranges_node
                self._type = 'seriesEqualityRangesNode'
            if enum_series_equality_ranges_node is not None:
                self._enum_series_equality_ranges_node = enum_series_equality_ranges_node
                self._type = 'enumSeriesEqualityRangesNode'
            if stale_range is not None:
                self._stale_range = stale_range
                self._type = 'staleRange'
            if threshold is not None:
                self._threshold = threshold
                self._type = 'threshold'
            if union_range is not None:
                self._union_range = union_range
                self._type = 'unionRange'
            if range_numeric_aggregation is not None:
                self._range_numeric_aggregation = range_numeric_aggregation
                self._type = 'rangeNumericAggregation'

        elif type_of_union == 'enumFilter':
            if enum_filter is None:
                raise ValueError('a union value must not be None')
            self._enum_filter = enum_filter
            self._type = 'enumFilter'
        elif type_of_union == 'function':
            if function is None:
                raise ValueError('a union value must not be None')
            self._function = function
            self._type = 'function'
        elif type_of_union == 'intersectRange':
            if intersect_range is None:
                raise ValueError('a union value must not be None')
            self._intersect_range = intersect_range
            self._type = 'intersectRange'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'onChange':
            if on_change is None:
                raise ValueError('a union value must not be None')
            self._on_change = on_change
            self._type = 'onChange'
        elif type_of_union == 'minMaxThreshold':
            if min_max_threshold is None:
                raise ValueError('a union value must not be None')
            self._min_max_threshold = min_max_threshold
            self._type = 'minMaxThreshold'
        elif type_of_union == 'peak':
            if peak is None:
                raise ValueError('a union value must not be None')
            self._peak = peak
            self._type = 'peak'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'seriesCrossoverRangesNode':
            if series_crossover_ranges_node is None:
                raise ValueError('a union value must not be None')
            self._series_crossover_ranges_node = series_crossover_ranges_node
            self._type = 'seriesCrossoverRangesNode'
        elif type_of_union == 'seriesEqualityRangesNode':
            if series_equality_ranges_node is None:
                raise ValueError('a union value must not be None')
            self._series_equality_ranges_node = series_equality_ranges_node
            self._type = 'seriesEqualityRangesNode'
        elif type_of_union == 'enumSeriesEqualityRangesNode':
            if enum_series_equality_ranges_node is None:
                raise ValueError('a union value must not be None')
            self._enum_series_equality_ranges_node = enum_series_equality_ranges_node
            self._type = 'enumSeriesEqualityRangesNode'
        elif type_of_union == 'staleRange':
            if stale_range is None:
                raise ValueError('a union value must not be None')
            self._stale_range = stale_range
            self._type = 'staleRange'
        elif type_of_union == 'threshold':
            if threshold is None:
                raise ValueError('a union value must not be None')
            self._threshold = threshold
            self._type = 'threshold'
        elif type_of_union == 'unionRange':
            if union_range is None:
                raise ValueError('a union value must not be None')
            self._union_range = union_range
            self._type = 'unionRange'
        elif type_of_union == 'rangeNumericAggregation':
            if range_numeric_aggregation is None:
                raise ValueError('a union value must not be None')
            self._range_numeric_aggregation = range_numeric_aggregation
            self._type = 'rangeNumericAggregation'

    @builtins.property
    def enum_filter(self) -> Optional["scout_compute_api_EnumFilterRangesNode"]:
        return self._enum_filter

    @builtins.property
    def function(self) -> Optional["scout_compute_api_RangesFunction"]:
        return self._function

    @builtins.property
    def intersect_range(self) -> Optional["scout_compute_api_IntersectRangesNode"]:
        return self._intersect_range

    @builtins.property
    def not_(self) -> Optional["scout_compute_api_NotRangesNode"]:
        return self._not_

    @builtins.property
    def on_change(self) -> Optional["scout_compute_api_OnChangeRangesNode"]:
        return self._on_change

    @builtins.property
    def min_max_threshold(self) -> Optional["scout_compute_api_MinMaxThresholdRangesNode"]:
        """
        Computes ranges where the input time series matches a filter defined by lower and upper bounds, and an operator.
        """
        return self._min_max_threshold

    @builtins.property
    def peak(self) -> Optional["scout_compute_api_PeakRangesNode"]:
        return self._peak

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_RawRangesNode"]:
        return self._raw

    @builtins.property
    def series_crossover_ranges_node(self) -> Optional["scout_compute_api_SeriesCrossoverRangesNode"]:
        return self._series_crossover_ranges_node

    @builtins.property
    def series_equality_ranges_node(self) -> Optional["scout_compute_api_SeriesEqualityRangesNode"]:
        return self._series_equality_ranges_node

    @builtins.property
    def enum_series_equality_ranges_node(self) -> Optional["scout_compute_api_EnumSeriesEqualityRangesNode"]:
        return self._enum_series_equality_ranges_node

    @builtins.property
    def stale_range(self) -> Optional["scout_compute_api_StaleRangesNode"]:
        return self._stale_range

    @builtins.property
    def threshold(self) -> Optional["scout_compute_api_ThresholdingRangesNode"]:
        """
        Computes ranges where the input time series matches a filter defined by a single threshold and an operator.
        """
        return self._threshold

    @builtins.property
    def union_range(self) -> Optional["scout_compute_api_UnionRangesNode"]:
        return self._union_range

    @builtins.property
    def range_numeric_aggregation(self) -> Optional["scout_compute_api_RangesNumericAggregationNode"]:
        return self._range_numeric_aggregation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_RangesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_RangesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'enumFilter' and self.enum_filter is not None:
            return visitor._enum_filter(self.enum_filter)
        if self._type == 'function' and self.function is not None:
            return visitor._function(self.function)
        if self._type == 'intersectRange' and self.intersect_range is not None:
            return visitor._intersect_range(self.intersect_range)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'onChange' and self.on_change is not None:
            return visitor._on_change(self.on_change)
        if self._type == 'minMaxThreshold' and self.min_max_threshold is not None:
            return visitor._min_max_threshold(self.min_max_threshold)
        if self._type == 'peak' and self.peak is not None:
            return visitor._peak(self.peak)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'seriesCrossoverRangesNode' and self.series_crossover_ranges_node is not None:
            return visitor._series_crossover_ranges_node(self.series_crossover_ranges_node)
        if self._type == 'seriesEqualityRangesNode' and self.series_equality_ranges_node is not None:
            return visitor._series_equality_ranges_node(self.series_equality_ranges_node)
        if self._type == 'enumSeriesEqualityRangesNode' and self.enum_series_equality_ranges_node is not None:
            return visitor._enum_series_equality_ranges_node(self.enum_series_equality_ranges_node)
        if self._type == 'staleRange' and self.stale_range is not None:
            return visitor._stale_range(self.stale_range)
        if self._type == 'threshold' and self.threshold is not None:
            return visitor._threshold(self.threshold)
        if self._type == 'unionRange' and self.union_range is not None:
            return visitor._union_range(self.union_range)
        if self._type == 'rangeNumericAggregation' and self.range_numeric_aggregation is not None:
            return visitor._range_numeric_aggregation(self.range_numeric_aggregation)


scout_compute_api_RangesNode.__name__ = "RangesNode"
scout_compute_api_RangesNode.__qualname__ = "RangesNode"
scout_compute_api_RangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangesNodeVisitor:

    @abstractmethod
    def _enum_filter(self, enum_filter: "scout_compute_api_EnumFilterRangesNode") -> Any:
        pass

    @abstractmethod
    def _function(self, function: "scout_compute_api_RangesFunction") -> Any:
        pass

    @abstractmethod
    def _intersect_range(self, intersect_range: "scout_compute_api_IntersectRangesNode") -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_compute_api_NotRangesNode") -> Any:
        pass

    @abstractmethod
    def _on_change(self, on_change: "scout_compute_api_OnChangeRangesNode") -> Any:
        pass

    @abstractmethod
    def _min_max_threshold(self, min_max_threshold: "scout_compute_api_MinMaxThresholdRangesNode") -> Any:
        pass

    @abstractmethod
    def _peak(self, peak: "scout_compute_api_PeakRangesNode") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_RawRangesNode") -> Any:
        pass

    @abstractmethod
    def _series_crossover_ranges_node(self, series_crossover_ranges_node: "scout_compute_api_SeriesCrossoverRangesNode") -> Any:
        pass

    @abstractmethod
    def _series_equality_ranges_node(self, series_equality_ranges_node: "scout_compute_api_SeriesEqualityRangesNode") -> Any:
        pass

    @abstractmethod
    def _enum_series_equality_ranges_node(self, enum_series_equality_ranges_node: "scout_compute_api_EnumSeriesEqualityRangesNode") -> Any:
        pass

    @abstractmethod
    def _stale_range(self, stale_range: "scout_compute_api_StaleRangesNode") -> Any:
        pass

    @abstractmethod
    def _threshold(self, threshold: "scout_compute_api_ThresholdingRangesNode") -> Any:
        pass

    @abstractmethod
    def _union_range(self, union_range: "scout_compute_api_UnionRangesNode") -> Any:
        pass

    @abstractmethod
    def _range_numeric_aggregation(self, range_numeric_aggregation: "scout_compute_api_RangesNumericAggregationNode") -> Any:
        pass


scout_compute_api_RangesNodeVisitor.__name__ = "RangesNodeVisitor"
scout_compute_api_RangesNodeVisitor.__qualname__ = "RangesNodeVisitor"
scout_compute_api_RangesNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangesNumericAggregationNode(ConjureBeanType):
    """
    Aggregates the values of a numeric series at each range specified by the input ranges.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangesNode),
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_RangeAggregationOperation)
        }

    __slots__: List[str] = ['_ranges', '_input', '_operation']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", operation: "scout_compute_api_RangeAggregationOperation", ranges: "scout_compute_api_RangesNode") -> None:
        self._ranges = ranges
        self._input = input
        self._operation = operation

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangesNode":
        return self._ranges

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_RangeAggregationOperation":
        return self._operation


scout_compute_api_RangesNumericAggregationNode.__name__ = "RangesNumericAggregationNode"
scout_compute_api_RangesNumericAggregationNode.__qualname__ = "RangesNumericAggregationNode"
scout_compute_api_RangesNumericAggregationNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RangesSummary(ConjureBeanType):
    """
    A summary of the ranges returned from a SummarizeRangesNode request. Returned when the number of ranges
found is above a threshold.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges_summary': ConjureFieldDefinition('rangesSummary', List[scout_compute_api_RangeSummary])
        }

    __slots__: List[str] = ['_ranges_summary']

    def __init__(self, ranges_summary: List["scout_compute_api_RangeSummary"]) -> None:
        self._ranges_summary = ranges_summary

    @builtins.property
    def ranges_summary(self) -> List["scout_compute_api_RangeSummary"]:
        return self._ranges_summary


scout_compute_api_RangesSummary.__name__ = "RangesSummary"
scout_compute_api_RangesSummary.__qualname__ = "RangesSummary"
scout_compute_api_RangesSummary.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RawEnumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_VariableName)
        }

    __slots__: List[str] = ['_name']

    def __init__(self, name: str) -> None:
        self._name = name

    @builtins.property
    def name(self) -> str:
        return self._name


scout_compute_api_RawEnumSeriesNode.__name__ = "RawEnumSeriesNode"
scout_compute_api_RawEnumSeriesNode.__qualname__ = "RawEnumSeriesNode"
scout_compute_api_RawEnumSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RawNumericSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_VariableName)
        }

    __slots__: List[str] = ['_name']

    def __init__(self, name: str) -> None:
        self._name = name

    @builtins.property
    def name(self) -> str:
        return self._name


scout_compute_api_RawNumericSeriesNode.__name__ = "RawNumericSeriesNode"
scout_compute_api_RawNumericSeriesNode.__qualname__ = "RawNumericSeriesNode"
scout_compute_api_RawNumericSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RawRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_VariableName)
        }

    __slots__: List[str] = ['_name']

    def __init__(self, name: str) -> None:
        self._name = name

    @builtins.property
    def name(self) -> str:
        return self._name


scout_compute_api_RawRangesNode.__name__ = "RawRangesNode"
scout_compute_api_RawRangesNode.__qualname__ = "RawRangesNode"
scout_compute_api_RawRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RawUntypedSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_VariableName)
        }

    __slots__: List[str] = ['_name']

    def __init__(self, name: str) -> None:
        self._name = name

    @builtins.property
    def name(self) -> str:
        return self._name


scout_compute_api_RawUntypedSeriesNode.__name__ = "RawUntypedSeriesNode"
scout_compute_api_RawUntypedSeriesNode.__qualname__ = "RawUntypedSeriesNode"
scout_compute_api_RawUntypedSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ResampleConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'interval': ConjureFieldDefinition('interval', scout_compute_api_DurationConstant),
            'interpolation': ConjureFieldDefinition('interpolation', OptionalTypeWrapper[scout_compute_api_ResampleInterpolationConfiguration])
        }

    __slots__: List[str] = ['_interval', '_interpolation']

    def __init__(self, interval: "scout_compute_api_DurationConstant", interpolation: Optional["scout_compute_api_ResampleInterpolationConfiguration"] = None) -> None:
        self._interval = interval
        self._interpolation = interpolation

    @builtins.property
    def interval(self) -> "scout_compute_api_DurationConstant":
        """
        Interval between resampled points
        """
        return self._interval

    @builtins.property
    def interpolation(self) -> Optional["scout_compute_api_ResampleInterpolationConfiguration"]:
        """
        Interpolation strategy to use (defaults to forward fill).
        """
        return self._interpolation


scout_compute_api_ResampleConfiguration.__name__ = "ResampleConfiguration"
scout_compute_api_ResampleConfiguration.__qualname__ = "ResampleConfiguration"
scout_compute_api_ResampleConfiguration.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ResampleInterpolationConfiguration(ConjureUnionType):
    _forward_fill_resample_interpolation_configuration: Optional["scout_compute_api_ForwardFillResampleInterpolationConfiguration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'forward_fill_resample_interpolation_configuration': ConjureFieldDefinition('forwardFillResampleInterpolationConfiguration', scout_compute_api_ForwardFillResampleInterpolationConfiguration)
        }

    def __init__(
            self,
            forward_fill_resample_interpolation_configuration: Optional["scout_compute_api_ForwardFillResampleInterpolationConfiguration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (forward_fill_resample_interpolation_configuration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if forward_fill_resample_interpolation_configuration is not None:
                self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
                self._type = 'forwardFillResampleInterpolationConfiguration'

        elif type_of_union == 'forwardFillResampleInterpolationConfiguration':
            if forward_fill_resample_interpolation_configuration is None:
                raise ValueError('a union value must not be None')
            self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
            self._type = 'forwardFillResampleInterpolationConfiguration'

    @builtins.property
    def forward_fill_resample_interpolation_configuration(self) -> Optional["scout_compute_api_ForwardFillResampleInterpolationConfiguration"]:
        return self._forward_fill_resample_interpolation_configuration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ResampleInterpolationConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ResampleInterpolationConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'forwardFillResampleInterpolationConfiguration' and self.forward_fill_resample_interpolation_configuration is not None:
            return visitor._forward_fill_resample_interpolation_configuration(self.forward_fill_resample_interpolation_configuration)


scout_compute_api_ResampleInterpolationConfiguration.__name__ = "ResampleInterpolationConfiguration"
scout_compute_api_ResampleInterpolationConfiguration.__qualname__ = "ResampleInterpolationConfiguration"
scout_compute_api_ResampleInterpolationConfiguration.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ResampleInterpolationConfigurationVisitor:

    @abstractmethod
    def _forward_fill_resample_interpolation_configuration(self, forward_fill_resample_interpolation_configuration: "scout_compute_api_ForwardFillResampleInterpolationConfiguration") -> Any:
        pass


scout_compute_api_ResampleInterpolationConfigurationVisitor.__name__ = "ResampleInterpolationConfigurationVisitor"
scout_compute_api_ResampleInterpolationConfigurationVisitor.__qualname__ = "ResampleInterpolationConfigurationVisitor"
scout_compute_api_ResampleInterpolationConfigurationVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RollingOperationSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'window': ConjureFieldDefinition('window', scout_compute_api_Window),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_RollingOperator)
        }

    __slots__: List[str] = ['_input', '_window', '_operator']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", operator: "scout_compute_api_RollingOperator", window: "scout_compute_api_Window") -> None:
        self._input = input
        self._window = window
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def window(self) -> "scout_compute_api_Window":
        return self._window

    @builtins.property
    def operator(self) -> "scout_compute_api_RollingOperator":
        return self._operator


scout_compute_api_RollingOperationSeriesNode.__name__ = "RollingOperationSeriesNode"
scout_compute_api_RollingOperationSeriesNode.__qualname__ = "RollingOperationSeriesNode"
scout_compute_api_RollingOperationSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RollingOperator(ConjureUnionType):
    _exponential_average: Optional["scout_compute_api_ExponentialAverage"] = None
    _average: Optional["scout_compute_api_Average"] = None
    _count: Optional["scout_compute_api_Count"] = None
    _min: Optional["scout_compute_api_Minimum"] = None
    _max: Optional["scout_compute_api_Maximum"] = None
    _standard_deviation: Optional["scout_compute_api_StandardDeviation"] = None
    _sum: Optional["scout_compute_api_Sum"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'exponential_average': ConjureFieldDefinition('exponentialAverage', scout_compute_api_ExponentialAverage),
            'average': ConjureFieldDefinition('average', scout_compute_api_Average),
            'count': ConjureFieldDefinition('count', scout_compute_api_Count),
            'min': ConjureFieldDefinition('min', scout_compute_api_Minimum),
            'max': ConjureFieldDefinition('max', scout_compute_api_Maximum),
            'standard_deviation': ConjureFieldDefinition('standardDeviation', scout_compute_api_StandardDeviation),
            'sum': ConjureFieldDefinition('sum', scout_compute_api_Sum)
        }

    def __init__(
            self,
            exponential_average: Optional["scout_compute_api_ExponentialAverage"] = None,
            average: Optional["scout_compute_api_Average"] = None,
            count: Optional["scout_compute_api_Count"] = None,
            min: Optional["scout_compute_api_Minimum"] = None,
            max: Optional["scout_compute_api_Maximum"] = None,
            standard_deviation: Optional["scout_compute_api_StandardDeviation"] = None,
            sum: Optional["scout_compute_api_Sum"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (exponential_average is not None) + (average is not None) + (count is not None) + (min is not None) + (max is not None) + (standard_deviation is not None) + (sum is not None) != 1:
                raise ValueError('a union must contain a single member')

            if exponential_average is not None:
                self._exponential_average = exponential_average
                self._type = 'exponentialAverage'
            if average is not None:
                self._average = average
                self._type = 'average'
            if count is not None:
                self._count = count
                self._type = 'count'
            if min is not None:
                self._min = min
                self._type = 'min'
            if max is not None:
                self._max = max
                self._type = 'max'
            if standard_deviation is not None:
                self._standard_deviation = standard_deviation
                self._type = 'standardDeviation'
            if sum is not None:
                self._sum = sum
                self._type = 'sum'

        elif type_of_union == 'exponentialAverage':
            if exponential_average is None:
                raise ValueError('a union value must not be None')
            self._exponential_average = exponential_average
            self._type = 'exponentialAverage'
        elif type_of_union == 'average':
            if average is None:
                raise ValueError('a union value must not be None')
            self._average = average
            self._type = 'average'
        elif type_of_union == 'count':
            if count is None:
                raise ValueError('a union value must not be None')
            self._count = count
            self._type = 'count'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'standardDeviation':
            if standard_deviation is None:
                raise ValueError('a union value must not be None')
            self._standard_deviation = standard_deviation
            self._type = 'standardDeviation'
        elif type_of_union == 'sum':
            if sum is None:
                raise ValueError('a union value must not be None')
            self._sum = sum
            self._type = 'sum'

    @builtins.property
    def exponential_average(self) -> Optional["scout_compute_api_ExponentialAverage"]:
        return self._exponential_average

    @builtins.property
    def average(self) -> Optional["scout_compute_api_Average"]:
        return self._average

    @builtins.property
    def count(self) -> Optional["scout_compute_api_Count"]:
        return self._count

    @builtins.property
    def min(self) -> Optional["scout_compute_api_Minimum"]:
        return self._min

    @builtins.property
    def max(self) -> Optional["scout_compute_api_Maximum"]:
        return self._max

    @builtins.property
    def standard_deviation(self) -> Optional["scout_compute_api_StandardDeviation"]:
        return self._standard_deviation

    @builtins.property
    def sum(self) -> Optional["scout_compute_api_Sum"]:
        return self._sum

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_RollingOperatorVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_RollingOperatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'exponentialAverage' and self.exponential_average is not None:
            return visitor._exponential_average(self.exponential_average)
        if self._type == 'average' and self.average is not None:
            return visitor._average(self.average)
        if self._type == 'count' and self.count is not None:
            return visitor._count(self.count)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'standardDeviation' and self.standard_deviation is not None:
            return visitor._standard_deviation(self.standard_deviation)
        if self._type == 'sum' and self.sum is not None:
            return visitor._sum(self.sum)


scout_compute_api_RollingOperator.__name__ = "RollingOperator"
scout_compute_api_RollingOperator.__qualname__ = "RollingOperator"
scout_compute_api_RollingOperator.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_RollingOperatorVisitor:

    @abstractmethod
    def _exponential_average(self, exponential_average: "scout_compute_api_ExponentialAverage") -> Any:
        pass

    @abstractmethod
    def _average(self, average: "scout_compute_api_Average") -> Any:
        pass

    @abstractmethod
    def _count(self, count: "scout_compute_api_Count") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_compute_api_Minimum") -> Any:
        pass

    @abstractmethod
    def _max(self, max: "scout_compute_api_Maximum") -> Any:
        pass

    @abstractmethod
    def _standard_deviation(self, standard_deviation: "scout_compute_api_StandardDeviation") -> Any:
        pass

    @abstractmethod
    def _sum(self, sum: "scout_compute_api_Sum") -> Any:
        pass


scout_compute_api_RollingOperatorVisitor.__name__ = "RollingOperatorVisitor"
scout_compute_api_RollingOperatorVisitor.__qualname__ = "RollingOperatorVisitor"
scout_compute_api_RollingOperatorVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ScaleSeriesNode(ConjureBeanType):
    """
    For every timestamp specified in the input series, multiply it by a constant factor.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'scalar': ConjureFieldDefinition('scalar', scout_compute_api_DoubleConstant),
            'scalar_unit': ConjureFieldDefinition('scalarUnit', OptionalTypeWrapper[scout_units_api_UnitSymbol])
        }

    __slots__: List[str] = ['_input', '_scalar', '_scalar_unit']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", scalar: "scout_compute_api_DoubleConstant", scalar_unit: Optional[str] = None) -> None:
        self._input = input
        self._scalar = scalar
        self._scalar_unit = scalar_unit

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def scalar(self) -> "scout_compute_api_DoubleConstant":
        """
        The constant to multiply each point by
        """
        return self._scalar

    @builtins.property
    def scalar_unit(self) -> Optional[str]:
        """
        The units of the scalar to multiply by. If empty, the scalar is considered unit-less.
        """
        return self._scalar_unit


scout_compute_api_ScaleSeriesNode.__name__ = "ScaleSeriesNode"
scout_compute_api_ScaleSeriesNode.__qualname__ = "ScaleSeriesNode"
scout_compute_api_ScaleSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ScatterNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_api_NumericSeriesNode),
            'y': ConjureFieldDefinition('y', scout_compute_api_NumericSeriesNode)
        }

    __slots__: List[str] = ['_x', '_y']

    def __init__(self, x: "scout_compute_api_NumericSeriesNode", y: "scout_compute_api_NumericSeriesNode") -> None:
        self._x = x
        self._y = y

    @builtins.property
    def x(self) -> "scout_compute_api_NumericSeriesNode":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_api_NumericSeriesNode":
        return self._y


scout_compute_api_ScatterNode.__name__ = "ScatterNode"
scout_compute_api_ScatterNode.__qualname__ = "ScatterNode"
scout_compute_api_ScatterNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SelectValueNode(ConjureUnionType):
    _first_point: Optional["scout_compute_api_SeriesNode"] = None
    _first_range: Optional["scout_compute_api_RangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_api_SeriesNode),
            'first_range': ConjureFieldDefinition('firstRange', scout_compute_api_RangesNode)
        }

    def __init__(
            self,
            first_point: Optional["scout_compute_api_SeriesNode"] = None,
            first_range: Optional["scout_compute_api_RangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (first_point is not None) + (first_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if first_point is not None:
                self._first_point = first_point
                self._type = 'firstPoint'
            if first_range is not None:
                self._first_range = first_range
                self._type = 'firstRange'

        elif type_of_union == 'firstPoint':
            if first_point is None:
                raise ValueError('a union value must not be None')
            self._first_point = first_point
            self._type = 'firstPoint'
        elif type_of_union == 'firstRange':
            if first_range is None:
                raise ValueError('a union value must not be None')
            self._first_range = first_range
            self._type = 'firstRange'

    @builtins.property
    def first_point(self) -> Optional["scout_compute_api_SeriesNode"]:
        return self._first_point

    @builtins.property
    def first_range(self) -> Optional["scout_compute_api_RangesNode"]:
        return self._first_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_SelectValueNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_SelectValueNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'firstPoint' and self.first_point is not None:
            return visitor._first_point(self.first_point)
        if self._type == 'firstRange' and self.first_range is not None:
            return visitor._first_range(self.first_range)


scout_compute_api_SelectValueNode.__name__ = "SelectValueNode"
scout_compute_api_SelectValueNode.__qualname__ = "SelectValueNode"
scout_compute_api_SelectValueNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SelectValueNodeVisitor:

    @abstractmethod
    def _first_point(self, first_point: "scout_compute_api_SeriesNode") -> Any:
        pass

    @abstractmethod
    def _first_range(self, first_range: "scout_compute_api_RangesNode") -> Any:
        pass


scout_compute_api_SelectValueNodeVisitor.__name__ = "SelectValueNodeVisitor"
scout_compute_api_SelectValueNodeVisitor.__qualname__ = "SelectValueNodeVisitor"
scout_compute_api_SelectValueNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SeriesCrossoverRangesNode(ConjureBeanType):
    """
    Produces a list of zero-duration ranges at the first point where two series cross over one another
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input_a': ConjureFieldDefinition('inputA', scout_compute_api_NumericSeriesNode),
            'input_b': ConjureFieldDefinition('inputB', scout_compute_api_NumericSeriesNode)
        }

    __slots__: List[str] = ['_input_a', '_input_b']

    def __init__(self, input_a: "scout_compute_api_NumericSeriesNode", input_b: "scout_compute_api_NumericSeriesNode") -> None:
        self._input_a = input_a
        self._input_b = input_b

    @builtins.property
    def input_a(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input_a

    @builtins.property
    def input_b(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input_b


scout_compute_api_SeriesCrossoverRangesNode.__name__ = "SeriesCrossoverRangesNode"
scout_compute_api_SeriesCrossoverRangesNode.__qualname__ = "SeriesCrossoverRangesNode"
scout_compute_api_SeriesCrossoverRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SeriesEqualityRangesNode(ConjureBeanType):
    """
    Produces a list of ranges for which provided series are all equal (or are not all equal).
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_NumericSeriesNode]),
            'equality_operator': ConjureFieldDefinition('equalityOperator', scout_compute_api_EqualityOperator),
            'tolerance': ConjureFieldDefinition('tolerance', OptionalTypeWrapper[scout_compute_api_DoubleConstant]),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_input', '_equality_operator', '_tolerance', '_persistence_window_configuration', '_interpolation_configuration']

    def __init__(self, equality_operator: "scout_compute_api_EqualityOperator", input: List["scout_compute_api_NumericSeriesNode"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None, persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None, tolerance: Optional["scout_compute_api_DoubleConstant"] = None) -> None:
        self._input = input
        self._equality_operator = equality_operator
        self._tolerance = tolerance
        self._persistence_window_configuration = persistence_window_configuration
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def input(self) -> List["scout_compute_api_NumericSeriesNode"]:
        return self._input

    @builtins.property
    def equality_operator(self) -> "scout_compute_api_EqualityOperator":
        return self._equality_operator

    @builtins.property
    def tolerance(self) -> Optional["scout_compute_api_DoubleConstant"]:
        return self._tolerance

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """
        Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_SeriesEqualityRangesNode.__name__ = "SeriesEqualityRangesNode"
scout_compute_api_SeriesEqualityRangesNode.__qualname__ = "SeriesEqualityRangesNode"
scout_compute_api_SeriesEqualityRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_api_RawUntypedSeriesNode"] = None
    _enum: Optional["scout_compute_api_EnumSeriesNode"] = None
    _numeric: Optional["scout_compute_api_NumericSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_api_RawUntypedSeriesNode),
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumSeriesNode),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_api_RawUntypedSeriesNode"] = None,
            enum: Optional["scout_compute_api_EnumSeriesNode"] = None,
            numeric: Optional["scout_compute_api_NumericSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (enum is not None) + (numeric is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_RawUntypedSeriesNode"]:
        return self._raw

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumSeriesNode"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericSeriesNode"]:
        return self._numeric

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_SeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_SeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)


scout_compute_api_SeriesNode.__name__ = "SeriesNode"
scout_compute_api_SeriesNode.__qualname__ = "SeriesNode"
scout_compute_api_SeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_RawUntypedSeriesNode") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericSeriesNode") -> Any:
        pass


scout_compute_api_SeriesNodeVisitor.__name__ = "SeriesNodeVisitor"
scout_compute_api_SeriesNodeVisitor.__qualname__ = "SeriesNodeVisitor"
scout_compute_api_SeriesNodeVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SeriesSpec(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_compute_api_LogicalSeriesRid),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_run_api_Duration])
        }

    __slots__: List[str] = ['_rid', '_offset']

    def __init__(self, rid: str, offset: Optional["scout_run_api_Duration"] = None) -> None:
        self._rid = rid
        self._offset = offset

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def offset(self) -> Optional["scout_run_api_Duration"]:
        """
        The offset of this series relative to the time scale in which the computation is performed.
        """
        return self._offset


scout_compute_api_SeriesSpec.__name__ = "SeriesSpec"
scout_compute_api_SeriesSpec.__qualname__ = "SeriesSpec"
scout_compute_api_SeriesSpec.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SetNegativeValuesToZero(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_SetNegativeValuesToZero.__name__ = "SetNegativeValuesToZero"
scout_compute_api_SetNegativeValuesToZero.__qualname__ = "SetNegativeValuesToZero"
scout_compute_api_SetNegativeValuesToZero.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_StaleRangesNode(ConjureBeanType):
    """
    Produces a list of ranges for which data does not exist for the specified duration or longer. Increases 
window size by the specified staleness threshold on both ends to capture edge cases of data not currently 
in view.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_SeriesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_DurationConstant),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', scout_compute_api_TimestampConstant),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', OptionalTypeWrapper[scout_compute_api_TimestampConstant])
        }

    __slots__: List[str] = ['_input', '_threshold', '_start_timestamp', '_end_timestamp']

    def __init__(self, input: "scout_compute_api_SeriesNode", start_timestamp: "scout_compute_api_TimestampConstant", threshold: "scout_compute_api_DurationConstant", end_timestamp: Optional["scout_compute_api_TimestampConstant"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp

    @builtins.property
    def input(self) -> "scout_compute_api_SeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_compute_api_DurationConstant":
        return self._threshold

    @builtins.property
    def start_timestamp(self) -> "scout_compute_api_TimestampConstant":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> Optional["scout_compute_api_TimestampConstant"]:
        return self._end_timestamp


scout_compute_api_StaleRangesNode.__name__ = "StaleRangesNode"
scout_compute_api_StaleRangesNode.__qualname__ = "StaleRangesNode"
scout_compute_api_StaleRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_StandardDeviation(ConjureBeanType):
    """
    The standard deviation of points inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_StandardDeviation.__name__ = "StandardDeviation"
scout_compute_api_StandardDeviation.__qualname__ = "StandardDeviation"
scout_compute_api_StandardDeviation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_StringSetConstant(ConjureUnionType):
    _literal: Optional[List[str]] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', List[str]),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional[List[str]] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional[List[str]]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_StringSetConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_StringSetConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_StringSetConstant.__name__ = "StringSetConstant"
scout_compute_api_StringSetConstant.__qualname__ = "StringSetConstant"
scout_compute_api_StringSetConstant.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_StringSetConstantVisitor:

    @abstractmethod
    def _literal(self, literal: List[str]) -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_StringSetConstantVisitor.__name__ = "StringSetConstantVisitor"
scout_compute_api_StringSetConstantVisitor.__qualname__ = "StringSetConstantVisitor"
scout_compute_api_StringSetConstantVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_Sum(ConjureBeanType):
    """
    The sum of point values inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Sum.__name__ = "Sum"
scout_compute_api_Sum.__qualname__ = "Sum"
scout_compute_api_Sum.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SumSeriesNode(ConjureBeanType):
    """
    For every timestamp specified in the input series, outputs a value that is the sum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeriesNode"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """
        Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_SumSeriesNode.__name__ = "SumSeriesNode"
scout_compute_api_SumSeriesNode.__qualname__ = "SumSeriesNode"
scout_compute_api_SumSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SummarizeCartesianNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_CartesianNode),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_api_CartesianBounds]),
            'max_points': ConjureFieldDefinition('maxPoints', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_bounds', '_max_points']

    def __init__(self, input: "scout_compute_api_CartesianNode", bounds: Optional["scout_compute_api_CartesianBounds"] = None, max_points: Optional[int] = None) -> None:
        self._input = input
        self._bounds = bounds
        self._max_points = max_points

    @builtins.property
    def input(self) -> "scout_compute_api_CartesianNode":
        return self._input

    @builtins.property
    def bounds(self) -> Optional["scout_compute_api_CartesianBounds"]:
        return self._bounds

    @builtins.property
    def max_points(self) -> Optional[int]:
        """
        The maximum number of points to return in the response. If more points are found, a BucketedCartesianPlot
will be returned. Maximum is 10,000. Defaults to 2,000 if not specified.
        """
        return self._max_points


scout_compute_api_SummarizeCartesianNode.__name__ = "SummarizeCartesianNode"
scout_compute_api_SummarizeCartesianNode.__qualname__ = "SummarizeCartesianNode"
scout_compute_api_SummarizeCartesianNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SummarizeGeoNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_GeoNode),
            'summary_strategy': ConjureFieldDefinition('summaryStrategy', scout_compute_api_GeoNodeSummaryStrategy)
        }

    __slots__: List[str] = ['_input', '_summary_strategy']

    def __init__(self, input: "scout_compute_api_GeoNode", summary_strategy: "scout_compute_api_GeoNodeSummaryStrategy") -> None:
        self._input = input
        self._summary_strategy = summary_strategy

    @builtins.property
    def input(self) -> "scout_compute_api_GeoNode":
        return self._input

    @builtins.property
    def summary_strategy(self) -> "scout_compute_api_GeoNodeSummaryStrategy":
        return self._summary_strategy


scout_compute_api_SummarizeGeoNode.__name__ = "SummarizeGeoNode"
scout_compute_api_SummarizeGeoNode.__qualname__ = "SummarizeGeoNode"
scout_compute_api_SummarizeGeoNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SummarizeRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_RangesNode),
            'max_ranges': ConjureFieldDefinition('maxRanges', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_max_ranges']

    def __init__(self, input: "scout_compute_api_RangesNode", max_ranges: Optional[int] = None) -> None:
        self._input = input
        self._max_ranges = max_ranges

    @builtins.property
    def input(self) -> "scout_compute_api_RangesNode":
        return self._input

    @builtins.property
    def max_ranges(self) -> Optional[int]:
        """
        The maximum number of ranges to return in the response. If more ranges are found, a RangesSummary
will be returned. Defaults to 2000 if not specified.
        """
        return self._max_ranges


scout_compute_api_SummarizeRangesNode.__name__ = "SummarizeRangesNode"
scout_compute_api_SummarizeRangesNode.__qualname__ = "SummarizeRangesNode"
scout_compute_api_SummarizeRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_SummarizeSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_SeriesNode),
            'resolution': ConjureFieldDefinition('resolution', int)
        }

    __slots__: List[str] = ['_input', '_resolution']

    def __init__(self, input: "scout_compute_api_SeriesNode", resolution: int) -> None:
        self._input = input
        self._resolution = resolution

    @builtins.property
    def input(self) -> "scout_compute_api_SeriesNode":
        return self._input

    @builtins.property
    def resolution(self) -> int:
        return self._resolution


scout_compute_api_SummarizeSeriesNode.__name__ = "SummarizeSeriesNode"
scout_compute_api_SummarizeSeriesNode.__qualname__ = "SummarizeSeriesNode"
scout_compute_api_SummarizeSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ThresholdOperator(ConjureEnumType):

    GREATER_THAN = 'GREATER_THAN'
    '''GREATER_THAN'''
    GREATER_THAN_OR_EQUAL_TO = 'GREATER_THAN_OR_EQUAL_TO'
    '''GREATER_THAN_OR_EQUAL_TO'''
    LESS_THAN = 'LESS_THAN'
    '''LESS_THAN'''
    LESS_THAN_OR_EQUAL_TO = 'LESS_THAN_OR_EQUAL_TO'
    '''LESS_THAN_OR_EQUAL_TO'''
    EQUAL_TO = 'EQUAL_TO'
    '''EQUAL_TO'''
    NOT_EQUAL_TO = 'NOT_EQUAL_TO'
    '''NOT_EQUAL_TO'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_ThresholdOperator.__name__ = "ThresholdOperator"
scout_compute_api_ThresholdOperator.__qualname__ = "ThresholdOperator"
scout_compute_api_ThresholdOperator.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ThresholdingRangesNode(ConjureBeanType):
    """
    Produces a list of ranges for which the threshold condition is satisfied.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_DoubleConstant),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_threshold', '_operator', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", operator: "scout_compute_api_ThresholdOperator", threshold: "scout_compute_api_DoubleConstant", persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._operator = operator
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_compute_api_DoubleConstant":
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_ThresholdingRangesNode.__name__ = "ThresholdingRangesNode"
scout_compute_api_ThresholdingRangesNode.__qualname__ = "ThresholdingRangesNode"
scout_compute_api_ThresholdingRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_TimeBucketedGeoPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_GeoTimeBucket])
        }

    __slots__: List[str] = ['_timestamps', '_buckets']

    def __init__(self, buckets: List["scout_compute_api_GeoTimeBucket"], timestamps: List["api_Timestamp"]) -> None:
        self._timestamps = timestamps
        self._buckets = buckets

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        """
        The end of the bucket, exclusive.
        """
        return self._timestamps

    @builtins.property
    def buckets(self) -> List["scout_compute_api_GeoTimeBucket"]:
        return self._buckets


scout_compute_api_TimeBucketedGeoPlot.__name__ = "TimeBucketedGeoPlot"
scout_compute_api_TimeBucketedGeoPlot.__qualname__ = "TimeBucketedGeoPlot"
scout_compute_api_TimeBucketedGeoPlot.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_TimeDifferenceSeriesNode(ConjureBeanType):
    """
    Outputs a new series where each value is the difference between the time of the current and previous points.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_SeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[scout_compute_api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_time_unit']

    def __init__(self, input: "scout_compute_api_SeriesNode", time_unit: Optional["scout_compute_api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_api_SeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["scout_compute_api_TimeUnit"]:
        """
        The time unit used to define the output values. Defaults to seconds if not specified.
        """
        return self._time_unit


scout_compute_api_TimeDifferenceSeriesNode.__name__ = "TimeDifferenceSeriesNode"
scout_compute_api_TimeDifferenceSeriesNode.__qualname__ = "TimeDifferenceSeriesNode"
scout_compute_api_TimeDifferenceSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_TimeUnit(ConjureEnumType):

    DAYS = 'DAYS'
    '''DAYS'''
    HOURS = 'HOURS'
    '''HOURS'''
    MINUTES = 'MINUTES'
    '''MINUTES'''
    SECONDS = 'SECONDS'
    '''SECONDS'''
    MILLISECONDS = 'MILLISECONDS'
    '''MILLISECONDS'''
    MICROSECONDS = 'MICROSECONDS'
    '''MICROSECONDS'''
    NANOSECONDS = 'NANOSECONDS'
    '''NANOSECONDS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_TimeUnit.__name__ = "TimeUnit"
scout_compute_api_TimeUnit.__qualname__ = "TimeUnit"
scout_compute_api_TimeUnit.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_TimestampConstant(ConjureUnionType):
    _literal: Optional["api_Timestamp"] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', api_Timestamp),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional["api_Timestamp"] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional["api_Timestamp"]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_TimestampConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_TimestampConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_TimestampConstant.__name__ = "TimestampConstant"
scout_compute_api_TimestampConstant.__qualname__ = "TimestampConstant"
scout_compute_api_TimestampConstant.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_TimestampConstantVisitor:

    @abstractmethod
    def _literal(self, literal: "api_Timestamp") -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_TimestampConstantVisitor.__name__ = "TimestampConstantVisitor"
scout_compute_api_TimestampConstantVisitor.__qualname__ = "TimestampConstantVisitor"
scout_compute_api_TimestampConstantVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnaryArithmeticOperation(ConjureEnumType):

    COS = 'COS'
    '''COS'''
    SIN = 'SIN'
    '''SIN'''
    TAN = 'TAN'
    '''TAN'''
    ABS = 'ABS'
    '''ABS'''
    ASIN = 'ASIN'
    '''ASIN'''
    ACOS = 'ACOS'
    '''ACOS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_UnaryArithmeticOperation.__name__ = "UnaryArithmeticOperation"
scout_compute_api_UnaryArithmeticOperation.__qualname__ = "UnaryArithmeticOperation"
scout_compute_api_UnaryArithmeticOperation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnaryArithmeticSeriesNode(ConjureBeanType):
    """
    Applies a point-wise transformation to a series. The transformation function is applied to every
individual data point.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_UnaryArithmeticOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", operation: "scout_compute_api_UnaryArithmeticOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_UnaryArithmeticOperation":
        return self._operation


scout_compute_api_UnaryArithmeticSeriesNode.__name__ = "UnaryArithmeticSeriesNode"
scout_compute_api_UnaryArithmeticSeriesNode.__qualname__ = "UnaryArithmeticSeriesNode"
scout_compute_api_UnaryArithmeticSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnionRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_api_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_api_RangesNode"]:
        return self._inputs


scout_compute_api_UnionRangesNode.__name__ = "UnionRangesNode"
scout_compute_api_UnionRangesNode.__qualname__ = "UnionRangesNode"
scout_compute_api_UnionRangesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnitComputationError(ConjureUnionType):
    _incompatible_units_operation: Optional["scout_compute_api_IncompatibleUnitOperation"] = None
    _units_missing: Optional["scout_compute_api_UnitsMissing"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'incompatible_units_operation': ConjureFieldDefinition('incompatibleUnitsOperation', scout_compute_api_IncompatibleUnitOperation),
            'units_missing': ConjureFieldDefinition('unitsMissing', scout_compute_api_UnitsMissing)
        }

    def __init__(
            self,
            incompatible_units_operation: Optional["scout_compute_api_IncompatibleUnitOperation"] = None,
            units_missing: Optional["scout_compute_api_UnitsMissing"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (incompatible_units_operation is not None) + (units_missing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if incompatible_units_operation is not None:
                self._incompatible_units_operation = incompatible_units_operation
                self._type = 'incompatibleUnitsOperation'
            if units_missing is not None:
                self._units_missing = units_missing
                self._type = 'unitsMissing'

        elif type_of_union == 'incompatibleUnitsOperation':
            if incompatible_units_operation is None:
                raise ValueError('a union value must not be None')
            self._incompatible_units_operation = incompatible_units_operation
            self._type = 'incompatibleUnitsOperation'
        elif type_of_union == 'unitsMissing':
            if units_missing is None:
                raise ValueError('a union value must not be None')
            self._units_missing = units_missing
            self._type = 'unitsMissing'

    @builtins.property
    def incompatible_units_operation(self) -> Optional["scout_compute_api_IncompatibleUnitOperation"]:
        return self._incompatible_units_operation

    @builtins.property
    def units_missing(self) -> Optional["scout_compute_api_UnitsMissing"]:
        return self._units_missing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_UnitComputationErrorVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_UnitComputationErrorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'incompatibleUnitsOperation' and self.incompatible_units_operation is not None:
            return visitor._incompatible_units_operation(self.incompatible_units_operation)
        if self._type == 'unitsMissing' and self.units_missing is not None:
            return visitor._units_missing(self.units_missing)


scout_compute_api_UnitComputationError.__name__ = "UnitComputationError"
scout_compute_api_UnitComputationError.__qualname__ = "UnitComputationError"
scout_compute_api_UnitComputationError.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnitComputationErrorVisitor:

    @abstractmethod
    def _incompatible_units_operation(self, incompatible_units_operation: "scout_compute_api_IncompatibleUnitOperation") -> Any:
        pass

    @abstractmethod
    def _units_missing(self, units_missing: "scout_compute_api_UnitsMissing") -> Any:
        pass


scout_compute_api_UnitComputationErrorVisitor.__name__ = "UnitComputationErrorVisitor"
scout_compute_api_UnitComputationErrorVisitor.__qualname__ = "UnitComputationErrorVisitor"
scout_compute_api_UnitComputationErrorVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnitConversionSeriesNode(ConjureBeanType):
    """
    Convert the given series to a different unit.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'output_unit': ConjureFieldDefinition('outputUnit', scout_units_api_UnitSymbol)
        }

    __slots__: List[str] = ['_input', '_output_unit']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", output_unit: str) -> None:
        self._input = input
        self._output_unit = output_unit

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def output_unit(self) -> str:
        return self._output_unit


scout_compute_api_UnitConversionSeriesNode.__name__ = "UnitConversionSeriesNode"
scout_compute_api_UnitConversionSeriesNode.__qualname__ = "UnitConversionSeriesNode"
scout_compute_api_UnitConversionSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnitOperation(ConjureEnumType):

    UNIT_AS_EXPONENT = 'UNIT_AS_EXPONENT'
    '''UNIT_AS_EXPONENT'''
    NON_INTEGER_AS_EXPONENT = 'NON_INTEGER_AS_EXPONENT'
    '''NON_INTEGER_AS_EXPONENT'''
    FLOOR_DIVISION = 'FLOOR_DIVISION'
    '''FLOOR_DIVISION'''
    MODULO = 'MODULO'
    '''MODULO'''
    CROSSOVER_COMPARISON = 'CROSSOVER_COMPARISON'
    '''CROSSOVER_COMPARISON'''
    MAX = 'MAX'
    '''MAX'''
    MIN = 'MIN'
    '''MIN'''
    MEAN = 'MEAN'
    '''MEAN'''
    UNION = 'UNION'
    '''UNION'''
    ADDITION = 'ADDITION'
    '''ADDITION'''
    SUBTRACTION = 'SUBTRACTION'
    '''SUBTRACTION'''
    UNIT_CONVERSION = 'UNIT_CONVERSION'
    '''UNIT_CONVERSION'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_UnitOperation.__name__ = "UnitOperation"
scout_compute_api_UnitOperation.__qualname__ = "UnitOperation"
scout_compute_api_UnitOperation.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnitResult(ConjureUnionType):
    _success: Optional[str] = None
    _no_unit_available: Optional[List["scout_compute_api_UnitComputationError"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_units_api_UnitSymbol),
            'no_unit_available': ConjureFieldDefinition('noUnitAvailable', List[scout_compute_api_UnitComputationError])
        }

    def __init__(
            self,
            success: Optional[str] = None,
            no_unit_available: Optional[List["scout_compute_api_UnitComputationError"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (no_unit_available is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if no_unit_available is not None:
                self._no_unit_available = no_unit_available
                self._type = 'noUnitAvailable'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'noUnitAvailable':
            if no_unit_available is None:
                raise ValueError('a union value must not be None')
            self._no_unit_available = no_unit_available
            self._type = 'noUnitAvailable'

    @builtins.property
    def success(self) -> Optional[str]:
        return self._success

    @builtins.property
    def no_unit_available(self) -> Optional[List["scout_compute_api_UnitComputationError"]]:
        """
        The resulting values have no units associated. If this is because of an error, it is listed here.
        """
        return self._no_unit_available

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_UnitResultVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_UnitResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'noUnitAvailable' and self.no_unit_available is not None:
            return visitor._no_unit_available(self.no_unit_available)


scout_compute_api_UnitResult.__name__ = "UnitResult"
scout_compute_api_UnitResult.__qualname__ = "UnitResult"
scout_compute_api_UnitResult.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnitResultVisitor:

    @abstractmethod
    def _success(self, success: str) -> Any:
        pass

    @abstractmethod
    def _no_unit_available(self, no_unit_available: List["scout_compute_api_UnitComputationError"]) -> Any:
        pass


scout_compute_api_UnitResultVisitor.__name__ = "UnitResultVisitor"
scout_compute_api_UnitResultVisitor.__qualname__ = "UnitResultVisitor"
scout_compute_api_UnitResultVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_UnitsMissing(ConjureBeanType):
    """
    At least one input is missing a unit.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_rids': ConjureFieldDefinition('seriesRids', List[scout_compute_api_LogicalSeriesRid])
        }

    __slots__: List[str] = ['_series_rids']

    def __init__(self, series_rids: List[str]) -> None:
        self._series_rids = series_rids

    @builtins.property
    def series_rids(self) -> List[str]:
        return self._series_rids


scout_compute_api_UnitsMissing.__name__ = "UnitsMissing"
scout_compute_api_UnitsMissing.__qualname__ = "UnitsMissing"
scout_compute_api_UnitsMissing.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_ValueDifferenceSeriesNode(ConjureBeanType):
    """
    Outputs a new series where each value is the difference between the values of the current and previous point.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeriesNode),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None) -> None:
        self._input = input
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        """
        Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified.
        """
        return self._negative_values_configuration


scout_compute_api_ValueDifferenceSeriesNode.__name__ = "ValueDifferenceSeriesNode"
scout_compute_api_ValueDifferenceSeriesNode.__qualname__ = "ValueDifferenceSeriesNode"
scout_compute_api_ValueDifferenceSeriesNode.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_VariableValue(ConjureUnionType):
    _double: Optional[float] = None
    _compute_node: Optional["scout_compute_api_ComputeNodeWithContext"] = None
    _duration: Optional["scout_run_api_Duration"] = None
    _function_rid: Optional[str] = None
    _integer: Optional[int] = None
    _series: Optional["scout_compute_api_SeriesSpec"] = None
    _string_set: Optional[List[str]] = None
    _timestamp: Optional["api_Timestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'double': ConjureFieldDefinition('double', float),
            'compute_node': ConjureFieldDefinition('computeNode', scout_compute_api_ComputeNodeWithContext),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration),
            'function_rid': ConjureFieldDefinition('functionRid', scout_rids_api_FunctionRid),
            'integer': ConjureFieldDefinition('integer', int),
            'series': ConjureFieldDefinition('series', scout_compute_api_SeriesSpec),
            'string_set': ConjureFieldDefinition('stringSet', List[str]),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp)
        }

    def __init__(
            self,
            double: Optional[float] = None,
            compute_node: Optional["scout_compute_api_ComputeNodeWithContext"] = None,
            duration: Optional["scout_run_api_Duration"] = None,
            function_rid: Optional[str] = None,
            integer: Optional[int] = None,
            series: Optional["scout_compute_api_SeriesSpec"] = None,
            string_set: Optional[List[str]] = None,
            timestamp: Optional["api_Timestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (double is not None) + (compute_node is not None) + (duration is not None) + (function_rid is not None) + (integer is not None) + (series is not None) + (string_set is not None) + (timestamp is not None) != 1:
                raise ValueError('a union must contain a single member')

            if double is not None:
                self._double = double
                self._type = 'double'
            if compute_node is not None:
                self._compute_node = compute_node
                self._type = 'computeNode'
            if duration is not None:
                self._duration = duration
                self._type = 'duration'
            if function_rid is not None:
                self._function_rid = function_rid
                self._type = 'functionRid'
            if integer is not None:
                self._integer = integer
                self._type = 'integer'
            if series is not None:
                self._series = series
                self._type = 'series'
            if string_set is not None:
                self._string_set = string_set
                self._type = 'stringSet'
            if timestamp is not None:
                self._timestamp = timestamp
                self._type = 'timestamp'

        elif type_of_union == 'double':
            if double is None:
                raise ValueError('a union value must not be None')
            self._double = double
            self._type = 'double'
        elif type_of_union == 'computeNode':
            if compute_node is None:
                raise ValueError('a union value must not be None')
            self._compute_node = compute_node
            self._type = 'computeNode'
        elif type_of_union == 'duration':
            if duration is None:
                raise ValueError('a union value must not be None')
            self._duration = duration
            self._type = 'duration'
        elif type_of_union == 'functionRid':
            if function_rid is None:
                raise ValueError('a union value must not be None')
            self._function_rid = function_rid
            self._type = 'functionRid'
        elif type_of_union == 'integer':
            if integer is None:
                raise ValueError('a union value must not be None')
            self._integer = integer
            self._type = 'integer'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'stringSet':
            if string_set is None:
                raise ValueError('a union value must not be None')
            self._string_set = string_set
            self._type = 'stringSet'
        elif type_of_union == 'timestamp':
            if timestamp is None:
                raise ValueError('a union value must not be None')
            self._timestamp = timestamp
            self._type = 'timestamp'

    @builtins.property
    def double(self) -> Optional[float]:
        return self._double

    @builtins.property
    def compute_node(self) -> Optional["scout_compute_api_ComputeNodeWithContext"]:
        return self._compute_node

    @builtins.property
    def duration(self) -> Optional["scout_run_api_Duration"]:
        return self._duration

    @builtins.property
    def function_rid(self) -> Optional[str]:
        return self._function_rid

    @builtins.property
    def integer(self) -> Optional[int]:
        return self._integer

    @builtins.property
    def series(self) -> Optional["scout_compute_api_SeriesSpec"]:
        return self._series

    @builtins.property
    def string_set(self) -> Optional[List[str]]:
        return self._string_set

    @builtins.property
    def timestamp(self) -> Optional["api_Timestamp"]:
        return self._timestamp

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_VariableValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_VariableValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'double' and self.double is not None:
            return visitor._double(self.double)
        if self._type == 'computeNode' and self.compute_node is not None:
            return visitor._compute_node(self.compute_node)
        if self._type == 'duration' and self.duration is not None:
            return visitor._duration(self.duration)
        if self._type == 'functionRid' and self.function_rid is not None:
            return visitor._function_rid(self.function_rid)
        if self._type == 'integer' and self.integer is not None:
            return visitor._integer(self.integer)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'stringSet' and self.string_set is not None:
            return visitor._string_set(self.string_set)
        if self._type == 'timestamp' and self.timestamp is not None:
            return visitor._timestamp(self.timestamp)


scout_compute_api_VariableValue.__name__ = "VariableValue"
scout_compute_api_VariableValue.__qualname__ = "VariableValue"
scout_compute_api_VariableValue.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_VariableValueVisitor:

    @abstractmethod
    def _double(self, double: float) -> Any:
        pass

    @abstractmethod
    def _compute_node(self, compute_node: "scout_compute_api_ComputeNodeWithContext") -> Any:
        pass

    @abstractmethod
    def _duration(self, duration: "scout_run_api_Duration") -> Any:
        pass

    @abstractmethod
    def _function_rid(self, function_rid: str) -> Any:
        pass

    @abstractmethod
    def _integer(self, integer: int) -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_compute_api_SeriesSpec") -> Any:
        pass

    @abstractmethod
    def _string_set(self, string_set: List[str]) -> Any:
        pass

    @abstractmethod
    def _timestamp(self, timestamp: "api_Timestamp") -> Any:
        pass


scout_compute_api_VariableValueVisitor.__name__ = "VariableValueVisitor"
scout_compute_api_VariableValueVisitor.__qualname__ = "VariableValueVisitor"
scout_compute_api_VariableValueVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_Window(ConjureUnionType):
    _duration: Optional["scout_compute_api_DurationConstant"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', scout_compute_api_DurationConstant)
        }

    def __init__(
            self,
            duration: Optional["scout_compute_api_DurationConstant"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (duration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if duration is not None:
                self._duration = duration
                self._type = 'duration'

        elif type_of_union == 'duration':
            if duration is None:
                raise ValueError('a union value must not be None')
            self._duration = duration
            self._type = 'duration'

    @builtins.property
    def duration(self) -> Optional["scout_compute_api_DurationConstant"]:
        return self._duration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_WindowVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_WindowVisitor'.format(visitor.__class__.__name__))
        if self._type == 'duration' and self.duration is not None:
            return visitor._duration(self.duration)


scout_compute_api_Window.__name__ = "Window"
scout_compute_api_Window.__qualname__ = "Window"
scout_compute_api_Window.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_WindowVisitor:

    @abstractmethod
    def _duration(self, duration: "scout_compute_api_DurationConstant") -> Any:
        pass


scout_compute_api_WindowVisitor.__name__ = "WindowVisitor"
scout_compute_api_WindowVisitor.__qualname__ = "WindowVisitor"
scout_compute_api_WindowVisitor.__module__ = "scout_service_api.scout_compute_api"


class scout_compute_api_deprecated_ArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_LocalVariableName, scout_compute_api_deprecated_NumericSeriesNode]),
            'expression': ConjureFieldDefinition('expression', str)
        }

    __slots__: List[str] = ['_inputs', '_expression']

    def __init__(self, expression: str, inputs: Dict[str, "scout_compute_api_deprecated_NumericSeriesNode"]) -> None:
        self._inputs = inputs
        self._expression = expression

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_api_deprecated_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def expression(self) -> str:
        return self._expression


scout_compute_api_deprecated_ArithmeticSeriesNode.__name__ = "ArithmeticSeriesNode"
scout_compute_api_deprecated_ArithmeticSeriesNode.__qualname__ = "ArithmeticSeriesNode"
scout_compute_api_deprecated_ArithmeticSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_BitOperationSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_BitOperationFunction)
        }

    __slots__: List[str] = ['_input', '_function']

    def __init__(self, function: "scout_compute_api_BitOperationFunction", input: "scout_compute_api_deprecated_NumericSeriesNode") -> None:
        self._input = input
        self._function = function

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_BitOperationFunction":
        return self._function


scout_compute_api_deprecated_BitOperationSeriesNode.__name__ = "BitOperationSeriesNode"
scout_compute_api_deprecated_BitOperationSeriesNode.__qualname__ = "BitOperationSeriesNode"
scout_compute_api_deprecated_BitOperationSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_CartesianBounds(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', float),
            'max_x': ConjureFieldDefinition('maxX', float),
            'min_y': ConjureFieldDefinition('minY', float),
            'max_y': ConjureFieldDefinition('maxY', float)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y']

    def __init__(self, max_x: float, max_y: float, min_x: float, min_y: float) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y

    @builtins.property
    def min_x(self) -> float:
        return self._min_x

    @builtins.property
    def max_x(self) -> float:
        return self._max_x

    @builtins.property
    def min_y(self) -> float:
        return self._min_y

    @builtins.property
    def max_y(self) -> float:
        return self._max_y


scout_compute_api_deprecated_CartesianBounds.__name__ = "CartesianBounds"
scout_compute_api_deprecated_CartesianBounds.__qualname__ = "CartesianBounds"
scout_compute_api_deprecated_CartesianBounds.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_CartesianNode(ConjureUnionType):
    _scatter: Optional["scout_compute_api_deprecated_ScatterNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter': ConjureFieldDefinition('scatter', scout_compute_api_deprecated_ScatterNode)
        }

    def __init__(
            self,
            scatter: Optional["scout_compute_api_deprecated_ScatterNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (scatter is not None) != 1:
                raise ValueError('a union must contain a single member')

            if scatter is not None:
                self._scatter = scatter
                self._type = 'scatter'

        elif type_of_union == 'scatter':
            if scatter is None:
                raise ValueError('a union value must not be None')
            self._scatter = scatter
            self._type = 'scatter'

    @builtins.property
    def scatter(self) -> Optional["scout_compute_api_deprecated_ScatterNode"]:
        return self._scatter

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_CartesianNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_CartesianNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'scatter' and self.scatter is not None:
            return visitor._scatter(self.scatter)


scout_compute_api_deprecated_CartesianNode.__name__ = "CartesianNode"
scout_compute_api_deprecated_CartesianNode.__qualname__ = "CartesianNode"
scout_compute_api_deprecated_CartesianNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_CartesianNodeVisitor:

    @abstractmethod
    def _scatter(self, scatter: "scout_compute_api_deprecated_ScatterNode") -> Any:
        pass


scout_compute_api_deprecated_CartesianNodeVisitor.__name__ = "CartesianNodeVisitor"
scout_compute_api_deprecated_CartesianNodeVisitor.__qualname__ = "CartesianNodeVisitor"
scout_compute_api_deprecated_CartesianNodeVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ComputableNode(ConjureUnionType):
    _ranges: Optional["scout_compute_api_deprecated_SummarizeRangesNode"] = None
    _series: Optional["scout_compute_api_deprecated_SummarizeSeriesNode"] = None
    _value: Optional["scout_compute_api_deprecated_SelectValueNode"] = None
    _cartesian: Optional["scout_compute_api_deprecated_SummarizeCartesianNode"] = None
    _frequency: Optional["scout_compute_api_deprecated_FrequencyDomainNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_deprecated_SummarizeRangesNode),
            'series': ConjureFieldDefinition('series', scout_compute_api_deprecated_SummarizeSeriesNode),
            'value': ConjureFieldDefinition('value', scout_compute_api_deprecated_SelectValueNode),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_api_deprecated_SummarizeCartesianNode),
            'frequency': ConjureFieldDefinition('frequency', scout_compute_api_deprecated_FrequencyDomainNode)
        }

    def __init__(
            self,
            ranges: Optional["scout_compute_api_deprecated_SummarizeRangesNode"] = None,
            series: Optional["scout_compute_api_deprecated_SummarizeSeriesNode"] = None,
            value: Optional["scout_compute_api_deprecated_SelectValueNode"] = None,
            cartesian: Optional["scout_compute_api_deprecated_SummarizeCartesianNode"] = None,
            frequency: Optional["scout_compute_api_deprecated_FrequencyDomainNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (ranges is not None) + (series is not None) + (value is not None) + (cartesian is not None) + (frequency is not None) != 1:
                raise ValueError('a union must contain a single member')

            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'
            if series is not None:
                self._series = series
                self._type = 'series'
            if value is not None:
                self._value = value
                self._type = 'value'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if frequency is not None:
                self._frequency = frequency
                self._type = 'frequency'

        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'frequency':
            if frequency is None:
                raise ValueError('a union value must not be None')
            self._frequency = frequency
            self._type = 'frequency'

    @builtins.property
    def ranges(self) -> Optional["scout_compute_api_deprecated_SummarizeRangesNode"]:
        return self._ranges

    @builtins.property
    def series(self) -> Optional["scout_compute_api_deprecated_SummarizeSeriesNode"]:
        return self._series

    @builtins.property
    def value(self) -> Optional["scout_compute_api_deprecated_SelectValueNode"]:
        return self._value

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_api_deprecated_SummarizeCartesianNode"]:
        return self._cartesian

    @builtins.property
    def frequency(self) -> Optional["scout_compute_api_deprecated_FrequencyDomainNode"]:
        return self._frequency

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_ComputableNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_ComputableNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'frequency' and self.frequency is not None:
            return visitor._frequency(self.frequency)


scout_compute_api_deprecated_ComputableNode.__name__ = "ComputableNode"
scout_compute_api_deprecated_ComputableNode.__qualname__ = "ComputableNode"
scout_compute_api_deprecated_ComputableNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ComputableNodeVisitor:

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_api_deprecated_SummarizeRangesNode") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_compute_api_deprecated_SummarizeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value(self, value: "scout_compute_api_deprecated_SelectValueNode") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_api_deprecated_SummarizeCartesianNode") -> Any:
        pass

    @abstractmethod
    def _frequency(self, frequency: "scout_compute_api_deprecated_FrequencyDomainNode") -> Any:
        pass


scout_compute_api_deprecated_ComputableNodeVisitor.__name__ = "ComputableNodeVisitor"
scout_compute_api_deprecated_ComputableNodeVisitor.__qualname__ = "ComputableNodeVisitor"
scout_compute_api_deprecated_ComputableNodeVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ComputeNodeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_deprecated_ComputableNode),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'context': ConjureFieldDefinition('context', scout_compute_api_deprecated_Context)
        }

    __slots__: List[str] = ['_node', '_start', '_end', '_context']

    def __init__(self, context: "scout_compute_api_deprecated_Context", end: "api_Timestamp", node: "scout_compute_api_deprecated_ComputableNode", start: "api_Timestamp") -> None:
        self._node = node
        self._start = start
        self._end = end
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_deprecated_ComputableNode":
        return self._node

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def context(self) -> "scout_compute_api_deprecated_Context":
        return self._context


scout_compute_api_deprecated_ComputeNodeRequest.__name__ = "ComputeNodeRequest"
scout_compute_api_deprecated_ComputeNodeRequest.__qualname__ = "ComputeNodeRequest"
scout_compute_api_deprecated_ComputeNodeRequest.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_Context(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_compute_api_SeriesSpec]),
            'variables_v2': ConjureFieldDefinition('variablesV2', Dict[scout_compute_api_VariableName, scout_compute_api_deprecated_VariableValue])
        }

    __slots__: List[str] = ['_variables', '_variables_v2']

    def __init__(self, variables: Dict[str, "scout_compute_api_SeriesSpec"], variables_v2: Dict[str, "scout_compute_api_deprecated_VariableValue"]) -> None:
        self._variables = variables
        self._variables_v2 = variables_v2

    @builtins.property
    def variables(self) -> Dict[str, "scout_compute_api_SeriesSpec"]:
        return self._variables

    @builtins.property
    def variables_v2(self) -> Dict[str, "scout_compute_api_deprecated_VariableValue"]:
        return self._variables_v2


scout_compute_api_deprecated_Context.__name__ = "Context"
scout_compute_api_deprecated_Context.__qualname__ = "Context"
scout_compute_api_deprecated_Context.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_CumulativeSumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', scout_compute_api_VariableName)
        }

    __slots__: List[str] = ['_input', '_start_timestamp']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", start_timestamp: str) -> None:
        self._input = input
        self._start_timestamp = start_timestamp

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_timestamp(self) -> str:
        return self._start_timestamp


scout_compute_api_deprecated_CumulativeSumSeriesNode.__name__ = "CumulativeSumSeriesNode"
scout_compute_api_deprecated_CumulativeSumSeriesNode.__qualname__ = "CumulativeSumSeriesNode"
scout_compute_api_deprecated_CumulativeSumSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_DerivativeSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[scout_compute_api_TimeUnit]),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_time_unit', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None, time_unit: Optional["scout_compute_api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["scout_compute_api_TimeUnit"]:
        return self._time_unit

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        return self._negative_values_configuration


scout_compute_api_deprecated_DerivativeSeriesNode.__name__ = "DerivativeSeriesNode"
scout_compute_api_deprecated_DerivativeSeriesNode.__qualname__ = "DerivativeSeriesNode"
scout_compute_api_deprecated_DerivativeSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumFilterRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_EnumSeriesNode),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_EnumFilterOperator),
            'values': ConjureFieldDefinition('values', List[str]),
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[int]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_run_api_Duration]),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_deprecated_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_operator', '_values', '_min_points', '_min_duration', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_deprecated_EnumSeriesNode", operator: "scout_compute_api_EnumFilterOperator", values: List[str], min_duration: Optional["scout_run_api_Duration"] = None, min_points: Optional[int] = None, persistence_window_configuration: Optional["scout_compute_api_deprecated_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._operator = operator
        self._values = values
        self._min_points = min_points
        self._min_duration = min_duration
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_EnumSeriesNode":
        return self._input

    @builtins.property
    def operator(self) -> "scout_compute_api_EnumFilterOperator":
        return self._operator

    @builtins.property
    def values(self) -> List[str]:
        return self._values

    @builtins.property
    def min_points(self) -> Optional[int]:
        """
        The minimum number of points for which this condition is satisfied. Must be non-negative. If not present,
will default to 1.
        """
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_run_api_Duration"]:
        """
        The minimum duration for which this condition is satisfied. Must be non-negative. If not present, will
default to 1 nanosecond.
        """
        return self._min_duration

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_deprecated_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_deprecated_EnumFilterRangesNode.__name__ = "EnumFilterRangesNode"
scout_compute_api_deprecated_EnumFilterRangesNode.__qualname__ = "EnumFilterRangesNode"
scout_compute_api_deprecated_EnumFilterRangesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumSeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_api_RawEnumSeriesNode"] = None
    _function: Optional["scout_compute_api_EnumSeriesFunction"] = None
    _time_range_filter: Optional["scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_api_deprecated_EnumTimeShiftSeriesNode"] = None
    _union: Optional["scout_compute_api_deprecated_EnumUnionSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_api_RawEnumSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_EnumSeriesFunction),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_api_deprecated_EnumTimeShiftSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_api_deprecated_EnumUnionSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_api_RawEnumSeriesNode"] = None,
            function: Optional["scout_compute_api_EnumSeriesFunction"] = None,
            time_range_filter: Optional["scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_api_deprecated_EnumTimeShiftSeriesNode"] = None,
            union: Optional["scout_compute_api_deprecated_EnumUnionSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (function is not None) + (time_range_filter is not None) + (time_shift is not None) + (union is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if function is not None:
                self._function = function
                self._type = 'function'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if union is not None:
                self._union = union
                self._type = 'union'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'function':
            if function is None:
                raise ValueError('a union value must not be None')
            self._function = function
            self._type = 'function'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_RawEnumSeriesNode"]:
        return self._raw

    @builtins.property
    def function(self) -> Optional["scout_compute_api_EnumSeriesFunction"]:
        return self._function

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_api_deprecated_EnumTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def union(self) -> Optional["scout_compute_api_deprecated_EnumUnionSeriesNode"]:
        return self._union

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_EnumSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_EnumSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'function' and self.function is not None:
            return visitor._function(self.function)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)


scout_compute_api_deprecated_EnumSeriesNode.__name__ = "EnumSeriesNode"
scout_compute_api_deprecated_EnumSeriesNode.__qualname__ = "EnumSeriesNode"
scout_compute_api_deprecated_EnumSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumSeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_RawEnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _function(self, function: "scout_compute_api_EnumSeriesFunction") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_api_deprecated_EnumTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_api_deprecated_EnumUnionSeriesNode") -> Any:
        pass


scout_compute_api_deprecated_EnumSeriesNodeVisitor.__name__ = "EnumSeriesNodeVisitor"
scout_compute_api_deprecated_EnumSeriesNodeVisitor.__qualname__ = "EnumSeriesNodeVisitor"
scout_compute_api_deprecated_EnumSeriesNodeVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_EnumSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[api_Timestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_api_deprecated_EnumSeriesNode", end_time: Optional["api_Timestamp"] = None, start_time: Optional["api_Timestamp"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_EnumSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["api_Timestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["api_Timestamp"]:
        return self._end_time


scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode.__name__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode.__qualname__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_EnumSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_run_api_Duration", input: "scout_compute_api_deprecated_EnumSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_EnumSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_api_deprecated_EnumTimeShiftSeriesNode.__name__ = "EnumTimeShiftSeriesNode"
scout_compute_api_deprecated_EnumTimeShiftSeriesNode.__qualname__ = "EnumTimeShiftSeriesNode"
scout_compute_api_deprecated_EnumTimeShiftSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumUnionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_deprecated_EnumSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_EnumUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_api_deprecated_EnumSeriesNode"], operation: "scout_compute_api_EnumUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_api_deprecated_EnumSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_EnumUnionOperation":
        return self._operation


scout_compute_api_deprecated_EnumUnionSeriesNode.__name__ = "EnumUnionSeriesNode"
scout_compute_api_deprecated_EnumUnionSeriesNode.__qualname__ = "EnumUnionSeriesNode"
scout_compute_api_deprecated_EnumUnionSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_FftNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input


scout_compute_api_deprecated_FftNode.__name__ = "FftNode"
scout_compute_api_deprecated_FftNode.__qualname__ = "FftNode"
scout_compute_api_deprecated_FftNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_FrequencyDomainNode(ConjureUnionType):
    _fft: Optional["scout_compute_api_deprecated_FftNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fft': ConjureFieldDefinition('fft', scout_compute_api_deprecated_FftNode)
        }

    def __init__(
            self,
            fft: Optional["scout_compute_api_deprecated_FftNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fft is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fft is not None:
                self._fft = fft
                self._type = 'fft'

        elif type_of_union == 'fft':
            if fft is None:
                raise ValueError('a union value must not be None')
            self._fft = fft
            self._type = 'fft'

    @builtins.property
    def fft(self) -> Optional["scout_compute_api_deprecated_FftNode"]:
        return self._fft

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_FrequencyDomainNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_FrequencyDomainNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'fft' and self.fft is not None:
            return visitor._fft(self.fft)


scout_compute_api_deprecated_FrequencyDomainNode.__name__ = "FrequencyDomainNode"
scout_compute_api_deprecated_FrequencyDomainNode.__qualname__ = "FrequencyDomainNode"
scout_compute_api_deprecated_FrequencyDomainNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_FrequencyDomainNodeVisitor:

    @abstractmethod
    def _fft(self, fft: "scout_compute_api_deprecated_FftNode") -> Any:
        pass


scout_compute_api_deprecated_FrequencyDomainNodeVisitor.__name__ = "FrequencyDomainNodeVisitor"
scout_compute_api_deprecated_FrequencyDomainNodeVisitor.__qualname__ = "FrequencyDomainNodeVisitor"
scout_compute_api_deprecated_FrequencyDomainNodeVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_IntersectRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_deprecated_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_api_deprecated_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_api_deprecated_RangesNode"]:
        return self._inputs


scout_compute_api_deprecated_IntersectRangesNode.__name__ = "IntersectRangesNode"
scout_compute_api_deprecated_IntersectRangesNode.__qualname__ = "IntersectRangesNode"
scout_compute_api_deprecated_IntersectRangesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericSeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_api_RawNumericSeriesNode"] = None
    _arithmetic: Optional["scout_compute_api_deprecated_ArithmeticSeriesNode"] = None
    _bit_operation: Optional["scout_compute_api_deprecated_BitOperationSeriesNode"] = None
    _cumulative_sum: Optional["scout_compute_api_deprecated_CumulativeSumSeriesNode"] = None
    _function: Optional["scout_compute_api_NumericSeriesFunction"] = None
    _derivative: Optional["scout_compute_api_deprecated_DerivativeSeriesNode"] = None
    _rolling_operation: Optional["scout_compute_api_deprecated_RollingOperationSeriesNode"] = None
    _unary_arithmetic: Optional["scout_compute_api_deprecated_UnaryArithmeticSeriesNode"] = None
    _time_difference: Optional["scout_compute_api_deprecated_TimeDifferenceSeriesNode"] = None
    _time_range_filter: Optional["scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_api_deprecated_NumericTimeShiftSeriesNode"] = None
    _union: Optional["scout_compute_api_deprecated_NumericUnionSeriesNode"] = None
    _value_difference: Optional["scout_compute_api_deprecated_ValueDifferenceSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_api_RawNumericSeriesNode),
            'arithmetic': ConjureFieldDefinition('arithmetic', scout_compute_api_deprecated_ArithmeticSeriesNode),
            'bit_operation': ConjureFieldDefinition('bitOperation', scout_compute_api_deprecated_BitOperationSeriesNode),
            'cumulative_sum': ConjureFieldDefinition('cumulativeSum', scout_compute_api_deprecated_CumulativeSumSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_NumericSeriesFunction),
            'derivative': ConjureFieldDefinition('derivative', scout_compute_api_deprecated_DerivativeSeriesNode),
            'rolling_operation': ConjureFieldDefinition('rollingOperation', scout_compute_api_deprecated_RollingOperationSeriesNode),
            'unary_arithmetic': ConjureFieldDefinition('unaryArithmetic', scout_compute_api_deprecated_UnaryArithmeticSeriesNode),
            'time_difference': ConjureFieldDefinition('timeDifference', scout_compute_api_deprecated_TimeDifferenceSeriesNode),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_api_deprecated_NumericTimeShiftSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_api_deprecated_NumericUnionSeriesNode),
            'value_difference': ConjureFieldDefinition('valueDifference', scout_compute_api_deprecated_ValueDifferenceSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_api_RawNumericSeriesNode"] = None,
            arithmetic: Optional["scout_compute_api_deprecated_ArithmeticSeriesNode"] = None,
            bit_operation: Optional["scout_compute_api_deprecated_BitOperationSeriesNode"] = None,
            cumulative_sum: Optional["scout_compute_api_deprecated_CumulativeSumSeriesNode"] = None,
            function: Optional["scout_compute_api_NumericSeriesFunction"] = None,
            derivative: Optional["scout_compute_api_deprecated_DerivativeSeriesNode"] = None,
            rolling_operation: Optional["scout_compute_api_deprecated_RollingOperationSeriesNode"] = None,
            unary_arithmetic: Optional["scout_compute_api_deprecated_UnaryArithmeticSeriesNode"] = None,
            time_difference: Optional["scout_compute_api_deprecated_TimeDifferenceSeriesNode"] = None,
            time_range_filter: Optional["scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_api_deprecated_NumericTimeShiftSeriesNode"] = None,
            union: Optional["scout_compute_api_deprecated_NumericUnionSeriesNode"] = None,
            value_difference: Optional["scout_compute_api_deprecated_ValueDifferenceSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (arithmetic is not None) + (bit_operation is not None) + (cumulative_sum is not None) + (function is not None) + (derivative is not None) + (rolling_operation is not None) + (unary_arithmetic is not None) + (time_difference is not None) + (time_range_filter is not None) + (time_shift is not None) + (union is not None) + (value_difference is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if arithmetic is not None:
                self._arithmetic = arithmetic
                self._type = 'arithmetic'
            if bit_operation is not None:
                self._bit_operation = bit_operation
                self._type = 'bitOperation'
            if cumulative_sum is not None:
                self._cumulative_sum = cumulative_sum
                self._type = 'cumulativeSum'
            if function is not None:
                self._function = function
                self._type = 'function'
            if derivative is not None:
                self._derivative = derivative
                self._type = 'derivative'
            if rolling_operation is not None:
                self._rolling_operation = rolling_operation
                self._type = 'rollingOperation'
            if unary_arithmetic is not None:
                self._unary_arithmetic = unary_arithmetic
                self._type = 'unaryArithmetic'
            if time_difference is not None:
                self._time_difference = time_difference
                self._type = 'timeDifference'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if union is not None:
                self._union = union
                self._type = 'union'
            if value_difference is not None:
                self._value_difference = value_difference
                self._type = 'valueDifference'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'arithmetic':
            if arithmetic is None:
                raise ValueError('a union value must not be None')
            self._arithmetic = arithmetic
            self._type = 'arithmetic'
        elif type_of_union == 'bitOperation':
            if bit_operation is None:
                raise ValueError('a union value must not be None')
            self._bit_operation = bit_operation
            self._type = 'bitOperation'
        elif type_of_union == 'cumulativeSum':
            if cumulative_sum is None:
                raise ValueError('a union value must not be None')
            self._cumulative_sum = cumulative_sum
            self._type = 'cumulativeSum'
        elif type_of_union == 'function':
            if function is None:
                raise ValueError('a union value must not be None')
            self._function = function
            self._type = 'function'
        elif type_of_union == 'derivative':
            if derivative is None:
                raise ValueError('a union value must not be None')
            self._derivative = derivative
            self._type = 'derivative'
        elif type_of_union == 'rollingOperation':
            if rolling_operation is None:
                raise ValueError('a union value must not be None')
            self._rolling_operation = rolling_operation
            self._type = 'rollingOperation'
        elif type_of_union == 'unaryArithmetic':
            if unary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._unary_arithmetic = unary_arithmetic
            self._type = 'unaryArithmetic'
        elif type_of_union == 'timeDifference':
            if time_difference is None:
                raise ValueError('a union value must not be None')
            self._time_difference = time_difference
            self._type = 'timeDifference'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'valueDifference':
            if value_difference is None:
                raise ValueError('a union value must not be None')
            self._value_difference = value_difference
            self._type = 'valueDifference'

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_RawNumericSeriesNode"]:
        return self._raw

    @builtins.property
    def arithmetic(self) -> Optional["scout_compute_api_deprecated_ArithmeticSeriesNode"]:
        return self._arithmetic

    @builtins.property
    def bit_operation(self) -> Optional["scout_compute_api_deprecated_BitOperationSeriesNode"]:
        return self._bit_operation

    @builtins.property
    def cumulative_sum(self) -> Optional["scout_compute_api_deprecated_CumulativeSumSeriesNode"]:
        return self._cumulative_sum

    @builtins.property
    def function(self) -> Optional["scout_compute_api_NumericSeriesFunction"]:
        return self._function

    @builtins.property
    def derivative(self) -> Optional["scout_compute_api_deprecated_DerivativeSeriesNode"]:
        return self._derivative

    @builtins.property
    def rolling_operation(self) -> Optional["scout_compute_api_deprecated_RollingOperationSeriesNode"]:
        return self._rolling_operation

    @builtins.property
    def unary_arithmetic(self) -> Optional["scout_compute_api_deprecated_UnaryArithmeticSeriesNode"]:
        return self._unary_arithmetic

    @builtins.property
    def time_difference(self) -> Optional["scout_compute_api_deprecated_TimeDifferenceSeriesNode"]:
        return self._time_difference

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_api_deprecated_NumericTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def union(self) -> Optional["scout_compute_api_deprecated_NumericUnionSeriesNode"]:
        return self._union

    @builtins.property
    def value_difference(self) -> Optional["scout_compute_api_deprecated_ValueDifferenceSeriesNode"]:
        return self._value_difference

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_NumericSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_NumericSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'arithmetic' and self.arithmetic is not None:
            return visitor._arithmetic(self.arithmetic)
        if self._type == 'bitOperation' and self.bit_operation is not None:
            return visitor._bit_operation(self.bit_operation)
        if self._type == 'cumulativeSum' and self.cumulative_sum is not None:
            return visitor._cumulative_sum(self.cumulative_sum)
        if self._type == 'function' and self.function is not None:
            return visitor._function(self.function)
        if self._type == 'derivative' and self.derivative is not None:
            return visitor._derivative(self.derivative)
        if self._type == 'rollingOperation' and self.rolling_operation is not None:
            return visitor._rolling_operation(self.rolling_operation)
        if self._type == 'unaryArithmetic' and self.unary_arithmetic is not None:
            return visitor._unary_arithmetic(self.unary_arithmetic)
        if self._type == 'timeDifference' and self.time_difference is not None:
            return visitor._time_difference(self.time_difference)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'valueDifference' and self.value_difference is not None:
            return visitor._value_difference(self.value_difference)


scout_compute_api_deprecated_NumericSeriesNode.__name__ = "NumericSeriesNode"
scout_compute_api_deprecated_NumericSeriesNode.__qualname__ = "NumericSeriesNode"
scout_compute_api_deprecated_NumericSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericSeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_RawNumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _arithmetic(self, arithmetic: "scout_compute_api_deprecated_ArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _bit_operation(self, bit_operation: "scout_compute_api_deprecated_BitOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _cumulative_sum(self, cumulative_sum: "scout_compute_api_deprecated_CumulativeSumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _function(self, function: "scout_compute_api_NumericSeriesFunction") -> Any:
        pass

    @abstractmethod
    def _derivative(self, derivative: "scout_compute_api_deprecated_DerivativeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _rolling_operation(self, rolling_operation: "scout_compute_api_deprecated_RollingOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _unary_arithmetic(self, unary_arithmetic: "scout_compute_api_deprecated_UnaryArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_difference(self, time_difference: "scout_compute_api_deprecated_TimeDifferenceSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_api_deprecated_NumericTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_api_deprecated_NumericUnionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value_difference(self, value_difference: "scout_compute_api_deprecated_ValueDifferenceSeriesNode") -> Any:
        pass


scout_compute_api_deprecated_NumericSeriesNodeVisitor.__name__ = "NumericSeriesNodeVisitor"
scout_compute_api_deprecated_NumericSeriesNodeVisitor.__qualname__ = "NumericSeriesNodeVisitor"
scout_compute_api_deprecated_NumericSeriesNodeVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[api_Timestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", end_time: Optional["api_Timestamp"] = None, start_time: Optional["api_Timestamp"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["api_Timestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["api_Timestamp"]:
        return self._end_time


scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode.__name__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode.__qualname__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_run_api_Duration", input: "scout_compute_api_deprecated_NumericSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_api_deprecated_NumericTimeShiftSeriesNode.__name__ = "NumericTimeShiftSeriesNode"
scout_compute_api_deprecated_NumericTimeShiftSeriesNode.__qualname__ = "NumericTimeShiftSeriesNode"
scout_compute_api_deprecated_NumericTimeShiftSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericUnionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_deprecated_NumericSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_NumericUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_api_deprecated_NumericSeriesNode"], operation: "scout_compute_api_NumericUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_api_deprecated_NumericSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_NumericUnionOperation":
        return self._operation


scout_compute_api_deprecated_NumericUnionSeriesNode.__name__ = "NumericUnionSeriesNode"
scout_compute_api_deprecated_NumericUnionSeriesNode.__qualname__ = "NumericUnionSeriesNode"
scout_compute_api_deprecated_NumericUnionSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_OnChangeRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_SeriesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_api_deprecated_SeriesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_SeriesNode":
        return self._input


scout_compute_api_deprecated_OnChangeRangesNode.__name__ = "OnChangeRangesNode"
scout_compute_api_deprecated_OnChangeRangesNode.__qualname__ = "OnChangeRangesNode"
scout_compute_api_deprecated_OnChangeRangesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_PersistenceWindowConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[int]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_run_api_Duration]),
            'output_range_start': ConjureFieldDefinition('outputRangeStart', scout_compute_api_OutputRangeStart)
        }

    __slots__: List[str] = ['_min_points', '_min_duration', '_output_range_start']

    def __init__(self, output_range_start: "scout_compute_api_OutputRangeStart", min_duration: Optional["scout_run_api_Duration"] = None, min_points: Optional[int] = None) -> None:
        self._min_points = min_points
        self._min_duration = min_duration
        self._output_range_start = output_range_start

    @builtins.property
    def min_points(self) -> Optional[int]:
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_run_api_Duration"]:
        return self._min_duration

    @builtins.property
    def output_range_start(self) -> "scout_compute_api_OutputRangeStart":
        return self._output_range_start


scout_compute_api_deprecated_PersistenceWindowConfiguration.__name__ = "PersistenceWindowConfiguration"
scout_compute_api_deprecated_PersistenceWindowConfiguration.__qualname__ = "PersistenceWindowConfiguration"
scout_compute_api_deprecated_PersistenceWindowConfiguration.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_RangesNode(ConjureUnionType):
    _function: Optional["scout_compute_api_RangesFunction"] = None
    _on_change: Optional["scout_compute_api_deprecated_OnChangeRangesNode"] = None
    _enum_filter: Optional["scout_compute_api_deprecated_EnumFilterRangesNode"] = None
    _threshold: Optional["scout_compute_api_deprecated_ThresholdingRangesNode"] = None
    _union_range: Optional["scout_compute_api_deprecated_UnionRangesNode"] = None
    _intersect_range: Optional["scout_compute_api_deprecated_IntersectRangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'function': ConjureFieldDefinition('function', scout_compute_api_RangesFunction),
            'on_change': ConjureFieldDefinition('onChange', scout_compute_api_deprecated_OnChangeRangesNode),
            'enum_filter': ConjureFieldDefinition('enumFilter', scout_compute_api_deprecated_EnumFilterRangesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_deprecated_ThresholdingRangesNode),
            'union_range': ConjureFieldDefinition('unionRange', scout_compute_api_deprecated_UnionRangesNode),
            'intersect_range': ConjureFieldDefinition('intersectRange', scout_compute_api_deprecated_IntersectRangesNode)
        }

    def __init__(
            self,
            function: Optional["scout_compute_api_RangesFunction"] = None,
            on_change: Optional["scout_compute_api_deprecated_OnChangeRangesNode"] = None,
            enum_filter: Optional["scout_compute_api_deprecated_EnumFilterRangesNode"] = None,
            threshold: Optional["scout_compute_api_deprecated_ThresholdingRangesNode"] = None,
            union_range: Optional["scout_compute_api_deprecated_UnionRangesNode"] = None,
            intersect_range: Optional["scout_compute_api_deprecated_IntersectRangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (function is not None) + (on_change is not None) + (enum_filter is not None) + (threshold is not None) + (union_range is not None) + (intersect_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if function is not None:
                self._function = function
                self._type = 'function'
            if on_change is not None:
                self._on_change = on_change
                self._type = 'onChange'
            if enum_filter is not None:
                self._enum_filter = enum_filter
                self._type = 'enumFilter'
            if threshold is not None:
                self._threshold = threshold
                self._type = 'threshold'
            if union_range is not None:
                self._union_range = union_range
                self._type = 'unionRange'
            if intersect_range is not None:
                self._intersect_range = intersect_range
                self._type = 'intersectRange'

        elif type_of_union == 'function':
            if function is None:
                raise ValueError('a union value must not be None')
            self._function = function
            self._type = 'function'
        elif type_of_union == 'onChange':
            if on_change is None:
                raise ValueError('a union value must not be None')
            self._on_change = on_change
            self._type = 'onChange'
        elif type_of_union == 'enumFilter':
            if enum_filter is None:
                raise ValueError('a union value must not be None')
            self._enum_filter = enum_filter
            self._type = 'enumFilter'
        elif type_of_union == 'threshold':
            if threshold is None:
                raise ValueError('a union value must not be None')
            self._threshold = threshold
            self._type = 'threshold'
        elif type_of_union == 'unionRange':
            if union_range is None:
                raise ValueError('a union value must not be None')
            self._union_range = union_range
            self._type = 'unionRange'
        elif type_of_union == 'intersectRange':
            if intersect_range is None:
                raise ValueError('a union value must not be None')
            self._intersect_range = intersect_range
            self._type = 'intersectRange'

    @builtins.property
    def function(self) -> Optional["scout_compute_api_RangesFunction"]:
        return self._function

    @builtins.property
    def on_change(self) -> Optional["scout_compute_api_deprecated_OnChangeRangesNode"]:
        return self._on_change

    @builtins.property
    def enum_filter(self) -> Optional["scout_compute_api_deprecated_EnumFilterRangesNode"]:
        return self._enum_filter

    @builtins.property
    def threshold(self) -> Optional["scout_compute_api_deprecated_ThresholdingRangesNode"]:
        return self._threshold

    @builtins.property
    def union_range(self) -> Optional["scout_compute_api_deprecated_UnionRangesNode"]:
        return self._union_range

    @builtins.property
    def intersect_range(self) -> Optional["scout_compute_api_deprecated_IntersectRangesNode"]:
        return self._intersect_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_RangesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_RangesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'function' and self.function is not None:
            return visitor._function(self.function)
        if self._type == 'onChange' and self.on_change is not None:
            return visitor._on_change(self.on_change)
        if self._type == 'enumFilter' and self.enum_filter is not None:
            return visitor._enum_filter(self.enum_filter)
        if self._type == 'threshold' and self.threshold is not None:
            return visitor._threshold(self.threshold)
        if self._type == 'unionRange' and self.union_range is not None:
            return visitor._union_range(self.union_range)
        if self._type == 'intersectRange' and self.intersect_range is not None:
            return visitor._intersect_range(self.intersect_range)


scout_compute_api_deprecated_RangesNode.__name__ = "RangesNode"
scout_compute_api_deprecated_RangesNode.__qualname__ = "RangesNode"
scout_compute_api_deprecated_RangesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_RangesNodeVisitor:

    @abstractmethod
    def _function(self, function: "scout_compute_api_RangesFunction") -> Any:
        pass

    @abstractmethod
    def _on_change(self, on_change: "scout_compute_api_deprecated_OnChangeRangesNode") -> Any:
        pass

    @abstractmethod
    def _enum_filter(self, enum_filter: "scout_compute_api_deprecated_EnumFilterRangesNode") -> Any:
        pass

    @abstractmethod
    def _threshold(self, threshold: "scout_compute_api_deprecated_ThresholdingRangesNode") -> Any:
        pass

    @abstractmethod
    def _union_range(self, union_range: "scout_compute_api_deprecated_UnionRangesNode") -> Any:
        pass

    @abstractmethod
    def _intersect_range(self, intersect_range: "scout_compute_api_deprecated_IntersectRangesNode") -> Any:
        pass


scout_compute_api_deprecated_RangesNodeVisitor.__name__ = "RangesNodeVisitor"
scout_compute_api_deprecated_RangesNodeVisitor.__qualname__ = "RangesNodeVisitor"
scout_compute_api_deprecated_RangesNodeVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_RollingOperationSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'window': ConjureFieldDefinition('window', scout_compute_api_deprecated_Window),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_RollingOperator)
        }

    __slots__: List[str] = ['_input', '_window', '_operator']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", operator: "scout_compute_api_RollingOperator", window: "scout_compute_api_deprecated_Window") -> None:
        self._input = input
        self._window = window
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def window(self) -> "scout_compute_api_deprecated_Window":
        return self._window

    @builtins.property
    def operator(self) -> "scout_compute_api_RollingOperator":
        return self._operator


scout_compute_api_deprecated_RollingOperationSeriesNode.__name__ = "RollingOperationSeriesNode"
scout_compute_api_deprecated_RollingOperationSeriesNode.__qualname__ = "RollingOperationSeriesNode"
scout_compute_api_deprecated_RollingOperationSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ScatterNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_api_deprecated_NumericSeriesNode),
            'y': ConjureFieldDefinition('y', scout_compute_api_deprecated_NumericSeriesNode)
        }

    __slots__: List[str] = ['_x', '_y']

    def __init__(self, x: "scout_compute_api_deprecated_NumericSeriesNode", y: "scout_compute_api_deprecated_NumericSeriesNode") -> None:
        self._x = x
        self._y = y

    @builtins.property
    def x(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._y


scout_compute_api_deprecated_ScatterNode.__name__ = "ScatterNode"
scout_compute_api_deprecated_ScatterNode.__qualname__ = "ScatterNode"
scout_compute_api_deprecated_ScatterNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SelectValueNode(ConjureUnionType):
    _first_point: Optional["scout_compute_api_deprecated_SeriesNode"] = None
    _first_range: Optional["scout_compute_api_deprecated_RangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_api_deprecated_SeriesNode),
            'first_range': ConjureFieldDefinition('firstRange', scout_compute_api_deprecated_RangesNode)
        }

    def __init__(
            self,
            first_point: Optional["scout_compute_api_deprecated_SeriesNode"] = None,
            first_range: Optional["scout_compute_api_deprecated_RangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (first_point is not None) + (first_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if first_point is not None:
                self._first_point = first_point
                self._type = 'firstPoint'
            if first_range is not None:
                self._first_range = first_range
                self._type = 'firstRange'

        elif type_of_union == 'firstPoint':
            if first_point is None:
                raise ValueError('a union value must not be None')
            self._first_point = first_point
            self._type = 'firstPoint'
        elif type_of_union == 'firstRange':
            if first_range is None:
                raise ValueError('a union value must not be None')
            self._first_range = first_range
            self._type = 'firstRange'

    @builtins.property
    def first_point(self) -> Optional["scout_compute_api_deprecated_SeriesNode"]:
        return self._first_point

    @builtins.property
    def first_range(self) -> Optional["scout_compute_api_deprecated_RangesNode"]:
        return self._first_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_SelectValueNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_SelectValueNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'firstPoint' and self.first_point is not None:
            return visitor._first_point(self.first_point)
        if self._type == 'firstRange' and self.first_range is not None:
            return visitor._first_range(self.first_range)


scout_compute_api_deprecated_SelectValueNode.__name__ = "SelectValueNode"
scout_compute_api_deprecated_SelectValueNode.__qualname__ = "SelectValueNode"
scout_compute_api_deprecated_SelectValueNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SelectValueNodeVisitor:

    @abstractmethod
    def _first_point(self, first_point: "scout_compute_api_deprecated_SeriesNode") -> Any:
        pass

    @abstractmethod
    def _first_range(self, first_range: "scout_compute_api_deprecated_RangesNode") -> Any:
        pass


scout_compute_api_deprecated_SelectValueNodeVisitor.__name__ = "SelectValueNodeVisitor"
scout_compute_api_deprecated_SelectValueNodeVisitor.__qualname__ = "SelectValueNodeVisitor"
scout_compute_api_deprecated_SelectValueNodeVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_api_RawUntypedSeriesNode"] = None
    _enum: Optional["scout_compute_api_deprecated_EnumSeriesNode"] = None
    _numeric: Optional["scout_compute_api_deprecated_NumericSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_api_RawUntypedSeriesNode),
            'enum': ConjureFieldDefinition('enum', scout_compute_api_deprecated_EnumSeriesNode),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_deprecated_NumericSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_api_RawUntypedSeriesNode"] = None,
            enum: Optional["scout_compute_api_deprecated_EnumSeriesNode"] = None,
            numeric: Optional["scout_compute_api_deprecated_NumericSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (enum is not None) + (numeric is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_RawUntypedSeriesNode"]:
        return self._raw

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_deprecated_EnumSeriesNode"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_deprecated_NumericSeriesNode"]:
        return self._numeric

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_SeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_SeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)


scout_compute_api_deprecated_SeriesNode.__name__ = "SeriesNode"
scout_compute_api_deprecated_SeriesNode.__qualname__ = "SeriesNode"
scout_compute_api_deprecated_SeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_RawUntypedSeriesNode") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_deprecated_EnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_deprecated_NumericSeriesNode") -> Any:
        pass


scout_compute_api_deprecated_SeriesNodeVisitor.__name__ = "SeriesNodeVisitor"
scout_compute_api_deprecated_SeriesNodeVisitor.__qualname__ = "SeriesNodeVisitor"
scout_compute_api_deprecated_SeriesNodeVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SummarizeCartesianNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_CartesianNode),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_api_deprecated_CartesianBounds]),
            'max_points': ConjureFieldDefinition('maxPoints', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_bounds', '_max_points']

    def __init__(self, input: "scout_compute_api_deprecated_CartesianNode", bounds: Optional["scout_compute_api_deprecated_CartesianBounds"] = None, max_points: Optional[int] = None) -> None:
        self._input = input
        self._bounds = bounds
        self._max_points = max_points

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_CartesianNode":
        return self._input

    @builtins.property
    def bounds(self) -> Optional["scout_compute_api_deprecated_CartesianBounds"]:
        return self._bounds

    @builtins.property
    def max_points(self) -> Optional[int]:
        return self._max_points


scout_compute_api_deprecated_SummarizeCartesianNode.__name__ = "SummarizeCartesianNode"
scout_compute_api_deprecated_SummarizeCartesianNode.__qualname__ = "SummarizeCartesianNode"
scout_compute_api_deprecated_SummarizeCartesianNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SummarizeRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_RangesNode),
            'max_ranges': ConjureFieldDefinition('maxRanges', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_max_ranges']

    def __init__(self, input: "scout_compute_api_deprecated_RangesNode", max_ranges: Optional[int] = None) -> None:
        self._input = input
        self._max_ranges = max_ranges

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_RangesNode":
        return self._input

    @builtins.property
    def max_ranges(self) -> Optional[int]:
        return self._max_ranges


scout_compute_api_deprecated_SummarizeRangesNode.__name__ = "SummarizeRangesNode"
scout_compute_api_deprecated_SummarizeRangesNode.__qualname__ = "SummarizeRangesNode"
scout_compute_api_deprecated_SummarizeRangesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SummarizeSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_SeriesNode),
            'resolution': ConjureFieldDefinition('resolution', int)
        }

    __slots__: List[str] = ['_input', '_resolution']

    def __init__(self, input: "scout_compute_api_deprecated_SeriesNode", resolution: int) -> None:
        self._input = input
        self._resolution = resolution

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_SeriesNode":
        return self._input

    @builtins.property
    def resolution(self) -> int:
        return self._resolution


scout_compute_api_deprecated_SummarizeSeriesNode.__name__ = "SummarizeSeriesNode"
scout_compute_api_deprecated_SummarizeSeriesNode.__qualname__ = "SummarizeSeriesNode"
scout_compute_api_deprecated_SummarizeSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ThresholdingRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'threshold': ConjureFieldDefinition('threshold', float),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[int]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_run_api_Duration]),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_deprecated_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_threshold', '_operator', '_min_points', '_min_duration', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", operator: "scout_compute_api_ThresholdOperator", threshold: float, min_duration: Optional["scout_run_api_Duration"] = None, min_points: Optional[int] = None, persistence_window_configuration: Optional["scout_compute_api_deprecated_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._operator = operator
        self._min_points = min_points
        self._min_duration = min_duration
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> float:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def min_points(self) -> Optional[int]:
        """
        The minimum number of points for which this condition is satisfied. Must be non-negative. If not present,
will default to 1.
        """
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_run_api_Duration"]:
        """
        The minimum duration for which this condition is satisfied. Must be non-negative. If not present, will
default to 1 nanosecond.
        """
        return self._min_duration

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_deprecated_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_deprecated_ThresholdingRangesNode.__name__ = "ThresholdingRangesNode"
scout_compute_api_deprecated_ThresholdingRangesNode.__qualname__ = "ThresholdingRangesNode"
scout_compute_api_deprecated_ThresholdingRangesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_TimeDifferenceSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_SeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[scout_compute_api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_time_unit']

    def __init__(self, input: "scout_compute_api_deprecated_SeriesNode", time_unit: Optional["scout_compute_api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_SeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["scout_compute_api_TimeUnit"]:
        return self._time_unit


scout_compute_api_deprecated_TimeDifferenceSeriesNode.__name__ = "TimeDifferenceSeriesNode"
scout_compute_api_deprecated_TimeDifferenceSeriesNode.__qualname__ = "TimeDifferenceSeriesNode"
scout_compute_api_deprecated_TimeDifferenceSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_UnaryArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_UnaryArithmeticOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", operation: "scout_compute_api_UnaryArithmeticOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_UnaryArithmeticOperation":
        return self._operation


scout_compute_api_deprecated_UnaryArithmeticSeriesNode.__name__ = "UnaryArithmeticSeriesNode"
scout_compute_api_deprecated_UnaryArithmeticSeriesNode.__qualname__ = "UnaryArithmeticSeriesNode"
scout_compute_api_deprecated_UnaryArithmeticSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_UnionRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_deprecated_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_api_deprecated_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_api_deprecated_RangesNode"]:
        return self._inputs


scout_compute_api_deprecated_UnionRangesNode.__name__ = "UnionRangesNode"
scout_compute_api_deprecated_UnionRangesNode.__qualname__ = "UnionRangesNode"
scout_compute_api_deprecated_UnionRangesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ValueDifferenceSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None) -> None:
        self._input = input
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        return self._negative_values_configuration


scout_compute_api_deprecated_ValueDifferenceSeriesNode.__name__ = "ValueDifferenceSeriesNode"
scout_compute_api_deprecated_ValueDifferenceSeriesNode.__qualname__ = "ValueDifferenceSeriesNode"
scout_compute_api_deprecated_ValueDifferenceSeriesNode.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_VariableValue(ConjureUnionType):
    _series: Optional["scout_compute_api_SeriesSpec"] = None
    _timestamp: Optional["api_Timestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_api_SeriesSpec),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp)
        }

    def __init__(
            self,
            series: Optional["scout_compute_api_SeriesSpec"] = None,
            timestamp: Optional["api_Timestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (series is not None) + (timestamp is not None) != 1:
                raise ValueError('a union must contain a single member')

            if series is not None:
                self._series = series
                self._type = 'series'
            if timestamp is not None:
                self._timestamp = timestamp
                self._type = 'timestamp'

        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'timestamp':
            if timestamp is None:
                raise ValueError('a union value must not be None')
            self._timestamp = timestamp
            self._type = 'timestamp'

    @builtins.property
    def series(self) -> Optional["scout_compute_api_SeriesSpec"]:
        return self._series

    @builtins.property
    def timestamp(self) -> Optional["api_Timestamp"]:
        return self._timestamp

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_VariableValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_VariableValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'timestamp' and self.timestamp is not None:
            return visitor._timestamp(self.timestamp)


scout_compute_api_deprecated_VariableValue.__name__ = "VariableValue"
scout_compute_api_deprecated_VariableValue.__qualname__ = "VariableValue"
scout_compute_api_deprecated_VariableValue.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_VariableValueVisitor:

    @abstractmethod
    def _series(self, series: "scout_compute_api_SeriesSpec") -> Any:
        pass

    @abstractmethod
    def _timestamp(self, timestamp: "api_Timestamp") -> Any:
        pass


scout_compute_api_deprecated_VariableValueVisitor.__name__ = "VariableValueVisitor"
scout_compute_api_deprecated_VariableValueVisitor.__qualname__ = "VariableValueVisitor"
scout_compute_api_deprecated_VariableValueVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_Window(ConjureUnionType):
    _duration: Optional["scout_run_api_Duration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    def __init__(
            self,
            duration: Optional["scout_run_api_Duration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (duration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if duration is not None:
                self._duration = duration
                self._type = 'duration'

        elif type_of_union == 'duration':
            if duration is None:
                raise ValueError('a union value must not be None')
            self._duration = duration
            self._type = 'duration'

    @builtins.property
    def duration(self) -> Optional["scout_run_api_Duration"]:
        return self._duration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_WindowVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_WindowVisitor'.format(visitor.__class__.__name__))
        if self._type == 'duration' and self.duration is not None:
            return visitor._duration(self.duration)


scout_compute_api_deprecated_Window.__name__ = "Window"
scout_compute_api_deprecated_Window.__qualname__ = "Window"
scout_compute_api_deprecated_Window.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_WindowVisitor:

    @abstractmethod
    def _duration(self, duration: "scout_run_api_Duration") -> Any:
        pass


scout_compute_api_deprecated_WindowVisitor.__name__ = "WindowVisitor"
scout_compute_api_deprecated_WindowVisitor.__qualname__ = "WindowVisitor"
scout_compute_api_deprecated_WindowVisitor.__module__ = "scout_service_api.scout_compute_api_deprecated"


class scout_compute_representation_api_BatchExpressionToComputeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'expressions': ConjureFieldDefinition('expressions', List[scout_compute_representation_api_ComputeExpression]),
            'default_ref_name': ConjureFieldDefinition('defaultRefName', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_expressions', '_default_ref_name']

    def __init__(self, expressions: List[str], default_ref_name: Optional[str] = None) -> None:
        self._expressions = expressions
        self._default_ref_name = default_ref_name

    @builtins.property
    def expressions(self) -> List[str]:
        return self._expressions

    @builtins.property
    def default_ref_name(self) -> Optional[str]:
        return self._default_ref_name


scout_compute_representation_api_BatchExpressionToComputeRequest.__name__ = "BatchExpressionToComputeRequest"
scout_compute_representation_api_BatchExpressionToComputeRequest.__qualname__ = "BatchExpressionToComputeRequest"
scout_compute_representation_api_BatchExpressionToComputeRequest.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_ChannelLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_ref': ConjureFieldDefinition('dataSourceRef', scout_api_DataSourceRefName),
            'channel': ConjureFieldDefinition('channel', scout_api_Channel)
        }

    __slots__: List[str] = ['_data_source_ref', '_channel']

    def __init__(self, channel: str, data_source_ref: str) -> None:
        self._data_source_ref = data_source_ref
        self._channel = channel

    @builtins.property
    def data_source_ref(self) -> str:
        return self._data_source_ref

    @builtins.property
    def channel(self) -> str:
        return self._channel


scout_compute_representation_api_ChannelLocator.__name__ = "ChannelLocator"
scout_compute_representation_api_ChannelLocator.__qualname__ = "ChannelLocator"
scout_compute_representation_api_ChannelLocator.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_CompiledEnumeratedSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_EnumSeriesNode),
            'context': ConjureFieldDefinition('context', scout_compute_representation_api_ComputeRepresentationContext)
        }

    __slots__: List[str] = ['_node', '_context']

    def __init__(self, context: "scout_compute_representation_api_ComputeRepresentationContext", node: "scout_compute_api_EnumSeriesNode") -> None:
        self._node = node
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_EnumSeriesNode":
        return self._node

    @builtins.property
    def context(self) -> "scout_compute_representation_api_ComputeRepresentationContext":
        return self._context


scout_compute_representation_api_CompiledEnumeratedSeries.__name__ = "CompiledEnumeratedSeries"
scout_compute_representation_api_CompiledEnumeratedSeries.__qualname__ = "CompiledEnumeratedSeries"
scout_compute_representation_api_CompiledEnumeratedSeries.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_CompiledNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_representation_api_Node),
            'context': ConjureFieldDefinition('context', scout_compute_representation_api_ComputeRepresentationContext)
        }

    __slots__: List[str] = ['_node', '_context']

    def __init__(self, context: "scout_compute_representation_api_ComputeRepresentationContext", node: "scout_compute_representation_api_Node") -> None:
        self._node = node
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_representation_api_Node":
        return self._node

    @builtins.property
    def context(self) -> "scout_compute_representation_api_ComputeRepresentationContext":
        return self._context


scout_compute_representation_api_CompiledNode.__name__ = "CompiledNode"
scout_compute_representation_api_CompiledNode.__qualname__ = "CompiledNode"
scout_compute_representation_api_CompiledNode.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_CompiledNumericSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_NumericSeriesNode),
            'context': ConjureFieldDefinition('context', scout_compute_representation_api_ComputeRepresentationContext)
        }

    __slots__: List[str] = ['_node', '_context']

    def __init__(self, context: "scout_compute_representation_api_ComputeRepresentationContext", node: "scout_compute_api_NumericSeriesNode") -> None:
        self._node = node
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_NumericSeriesNode":
        return self._node

    @builtins.property
    def context(self) -> "scout_compute_representation_api_ComputeRepresentationContext":
        return self._context


scout_compute_representation_api_CompiledNumericSeries.__name__ = "CompiledNumericSeries"
scout_compute_representation_api_CompiledNumericSeries.__qualname__ = "CompiledNumericSeries"
scout_compute_representation_api_CompiledNumericSeries.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_CompiledRangeSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_RangesNode),
            'context': ConjureFieldDefinition('context', scout_compute_representation_api_ComputeRepresentationContext)
        }

    __slots__: List[str] = ['_node', '_context']

    def __init__(self, context: "scout_compute_representation_api_ComputeRepresentationContext", node: "scout_compute_api_RangesNode") -> None:
        self._node = node
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_RangesNode":
        return self._node

    @builtins.property
    def context(self) -> "scout_compute_representation_api_ComputeRepresentationContext":
        return self._context


scout_compute_representation_api_CompiledRangeSeries.__name__ = "CompiledRangeSeries"
scout_compute_representation_api_CompiledRangeSeries.__qualname__ = "CompiledRangeSeries"
scout_compute_representation_api_CompiledRangeSeries.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_ComputeRepresentationContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_compute_representation_api_ComputeRepresentationVariableValue]),
            'function_variables': ConjureFieldDefinition('functionVariables', Dict[scout_compute_api_FunctionReference, scout_compute_representation_api_ComputeRepresentationContext])
        }

    __slots__: List[str] = ['_variables', '_function_variables']

    def __init__(self, function_variables: Dict[str, "scout_compute_representation_api_ComputeRepresentationContext"], variables: Dict[str, "scout_compute_representation_api_ComputeRepresentationVariableValue"]) -> None:
        self._variables = variables
        self._function_variables = function_variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_compute_representation_api_ComputeRepresentationVariableValue"]:
        return self._variables

    @builtins.property
    def function_variables(self) -> Dict[str, "scout_compute_representation_api_ComputeRepresentationContext"]:
        return self._function_variables


scout_compute_representation_api_ComputeRepresentationContext.__name__ = "ComputeRepresentationContext"
scout_compute_representation_api_ComputeRepresentationContext.__qualname__ = "ComputeRepresentationContext"
scout_compute_representation_api_ComputeRepresentationContext.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_ComputeRepresentationService(Service):
    """
    The Compute Representation Service provides the ability to translate between a human-readable expression language
and a compute graph. Bidirectional translation is supported.
    """

    def compute_to_expression(self, auth_header: str, request: "scout_compute_representation_api_CompiledNode") -> str:
        """
        Converts a compute graph and its context into a its expression language representation.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/compute/representation/v1/compute-to-expression'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_representation_api_ComputeExpression, self._return_none_for_unknown_union_types)

    def batch_compute_to_expression(self, auth_header: str, request: Dict[str, "scout_compute_representation_api_CompiledNode"]) -> Dict[str, str]:
        """
        Converts a batch of compute graphs and their contexts into their expression language representation. Requires
a string key reference to be provided for each graph.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/compute/representation/v1/batch-compute-to-expression'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[str, scout_compute_representation_api_ComputeExpression], self._return_none_for_unknown_union_types)

    def expression_to_compute(self, auth_header: str, request: "scout_compute_representation_api_ExpressionToComputeRequest") -> "scout_compute_representation_api_ExpressionToComputeResult":
        """
        Converts an expression language representation into a compute graph. The outputted graph can be passed to
the compute service or checks service for execution.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/compute/representation/v1/expression-to-compute'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_representation_api_ExpressionToComputeResult, self._return_none_for_unknown_union_types)

    def batch_expression_to_compute(self, auth_header: str, request: "scout_compute_representation_api_BatchExpressionToComputeRequest") -> Dict[str, "scout_compute_representation_api_ExpressionToComputeResult"]:
        """
        Converts a batch of expressions into their compute graph representation.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/compute/representation/v1/batch-expression-to-compute'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_compute_representation_api_ComputeExpression, scout_compute_representation_api_ExpressionToComputeResult], self._return_none_for_unknown_union_types)


scout_compute_representation_api_ComputeRepresentationService.__name__ = "ComputeRepresentationService"
scout_compute_representation_api_ComputeRepresentationService.__qualname__ = "ComputeRepresentationService"
scout_compute_representation_api_ComputeRepresentationService.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_ComputeRepresentationVariableValue(ConjureUnionType):
    _double: Optional[float] = None
    _duration: Optional["scout_run_api_Duration"] = None
    _integer: Optional[int] = None
    _string_set: Optional[List[str]] = None
    _timestamp: Optional["api_Timestamp"] = None
    _function_rid: Optional[str] = None
    _series: Optional["scout_compute_representation_api_ChannelLocator"] = None
    _external_variable_reference: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'double': ConjureFieldDefinition('double', float),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration),
            'integer': ConjureFieldDefinition('integer', int),
            'string_set': ConjureFieldDefinition('stringSet', List[str]),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'function_rid': ConjureFieldDefinition('functionRid', scout_rids_api_FunctionRid),
            'series': ConjureFieldDefinition('series', scout_compute_representation_api_ChannelLocator),
            'external_variable_reference': ConjureFieldDefinition('externalVariableReference', str)
        }

    def __init__(
            self,
            double: Optional[float] = None,
            duration: Optional["scout_run_api_Duration"] = None,
            integer: Optional[int] = None,
            string_set: Optional[List[str]] = None,
            timestamp: Optional["api_Timestamp"] = None,
            function_rid: Optional[str] = None,
            series: Optional["scout_compute_representation_api_ChannelLocator"] = None,
            external_variable_reference: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (double is not None) + (duration is not None) + (integer is not None) + (string_set is not None) + (timestamp is not None) + (function_rid is not None) + (series is not None) + (external_variable_reference is not None) != 1:
                raise ValueError('a union must contain a single member')

            if double is not None:
                self._double = double
                self._type = 'double'
            if duration is not None:
                self._duration = duration
                self._type = 'duration'
            if integer is not None:
                self._integer = integer
                self._type = 'integer'
            if string_set is not None:
                self._string_set = string_set
                self._type = 'stringSet'
            if timestamp is not None:
                self._timestamp = timestamp
                self._type = 'timestamp'
            if function_rid is not None:
                self._function_rid = function_rid
                self._type = 'functionRid'
            if series is not None:
                self._series = series
                self._type = 'series'
            if external_variable_reference is not None:
                self._external_variable_reference = external_variable_reference
                self._type = 'externalVariableReference'

        elif type_of_union == 'double':
            if double is None:
                raise ValueError('a union value must not be None')
            self._double = double
            self._type = 'double'
        elif type_of_union == 'duration':
            if duration is None:
                raise ValueError('a union value must not be None')
            self._duration = duration
            self._type = 'duration'
        elif type_of_union == 'integer':
            if integer is None:
                raise ValueError('a union value must not be None')
            self._integer = integer
            self._type = 'integer'
        elif type_of_union == 'stringSet':
            if string_set is None:
                raise ValueError('a union value must not be None')
            self._string_set = string_set
            self._type = 'stringSet'
        elif type_of_union == 'timestamp':
            if timestamp is None:
                raise ValueError('a union value must not be None')
            self._timestamp = timestamp
            self._type = 'timestamp'
        elif type_of_union == 'functionRid':
            if function_rid is None:
                raise ValueError('a union value must not be None')
            self._function_rid = function_rid
            self._type = 'functionRid'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'externalVariableReference':
            if external_variable_reference is None:
                raise ValueError('a union value must not be None')
            self._external_variable_reference = external_variable_reference
            self._type = 'externalVariableReference'

    @builtins.property
    def double(self) -> Optional[float]:
        return self._double

    @builtins.property
    def duration(self) -> Optional["scout_run_api_Duration"]:
        return self._duration

    @builtins.property
    def integer(self) -> Optional[int]:
        return self._integer

    @builtins.property
    def string_set(self) -> Optional[List[str]]:
        return self._string_set

    @builtins.property
    def timestamp(self) -> Optional["api_Timestamp"]:
        return self._timestamp

    @builtins.property
    def function_rid(self) -> Optional[str]:
        return self._function_rid

    @builtins.property
    def series(self) -> Optional["scout_compute_representation_api_ChannelLocator"]:
        return self._series

    @builtins.property
    def external_variable_reference(self) -> Optional[str]:
        return self._external_variable_reference

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_representation_api_ComputeRepresentationVariableValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_representation_api_ComputeRepresentationVariableValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'double' and self.double is not None:
            return visitor._double(self.double)
        if self._type == 'duration' and self.duration is not None:
            return visitor._duration(self.duration)
        if self._type == 'integer' and self.integer is not None:
            return visitor._integer(self.integer)
        if self._type == 'stringSet' and self.string_set is not None:
            return visitor._string_set(self.string_set)
        if self._type == 'timestamp' and self.timestamp is not None:
            return visitor._timestamp(self.timestamp)
        if self._type == 'functionRid' and self.function_rid is not None:
            return visitor._function_rid(self.function_rid)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'externalVariableReference' and self.external_variable_reference is not None:
            return visitor._external_variable_reference(self.external_variable_reference)


scout_compute_representation_api_ComputeRepresentationVariableValue.__name__ = "ComputeRepresentationVariableValue"
scout_compute_representation_api_ComputeRepresentationVariableValue.__qualname__ = "ComputeRepresentationVariableValue"
scout_compute_representation_api_ComputeRepresentationVariableValue.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_ComputeRepresentationVariableValueVisitor:

    @abstractmethod
    def _double(self, double: float) -> Any:
        pass

    @abstractmethod
    def _duration(self, duration: "scout_run_api_Duration") -> Any:
        pass

    @abstractmethod
    def _integer(self, integer: int) -> Any:
        pass

    @abstractmethod
    def _string_set(self, string_set: List[str]) -> Any:
        pass

    @abstractmethod
    def _timestamp(self, timestamp: "api_Timestamp") -> Any:
        pass

    @abstractmethod
    def _function_rid(self, function_rid: str) -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_compute_representation_api_ChannelLocator") -> Any:
        pass

    @abstractmethod
    def _external_variable_reference(self, external_variable_reference: str) -> Any:
        pass


scout_compute_representation_api_ComputeRepresentationVariableValueVisitor.__name__ = "ComputeRepresentationVariableValueVisitor"
scout_compute_representation_api_ComputeRepresentationVariableValueVisitor.__qualname__ = "ComputeRepresentationVariableValueVisitor"
scout_compute_representation_api_ComputeRepresentationVariableValueVisitor.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_ErrorExpressionToComputeResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_message': ConjureFieldDefinition('errorMessage', str)
        }

    __slots__: List[str] = ['_error_message']

    def __init__(self, error_message: str) -> None:
        self._error_message = error_message

    @builtins.property
    def error_message(self) -> str:
        return self._error_message


scout_compute_representation_api_ErrorExpressionToComputeResult.__name__ = "ErrorExpressionToComputeResult"
scout_compute_representation_api_ErrorExpressionToComputeResult.__qualname__ = "ErrorExpressionToComputeResult"
scout_compute_representation_api_ErrorExpressionToComputeResult.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_ExpressionToComputeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'expression': ConjureFieldDefinition('expression', scout_compute_representation_api_ComputeExpression),
            'default_ref_name': ConjureFieldDefinition('defaultRefName', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_expression', '_default_ref_name']

    def __init__(self, expression: str, default_ref_name: Optional[str] = None) -> None:
        self._expression = expression
        self._default_ref_name = default_ref_name

    @builtins.property
    def expression(self) -> str:
        return self._expression

    @builtins.property
    def default_ref_name(self) -> Optional[str]:
        return self._default_ref_name


scout_compute_representation_api_ExpressionToComputeRequest.__name__ = "ExpressionToComputeRequest"
scout_compute_representation_api_ExpressionToComputeRequest.__qualname__ = "ExpressionToComputeRequest"
scout_compute_representation_api_ExpressionToComputeRequest.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_ExpressionToComputeResult(ConjureUnionType):
    _success: Optional["scout_compute_representation_api_SuccessExpressionToComputeResult"] = None
    _error: Optional["scout_compute_representation_api_ErrorExpressionToComputeResult"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_compute_representation_api_SuccessExpressionToComputeResult),
            'error': ConjureFieldDefinition('error', scout_compute_representation_api_ErrorExpressionToComputeResult)
        }

    def __init__(
            self,
            success: Optional["scout_compute_representation_api_SuccessExpressionToComputeResult"] = None,
            error: Optional["scout_compute_representation_api_ErrorExpressionToComputeResult"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'

    @builtins.property
    def success(self) -> Optional["scout_compute_representation_api_SuccessExpressionToComputeResult"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["scout_compute_representation_api_ErrorExpressionToComputeResult"]:
        return self._error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_representation_api_ExpressionToComputeResultVisitor):
            raise ValueError('{} is not an instance of scout_compute_representation_api_ExpressionToComputeResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)


scout_compute_representation_api_ExpressionToComputeResult.__name__ = "ExpressionToComputeResult"
scout_compute_representation_api_ExpressionToComputeResult.__qualname__ = "ExpressionToComputeResult"
scout_compute_representation_api_ExpressionToComputeResult.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_ExpressionToComputeResultVisitor:

    @abstractmethod
    def _success(self, success: "scout_compute_representation_api_SuccessExpressionToComputeResult") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "scout_compute_representation_api_ErrorExpressionToComputeResult") -> Any:
        pass


scout_compute_representation_api_ExpressionToComputeResultVisitor.__name__ = "ExpressionToComputeResultVisitor"
scout_compute_representation_api_ExpressionToComputeResultVisitor.__qualname__ = "ExpressionToComputeResultVisitor"
scout_compute_representation_api_ExpressionToComputeResultVisitor.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_Node(ConjureUnionType):
    _enumerated_series: Optional["scout_compute_api_EnumSeriesNode"] = None
    _numeric_series: Optional["scout_compute_api_NumericSeriesNode"] = None
    _range_series: Optional["scout_compute_api_RangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'enumerated_series': ConjureFieldDefinition('enumeratedSeries', scout_compute_api_EnumSeriesNode),
            'numeric_series': ConjureFieldDefinition('numericSeries', scout_compute_api_NumericSeriesNode),
            'range_series': ConjureFieldDefinition('rangeSeries', scout_compute_api_RangesNode)
        }

    def __init__(
            self,
            enumerated_series: Optional["scout_compute_api_EnumSeriesNode"] = None,
            numeric_series: Optional["scout_compute_api_NumericSeriesNode"] = None,
            range_series: Optional["scout_compute_api_RangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (enumerated_series is not None) + (numeric_series is not None) + (range_series is not None) != 1:
                raise ValueError('a union must contain a single member')

            if enumerated_series is not None:
                self._enumerated_series = enumerated_series
                self._type = 'enumeratedSeries'
            if numeric_series is not None:
                self._numeric_series = numeric_series
                self._type = 'numericSeries'
            if range_series is not None:
                self._range_series = range_series
                self._type = 'rangeSeries'

        elif type_of_union == 'enumeratedSeries':
            if enumerated_series is None:
                raise ValueError('a union value must not be None')
            self._enumerated_series = enumerated_series
            self._type = 'enumeratedSeries'
        elif type_of_union == 'numericSeries':
            if numeric_series is None:
                raise ValueError('a union value must not be None')
            self._numeric_series = numeric_series
            self._type = 'numericSeries'
        elif type_of_union == 'rangeSeries':
            if range_series is None:
                raise ValueError('a union value must not be None')
            self._range_series = range_series
            self._type = 'rangeSeries'

    @builtins.property
    def enumerated_series(self) -> Optional["scout_compute_api_EnumSeriesNode"]:
        return self._enumerated_series

    @builtins.property
    def numeric_series(self) -> Optional["scout_compute_api_NumericSeriesNode"]:
        return self._numeric_series

    @builtins.property
    def range_series(self) -> Optional["scout_compute_api_RangesNode"]:
        return self._range_series

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_representation_api_NodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_representation_api_NodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'enumeratedSeries' and self.enumerated_series is not None:
            return visitor._enumerated_series(self.enumerated_series)
        if self._type == 'numericSeries' and self.numeric_series is not None:
            return visitor._numeric_series(self.numeric_series)
        if self._type == 'rangeSeries' and self.range_series is not None:
            return visitor._range_series(self.range_series)


scout_compute_representation_api_Node.__name__ = "Node"
scout_compute_representation_api_Node.__qualname__ = "Node"
scout_compute_representation_api_Node.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_NodeVisitor:

    @abstractmethod
    def _enumerated_series(self, enumerated_series: "scout_compute_api_EnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _numeric_series(self, numeric_series: "scout_compute_api_NumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _range_series(self, range_series: "scout_compute_api_RangesNode") -> Any:
        pass


scout_compute_representation_api_NodeVisitor.__name__ = "NodeVisitor"
scout_compute_representation_api_NodeVisitor.__qualname__ = "NodeVisitor"
scout_compute_representation_api_NodeVisitor.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_representation_api_SuccessExpressionToComputeResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_representation_api_CompiledNode)
        }

    __slots__: List[str] = ['_node']

    def __init__(self, node: "scout_compute_representation_api_CompiledNode") -> None:
        self._node = node

    @builtins.property
    def node(self) -> "scout_compute_representation_api_CompiledNode":
        return self._node


scout_compute_representation_api_SuccessExpressionToComputeResult.__name__ = "SuccessExpressionToComputeResult"
scout_compute_representation_api_SuccessExpressionToComputeResult.__qualname__ = "SuccessExpressionToComputeResult"
scout_compute_representation_api_SuccessExpressionToComputeResult.__module__ = "scout_service_api.scout_compute_representation_api"


class scout_compute_resolved_api_AggregateEnumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'aggregation_function': ConjureFieldDefinition('aggregationFunction', scout_compute_api_EnumAggregationFunction)
        }

    __slots__: List[str] = ['_input', '_aggregation_function']

    def __init__(self, aggregation_function: "scout_compute_api_EnumAggregationFunction", input: "scout_compute_resolved_api_EnumSeriesNode") -> None:
        self._input = input
        self._aggregation_function = aggregation_function

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def aggregation_function(self) -> "scout_compute_api_EnumAggregationFunction":
        return self._aggregation_function


scout_compute_resolved_api_AggregateEnumSeriesNode.__name__ = "AggregateEnumSeriesNode"
scout_compute_resolved_api_AggregateEnumSeriesNode.__qualname__ = "AggregateEnumSeriesNode"
scout_compute_resolved_api_AggregateEnumSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_AggregateNumericSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'aggregation_function': ConjureFieldDefinition('aggregationFunction', scout_compute_api_NumericAggregationFunction)
        }

    __slots__: List[str] = ['_input', '_aggregation_function']

    def __init__(self, aggregation_function: "scout_compute_api_NumericAggregationFunction", input: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input = input
        self._aggregation_function = aggregation_function

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def aggregation_function(self) -> "scout_compute_api_NumericAggregationFunction":
        return self._aggregation_function


scout_compute_resolved_api_AggregateNumericSeriesNode.__name__ = "AggregateNumericSeriesNode"
scout_compute_resolved_api_AggregateNumericSeriesNode.__qualname__ = "AggregateNumericSeriesNode"
scout_compute_resolved_api_AggregateNumericSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_LocalVariableName, scout_compute_resolved_api_NumericSeriesNode]),
            'expression': ConjureFieldDefinition('expression', str),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_expression', '_interpolation_configuration']

    def __init__(self, expression: str, inputs: Dict[str, "scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._expression = expression
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def expression(self) -> str:
        return self._expression

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_ArithmeticSeriesNode.__name__ = "ArithmeticSeriesNode"
scout_compute_resolved_api_ArithmeticSeriesNode.__qualname__ = "ArithmeticSeriesNode"
scout_compute_resolved_api_ArithmeticSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_BinaryArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input1': ConjureFieldDefinition('input1', scout_compute_resolved_api_NumericSeriesNode),
            'input2': ConjureFieldDefinition('input2', scout_compute_resolved_api_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_BinaryArithmeticOperation),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_input1', '_input2', '_operation', '_interpolation_configuration']

    def __init__(self, input1: "scout_compute_resolved_api_NumericSeriesNode", input2: "scout_compute_resolved_api_NumericSeriesNode", interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration", operation: "scout_compute_api_BinaryArithmeticOperation") -> None:
        self._input1 = input1
        self._input2 = input2
        self._operation = operation
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def input1(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input1

    @builtins.property
    def input2(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input2

    @builtins.property
    def operation(self) -> "scout_compute_api_BinaryArithmeticOperation":
        return self._operation

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_BinaryArithmeticSeriesNode.__name__ = "BinaryArithmeticSeriesNode"
scout_compute_resolved_api_BinaryArithmeticSeriesNode.__qualname__ = "BinaryArithmeticSeriesNode"
scout_compute_resolved_api_BinaryArithmeticSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_BitOperationSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_BitOperationFunction)
        }

    __slots__: List[str] = ['_input', '_function']

    def __init__(self, function: "scout_compute_api_BitOperationFunction", input: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input = input
        self._function = function

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_BitOperationFunction":
        return self._function


scout_compute_resolved_api_BitOperationSeriesNode.__name__ = "BitOperationSeriesNode"
scout_compute_resolved_api_BitOperationSeriesNode.__qualname__ = "BitOperationSeriesNode"
scout_compute_resolved_api_BitOperationSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CartesianBounds(ConjureBeanType):
    """
    Min/max bounds of an XY Cartesian plot, inclusive.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', float),
            'max_x': ConjureFieldDefinition('maxX', float),
            'min_y': ConjureFieldDefinition('minY', float),
            'max_y': ConjureFieldDefinition('maxY', float)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y']

    def __init__(self, max_x: float, max_y: float, min_x: float, min_y: float) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y

    @builtins.property
    def min_x(self) -> float:
        return self._min_x

    @builtins.property
    def max_x(self) -> float:
        return self._max_x

    @builtins.property
    def min_y(self) -> float:
        return self._min_y

    @builtins.property
    def max_y(self) -> float:
        return self._max_y


scout_compute_resolved_api_CartesianBounds.__name__ = "CartesianBounds"
scout_compute_resolved_api_CartesianBounds.__qualname__ = "CartesianBounds"
scout_compute_resolved_api_CartesianBounds.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CartesianNode(ConjureUnionType):
    _scatter: Optional["scout_compute_resolved_api_ScatterNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter': ConjureFieldDefinition('scatter', scout_compute_resolved_api_ScatterNode)
        }

    def __init__(
            self,
            scatter: Optional["scout_compute_resolved_api_ScatterNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (scatter is not None) != 1:
                raise ValueError('a union must contain a single member')

            if scatter is not None:
                self._scatter = scatter
                self._type = 'scatter'

        elif type_of_union == 'scatter':
            if scatter is None:
                raise ValueError('a union value must not be None')
            self._scatter = scatter
            self._type = 'scatter'

    @builtins.property
    def scatter(self) -> Optional["scout_compute_resolved_api_ScatterNode"]:
        return self._scatter

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_CartesianNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_CartesianNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'scatter' and self.scatter is not None:
            return visitor._scatter(self.scatter)


scout_compute_resolved_api_CartesianNode.__name__ = "CartesianNode"
scout_compute_resolved_api_CartesianNode.__qualname__ = "CartesianNode"
scout_compute_resolved_api_CartesianNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CartesianNodeVisitor:

    @abstractmethod
    def _scatter(self, scatter: "scout_compute_resolved_api_ScatterNode") -> Any:
        pass


scout_compute_resolved_api_CartesianNodeVisitor.__name__ = "CartesianNodeVisitor"
scout_compute_resolved_api_CartesianNodeVisitor.__qualname__ = "CartesianNodeVisitor"
scout_compute_resolved_api_CartesianNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CumulativeSumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp)
        }

    __slots__: List[str] = ['_input', '_start_timestamp']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", start_timestamp: "api_Timestamp") -> None:
        self._input = input
        self._start_timestamp = start_timestamp

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp


scout_compute_resolved_api_CumulativeSumSeriesNode.__name__ = "CumulativeSumSeriesNode"
scout_compute_resolved_api_CumulativeSumSeriesNode.__qualname__ = "CumulativeSumSeriesNode"
scout_compute_resolved_api_CumulativeSumSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_DerivativeSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[scout_compute_api_TimeUnit]),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_time_unit', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None, time_unit: Optional["scout_compute_api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["scout_compute_api_TimeUnit"]:
        return self._time_unit

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        return self._negative_values_configuration


scout_compute_resolved_api_DerivativeSeriesNode.__name__ = "DerivativeSeriesNode"
scout_compute_resolved_api_DerivativeSeriesNode.__qualname__ = "DerivativeSeriesNode"
scout_compute_resolved_api_DerivativeSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumEqualityRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_EnumSeriesNode]),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_EqualityOperator),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_resolved_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_operator', '_interpolation_configuration', '_persistence_window_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_EnumSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration", operator: "scout_compute_api_EqualityOperator", persistence_window_configuration: Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"] = None) -> None:
        self._inputs = inputs
        self._operator = operator
        self._interpolation_configuration = interpolation_configuration
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_EnumSeriesNode"]:
        return self._inputs

    @builtins.property
    def operator(self) -> "scout_compute_api_EqualityOperator":
        return self._operator

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_resolved_api_EnumEqualityRangesNode.__name__ = "EnumEqualityRangesNode"
scout_compute_resolved_api_EnumEqualityRangesNode.__qualname__ = "EnumEqualityRangesNode"
scout_compute_resolved_api_EnumEqualityRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumFilterRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_EnumFilterOperator),
            'values': ConjureFieldDefinition('values', List[str]),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_resolved_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_operator', '_values', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_resolved_api_EnumSeriesNode", operator: "scout_compute_api_EnumFilterOperator", values: List[str], persistence_window_configuration: Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._operator = operator
        self._values = values
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def operator(self) -> "scout_compute_api_EnumFilterOperator":
        return self._operator

    @builtins.property
    def values(self) -> List[str]:
        return self._values

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_resolved_api_EnumFilterRangesNode.__name__ = "EnumFilterRangesNode"
scout_compute_resolved_api_EnumFilterRangesNode.__qualname__ = "EnumFilterRangesNode"
scout_compute_resolved_api_EnumFilterRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumFilterTransformationSeriesNode(ConjureBeanType):
    """
    Outputs the values of the enum plot value within the ranges specified by a ranges node
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'filter': ConjureFieldDefinition('filter', scout_compute_resolved_api_RangesNode)
        }

    __slots__: List[str] = ['_input', '_filter']

    def __init__(self, filter: "scout_compute_resolved_api_RangesNode", input: "scout_compute_resolved_api_EnumSeriesNode") -> None:
        self._input = input
        self._filter = filter

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def filter(self) -> "scout_compute_resolved_api_RangesNode":
        return self._filter


scout_compute_resolved_api_EnumFilterTransformationSeriesNode.__name__ = "EnumFilterTransformationSeriesNode"
scout_compute_resolved_api_EnumFilterTransformationSeriesNode.__qualname__ = "EnumFilterTransformationSeriesNode"
scout_compute_resolved_api_EnumFilterTransformationSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumHistogramNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_VariableName, scout_compute_resolved_api_EnumSeriesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: Dict[str, "scout_compute_resolved_api_EnumSeriesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_resolved_api_EnumSeriesNode"]:
        return self._inputs


scout_compute_resolved_api_EnumHistogramNode.__name__ = "EnumHistogramNode"
scout_compute_resolved_api_EnumHistogramNode.__qualname__ = "EnumHistogramNode"
scout_compute_resolved_api_EnumHistogramNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumResampleSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'resample_configuration': ConjureFieldDefinition('resampleConfiguration', scout_compute_resolved_api_ResampleConfiguration)
        }

    __slots__: List[str] = ['_input', '_resample_configuration']

    def __init__(self, input: "scout_compute_resolved_api_EnumSeriesNode", resample_configuration: "scout_compute_resolved_api_ResampleConfiguration") -> None:
        self._input = input
        self._resample_configuration = resample_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def resample_configuration(self) -> "scout_compute_resolved_api_ResampleConfiguration":
        return self._resample_configuration


scout_compute_resolved_api_EnumResampleSeriesNode.__name__ = "EnumResampleSeriesNode"
scout_compute_resolved_api_EnumResampleSeriesNode.__qualname__ = "EnumResampleSeriesNode"
scout_compute_resolved_api_EnumResampleSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumSeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_resolved_api_RawEnumSeriesNode"] = None
    _resample: Optional["scout_compute_resolved_api_EnumResampleSeriesNode"] = None
    _time_range_filter: Optional["scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_resolved_api_EnumTimeShiftSeriesNode"] = None
    _union: Optional["scout_compute_resolved_api_EnumUnionSeriesNode"] = None
    _aggregate: Optional["scout_compute_resolved_api_AggregateEnumSeriesNode"] = None
    _filter_transformation: Optional["scout_compute_resolved_api_EnumFilterTransformationSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_RawEnumSeriesNode),
            'resample': ConjureFieldDefinition('resample', scout_compute_resolved_api_EnumResampleSeriesNode),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_resolved_api_EnumTimeShiftSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_resolved_api_EnumUnionSeriesNode),
            'aggregate': ConjureFieldDefinition('aggregate', scout_compute_resolved_api_AggregateEnumSeriesNode),
            'filter_transformation': ConjureFieldDefinition('filterTransformation', scout_compute_resolved_api_EnumFilterTransformationSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_resolved_api_RawEnumSeriesNode"] = None,
            resample: Optional["scout_compute_resolved_api_EnumResampleSeriesNode"] = None,
            time_range_filter: Optional["scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_resolved_api_EnumTimeShiftSeriesNode"] = None,
            union: Optional["scout_compute_resolved_api_EnumUnionSeriesNode"] = None,
            aggregate: Optional["scout_compute_resolved_api_AggregateEnumSeriesNode"] = None,
            filter_transformation: Optional["scout_compute_resolved_api_EnumFilterTransformationSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (resample is not None) + (time_range_filter is not None) + (time_shift is not None) + (union is not None) + (aggregate is not None) + (filter_transformation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if resample is not None:
                self._resample = resample
                self._type = 'resample'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if union is not None:
                self._union = union
                self._type = 'union'
            if aggregate is not None:
                self._aggregate = aggregate
                self._type = 'aggregate'
            if filter_transformation is not None:
                self._filter_transformation = filter_transformation
                self._type = 'filterTransformation'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'resample':
            if resample is None:
                raise ValueError('a union value must not be None')
            self._resample = resample
            self._type = 'resample'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'aggregate':
            if aggregate is None:
                raise ValueError('a union value must not be None')
            self._aggregate = aggregate
            self._type = 'aggregate'
        elif type_of_union == 'filterTransformation':
            if filter_transformation is None:
                raise ValueError('a union value must not be None')
            self._filter_transformation = filter_transformation
            self._type = 'filterTransformation'

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_RawEnumSeriesNode"]:
        return self._raw

    @builtins.property
    def resample(self) -> Optional["scout_compute_resolved_api_EnumResampleSeriesNode"]:
        return self._resample

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_resolved_api_EnumTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def union(self) -> Optional["scout_compute_resolved_api_EnumUnionSeriesNode"]:
        return self._union

    @builtins.property
    def aggregate(self) -> Optional["scout_compute_resolved_api_AggregateEnumSeriesNode"]:
        return self._aggregate

    @builtins.property
    def filter_transformation(self) -> Optional["scout_compute_resolved_api_EnumFilterTransformationSeriesNode"]:
        return self._filter_transformation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_EnumSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_EnumSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'resample' and self.resample is not None:
            return visitor._resample(self.resample)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'aggregate' and self.aggregate is not None:
            return visitor._aggregate(self.aggregate)
        if self._type == 'filterTransformation' and self.filter_transformation is not None:
            return visitor._filter_transformation(self.filter_transformation)


scout_compute_resolved_api_EnumSeriesNode.__name__ = "EnumSeriesNode"
scout_compute_resolved_api_EnumSeriesNode.__qualname__ = "EnumSeriesNode"
scout_compute_resolved_api_EnumSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumSeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_RawEnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _resample(self, resample: "scout_compute_resolved_api_EnumResampleSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_resolved_api_EnumTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_resolved_api_EnumUnionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _aggregate(self, aggregate: "scout_compute_resolved_api_AggregateEnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _filter_transformation(self, filter_transformation: "scout_compute_resolved_api_EnumFilterTransformationSeriesNode") -> Any:
        pass


scout_compute_resolved_api_EnumSeriesNodeVisitor.__name__ = "EnumSeriesNodeVisitor"
scout_compute_resolved_api_EnumSeriesNodeVisitor.__qualname__ = "EnumSeriesNodeVisitor"
scout_compute_resolved_api_EnumSeriesNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[api_Timestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_resolved_api_EnumSeriesNode", end_time: Optional["api_Timestamp"] = None, start_time: Optional["api_Timestamp"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["api_Timestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["api_Timestamp"]:
        return self._end_time


scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode.__name__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode.__qualname__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_run_api_Duration", input: "scout_compute_resolved_api_EnumSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_resolved_api_EnumTimeShiftSeriesNode.__name__ = "EnumTimeShiftSeriesNode"
scout_compute_resolved_api_EnumTimeShiftSeriesNode.__qualname__ = "EnumTimeShiftSeriesNode"
scout_compute_resolved_api_EnumTimeShiftSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumUnionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_resolved_api_EnumSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_EnumUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_resolved_api_EnumSeriesNode"], operation: "scout_compute_api_EnumUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_resolved_api_EnumSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_EnumUnionOperation":
        return self._operation


scout_compute_resolved_api_EnumUnionSeriesNode.__name__ = "EnumUnionSeriesNode"
scout_compute_resolved_api_EnumUnionSeriesNode.__qualname__ = "EnumUnionSeriesNode"
scout_compute_resolved_api_EnumUnionSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ExtremaRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'returns_peaks': ConjureFieldDefinition('returnsPeaks', bool),
            'minimum_prominence': ConjureFieldDefinition('minimumProminence', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_input', '_returns_peaks', '_minimum_prominence']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", returns_peaks: bool, minimum_prominence: Optional[float] = None) -> None:
        self._input = input
        self._returns_peaks = returns_peaks
        self._minimum_prominence = minimum_prominence

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def returns_peaks(self) -> bool:
        return self._returns_peaks

    @builtins.property
    def minimum_prominence(self) -> Optional[float]:
        return self._minimum_prominence


scout_compute_resolved_api_ExtremaRangesNode.__name__ = "ExtremaRangesNode"
scout_compute_resolved_api_ExtremaRangesNode.__qualname__ = "ExtremaRangesNode"
scout_compute_resolved_api_ExtremaRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_FftNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input


scout_compute_resolved_api_FftNode.__name__ = "FftNode"
scout_compute_resolved_api_FftNode.__qualname__ = "FftNode"
scout_compute_resolved_api_FftNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ForwardFillInterpolation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'interpolation_radius': ConjureFieldDefinition('interpolationRadius', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_interpolation_radius']

    def __init__(self, interpolation_radius: "scout_run_api_Duration") -> None:
        self._interpolation_radius = interpolation_radius

    @builtins.property
    def interpolation_radius(self) -> "scout_run_api_Duration":
        return self._interpolation_radius


scout_compute_resolved_api_ForwardFillInterpolation.__name__ = "ForwardFillInterpolation"
scout_compute_resolved_api_ForwardFillInterpolation.__qualname__ = "ForwardFillInterpolation"
scout_compute_resolved_api_ForwardFillInterpolation.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration.__name__ = "ForwardFillResampleInterpolationConfiguration"
scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration.__qualname__ = "ForwardFillResampleInterpolationConfiguration"
scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_FrequencyDomainNode(ConjureUnionType):
    _fft: Optional["scout_compute_resolved_api_FftNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fft': ConjureFieldDefinition('fft', scout_compute_resolved_api_FftNode)
        }

    def __init__(
            self,
            fft: Optional["scout_compute_resolved_api_FftNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fft is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fft is not None:
                self._fft = fft
                self._type = 'fft'

        elif type_of_union == 'fft':
            if fft is None:
                raise ValueError('a union value must not be None')
            self._fft = fft
            self._type = 'fft'

    @builtins.property
    def fft(self) -> Optional["scout_compute_resolved_api_FftNode"]:
        return self._fft

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_FrequencyDomainNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_FrequencyDomainNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'fft' and self.fft is not None:
            return visitor._fft(self.fft)


scout_compute_resolved_api_FrequencyDomainNode.__name__ = "FrequencyDomainNode"
scout_compute_resolved_api_FrequencyDomainNode.__qualname__ = "FrequencyDomainNode"
scout_compute_resolved_api_FrequencyDomainNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_FrequencyDomainNodeVisitor:

    @abstractmethod
    def _fft(self, fft: "scout_compute_resolved_api_FftNode") -> Any:
        pass


scout_compute_resolved_api_FrequencyDomainNodeVisitor.__name__ = "FrequencyDomainNodeVisitor"
scout_compute_resolved_api_FrequencyDomainNodeVisitor.__qualname__ = "FrequencyDomainNodeVisitor"
scout_compute_resolved_api_FrequencyDomainNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_GeoNode(ConjureUnionType):
    _lat_long_geo_node: Optional["scout_compute_resolved_api_LatLongGeoNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'lat_long_geo_node': ConjureFieldDefinition('latLongGeoNode', scout_compute_resolved_api_LatLongGeoNode)
        }

    def __init__(
            self,
            lat_long_geo_node: Optional["scout_compute_resolved_api_LatLongGeoNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (lat_long_geo_node is not None) != 1:
                raise ValueError('a union must contain a single member')

            if lat_long_geo_node is not None:
                self._lat_long_geo_node = lat_long_geo_node
                self._type = 'latLongGeoNode'

        elif type_of_union == 'latLongGeoNode':
            if lat_long_geo_node is None:
                raise ValueError('a union value must not be None')
            self._lat_long_geo_node = lat_long_geo_node
            self._type = 'latLongGeoNode'

    @builtins.property
    def lat_long_geo_node(self) -> Optional["scout_compute_resolved_api_LatLongGeoNode"]:
        return self._lat_long_geo_node

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_GeoNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_GeoNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'latLongGeoNode' and self.lat_long_geo_node is not None:
            return visitor._lat_long_geo_node(self.lat_long_geo_node)


scout_compute_resolved_api_GeoNode.__name__ = "GeoNode"
scout_compute_resolved_api_GeoNode.__qualname__ = "GeoNode"
scout_compute_resolved_api_GeoNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_GeoNodeVisitor:

    @abstractmethod
    def _lat_long_geo_node(self, lat_long_geo_node: "scout_compute_resolved_api_LatLongGeoNode") -> Any:
        pass


scout_compute_resolved_api_GeoNodeVisitor.__name__ = "GeoNodeVisitor"
scout_compute_resolved_api_GeoNodeVisitor.__qualname__ = "GeoNodeVisitor"
scout_compute_resolved_api_GeoNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_GeoNodeSummaryStrategy(ConjureUnionType):
    _temporal: Optional["scout_compute_resolved_api_GeoNodeTemporalSummary"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'temporal': ConjureFieldDefinition('temporal', scout_compute_resolved_api_GeoNodeTemporalSummary)
        }

    def __init__(
            self,
            temporal: Optional["scout_compute_resolved_api_GeoNodeTemporalSummary"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (temporal is not None) != 1:
                raise ValueError('a union must contain a single member')

            if temporal is not None:
                self._temporal = temporal
                self._type = 'temporal'

        elif type_of_union == 'temporal':
            if temporal is None:
                raise ValueError('a union value must not be None')
            self._temporal = temporal
            self._type = 'temporal'

    @builtins.property
    def temporal(self) -> Optional["scout_compute_resolved_api_GeoNodeTemporalSummary"]:
        return self._temporal

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_GeoNodeSummaryStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_GeoNodeSummaryStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'temporal' and self.temporal is not None:
            return visitor._temporal(self.temporal)


scout_compute_resolved_api_GeoNodeSummaryStrategy.__name__ = "GeoNodeSummaryStrategy"
scout_compute_resolved_api_GeoNodeSummaryStrategy.__qualname__ = "GeoNodeSummaryStrategy"
scout_compute_resolved_api_GeoNodeSummaryStrategy.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_GeoNodeSummaryStrategyVisitor:

    @abstractmethod
    def _temporal(self, temporal: "scout_compute_resolved_api_GeoNodeTemporalSummary") -> Any:
        pass


scout_compute_resolved_api_GeoNodeSummaryStrategyVisitor.__name__ = "GeoNodeSummaryStrategyVisitor"
scout_compute_resolved_api_GeoNodeSummaryStrategyVisitor.__qualname__ = "GeoNodeSummaryStrategyVisitor"
scout_compute_resolved_api_GeoNodeSummaryStrategyVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_GeoNodeTemporalSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resolution': ConjureFieldDefinition('resolution', int)
        }

    __slots__: List[str] = ['_resolution']

    def __init__(self, resolution: int) -> None:
        self._resolution = resolution

    @builtins.property
    def resolution(self) -> int:
        return self._resolution


scout_compute_resolved_api_GeoNodeTemporalSummary.__name__ = "GeoNodeTemporalSummary"
scout_compute_resolved_api_GeoNodeTemporalSummary.__qualname__ = "GeoNodeTemporalSummary"
scout_compute_resolved_api_GeoNodeTemporalSummary.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_HistogramNode(ConjureUnionType):
    _numeric_histogram: Optional["scout_compute_resolved_api_NumericHistogramNode"] = None
    _enum_histogram: Optional["scout_compute_resolved_api_EnumHistogramNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric_histogram': ConjureFieldDefinition('numericHistogram', scout_compute_resolved_api_NumericHistogramNode),
            'enum_histogram': ConjureFieldDefinition('enumHistogram', scout_compute_resolved_api_EnumHistogramNode)
        }

    def __init__(
            self,
            numeric_histogram: Optional["scout_compute_resolved_api_NumericHistogramNode"] = None,
            enum_histogram: Optional["scout_compute_resolved_api_EnumHistogramNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric_histogram is not None) + (enum_histogram is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric_histogram is not None:
                self._numeric_histogram = numeric_histogram
                self._type = 'numericHistogram'
            if enum_histogram is not None:
                self._enum_histogram = enum_histogram
                self._type = 'enumHistogram'

        elif type_of_union == 'numericHistogram':
            if numeric_histogram is None:
                raise ValueError('a union value must not be None')
            self._numeric_histogram = numeric_histogram
            self._type = 'numericHistogram'
        elif type_of_union == 'enumHistogram':
            if enum_histogram is None:
                raise ValueError('a union value must not be None')
            self._enum_histogram = enum_histogram
            self._type = 'enumHistogram'

    @builtins.property
    def numeric_histogram(self) -> Optional["scout_compute_resolved_api_NumericHistogramNode"]:
        return self._numeric_histogram

    @builtins.property
    def enum_histogram(self) -> Optional["scout_compute_resolved_api_EnumHistogramNode"]:
        return self._enum_histogram

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_HistogramNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_HistogramNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numericHistogram' and self.numeric_histogram is not None:
            return visitor._numeric_histogram(self.numeric_histogram)
        if self._type == 'enumHistogram' and self.enum_histogram is not None:
            return visitor._enum_histogram(self.enum_histogram)


scout_compute_resolved_api_HistogramNode.__name__ = "HistogramNode"
scout_compute_resolved_api_HistogramNode.__qualname__ = "HistogramNode"
scout_compute_resolved_api_HistogramNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_HistogramNodeVisitor:

    @abstractmethod
    def _numeric_histogram(self, numeric_histogram: "scout_compute_resolved_api_NumericHistogramNode") -> Any:
        pass

    @abstractmethod
    def _enum_histogram(self, enum_histogram: "scout_compute_resolved_api_EnumHistogramNode") -> Any:
        pass


scout_compute_resolved_api_HistogramNodeVisitor.__name__ = "HistogramNodeVisitor"
scout_compute_resolved_api_HistogramNodeVisitor.__qualname__ = "HistogramNodeVisitor"
scout_compute_resolved_api_HistogramNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_IntegralSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[scout_compute_api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_start_timestamp', '_time_unit']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", start_timestamp: "api_Timestamp", time_unit: Optional["scout_compute_api_TimeUnit"] = None) -> None:
        self._input = input
        self._start_timestamp = start_timestamp
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def time_unit(self) -> Optional["scout_compute_api_TimeUnit"]:
        return self._time_unit


scout_compute_resolved_api_IntegralSeriesNode.__name__ = "IntegralSeriesNode"
scout_compute_resolved_api_IntegralSeriesNode.__qualname__ = "IntegralSeriesNode"
scout_compute_resolved_api_IntegralSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_InterpolationConfiguration(ConjureUnionType):
    _forward_fill_interpolation: Optional["scout_compute_resolved_api_ForwardFillInterpolation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'forward_fill_interpolation': ConjureFieldDefinition('forwardFillInterpolation', scout_compute_resolved_api_ForwardFillInterpolation)
        }

    def __init__(
            self,
            forward_fill_interpolation: Optional["scout_compute_resolved_api_ForwardFillInterpolation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (forward_fill_interpolation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if forward_fill_interpolation is not None:
                self._forward_fill_interpolation = forward_fill_interpolation
                self._type = 'forwardFillInterpolation'

        elif type_of_union == 'forwardFillInterpolation':
            if forward_fill_interpolation is None:
                raise ValueError('a union value must not be None')
            self._forward_fill_interpolation = forward_fill_interpolation
            self._type = 'forwardFillInterpolation'

    @builtins.property
    def forward_fill_interpolation(self) -> Optional["scout_compute_resolved_api_ForwardFillInterpolation"]:
        return self._forward_fill_interpolation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_InterpolationConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_InterpolationConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'forwardFillInterpolation' and self.forward_fill_interpolation is not None:
            return visitor._forward_fill_interpolation(self.forward_fill_interpolation)


scout_compute_resolved_api_InterpolationConfiguration.__name__ = "InterpolationConfiguration"
scout_compute_resolved_api_InterpolationConfiguration.__qualname__ = "InterpolationConfiguration"
scout_compute_resolved_api_InterpolationConfiguration.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_InterpolationConfigurationVisitor:

    @abstractmethod
    def _forward_fill_interpolation(self, forward_fill_interpolation: "scout_compute_resolved_api_ForwardFillInterpolation") -> Any:
        pass


scout_compute_resolved_api_InterpolationConfigurationVisitor.__name__ = "InterpolationConfigurationVisitor"
scout_compute_resolved_api_InterpolationConfigurationVisitor.__qualname__ = "InterpolationConfigurationVisitor"
scout_compute_resolved_api_InterpolationConfigurationVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_IntersectRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_resolved_api_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_RangesNode"]:
        return self._inputs


scout_compute_resolved_api_IntersectRangesNode.__name__ = "IntersectRangesNode"
scout_compute_resolved_api_IntersectRangesNode.__qualname__ = "IntersectRangesNode"
scout_compute_resolved_api_IntersectRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LatLongBounds(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'south_west': ConjureFieldDefinition('southWest', scout_compute_api_LatLongPoint),
            'north_east': ConjureFieldDefinition('northEast', scout_compute_api_LatLongPoint)
        }

    __slots__: List[str] = ['_south_west', '_north_east']

    def __init__(self, north_east: "scout_compute_api_LatLongPoint", south_west: "scout_compute_api_LatLongPoint") -> None:
        self._south_west = south_west
        self._north_east = north_east

    @builtins.property
    def south_west(self) -> "scout_compute_api_LatLongPoint":
        return self._south_west

    @builtins.property
    def north_east(self) -> "scout_compute_api_LatLongPoint":
        return self._north_east


scout_compute_resolved_api_LatLongBounds.__name__ = "LatLongBounds"
scout_compute_resolved_api_LatLongBounds.__qualname__ = "LatLongBounds"
scout_compute_resolved_api_LatLongBounds.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LatLongGeoNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'latitude': ConjureFieldDefinition('latitude', scout_compute_resolved_api_NumericSeriesNode),
            'longitude': ConjureFieldDefinition('longitude', scout_compute_resolved_api_NumericSeriesNode),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_resolved_api_LatLongBounds])
        }

    __slots__: List[str] = ['_latitude', '_longitude', '_bounds']

    def __init__(self, latitude: "scout_compute_resolved_api_NumericSeriesNode", longitude: "scout_compute_resolved_api_NumericSeriesNode", bounds: Optional["scout_compute_resolved_api_LatLongBounds"] = None) -> None:
        self._latitude = latitude
        self._longitude = longitude
        self._bounds = bounds

    @builtins.property
    def latitude(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._latitude

    @builtins.property
    def longitude(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._longitude

    @builtins.property
    def bounds(self) -> Optional["scout_compute_resolved_api_LatLongBounds"]:
        return self._bounds


scout_compute_resolved_api_LatLongGeoNode.__name__ = "LatLongGeoNode"
scout_compute_resolved_api_LatLongGeoNode.__qualname__ = "LatLongGeoNode"
scout_compute_resolved_api_LatLongGeoNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_MaxSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_MaxSeriesNode.__name__ = "MaxSeriesNode"
scout_compute_resolved_api_MaxSeriesNode.__qualname__ = "MaxSeriesNode"
scout_compute_resolved_api_MaxSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_MeanSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_MeanSeriesNode.__name__ = "MeanSeriesNode"
scout_compute_resolved_api_MeanSeriesNode.__qualname__ = "MeanSeriesNode"
scout_compute_resolved_api_MeanSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_MinMaxThresholdRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'lower_bound': ConjureFieldDefinition('lowerBound', float),
            'upper_bound': ConjureFieldDefinition('upperBound', float),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_MinMaxThresholdOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_resolved_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_lower_bound', '_upper_bound', '_operator', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", lower_bound: float, operator: "scout_compute_api_MinMaxThresholdOperator", upper_bound: float, persistence_window_configuration: Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._lower_bound = lower_bound
        self._upper_bound = upper_bound
        self._operator = operator
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def lower_bound(self) -> float:
        return self._lower_bound

    @builtins.property
    def upper_bound(self) -> float:
        return self._upper_bound

    @builtins.property
    def operator(self) -> "scout_compute_api_MinMaxThresholdOperator":
        return self._operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_resolved_api_MinMaxThresholdRangesNode.__name__ = "MinMaxThresholdRangesNode"
scout_compute_resolved_api_MinMaxThresholdRangesNode.__qualname__ = "MinMaxThresholdRangesNode"
scout_compute_resolved_api_MinMaxThresholdRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_MinSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_MinSeriesNode.__name__ = "MinSeriesNode"
scout_compute_resolved_api_MinSeriesNode.__qualname__ = "MinSeriesNode"
scout_compute_resolved_api_MinSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NotRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_RangesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_resolved_api_RangesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_RangesNode":
        return self._input


scout_compute_resolved_api_NotRangesNode.__name__ = "NotRangesNode"
scout_compute_resolved_api_NotRangesNode.__qualname__ = "NotRangesNode"
scout_compute_resolved_api_NotRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericFilterTransformationSeriesNode(ConjureBeanType):
    """
    Outputs the values of the numeric plot value within the ranges specified by a ranges node
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'filter': ConjureFieldDefinition('filter', scout_compute_resolved_api_RangesNode)
        }

    __slots__: List[str] = ['_input', '_filter']

    def __init__(self, filter: "scout_compute_resolved_api_RangesNode", input: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input = input
        self._filter = filter

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def filter(self) -> "scout_compute_resolved_api_RangesNode":
        return self._filter


scout_compute_resolved_api_NumericFilterTransformationSeriesNode.__name__ = "NumericFilterTransformationSeriesNode"
scout_compute_resolved_api_NumericFilterTransformationSeriesNode.__qualname__ = "NumericFilterTransformationSeriesNode"
scout_compute_resolved_api_NumericFilterTransformationSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericHistogramBucketStrategy(ConjureUnionType):
    _bucket_count: Optional[int] = None
    _bucket_width_and_offset: Optional["scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket_count': ConjureFieldDefinition('bucketCount', int),
            'bucket_width_and_offset': ConjureFieldDefinition('bucketWidthAndOffset', scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset)
        }

    def __init__(
            self,
            bucket_count: Optional[int] = None,
            bucket_width_and_offset: Optional["scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (bucket_count is not None) + (bucket_width_and_offset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if bucket_count is not None:
                self._bucket_count = bucket_count
                self._type = 'bucketCount'
            if bucket_width_and_offset is not None:
                self._bucket_width_and_offset = bucket_width_and_offset
                self._type = 'bucketWidthAndOffset'

        elif type_of_union == 'bucketCount':
            if bucket_count is None:
                raise ValueError('a union value must not be None')
            self._bucket_count = bucket_count
            self._type = 'bucketCount'
        elif type_of_union == 'bucketWidthAndOffset':
            if bucket_width_and_offset is None:
                raise ValueError('a union value must not be None')
            self._bucket_width_and_offset = bucket_width_and_offset
            self._type = 'bucketWidthAndOffset'

    @builtins.property
    def bucket_count(self) -> Optional[int]:
        return self._bucket_count

    @builtins.property
    def bucket_width_and_offset(self) -> Optional["scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset"]:
        return self._bucket_width_and_offset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'bucketCount' and self.bucket_count is not None:
            return visitor._bucket_count(self.bucket_count)
        if self._type == 'bucketWidthAndOffset' and self.bucket_width_and_offset is not None:
            return visitor._bucket_width_and_offset(self.bucket_width_and_offset)


scout_compute_resolved_api_NumericHistogramBucketStrategy.__name__ = "NumericHistogramBucketStrategy"
scout_compute_resolved_api_NumericHistogramBucketStrategy.__qualname__ = "NumericHistogramBucketStrategy"
scout_compute_resolved_api_NumericHistogramBucketStrategy.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor:

    @abstractmethod
    def _bucket_count(self, bucket_count: int) -> Any:
        pass

    @abstractmethod
    def _bucket_width_and_offset(self, bucket_width_and_offset: "scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset") -> Any:
        pass


scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor.__name__ = "NumericHistogramBucketStrategyVisitor"
scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor.__qualname__ = "NumericHistogramBucketStrategyVisitor"
scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'width': ConjureFieldDefinition('width', float),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_width', '_offset']

    def __init__(self, width: float, offset: Optional[float] = None) -> None:
        self._width = width
        self._offset = offset

    @builtins.property
    def width(self) -> float:
        return self._width

    @builtins.property
    def offset(self) -> Optional[float]:
        return self._offset


scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset.__name__ = "NumericHistogramBucketWidthAndOffset"
scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset.__qualname__ = "NumericHistogramBucketWidthAndOffset"
scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericHistogramNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_VariableName, scout_compute_resolved_api_NumericSeriesNode]),
            'bucket_strategy': ConjureFieldDefinition('bucketStrategy', OptionalTypeWrapper[scout_compute_resolved_api_NumericHistogramBucketStrategy])
        }

    __slots__: List[str] = ['_inputs', '_bucket_strategy']

    def __init__(self, inputs: Dict[str, "scout_compute_resolved_api_NumericSeriesNode"], bucket_strategy: Optional["scout_compute_resolved_api_NumericHistogramBucketStrategy"] = None) -> None:
        self._inputs = inputs
        self._bucket_strategy = bucket_strategy

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def bucket_strategy(self) -> Optional["scout_compute_resolved_api_NumericHistogramBucketStrategy"]:
        return self._bucket_strategy


scout_compute_resolved_api_NumericHistogramNode.__name__ = "NumericHistogramNode"
scout_compute_resolved_api_NumericHistogramNode.__qualname__ = "NumericHistogramNode"
scout_compute_resolved_api_NumericHistogramNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericResampleSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'resample_configuration': ConjureFieldDefinition('resampleConfiguration', scout_compute_resolved_api_ResampleConfiguration)
        }

    __slots__: List[str] = ['_input', '_resample_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", resample_configuration: "scout_compute_resolved_api_ResampleConfiguration") -> None:
        self._input = input
        self._resample_configuration = resample_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def resample_configuration(self) -> "scout_compute_resolved_api_ResampleConfiguration":
        return self._resample_configuration


scout_compute_resolved_api_NumericResampleSeriesNode.__name__ = "NumericResampleSeriesNode"
scout_compute_resolved_api_NumericResampleSeriesNode.__qualname__ = "NumericResampleSeriesNode"
scout_compute_resolved_api_NumericResampleSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericSeriesNode(ConjureUnionType):
    _arithmetic: Optional["scout_compute_resolved_api_ArithmeticSeriesNode"] = None
    _bit_operation: Optional["scout_compute_resolved_api_BitOperationSeriesNode"] = None
    _cumulative_sum: Optional["scout_compute_resolved_api_CumulativeSumSeriesNode"] = None
    _derivative: Optional["scout_compute_resolved_api_DerivativeSeriesNode"] = None
    _integral: Optional["scout_compute_resolved_api_IntegralSeriesNode"] = None
    _max: Optional["scout_compute_resolved_api_MaxSeriesNode"] = None
    _mean: Optional["scout_compute_resolved_api_MeanSeriesNode"] = None
    _min: Optional["scout_compute_resolved_api_MinSeriesNode"] = None
    _offset: Optional["scout_compute_resolved_api_OffsetSeriesNode"] = None
    _product: Optional["scout_compute_resolved_api_ProductSeriesNode"] = None
    _raw: Optional["scout_compute_resolved_api_RawNumericSeriesNode"] = None
    _resample: Optional["scout_compute_resolved_api_NumericResampleSeriesNode"] = None
    _rolling_operation: Optional["scout_compute_resolved_api_RollingOperationSeriesNode"] = None
    _aggregate: Optional["scout_compute_resolved_api_AggregateNumericSeriesNode"] = None
    _sum: Optional["scout_compute_resolved_api_SumSeriesNode"] = None
    _scale: Optional["scout_compute_resolved_api_ScaleSeriesNode"] = None
    _time_difference: Optional["scout_compute_resolved_api_TimeDifferenceSeriesNode"] = None
    _time_range_filter: Optional["scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_resolved_api_NumericTimeShiftSeriesNode"] = None
    _unary_arithmetic: Optional["scout_compute_resolved_api_UnaryArithmeticSeriesNode"] = None
    _binary_arithmetic: Optional["scout_compute_resolved_api_BinaryArithmeticSeriesNode"] = None
    _union: Optional["scout_compute_resolved_api_NumericUnionSeriesNode"] = None
    _unit_conversion: Optional["scout_compute_resolved_api_UnitConversionSeriesNode"] = None
    _value_difference: Optional["scout_compute_resolved_api_ValueDifferenceSeriesNode"] = None
    _filter_transformation: Optional["scout_compute_resolved_api_NumericFilterTransformationSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arithmetic': ConjureFieldDefinition('arithmetic', scout_compute_resolved_api_ArithmeticSeriesNode),
            'bit_operation': ConjureFieldDefinition('bitOperation', scout_compute_resolved_api_BitOperationSeriesNode),
            'cumulative_sum': ConjureFieldDefinition('cumulativeSum', scout_compute_resolved_api_CumulativeSumSeriesNode),
            'derivative': ConjureFieldDefinition('derivative', scout_compute_resolved_api_DerivativeSeriesNode),
            'integral': ConjureFieldDefinition('integral', scout_compute_resolved_api_IntegralSeriesNode),
            'max': ConjureFieldDefinition('max', scout_compute_resolved_api_MaxSeriesNode),
            'mean': ConjureFieldDefinition('mean', scout_compute_resolved_api_MeanSeriesNode),
            'min': ConjureFieldDefinition('min', scout_compute_resolved_api_MinSeriesNode),
            'offset': ConjureFieldDefinition('offset', scout_compute_resolved_api_OffsetSeriesNode),
            'product': ConjureFieldDefinition('product', scout_compute_resolved_api_ProductSeriesNode),
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_RawNumericSeriesNode),
            'resample': ConjureFieldDefinition('resample', scout_compute_resolved_api_NumericResampleSeriesNode),
            'rolling_operation': ConjureFieldDefinition('rollingOperation', scout_compute_resolved_api_RollingOperationSeriesNode),
            'aggregate': ConjureFieldDefinition('aggregate', scout_compute_resolved_api_AggregateNumericSeriesNode),
            'sum': ConjureFieldDefinition('sum', scout_compute_resolved_api_SumSeriesNode),
            'scale': ConjureFieldDefinition('scale', scout_compute_resolved_api_ScaleSeriesNode),
            'time_difference': ConjureFieldDefinition('timeDifference', scout_compute_resolved_api_TimeDifferenceSeriesNode),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_resolved_api_NumericTimeShiftSeriesNode),
            'unary_arithmetic': ConjureFieldDefinition('unaryArithmetic', scout_compute_resolved_api_UnaryArithmeticSeriesNode),
            'binary_arithmetic': ConjureFieldDefinition('binaryArithmetic', scout_compute_resolved_api_BinaryArithmeticSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_resolved_api_NumericUnionSeriesNode),
            'unit_conversion': ConjureFieldDefinition('unitConversion', scout_compute_resolved_api_UnitConversionSeriesNode),
            'value_difference': ConjureFieldDefinition('valueDifference', scout_compute_resolved_api_ValueDifferenceSeriesNode),
            'filter_transformation': ConjureFieldDefinition('filterTransformation', scout_compute_resolved_api_NumericFilterTransformationSeriesNode)
        }

    def __init__(
            self,
            arithmetic: Optional["scout_compute_resolved_api_ArithmeticSeriesNode"] = None,
            bit_operation: Optional["scout_compute_resolved_api_BitOperationSeriesNode"] = None,
            cumulative_sum: Optional["scout_compute_resolved_api_CumulativeSumSeriesNode"] = None,
            derivative: Optional["scout_compute_resolved_api_DerivativeSeriesNode"] = None,
            integral: Optional["scout_compute_resolved_api_IntegralSeriesNode"] = None,
            max: Optional["scout_compute_resolved_api_MaxSeriesNode"] = None,
            mean: Optional["scout_compute_resolved_api_MeanSeriesNode"] = None,
            min: Optional["scout_compute_resolved_api_MinSeriesNode"] = None,
            offset: Optional["scout_compute_resolved_api_OffsetSeriesNode"] = None,
            product: Optional["scout_compute_resolved_api_ProductSeriesNode"] = None,
            raw: Optional["scout_compute_resolved_api_RawNumericSeriesNode"] = None,
            resample: Optional["scout_compute_resolved_api_NumericResampleSeriesNode"] = None,
            rolling_operation: Optional["scout_compute_resolved_api_RollingOperationSeriesNode"] = None,
            aggregate: Optional["scout_compute_resolved_api_AggregateNumericSeriesNode"] = None,
            sum: Optional["scout_compute_resolved_api_SumSeriesNode"] = None,
            scale: Optional["scout_compute_resolved_api_ScaleSeriesNode"] = None,
            time_difference: Optional["scout_compute_resolved_api_TimeDifferenceSeriesNode"] = None,
            time_range_filter: Optional["scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_resolved_api_NumericTimeShiftSeriesNode"] = None,
            unary_arithmetic: Optional["scout_compute_resolved_api_UnaryArithmeticSeriesNode"] = None,
            binary_arithmetic: Optional["scout_compute_resolved_api_BinaryArithmeticSeriesNode"] = None,
            union: Optional["scout_compute_resolved_api_NumericUnionSeriesNode"] = None,
            unit_conversion: Optional["scout_compute_resolved_api_UnitConversionSeriesNode"] = None,
            value_difference: Optional["scout_compute_resolved_api_ValueDifferenceSeriesNode"] = None,
            filter_transformation: Optional["scout_compute_resolved_api_NumericFilterTransformationSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (arithmetic is not None) + (bit_operation is not None) + (cumulative_sum is not None) + (derivative is not None) + (integral is not None) + (max is not None) + (mean is not None) + (min is not None) + (offset is not None) + (product is not None) + (raw is not None) + (resample is not None) + (rolling_operation is not None) + (aggregate is not None) + (sum is not None) + (scale is not None) + (time_difference is not None) + (time_range_filter is not None) + (time_shift is not None) + (unary_arithmetic is not None) + (binary_arithmetic is not None) + (union is not None) + (unit_conversion is not None) + (value_difference is not None) + (filter_transformation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if arithmetic is not None:
                self._arithmetic = arithmetic
                self._type = 'arithmetic'
            if bit_operation is not None:
                self._bit_operation = bit_operation
                self._type = 'bitOperation'
            if cumulative_sum is not None:
                self._cumulative_sum = cumulative_sum
                self._type = 'cumulativeSum'
            if derivative is not None:
                self._derivative = derivative
                self._type = 'derivative'
            if integral is not None:
                self._integral = integral
                self._type = 'integral'
            if max is not None:
                self._max = max
                self._type = 'max'
            if mean is not None:
                self._mean = mean
                self._type = 'mean'
            if min is not None:
                self._min = min
                self._type = 'min'
            if offset is not None:
                self._offset = offset
                self._type = 'offset'
            if product is not None:
                self._product = product
                self._type = 'product'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if resample is not None:
                self._resample = resample
                self._type = 'resample'
            if rolling_operation is not None:
                self._rolling_operation = rolling_operation
                self._type = 'rollingOperation'
            if aggregate is not None:
                self._aggregate = aggregate
                self._type = 'aggregate'
            if sum is not None:
                self._sum = sum
                self._type = 'sum'
            if scale is not None:
                self._scale = scale
                self._type = 'scale'
            if time_difference is not None:
                self._time_difference = time_difference
                self._type = 'timeDifference'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if unary_arithmetic is not None:
                self._unary_arithmetic = unary_arithmetic
                self._type = 'unaryArithmetic'
            if binary_arithmetic is not None:
                self._binary_arithmetic = binary_arithmetic
                self._type = 'binaryArithmetic'
            if union is not None:
                self._union = union
                self._type = 'union'
            if unit_conversion is not None:
                self._unit_conversion = unit_conversion
                self._type = 'unitConversion'
            if value_difference is not None:
                self._value_difference = value_difference
                self._type = 'valueDifference'
            if filter_transformation is not None:
                self._filter_transformation = filter_transformation
                self._type = 'filterTransformation'

        elif type_of_union == 'arithmetic':
            if arithmetic is None:
                raise ValueError('a union value must not be None')
            self._arithmetic = arithmetic
            self._type = 'arithmetic'
        elif type_of_union == 'bitOperation':
            if bit_operation is None:
                raise ValueError('a union value must not be None')
            self._bit_operation = bit_operation
            self._type = 'bitOperation'
        elif type_of_union == 'cumulativeSum':
            if cumulative_sum is None:
                raise ValueError('a union value must not be None')
            self._cumulative_sum = cumulative_sum
            self._type = 'cumulativeSum'
        elif type_of_union == 'derivative':
            if derivative is None:
                raise ValueError('a union value must not be None')
            self._derivative = derivative
            self._type = 'derivative'
        elif type_of_union == 'integral':
            if integral is None:
                raise ValueError('a union value must not be None')
            self._integral = integral
            self._type = 'integral'
        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'mean':
            if mean is None:
                raise ValueError('a union value must not be None')
            self._mean = mean
            self._type = 'mean'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'offset':
            if offset is None:
                raise ValueError('a union value must not be None')
            self._offset = offset
            self._type = 'offset'
        elif type_of_union == 'product':
            if product is None:
                raise ValueError('a union value must not be None')
            self._product = product
            self._type = 'product'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'resample':
            if resample is None:
                raise ValueError('a union value must not be None')
            self._resample = resample
            self._type = 'resample'
        elif type_of_union == 'rollingOperation':
            if rolling_operation is None:
                raise ValueError('a union value must not be None')
            self._rolling_operation = rolling_operation
            self._type = 'rollingOperation'
        elif type_of_union == 'aggregate':
            if aggregate is None:
                raise ValueError('a union value must not be None')
            self._aggregate = aggregate
            self._type = 'aggregate'
        elif type_of_union == 'sum':
            if sum is None:
                raise ValueError('a union value must not be None')
            self._sum = sum
            self._type = 'sum'
        elif type_of_union == 'scale':
            if scale is None:
                raise ValueError('a union value must not be None')
            self._scale = scale
            self._type = 'scale'
        elif type_of_union == 'timeDifference':
            if time_difference is None:
                raise ValueError('a union value must not be None')
            self._time_difference = time_difference
            self._type = 'timeDifference'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'unaryArithmetic':
            if unary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._unary_arithmetic = unary_arithmetic
            self._type = 'unaryArithmetic'
        elif type_of_union == 'binaryArithmetic':
            if binary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._binary_arithmetic = binary_arithmetic
            self._type = 'binaryArithmetic'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'unitConversion':
            if unit_conversion is None:
                raise ValueError('a union value must not be None')
            self._unit_conversion = unit_conversion
            self._type = 'unitConversion'
        elif type_of_union == 'valueDifference':
            if value_difference is None:
                raise ValueError('a union value must not be None')
            self._value_difference = value_difference
            self._type = 'valueDifference'
        elif type_of_union == 'filterTransformation':
            if filter_transformation is None:
                raise ValueError('a union value must not be None')
            self._filter_transformation = filter_transformation
            self._type = 'filterTransformation'

    @builtins.property
    def arithmetic(self) -> Optional["scout_compute_resolved_api_ArithmeticSeriesNode"]:
        return self._arithmetic

    @builtins.property
    def bit_operation(self) -> Optional["scout_compute_resolved_api_BitOperationSeriesNode"]:
        return self._bit_operation

    @builtins.property
    def cumulative_sum(self) -> Optional["scout_compute_resolved_api_CumulativeSumSeriesNode"]:
        return self._cumulative_sum

    @builtins.property
    def derivative(self) -> Optional["scout_compute_resolved_api_DerivativeSeriesNode"]:
        return self._derivative

    @builtins.property
    def integral(self) -> Optional["scout_compute_resolved_api_IntegralSeriesNode"]:
        return self._integral

    @builtins.property
    def max(self) -> Optional["scout_compute_resolved_api_MaxSeriesNode"]:
        return self._max

    @builtins.property
    def mean(self) -> Optional["scout_compute_resolved_api_MeanSeriesNode"]:
        return self._mean

    @builtins.property
    def min(self) -> Optional["scout_compute_resolved_api_MinSeriesNode"]:
        return self._min

    @builtins.property
    def offset(self) -> Optional["scout_compute_resolved_api_OffsetSeriesNode"]:
        return self._offset

    @builtins.property
    def product(self) -> Optional["scout_compute_resolved_api_ProductSeriesNode"]:
        return self._product

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_RawNumericSeriesNode"]:
        return self._raw

    @builtins.property
    def resample(self) -> Optional["scout_compute_resolved_api_NumericResampleSeriesNode"]:
        return self._resample

    @builtins.property
    def rolling_operation(self) -> Optional["scout_compute_resolved_api_RollingOperationSeriesNode"]:
        return self._rolling_operation

    @builtins.property
    def aggregate(self) -> Optional["scout_compute_resolved_api_AggregateNumericSeriesNode"]:
        return self._aggregate

    @builtins.property
    def sum(self) -> Optional["scout_compute_resolved_api_SumSeriesNode"]:
        return self._sum

    @builtins.property
    def scale(self) -> Optional["scout_compute_resolved_api_ScaleSeriesNode"]:
        return self._scale

    @builtins.property
    def time_difference(self) -> Optional["scout_compute_resolved_api_TimeDifferenceSeriesNode"]:
        return self._time_difference

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_resolved_api_NumericTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def unary_arithmetic(self) -> Optional["scout_compute_resolved_api_UnaryArithmeticSeriesNode"]:
        return self._unary_arithmetic

    @builtins.property
    def binary_arithmetic(self) -> Optional["scout_compute_resolved_api_BinaryArithmeticSeriesNode"]:
        return self._binary_arithmetic

    @builtins.property
    def union(self) -> Optional["scout_compute_resolved_api_NumericUnionSeriesNode"]:
        return self._union

    @builtins.property
    def unit_conversion(self) -> Optional["scout_compute_resolved_api_UnitConversionSeriesNode"]:
        return self._unit_conversion

    @builtins.property
    def value_difference(self) -> Optional["scout_compute_resolved_api_ValueDifferenceSeriesNode"]:
        return self._value_difference

    @builtins.property
    def filter_transformation(self) -> Optional["scout_compute_resolved_api_NumericFilterTransformationSeriesNode"]:
        return self._filter_transformation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_NumericSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_NumericSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'arithmetic' and self.arithmetic is not None:
            return visitor._arithmetic(self.arithmetic)
        if self._type == 'bitOperation' and self.bit_operation is not None:
            return visitor._bit_operation(self.bit_operation)
        if self._type == 'cumulativeSum' and self.cumulative_sum is not None:
            return visitor._cumulative_sum(self.cumulative_sum)
        if self._type == 'derivative' and self.derivative is not None:
            return visitor._derivative(self.derivative)
        if self._type == 'integral' and self.integral is not None:
            return visitor._integral(self.integral)
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'mean' and self.mean is not None:
            return visitor._mean(self.mean)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'offset' and self.offset is not None:
            return visitor._offset(self.offset)
        if self._type == 'product' and self.product is not None:
            return visitor._product(self.product)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'resample' and self.resample is not None:
            return visitor._resample(self.resample)
        if self._type == 'rollingOperation' and self.rolling_operation is not None:
            return visitor._rolling_operation(self.rolling_operation)
        if self._type == 'aggregate' and self.aggregate is not None:
            return visitor._aggregate(self.aggregate)
        if self._type == 'sum' and self.sum is not None:
            return visitor._sum(self.sum)
        if self._type == 'scale' and self.scale is not None:
            return visitor._scale(self.scale)
        if self._type == 'timeDifference' and self.time_difference is not None:
            return visitor._time_difference(self.time_difference)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'unaryArithmetic' and self.unary_arithmetic is not None:
            return visitor._unary_arithmetic(self.unary_arithmetic)
        if self._type == 'binaryArithmetic' and self.binary_arithmetic is not None:
            return visitor._binary_arithmetic(self.binary_arithmetic)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'unitConversion' and self.unit_conversion is not None:
            return visitor._unit_conversion(self.unit_conversion)
        if self._type == 'valueDifference' and self.value_difference is not None:
            return visitor._value_difference(self.value_difference)
        if self._type == 'filterTransformation' and self.filter_transformation is not None:
            return visitor._filter_transformation(self.filter_transformation)


scout_compute_resolved_api_NumericSeriesNode.__name__ = "NumericSeriesNode"
scout_compute_resolved_api_NumericSeriesNode.__qualname__ = "NumericSeriesNode"
scout_compute_resolved_api_NumericSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericSeriesNodeVisitor:

    @abstractmethod
    def _arithmetic(self, arithmetic: "scout_compute_resolved_api_ArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _bit_operation(self, bit_operation: "scout_compute_resolved_api_BitOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _cumulative_sum(self, cumulative_sum: "scout_compute_resolved_api_CumulativeSumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _derivative(self, derivative: "scout_compute_resolved_api_DerivativeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _integral(self, integral: "scout_compute_resolved_api_IntegralSeriesNode") -> Any:
        pass

    @abstractmethod
    def _max(self, max: "scout_compute_resolved_api_MaxSeriesNode") -> Any:
        pass

    @abstractmethod
    def _mean(self, mean: "scout_compute_resolved_api_MeanSeriesNode") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_compute_resolved_api_MinSeriesNode") -> Any:
        pass

    @abstractmethod
    def _offset(self, offset: "scout_compute_resolved_api_OffsetSeriesNode") -> Any:
        pass

    @abstractmethod
    def _product(self, product: "scout_compute_resolved_api_ProductSeriesNode") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_RawNumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _resample(self, resample: "scout_compute_resolved_api_NumericResampleSeriesNode") -> Any:
        pass

    @abstractmethod
    def _rolling_operation(self, rolling_operation: "scout_compute_resolved_api_RollingOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _aggregate(self, aggregate: "scout_compute_resolved_api_AggregateNumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _sum(self, sum: "scout_compute_resolved_api_SumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _scale(self, scale: "scout_compute_resolved_api_ScaleSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_difference(self, time_difference: "scout_compute_resolved_api_TimeDifferenceSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_resolved_api_NumericTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _unary_arithmetic(self, unary_arithmetic: "scout_compute_resolved_api_UnaryArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _binary_arithmetic(self, binary_arithmetic: "scout_compute_resolved_api_BinaryArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_resolved_api_NumericUnionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _unit_conversion(self, unit_conversion: "scout_compute_resolved_api_UnitConversionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value_difference(self, value_difference: "scout_compute_resolved_api_ValueDifferenceSeriesNode") -> Any:
        pass

    @abstractmethod
    def _filter_transformation(self, filter_transformation: "scout_compute_resolved_api_NumericFilterTransformationSeriesNode") -> Any:
        pass


scout_compute_resolved_api_NumericSeriesNodeVisitor.__name__ = "NumericSeriesNodeVisitor"
scout_compute_resolved_api_NumericSeriesNodeVisitor.__qualname__ = "NumericSeriesNodeVisitor"
scout_compute_resolved_api_NumericSeriesNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[api_Timestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", end_time: Optional["api_Timestamp"] = None, start_time: Optional["api_Timestamp"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["api_Timestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["api_Timestamp"]:
        return self._end_time


scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode.__name__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode.__qualname__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_run_api_Duration", input: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_resolved_api_NumericTimeShiftSeriesNode.__name__ = "NumericTimeShiftSeriesNode"
scout_compute_resolved_api_NumericTimeShiftSeriesNode.__qualname__ = "NumericTimeShiftSeriesNode"
scout_compute_resolved_api_NumericTimeShiftSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericUnionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_resolved_api_NumericSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_NumericUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_resolved_api_NumericSeriesNode"], operation: "scout_compute_api_NumericUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_NumericUnionOperation":
        return self._operation


scout_compute_resolved_api_NumericUnionSeriesNode.__name__ = "NumericUnionSeriesNode"
scout_compute_resolved_api_NumericUnionSeriesNode.__qualname__ = "NumericUnionSeriesNode"
scout_compute_resolved_api_NumericUnionSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_OffsetSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'scalar': ConjureFieldDefinition('scalar', float)
        }

    __slots__: List[str] = ['_input', '_scalar']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", scalar: float) -> None:
        self._input = input
        self._scalar = scalar

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def scalar(self) -> float:
        return self._scalar


scout_compute_resolved_api_OffsetSeriesNode.__name__ = "OffsetSeriesNode"
scout_compute_resolved_api_OffsetSeriesNode.__qualname__ = "OffsetSeriesNode"
scout_compute_resolved_api_OffsetSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_OnChangeRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_SeriesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_resolved_api_SeriesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_SeriesNode":
        return self._input


scout_compute_resolved_api_OnChangeRangesNode.__name__ = "OnChangeRangesNode"
scout_compute_resolved_api_OnChangeRangesNode.__qualname__ = "OnChangeRangesNode"
scout_compute_resolved_api_OnChangeRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_PersistenceWindowConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[int]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_run_api_Duration]),
            'output_range_start': ConjureFieldDefinition('outputRangeStart', scout_compute_api_OutputRangeStart)
        }

    __slots__: List[str] = ['_min_points', '_min_duration', '_output_range_start']

    def __init__(self, output_range_start: "scout_compute_api_OutputRangeStart", min_duration: Optional["scout_run_api_Duration"] = None, min_points: Optional[int] = None) -> None:
        self._min_points = min_points
        self._min_duration = min_duration
        self._output_range_start = output_range_start

    @builtins.property
    def min_points(self) -> Optional[int]:
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_run_api_Duration"]:
        return self._min_duration

    @builtins.property
    def output_range_start(self) -> "scout_compute_api_OutputRangeStart":
        return self._output_range_start


scout_compute_resolved_api_PersistenceWindowConfiguration.__name__ = "PersistenceWindowConfiguration"
scout_compute_resolved_api_PersistenceWindowConfiguration.__qualname__ = "PersistenceWindowConfiguration"
scout_compute_resolved_api_PersistenceWindowConfiguration.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ProductSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_ProductSeriesNode.__name__ = "ProductSeriesNode"
scout_compute_resolved_api_ProductSeriesNode.__qualname__ = "ProductSeriesNode"
scout_compute_resolved_api_ProductSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RangesNode(ConjureUnionType):
    _enum_filter: Optional["scout_compute_resolved_api_EnumFilterRangesNode"] = None
    _enum_equality: Optional["scout_compute_resolved_api_EnumEqualityRangesNode"] = None
    _extrema: Optional["scout_compute_resolved_api_ExtremaRangesNode"] = None
    _intersect_range: Optional["scout_compute_resolved_api_IntersectRangesNode"] = None
    _not_: Optional["scout_compute_resolved_api_NotRangesNode"] = None
    _min_max_threshold: Optional["scout_compute_resolved_api_MinMaxThresholdRangesNode"] = None
    _on_change: Optional["scout_compute_resolved_api_OnChangeRangesNode"] = None
    _threshold: Optional["scout_compute_resolved_api_ThresholdingRangesNode"] = None
    _series_crossover_ranges_node: Optional["scout_compute_resolved_api_SeriesCrossoverRangesNode"] = None
    _stale_range: Optional["scout_compute_resolved_api_StaleRangesNode"] = None
    _union_range: Optional["scout_compute_resolved_api_UnionRangesNode"] = None
    _range_numeric_aggregation: Optional["scout_compute_resolved_api_RangesNumericAggregationNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'enum_filter': ConjureFieldDefinition('enumFilter', scout_compute_resolved_api_EnumFilterRangesNode),
            'enum_equality': ConjureFieldDefinition('enumEquality', scout_compute_resolved_api_EnumEqualityRangesNode),
            'extrema': ConjureFieldDefinition('extrema', scout_compute_resolved_api_ExtremaRangesNode),
            'intersect_range': ConjureFieldDefinition('intersectRange', scout_compute_resolved_api_IntersectRangesNode),
            'not_': ConjureFieldDefinition('not', scout_compute_resolved_api_NotRangesNode),
            'min_max_threshold': ConjureFieldDefinition('minMaxThreshold', scout_compute_resolved_api_MinMaxThresholdRangesNode),
            'on_change': ConjureFieldDefinition('onChange', scout_compute_resolved_api_OnChangeRangesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_resolved_api_ThresholdingRangesNode),
            'series_crossover_ranges_node': ConjureFieldDefinition('seriesCrossoverRangesNode', scout_compute_resolved_api_SeriesCrossoverRangesNode),
            'stale_range': ConjureFieldDefinition('staleRange', scout_compute_resolved_api_StaleRangesNode),
            'union_range': ConjureFieldDefinition('unionRange', scout_compute_resolved_api_UnionRangesNode),
            'range_numeric_aggregation': ConjureFieldDefinition('rangeNumericAggregation', scout_compute_resolved_api_RangesNumericAggregationNode)
        }

    def __init__(
            self,
            enum_filter: Optional["scout_compute_resolved_api_EnumFilterRangesNode"] = None,
            enum_equality: Optional["scout_compute_resolved_api_EnumEqualityRangesNode"] = None,
            extrema: Optional["scout_compute_resolved_api_ExtremaRangesNode"] = None,
            intersect_range: Optional["scout_compute_resolved_api_IntersectRangesNode"] = None,
            not_: Optional["scout_compute_resolved_api_NotRangesNode"] = None,
            min_max_threshold: Optional["scout_compute_resolved_api_MinMaxThresholdRangesNode"] = None,
            on_change: Optional["scout_compute_resolved_api_OnChangeRangesNode"] = None,
            threshold: Optional["scout_compute_resolved_api_ThresholdingRangesNode"] = None,
            series_crossover_ranges_node: Optional["scout_compute_resolved_api_SeriesCrossoverRangesNode"] = None,
            stale_range: Optional["scout_compute_resolved_api_StaleRangesNode"] = None,
            union_range: Optional["scout_compute_resolved_api_UnionRangesNode"] = None,
            range_numeric_aggregation: Optional["scout_compute_resolved_api_RangesNumericAggregationNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (enum_filter is not None) + (enum_equality is not None) + (extrema is not None) + (intersect_range is not None) + (not_ is not None) + (min_max_threshold is not None) + (on_change is not None) + (threshold is not None) + (series_crossover_ranges_node is not None) + (stale_range is not None) + (union_range is not None) + (range_numeric_aggregation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if enum_filter is not None:
                self._enum_filter = enum_filter
                self._type = 'enumFilter'
            if enum_equality is not None:
                self._enum_equality = enum_equality
                self._type = 'enumEquality'
            if extrema is not None:
                self._extrema = extrema
                self._type = 'extrema'
            if intersect_range is not None:
                self._intersect_range = intersect_range
                self._type = 'intersectRange'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if min_max_threshold is not None:
                self._min_max_threshold = min_max_threshold
                self._type = 'minMaxThreshold'
            if on_change is not None:
                self._on_change = on_change
                self._type = 'onChange'
            if threshold is not None:
                self._threshold = threshold
                self._type = 'threshold'
            if series_crossover_ranges_node is not None:
                self._series_crossover_ranges_node = series_crossover_ranges_node
                self._type = 'seriesCrossoverRangesNode'
            if stale_range is not None:
                self._stale_range = stale_range
                self._type = 'staleRange'
            if union_range is not None:
                self._union_range = union_range
                self._type = 'unionRange'
            if range_numeric_aggregation is not None:
                self._range_numeric_aggregation = range_numeric_aggregation
                self._type = 'rangeNumericAggregation'

        elif type_of_union == 'enumFilter':
            if enum_filter is None:
                raise ValueError('a union value must not be None')
            self._enum_filter = enum_filter
            self._type = 'enumFilter'
        elif type_of_union == 'enumEquality':
            if enum_equality is None:
                raise ValueError('a union value must not be None')
            self._enum_equality = enum_equality
            self._type = 'enumEquality'
        elif type_of_union == 'extrema':
            if extrema is None:
                raise ValueError('a union value must not be None')
            self._extrema = extrema
            self._type = 'extrema'
        elif type_of_union == 'intersectRange':
            if intersect_range is None:
                raise ValueError('a union value must not be None')
            self._intersect_range = intersect_range
            self._type = 'intersectRange'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'minMaxThreshold':
            if min_max_threshold is None:
                raise ValueError('a union value must not be None')
            self._min_max_threshold = min_max_threshold
            self._type = 'minMaxThreshold'
        elif type_of_union == 'onChange':
            if on_change is None:
                raise ValueError('a union value must not be None')
            self._on_change = on_change
            self._type = 'onChange'
        elif type_of_union == 'threshold':
            if threshold is None:
                raise ValueError('a union value must not be None')
            self._threshold = threshold
            self._type = 'threshold'
        elif type_of_union == 'seriesCrossoverRangesNode':
            if series_crossover_ranges_node is None:
                raise ValueError('a union value must not be None')
            self._series_crossover_ranges_node = series_crossover_ranges_node
            self._type = 'seriesCrossoverRangesNode'
        elif type_of_union == 'staleRange':
            if stale_range is None:
                raise ValueError('a union value must not be None')
            self._stale_range = stale_range
            self._type = 'staleRange'
        elif type_of_union == 'unionRange':
            if union_range is None:
                raise ValueError('a union value must not be None')
            self._union_range = union_range
            self._type = 'unionRange'
        elif type_of_union == 'rangeNumericAggregation':
            if range_numeric_aggregation is None:
                raise ValueError('a union value must not be None')
            self._range_numeric_aggregation = range_numeric_aggregation
            self._type = 'rangeNumericAggregation'

    @builtins.property
    def enum_filter(self) -> Optional["scout_compute_resolved_api_EnumFilterRangesNode"]:
        return self._enum_filter

    @builtins.property
    def enum_equality(self) -> Optional["scout_compute_resolved_api_EnumEqualityRangesNode"]:
        return self._enum_equality

    @builtins.property
    def extrema(self) -> Optional["scout_compute_resolved_api_ExtremaRangesNode"]:
        return self._extrema

    @builtins.property
    def intersect_range(self) -> Optional["scout_compute_resolved_api_IntersectRangesNode"]:
        return self._intersect_range

    @builtins.property
    def not_(self) -> Optional["scout_compute_resolved_api_NotRangesNode"]:
        return self._not_

    @builtins.property
    def min_max_threshold(self) -> Optional["scout_compute_resolved_api_MinMaxThresholdRangesNode"]:
        return self._min_max_threshold

    @builtins.property
    def on_change(self) -> Optional["scout_compute_resolved_api_OnChangeRangesNode"]:
        return self._on_change

    @builtins.property
    def threshold(self) -> Optional["scout_compute_resolved_api_ThresholdingRangesNode"]:
        return self._threshold

    @builtins.property
    def series_crossover_ranges_node(self) -> Optional["scout_compute_resolved_api_SeriesCrossoverRangesNode"]:
        return self._series_crossover_ranges_node

    @builtins.property
    def stale_range(self) -> Optional["scout_compute_resolved_api_StaleRangesNode"]:
        return self._stale_range

    @builtins.property
    def union_range(self) -> Optional["scout_compute_resolved_api_UnionRangesNode"]:
        return self._union_range

    @builtins.property
    def range_numeric_aggregation(self) -> Optional["scout_compute_resolved_api_RangesNumericAggregationNode"]:
        return self._range_numeric_aggregation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_RangesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_RangesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'enumFilter' and self.enum_filter is not None:
            return visitor._enum_filter(self.enum_filter)
        if self._type == 'enumEquality' and self.enum_equality is not None:
            return visitor._enum_equality(self.enum_equality)
        if self._type == 'extrema' and self.extrema is not None:
            return visitor._extrema(self.extrema)
        if self._type == 'intersectRange' and self.intersect_range is not None:
            return visitor._intersect_range(self.intersect_range)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'minMaxThreshold' and self.min_max_threshold is not None:
            return visitor._min_max_threshold(self.min_max_threshold)
        if self._type == 'onChange' and self.on_change is not None:
            return visitor._on_change(self.on_change)
        if self._type == 'threshold' and self.threshold is not None:
            return visitor._threshold(self.threshold)
        if self._type == 'seriesCrossoverRangesNode' and self.series_crossover_ranges_node is not None:
            return visitor._series_crossover_ranges_node(self.series_crossover_ranges_node)
        if self._type == 'staleRange' and self.stale_range is not None:
            return visitor._stale_range(self.stale_range)
        if self._type == 'unionRange' and self.union_range is not None:
            return visitor._union_range(self.union_range)
        if self._type == 'rangeNumericAggregation' and self.range_numeric_aggregation is not None:
            return visitor._range_numeric_aggregation(self.range_numeric_aggregation)


scout_compute_resolved_api_RangesNode.__name__ = "RangesNode"
scout_compute_resolved_api_RangesNode.__qualname__ = "RangesNode"
scout_compute_resolved_api_RangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RangesNodeVisitor:

    @abstractmethod
    def _enum_filter(self, enum_filter: "scout_compute_resolved_api_EnumFilterRangesNode") -> Any:
        pass

    @abstractmethod
    def _enum_equality(self, enum_equality: "scout_compute_resolved_api_EnumEqualityRangesNode") -> Any:
        pass

    @abstractmethod
    def _extrema(self, extrema: "scout_compute_resolved_api_ExtremaRangesNode") -> Any:
        pass

    @abstractmethod
    def _intersect_range(self, intersect_range: "scout_compute_resolved_api_IntersectRangesNode") -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_compute_resolved_api_NotRangesNode") -> Any:
        pass

    @abstractmethod
    def _min_max_threshold(self, min_max_threshold: "scout_compute_resolved_api_MinMaxThresholdRangesNode") -> Any:
        pass

    @abstractmethod
    def _on_change(self, on_change: "scout_compute_resolved_api_OnChangeRangesNode") -> Any:
        pass

    @abstractmethod
    def _threshold(self, threshold: "scout_compute_resolved_api_ThresholdingRangesNode") -> Any:
        pass

    @abstractmethod
    def _series_crossover_ranges_node(self, series_crossover_ranges_node: "scout_compute_resolved_api_SeriesCrossoverRangesNode") -> Any:
        pass

    @abstractmethod
    def _stale_range(self, stale_range: "scout_compute_resolved_api_StaleRangesNode") -> Any:
        pass

    @abstractmethod
    def _union_range(self, union_range: "scout_compute_resolved_api_UnionRangesNode") -> Any:
        pass

    @abstractmethod
    def _range_numeric_aggregation(self, range_numeric_aggregation: "scout_compute_resolved_api_RangesNumericAggregationNode") -> Any:
        pass


scout_compute_resolved_api_RangesNodeVisitor.__name__ = "RangesNodeVisitor"
scout_compute_resolved_api_RangesNodeVisitor.__qualname__ = "RangesNodeVisitor"
scout_compute_resolved_api_RangesNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RangesNumericAggregationNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_resolved_api_RangesNode),
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_RangeAggregationOperation)
        }

    __slots__: List[str] = ['_ranges', '_input', '_operation']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", operation: "scout_compute_api_RangeAggregationOperation", ranges: "scout_compute_resolved_api_RangesNode") -> None:
        self._ranges = ranges
        self._input = input
        self._operation = operation

    @builtins.property
    def ranges(self) -> "scout_compute_resolved_api_RangesNode":
        return self._ranges

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_RangeAggregationOperation":
        return self._operation


scout_compute_resolved_api_RangesNumericAggregationNode.__name__ = "RangesNumericAggregationNode"
scout_compute_resolved_api_RangesNumericAggregationNode.__qualname__ = "RangesNumericAggregationNode"
scout_compute_resolved_api_RangesNumericAggregationNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RawEnumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_api_SeriesSpec)
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: "scout_compute_api_SeriesSpec") -> None:
        self._series = series

    @builtins.property
    def series(self) -> "scout_compute_api_SeriesSpec":
        return self._series


scout_compute_resolved_api_RawEnumSeriesNode.__name__ = "RawEnumSeriesNode"
scout_compute_resolved_api_RawEnumSeriesNode.__qualname__ = "RawEnumSeriesNode"
scout_compute_resolved_api_RawEnumSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RawNumericSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_api_SeriesSpec)
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: "scout_compute_api_SeriesSpec") -> None:
        self._series = series

    @builtins.property
    def series(self) -> "scout_compute_api_SeriesSpec":
        return self._series


scout_compute_resolved_api_RawNumericSeriesNode.__name__ = "RawNumericSeriesNode"
scout_compute_resolved_api_RawNumericSeriesNode.__qualname__ = "RawNumericSeriesNode"
scout_compute_resolved_api_RawNumericSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RawUntypedSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_api_SeriesSpec)
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: "scout_compute_api_SeriesSpec") -> None:
        self._series = series

    @builtins.property
    def series(self) -> "scout_compute_api_SeriesSpec":
        return self._series


scout_compute_resolved_api_RawUntypedSeriesNode.__name__ = "RawUntypedSeriesNode"
scout_compute_resolved_api_RawUntypedSeriesNode.__qualname__ = "RawUntypedSeriesNode"
scout_compute_resolved_api_RawUntypedSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResampleConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'interval': ConjureFieldDefinition('interval', scout_run_api_Duration),
            'interpolation': ConjureFieldDefinition('interpolation', scout_compute_resolved_api_ResampleInterpolationConfiguration)
        }

    __slots__: List[str] = ['_interval', '_interpolation']

    def __init__(self, interpolation: "scout_compute_resolved_api_ResampleInterpolationConfiguration", interval: "scout_run_api_Duration") -> None:
        self._interval = interval
        self._interpolation = interpolation

    @builtins.property
    def interval(self) -> "scout_run_api_Duration":
        return self._interval

    @builtins.property
    def interpolation(self) -> "scout_compute_resolved_api_ResampleInterpolationConfiguration":
        return self._interpolation


scout_compute_resolved_api_ResampleConfiguration.__name__ = "ResampleConfiguration"
scout_compute_resolved_api_ResampleConfiguration.__qualname__ = "ResampleConfiguration"
scout_compute_resolved_api_ResampleConfiguration.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResampleInterpolationConfiguration(ConjureUnionType):
    _forward_fill_resample_interpolation_configuration: Optional["scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'forward_fill_resample_interpolation_configuration': ConjureFieldDefinition('forwardFillResampleInterpolationConfiguration', scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration)
        }

    def __init__(
            self,
            forward_fill_resample_interpolation_configuration: Optional["scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (forward_fill_resample_interpolation_configuration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if forward_fill_resample_interpolation_configuration is not None:
                self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
                self._type = 'forwardFillResampleInterpolationConfiguration'

        elif type_of_union == 'forwardFillResampleInterpolationConfiguration':
            if forward_fill_resample_interpolation_configuration is None:
                raise ValueError('a union value must not be None')
            self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
            self._type = 'forwardFillResampleInterpolationConfiguration'

    @builtins.property
    def forward_fill_resample_interpolation_configuration(self) -> Optional["scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration"]:
        return self._forward_fill_resample_interpolation_configuration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'forwardFillResampleInterpolationConfiguration' and self.forward_fill_resample_interpolation_configuration is not None:
            return visitor._forward_fill_resample_interpolation_configuration(self.forward_fill_resample_interpolation_configuration)


scout_compute_resolved_api_ResampleInterpolationConfiguration.__name__ = "ResampleInterpolationConfiguration"
scout_compute_resolved_api_ResampleInterpolationConfiguration.__qualname__ = "ResampleInterpolationConfiguration"
scout_compute_resolved_api_ResampleInterpolationConfiguration.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor:

    @abstractmethod
    def _forward_fill_resample_interpolation_configuration(self, forward_fill_resample_interpolation_configuration: "scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration") -> Any:
        pass


scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor.__name__ = "ResampleInterpolationConfigurationVisitor"
scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor.__qualname__ = "ResampleInterpolationConfigurationVisitor"
scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResolvedNode(ConjureUnionType):
    _ranges: Optional["scout_compute_resolved_api_SummarizeRangesNode"] = None
    _series: Optional["scout_compute_resolved_api_SummarizeSeriesNode"] = None
    _value: Optional["scout_compute_resolved_api_SelectValueNode"] = None
    _cartesian: Optional["scout_compute_resolved_api_SummarizeCartesianNode"] = None
    _frequency: Optional["scout_compute_resolved_api_FrequencyDomainNode"] = None
    _histogram: Optional["scout_compute_resolved_api_HistogramNode"] = None
    _geo: Optional["scout_compute_resolved_api_SummarizeGeoNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_resolved_api_SummarizeRangesNode),
            'series': ConjureFieldDefinition('series', scout_compute_resolved_api_SummarizeSeriesNode),
            'value': ConjureFieldDefinition('value', scout_compute_resolved_api_SelectValueNode),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_resolved_api_SummarizeCartesianNode),
            'frequency': ConjureFieldDefinition('frequency', scout_compute_resolved_api_FrequencyDomainNode),
            'histogram': ConjureFieldDefinition('histogram', scout_compute_resolved_api_HistogramNode),
            'geo': ConjureFieldDefinition('geo', scout_compute_resolved_api_SummarizeGeoNode)
        }

    def __init__(
            self,
            ranges: Optional["scout_compute_resolved_api_SummarizeRangesNode"] = None,
            series: Optional["scout_compute_resolved_api_SummarizeSeriesNode"] = None,
            value: Optional["scout_compute_resolved_api_SelectValueNode"] = None,
            cartesian: Optional["scout_compute_resolved_api_SummarizeCartesianNode"] = None,
            frequency: Optional["scout_compute_resolved_api_FrequencyDomainNode"] = None,
            histogram: Optional["scout_compute_resolved_api_HistogramNode"] = None,
            geo: Optional["scout_compute_resolved_api_SummarizeGeoNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (ranges is not None) + (series is not None) + (value is not None) + (cartesian is not None) + (frequency is not None) + (histogram is not None) + (geo is not None) != 1:
                raise ValueError('a union must contain a single member')

            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'
            if series is not None:
                self._series = series
                self._type = 'series'
            if value is not None:
                self._value = value
                self._type = 'value'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if frequency is not None:
                self._frequency = frequency
                self._type = 'frequency'
            if histogram is not None:
                self._histogram = histogram
                self._type = 'histogram'
            if geo is not None:
                self._geo = geo
                self._type = 'geo'

        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'frequency':
            if frequency is None:
                raise ValueError('a union value must not be None')
            self._frequency = frequency
            self._type = 'frequency'
        elif type_of_union == 'histogram':
            if histogram is None:
                raise ValueError('a union value must not be None')
            self._histogram = histogram
            self._type = 'histogram'
        elif type_of_union == 'geo':
            if geo is None:
                raise ValueError('a union value must not be None')
            self._geo = geo
            self._type = 'geo'

    @builtins.property
    def ranges(self) -> Optional["scout_compute_resolved_api_SummarizeRangesNode"]:
        return self._ranges

    @builtins.property
    def series(self) -> Optional["scout_compute_resolved_api_SummarizeSeriesNode"]:
        return self._series

    @builtins.property
    def value(self) -> Optional["scout_compute_resolved_api_SelectValueNode"]:
        return self._value

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_resolved_api_SummarizeCartesianNode"]:
        return self._cartesian

    @builtins.property
    def frequency(self) -> Optional["scout_compute_resolved_api_FrequencyDomainNode"]:
        return self._frequency

    @builtins.property
    def histogram(self) -> Optional["scout_compute_resolved_api_HistogramNode"]:
        return self._histogram

    @builtins.property
    def geo(self) -> Optional["scout_compute_resolved_api_SummarizeGeoNode"]:
        return self._geo

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_ResolvedNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_ResolvedNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'frequency' and self.frequency is not None:
            return visitor._frequency(self.frequency)
        if self._type == 'histogram' and self.histogram is not None:
            return visitor._histogram(self.histogram)
        if self._type == 'geo' and self.geo is not None:
            return visitor._geo(self.geo)


scout_compute_resolved_api_ResolvedNode.__name__ = "ResolvedNode"
scout_compute_resolved_api_ResolvedNode.__qualname__ = "ResolvedNode"
scout_compute_resolved_api_ResolvedNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResolvedNodeVisitor:

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_resolved_api_SummarizeRangesNode") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_compute_resolved_api_SummarizeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value(self, value: "scout_compute_resolved_api_SelectValueNode") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_resolved_api_SummarizeCartesianNode") -> Any:
        pass

    @abstractmethod
    def _frequency(self, frequency: "scout_compute_resolved_api_FrequencyDomainNode") -> Any:
        pass

    @abstractmethod
    def _histogram(self, histogram: "scout_compute_resolved_api_HistogramNode") -> Any:
        pass

    @abstractmethod
    def _geo(self, geo: "scout_compute_resolved_api_SummarizeGeoNode") -> Any:
        pass


scout_compute_resolved_api_ResolvedNodeVisitor.__name__ = "ResolvedNodeVisitor"
scout_compute_resolved_api_ResolvedNodeVisitor.__qualname__ = "ResolvedNodeVisitor"
scout_compute_resolved_api_ResolvedNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RollingOperationSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'window': ConjureFieldDefinition('window', scout_compute_resolved_api_Window),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_RollingOperator)
        }

    __slots__: List[str] = ['_input', '_window', '_operator']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", operator: "scout_compute_api_RollingOperator", window: "scout_compute_resolved_api_Window") -> None:
        self._input = input
        self._window = window
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def window(self) -> "scout_compute_resolved_api_Window":
        return self._window

    @builtins.property
    def operator(self) -> "scout_compute_api_RollingOperator":
        return self._operator


scout_compute_resolved_api_RollingOperationSeriesNode.__name__ = "RollingOperationSeriesNode"
scout_compute_resolved_api_RollingOperationSeriesNode.__qualname__ = "RollingOperationSeriesNode"
scout_compute_resolved_api_RollingOperationSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ScaleSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'scalar': ConjureFieldDefinition('scalar', float),
            'scalar_unit': ConjureFieldDefinition('scalarUnit', OptionalTypeWrapper[scout_units_api_UnitSymbol])
        }

    __slots__: List[str] = ['_input', '_scalar', '_scalar_unit']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", scalar: float, scalar_unit: Optional[str] = None) -> None:
        self._input = input
        self._scalar = scalar
        self._scalar_unit = scalar_unit

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def scalar(self) -> float:
        return self._scalar

    @builtins.property
    def scalar_unit(self) -> Optional[str]:
        return self._scalar_unit


scout_compute_resolved_api_ScaleSeriesNode.__name__ = "ScaleSeriesNode"
scout_compute_resolved_api_ScaleSeriesNode.__qualname__ = "ScaleSeriesNode"
scout_compute_resolved_api_ScaleSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ScatterNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_resolved_api_NumericSeriesNode),
            'y': ConjureFieldDefinition('y', scout_compute_resolved_api_NumericSeriesNode)
        }

    __slots__: List[str] = ['_x', '_y']

    def __init__(self, x: "scout_compute_resolved_api_NumericSeriesNode", y: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._x = x
        self._y = y

    @builtins.property
    def x(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._y


scout_compute_resolved_api_ScatterNode.__name__ = "ScatterNode"
scout_compute_resolved_api_ScatterNode.__qualname__ = "ScatterNode"
scout_compute_resolved_api_ScatterNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SelectValueNode(ConjureUnionType):
    _first_point: Optional["scout_compute_resolved_api_SeriesNode"] = None
    _first_range: Optional["scout_compute_resolved_api_RangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_resolved_api_SeriesNode),
            'first_range': ConjureFieldDefinition('firstRange', scout_compute_resolved_api_RangesNode)
        }

    def __init__(
            self,
            first_point: Optional["scout_compute_resolved_api_SeriesNode"] = None,
            first_range: Optional["scout_compute_resolved_api_RangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (first_point is not None) + (first_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if first_point is not None:
                self._first_point = first_point
                self._type = 'firstPoint'
            if first_range is not None:
                self._first_range = first_range
                self._type = 'firstRange'

        elif type_of_union == 'firstPoint':
            if first_point is None:
                raise ValueError('a union value must not be None')
            self._first_point = first_point
            self._type = 'firstPoint'
        elif type_of_union == 'firstRange':
            if first_range is None:
                raise ValueError('a union value must not be None')
            self._first_range = first_range
            self._type = 'firstRange'

    @builtins.property
    def first_point(self) -> Optional["scout_compute_resolved_api_SeriesNode"]:
        return self._first_point

    @builtins.property
    def first_range(self) -> Optional["scout_compute_resolved_api_RangesNode"]:
        return self._first_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_SelectValueNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_SelectValueNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'firstPoint' and self.first_point is not None:
            return visitor._first_point(self.first_point)
        if self._type == 'firstRange' and self.first_range is not None:
            return visitor._first_range(self.first_range)


scout_compute_resolved_api_SelectValueNode.__name__ = "SelectValueNode"
scout_compute_resolved_api_SelectValueNode.__qualname__ = "SelectValueNode"
scout_compute_resolved_api_SelectValueNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SelectValueNodeVisitor:

    @abstractmethod
    def _first_point(self, first_point: "scout_compute_resolved_api_SeriesNode") -> Any:
        pass

    @abstractmethod
    def _first_range(self, first_range: "scout_compute_resolved_api_RangesNode") -> Any:
        pass


scout_compute_resolved_api_SelectValueNodeVisitor.__name__ = "SelectValueNodeVisitor"
scout_compute_resolved_api_SelectValueNodeVisitor.__qualname__ = "SelectValueNodeVisitor"
scout_compute_resolved_api_SelectValueNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SeriesCrossoverRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input_a': ConjureFieldDefinition('inputA', scout_compute_resolved_api_NumericSeriesNode),
            'input_b': ConjureFieldDefinition('inputB', scout_compute_resolved_api_NumericSeriesNode)
        }

    __slots__: List[str] = ['_input_a', '_input_b']

    def __init__(self, input_a: "scout_compute_resolved_api_NumericSeriesNode", input_b: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input_a = input_a
        self._input_b = input_b

    @builtins.property
    def input_a(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input_a

    @builtins.property
    def input_b(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input_b


scout_compute_resolved_api_SeriesCrossoverRangesNode.__name__ = "SeriesCrossoverRangesNode"
scout_compute_resolved_api_SeriesCrossoverRangesNode.__qualname__ = "SeriesCrossoverRangesNode"
scout_compute_resolved_api_SeriesCrossoverRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_resolved_api_RawUntypedSeriesNode"] = None
    _enum: Optional["scout_compute_resolved_api_EnumSeriesNode"] = None
    _numeric: Optional["scout_compute_resolved_api_NumericSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_RawUntypedSeriesNode),
            'enum': ConjureFieldDefinition('enum', scout_compute_resolved_api_EnumSeriesNode),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_resolved_api_NumericSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_resolved_api_RawUntypedSeriesNode"] = None,
            enum: Optional["scout_compute_resolved_api_EnumSeriesNode"] = None,
            numeric: Optional["scout_compute_resolved_api_NumericSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (enum is not None) + (numeric is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_RawUntypedSeriesNode"]:
        return self._raw

    @builtins.property
    def enum(self) -> Optional["scout_compute_resolved_api_EnumSeriesNode"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._numeric

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_SeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_SeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)


scout_compute_resolved_api_SeriesNode.__name__ = "SeriesNode"
scout_compute_resolved_api_SeriesNode.__qualname__ = "SeriesNode"
scout_compute_resolved_api_SeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_RawUntypedSeriesNode") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_resolved_api_EnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_resolved_api_NumericSeriesNode") -> Any:
        pass


scout_compute_resolved_api_SeriesNodeVisitor.__name__ = "SeriesNodeVisitor"
scout_compute_resolved_api_SeriesNodeVisitor.__qualname__ = "SeriesNodeVisitor"
scout_compute_resolved_api_SeriesNodeVisitor.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_StaleRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_SeriesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_run_api_Duration),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp)
        }

    __slots__: List[str] = ['_input', '_threshold', '_start_timestamp']

    def __init__(self, input: "scout_compute_resolved_api_SeriesNode", start_timestamp: "api_Timestamp", threshold: "scout_run_api_Duration") -> None:
        self._input = input
        self._threshold = threshold
        self._start_timestamp = start_timestamp

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_SeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_run_api_Duration":
        return self._threshold

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp


scout_compute_resolved_api_StaleRangesNode.__name__ = "StaleRangesNode"
scout_compute_resolved_api_StaleRangesNode.__qualname__ = "StaleRangesNode"
scout_compute_resolved_api_StaleRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_SumSeriesNode.__name__ = "SumSeriesNode"
scout_compute_resolved_api_SumSeriesNode.__qualname__ = "SumSeriesNode"
scout_compute_resolved_api_SumSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SummarizeCartesianNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_CartesianNode),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_resolved_api_CartesianBounds]),
            'max_points': ConjureFieldDefinition('maxPoints', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_bounds', '_max_points']

    def __init__(self, input: "scout_compute_resolved_api_CartesianNode", bounds: Optional["scout_compute_resolved_api_CartesianBounds"] = None, max_points: Optional[int] = None) -> None:
        self._input = input
        self._bounds = bounds
        self._max_points = max_points

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_CartesianNode":
        return self._input

    @builtins.property
    def bounds(self) -> Optional["scout_compute_resolved_api_CartesianBounds"]:
        return self._bounds

    @builtins.property
    def max_points(self) -> Optional[int]:
        return self._max_points


scout_compute_resolved_api_SummarizeCartesianNode.__name__ = "SummarizeCartesianNode"
scout_compute_resolved_api_SummarizeCartesianNode.__qualname__ = "SummarizeCartesianNode"
scout_compute_resolved_api_SummarizeCartesianNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SummarizeGeoNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_GeoNode),
            'summary_strategy': ConjureFieldDefinition('summaryStrategy', scout_compute_resolved_api_GeoNodeSummaryStrategy)
        }

    __slots__: List[str] = ['_input', '_summary_strategy']

    def __init__(self, input: "scout_compute_resolved_api_GeoNode", summary_strategy: "scout_compute_resolved_api_GeoNodeSummaryStrategy") -> None:
        self._input = input
        self._summary_strategy = summary_strategy

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_GeoNode":
        return self._input

    @builtins.property
    def summary_strategy(self) -> "scout_compute_resolved_api_GeoNodeSummaryStrategy":
        return self._summary_strategy


scout_compute_resolved_api_SummarizeGeoNode.__name__ = "SummarizeGeoNode"
scout_compute_resolved_api_SummarizeGeoNode.__qualname__ = "SummarizeGeoNode"
scout_compute_resolved_api_SummarizeGeoNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SummarizeRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_RangesNode),
            'max_ranges': ConjureFieldDefinition('maxRanges', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_max_ranges']

    def __init__(self, input: "scout_compute_resolved_api_RangesNode", max_ranges: Optional[int] = None) -> None:
        self._input = input
        self._max_ranges = max_ranges

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_RangesNode":
        return self._input

    @builtins.property
    def max_ranges(self) -> Optional[int]:
        return self._max_ranges


scout_compute_resolved_api_SummarizeRangesNode.__name__ = "SummarizeRangesNode"
scout_compute_resolved_api_SummarizeRangesNode.__qualname__ = "SummarizeRangesNode"
scout_compute_resolved_api_SummarizeRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SummarizeSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_SeriesNode),
            'resolution': ConjureFieldDefinition('resolution', int)
        }

    __slots__: List[str] = ['_input', '_resolution']

    def __init__(self, input: "scout_compute_resolved_api_SeriesNode", resolution: int) -> None:
        self._input = input
        self._resolution = resolution

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_SeriesNode":
        return self._input

    @builtins.property
    def resolution(self) -> int:
        return self._resolution


scout_compute_resolved_api_SummarizeSeriesNode.__name__ = "SummarizeSeriesNode"
scout_compute_resolved_api_SummarizeSeriesNode.__qualname__ = "SummarizeSeriesNode"
scout_compute_resolved_api_SummarizeSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ThresholdingRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'threshold': ConjureFieldDefinition('threshold', float),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_resolved_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_threshold', '_operator', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", operator: "scout_compute_api_ThresholdOperator", threshold: float, persistence_window_configuration: Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._operator = operator
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> float:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_resolved_api_ThresholdingRangesNode.__name__ = "ThresholdingRangesNode"
scout_compute_resolved_api_ThresholdingRangesNode.__qualname__ = "ThresholdingRangesNode"
scout_compute_resolved_api_ThresholdingRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_TimeDifferenceSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_SeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[scout_compute_api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_time_unit']

    def __init__(self, input: "scout_compute_resolved_api_SeriesNode", time_unit: Optional["scout_compute_api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_SeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["scout_compute_api_TimeUnit"]:
        return self._time_unit


scout_compute_resolved_api_TimeDifferenceSeriesNode.__name__ = "TimeDifferenceSeriesNode"
scout_compute_resolved_api_TimeDifferenceSeriesNode.__qualname__ = "TimeDifferenceSeriesNode"
scout_compute_resolved_api_TimeDifferenceSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_UnaryArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_UnaryArithmeticOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", operation: "scout_compute_api_UnaryArithmeticOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_UnaryArithmeticOperation":
        return self._operation


scout_compute_resolved_api_UnaryArithmeticSeriesNode.__name__ = "UnaryArithmeticSeriesNode"
scout_compute_resolved_api_UnaryArithmeticSeriesNode.__qualname__ = "UnaryArithmeticSeriesNode"
scout_compute_resolved_api_UnaryArithmeticSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_UnionRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_resolved_api_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_RangesNode"]:
        return self._inputs


scout_compute_resolved_api_UnionRangesNode.__name__ = "UnionRangesNode"
scout_compute_resolved_api_UnionRangesNode.__qualname__ = "UnionRangesNode"
scout_compute_resolved_api_UnionRangesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_UnitConversionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'output_unit': ConjureFieldDefinition('outputUnit', scout_units_api_UnitSymbol)
        }

    __slots__: List[str] = ['_input', '_output_unit']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", output_unit: str) -> None:
        self._input = input
        self._output_unit = output_unit

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def output_unit(self) -> str:
        return self._output_unit


scout_compute_resolved_api_UnitConversionSeriesNode.__name__ = "UnitConversionSeriesNode"
scout_compute_resolved_api_UnitConversionSeriesNode.__qualname__ = "UnitConversionSeriesNode"
scout_compute_resolved_api_UnitConversionSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ValueDifferenceSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None) -> None:
        self._input = input
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        return self._negative_values_configuration


scout_compute_resolved_api_ValueDifferenceSeriesNode.__name__ = "ValueDifferenceSeriesNode"
scout_compute_resolved_api_ValueDifferenceSeriesNode.__qualname__ = "ValueDifferenceSeriesNode"
scout_compute_resolved_api_ValueDifferenceSeriesNode.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_compute_resolved_api_Window(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_duration']

    def __init__(self, duration: "scout_run_api_Duration") -> None:
        self._duration = duration

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_resolved_api_Window.__name__ = "Window"
scout_compute_resolved_api_Window.__qualname__ = "Window"
scout_compute_resolved_api_Window.__module__ = "scout_service_api.scout_compute_resolved_api"


class scout_dataexport_api_AllTimestampsForwardFillStrategy(ConjureBeanType):
    """
    All timestamps will be kept.
The value of a channel at a timestamp will be its latest
value, within the provided look back period.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'look_back_period': ConjureFieldDefinition('lookBackPeriod', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_look_back_period']

    def __init__(self, look_back_period: "scout_run_api_Duration") -> None:
        self._look_back_period = look_back_period

    @builtins.property
    def look_back_period(self) -> "scout_run_api_Duration":
        return self._look_back_period


scout_dataexport_api_AllTimestampsForwardFillStrategy.__name__ = "AllTimestampsForwardFillStrategy"
scout_dataexport_api_AllTimestampsForwardFillStrategy.__qualname__ = "AllTimestampsForwardFillStrategy"
scout_dataexport_api_AllTimestampsForwardFillStrategy.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_CompressionFormat(ConjureEnumType):

    GZIP = 'GZIP'
    '''GZIP'''
    ZIP = 'ZIP'
    '''ZIP'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_dataexport_api_CompressionFormat.__name__ = "CompressionFormat"
scout_dataexport_api_CompressionFormat.__qualname__ = "CompressionFormat"
scout_dataexport_api_CompressionFormat.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_Csv(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_Csv.__name__ = "Csv"
scout_dataexport_api_Csv.__qualname__ = "Csv"
scout_dataexport_api_Csv.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_DataExportService(Service):
    """
    Provides functionality for exporting data from Scout.
    """

    def export_channel_data(self, auth_header: str, request: "scout_dataexport_api_ExportDataRequest") -> Any:
        """
        Required permissions matches those required to compute the channels via the compute API.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/export/v1/export'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw


scout_dataexport_api_DataExportService.__name__ = "DataExportService"
scout_dataexport_api_DataExportService.__qualname__ = "DataExportService"
scout_dataexport_api_DataExportService.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_ExportChannels(ConjureUnionType):
    _time_domain: Optional["scout_dataexport_api_ExportTimeDomainChannels"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_domain': ConjureFieldDefinition('timeDomain', scout_dataexport_api_ExportTimeDomainChannels)
        }

    def __init__(
            self,
            time_domain: Optional["scout_dataexport_api_ExportTimeDomainChannels"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (time_domain is not None) != 1:
                raise ValueError('a union must contain a single member')

            if time_domain is not None:
                self._time_domain = time_domain
                self._type = 'timeDomain'

        elif type_of_union == 'timeDomain':
            if time_domain is None:
                raise ValueError('a union value must not be None')
            self._time_domain = time_domain
            self._type = 'timeDomain'

    @builtins.property
    def time_domain(self) -> Optional["scout_dataexport_api_ExportTimeDomainChannels"]:
        return self._time_domain

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_ExportChannelsVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_ExportChannelsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timeDomain' and self.time_domain is not None:
            return visitor._time_domain(self.time_domain)


scout_dataexport_api_ExportChannels.__name__ = "ExportChannels"
scout_dataexport_api_ExportChannels.__qualname__ = "ExportChannels"
scout_dataexport_api_ExportChannels.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_ExportChannelsVisitor:

    @abstractmethod
    def _time_domain(self, time_domain: "scout_dataexport_api_ExportTimeDomainChannels") -> Any:
        pass


scout_dataexport_api_ExportChannelsVisitor.__name__ = "ExportChannelsVisitor"
scout_dataexport_api_ExportChannelsVisitor.__qualname__ = "ExportChannelsVisitor"
scout_dataexport_api_ExportChannelsVisitor.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_ExportDataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'format': ConjureFieldDefinition('format', scout_dataexport_api_ExportFormat),
            'compression': ConjureFieldDefinition('compression', OptionalTypeWrapper[scout_dataexport_api_CompressionFormat]),
            'start_time': ConjureFieldDefinition('startTime', api_Timestamp),
            'end_time': ConjureFieldDefinition('endTime', api_Timestamp),
            'resolution': ConjureFieldDefinition('resolution', scout_dataexport_api_ResolutionOption),
            'channels': ConjureFieldDefinition('channels', scout_dataexport_api_ExportChannels),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_format', '_compression', '_start_time', '_end_time', '_resolution', '_channels', '_context']

    def __init__(self, channels: "scout_dataexport_api_ExportChannels", context: "scout_compute_api_Context", end_time: "api_Timestamp", format: "scout_dataexport_api_ExportFormat", resolution: "scout_dataexport_api_ResolutionOption", start_time: "api_Timestamp", compression: Optional["scout_dataexport_api_CompressionFormat"] = None) -> None:
        self._format = format
        self._compression = compression
        self._start_time = start_time
        self._end_time = end_time
        self._resolution = resolution
        self._channels = channels
        self._context = context

    @builtins.property
    def format(self) -> "scout_dataexport_api_ExportFormat":
        return self._format

    @builtins.property
    def compression(self) -> Optional["scout_dataexport_api_CompressionFormat"]:
        return self._compression

    @builtins.property
    def start_time(self) -> "api_Timestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> "api_Timestamp":
        return self._end_time

    @builtins.property
    def resolution(self) -> "scout_dataexport_api_ResolutionOption":
        return self._resolution

    @builtins.property
    def channels(self) -> "scout_dataexport_api_ExportChannels":
        return self._channels

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_dataexport_api_ExportDataRequest.__name__ = "ExportDataRequest"
scout_dataexport_api_ExportDataRequest.__qualname__ = "ExportDataRequest"
scout_dataexport_api_ExportDataRequest.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_ExportFormat(ConjureUnionType):
    _csv: Optional["scout_dataexport_api_Csv"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'csv': ConjureFieldDefinition('csv', scout_dataexport_api_Csv)
        }

    def __init__(
            self,
            csv: Optional["scout_dataexport_api_Csv"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (csv is not None) != 1:
                raise ValueError('a union must contain a single member')

            if csv is not None:
                self._csv = csv
                self._type = 'csv'

        elif type_of_union == 'csv':
            if csv is None:
                raise ValueError('a union value must not be None')
            self._csv = csv
            self._type = 'csv'

    @builtins.property
    def csv(self) -> Optional["scout_dataexport_api_Csv"]:
        return self._csv

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_ExportFormatVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_ExportFormatVisitor'.format(visitor.__class__.__name__))
        if self._type == 'csv' and self.csv is not None:
            return visitor._csv(self.csv)


scout_dataexport_api_ExportFormat.__name__ = "ExportFormat"
scout_dataexport_api_ExportFormat.__qualname__ = "ExportFormat"
scout_dataexport_api_ExportFormat.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_ExportFormatVisitor:

    @abstractmethod
    def _csv(self, csv: "scout_dataexport_api_Csv") -> Any:
        pass


scout_dataexport_api_ExportFormatVisitor.__name__ = "ExportFormatVisitor"
scout_dataexport_api_ExportFormatVisitor.__qualname__ = "ExportFormatVisitor"
scout_dataexport_api_ExportFormatVisitor.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_ExportTimeDomainChannels(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'output_timestamp_format': ConjureFieldDefinition('outputTimestampFormat', scout_dataexport_api_TimestampFormat),
            'merge_timestamp_strategy': ConjureFieldDefinition('mergeTimestampStrategy', scout_dataexport_api_MergeTimestampStrategy),
            'channels': ConjureFieldDefinition('channels', List[scout_dataexport_api_TimeDomainChannel])
        }

    __slots__: List[str] = ['_output_timestamp_format', '_merge_timestamp_strategy', '_channels']

    def __init__(self, channels: List["scout_dataexport_api_TimeDomainChannel"], merge_timestamp_strategy: "scout_dataexport_api_MergeTimestampStrategy", output_timestamp_format: "scout_dataexport_api_TimestampFormat") -> None:
        self._output_timestamp_format = output_timestamp_format
        self._merge_timestamp_strategy = merge_timestamp_strategy
        self._channels = channels

    @builtins.property
    def output_timestamp_format(self) -> "scout_dataexport_api_TimestampFormat":
        return self._output_timestamp_format

    @builtins.property
    def merge_timestamp_strategy(self) -> "scout_dataexport_api_MergeTimestampStrategy":
        return self._merge_timestamp_strategy

    @builtins.property
    def channels(self) -> List["scout_dataexport_api_TimeDomainChannel"]:
        return self._channels


scout_dataexport_api_ExportTimeDomainChannels.__name__ = "ExportTimeDomainChannels"
scout_dataexport_api_ExportTimeDomainChannels.__qualname__ = "ExportTimeDomainChannels"
scout_dataexport_api_ExportTimeDomainChannels.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_Iso8601TimestampFormat(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_Iso8601TimestampFormat.__name__ = "Iso8601TimestampFormat"
scout_dataexport_api_Iso8601TimestampFormat.__qualname__ = "Iso8601TimestampFormat"
scout_dataexport_api_Iso8601TimestampFormat.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_MergeTimestampStrategy(ConjureUnionType):
    """How to handle timestamps that are not aligned."""
    _none: Optional["scout_dataexport_api_NoneStrategy"] = None
    _all_timestamps_forward_fill: Optional["scout_dataexport_api_AllTimestampsForwardFillStrategy"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'none': ConjureFieldDefinition('none', scout_dataexport_api_NoneStrategy),
            'all_timestamps_forward_fill': ConjureFieldDefinition('allTimestampsForwardFill', scout_dataexport_api_AllTimestampsForwardFillStrategy)
        }

    def __init__(
            self,
            none: Optional["scout_dataexport_api_NoneStrategy"] = None,
            all_timestamps_forward_fill: Optional["scout_dataexport_api_AllTimestampsForwardFillStrategy"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (none is not None) + (all_timestamps_forward_fill is not None) != 1:
                raise ValueError('a union must contain a single member')

            if none is not None:
                self._none = none
                self._type = 'none'
            if all_timestamps_forward_fill is not None:
                self._all_timestamps_forward_fill = all_timestamps_forward_fill
                self._type = 'allTimestampsForwardFill'

        elif type_of_union == 'none':
            if none is None:
                raise ValueError('a union value must not be None')
            self._none = none
            self._type = 'none'
        elif type_of_union == 'allTimestampsForwardFill':
            if all_timestamps_forward_fill is None:
                raise ValueError('a union value must not be None')
            self._all_timestamps_forward_fill = all_timestamps_forward_fill
            self._type = 'allTimestampsForwardFill'

    @builtins.property
    def none(self) -> Optional["scout_dataexport_api_NoneStrategy"]:
        return self._none

    @builtins.property
    def all_timestamps_forward_fill(self) -> Optional["scout_dataexport_api_AllTimestampsForwardFillStrategy"]:
        return self._all_timestamps_forward_fill

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_MergeTimestampStrategyVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_MergeTimestampStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'none' and self.none is not None:
            return visitor._none(self.none)
        if self._type == 'allTimestampsForwardFill' and self.all_timestamps_forward_fill is not None:
            return visitor._all_timestamps_forward_fill(self.all_timestamps_forward_fill)


scout_dataexport_api_MergeTimestampStrategy.__name__ = "MergeTimestampStrategy"
scout_dataexport_api_MergeTimestampStrategy.__qualname__ = "MergeTimestampStrategy"
scout_dataexport_api_MergeTimestampStrategy.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_MergeTimestampStrategyVisitor:

    @abstractmethod
    def _none(self, none: "scout_dataexport_api_NoneStrategy") -> Any:
        pass

    @abstractmethod
    def _all_timestamps_forward_fill(self, all_timestamps_forward_fill: "scout_dataexport_api_AllTimestampsForwardFillStrategy") -> Any:
        pass


scout_dataexport_api_MergeTimestampStrategyVisitor.__name__ = "MergeTimestampStrategyVisitor"
scout_dataexport_api_MergeTimestampStrategyVisitor.__qualname__ = "MergeTimestampStrategyVisitor"
scout_dataexport_api_MergeTimestampStrategyVisitor.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_NoneStrategy(ConjureBeanType):
    """
    Do nothing. The value of a channel will be empty at
timestamps not present in its original time series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_NoneStrategy.__name__ = "NoneStrategy"
scout_dataexport_api_NoneStrategy.__qualname__ = "NoneStrategy"
scout_dataexport_api_NoneStrategy.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_RelativeTimestampFormat(ConjureBeanType):
    """
    Returns in relative time to the supplied timestamp.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'relative_to': ConjureFieldDefinition('relativeTo', api_Timestamp),
            'time_unit': ConjureFieldDefinition('timeUnit', scout_compute_api_TimeUnit)
        }

    __slots__: List[str] = ['_relative_to', '_time_unit']

    def __init__(self, relative_to: "api_Timestamp", time_unit: "scout_compute_api_TimeUnit") -> None:
        self._relative_to = relative_to
        self._time_unit = time_unit

    @builtins.property
    def relative_to(self) -> "api_Timestamp":
        return self._relative_to

    @builtins.property
    def time_unit(self) -> "scout_compute_api_TimeUnit":
        return self._time_unit


scout_dataexport_api_RelativeTimestampFormat.__name__ = "RelativeTimestampFormat"
scout_dataexport_api_RelativeTimestampFormat.__qualname__ = "RelativeTimestampFormat"
scout_dataexport_api_RelativeTimestampFormat.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_ResolutionOption(ConjureUnionType):
    """The minimum desired step between adjacent timestamps. If multiple values are available for a timestamp,
the mean of the values will be used for numeric types and the mode of the values will be used for enum types."""
    _nanoseconds: Optional[int] = None
    _undecimated: Optional["scout_dataexport_api_UndecimatedResolution"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'nanoseconds': ConjureFieldDefinition('nanoseconds', int),
            'undecimated': ConjureFieldDefinition('undecimated', scout_dataexport_api_UndecimatedResolution)
        }

    def __init__(
            self,
            nanoseconds: Optional[int] = None,
            undecimated: Optional["scout_dataexport_api_UndecimatedResolution"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (nanoseconds is not None) + (undecimated is not None) != 1:
                raise ValueError('a union must contain a single member')

            if nanoseconds is not None:
                self._nanoseconds = nanoseconds
                self._type = 'nanoseconds'
            if undecimated is not None:
                self._undecimated = undecimated
                self._type = 'undecimated'

        elif type_of_union == 'nanoseconds':
            if nanoseconds is None:
                raise ValueError('a union value must not be None')
            self._nanoseconds = nanoseconds
            self._type = 'nanoseconds'
        elif type_of_union == 'undecimated':
            if undecimated is None:
                raise ValueError('a union value must not be None')
            self._undecimated = undecimated
            self._type = 'undecimated'

    @builtins.property
    def nanoseconds(self) -> Optional[int]:
        return self._nanoseconds

    @builtins.property
    def undecimated(self) -> Optional["scout_dataexport_api_UndecimatedResolution"]:
        return self._undecimated

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_ResolutionOptionVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_ResolutionOptionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'nanoseconds' and self.nanoseconds is not None:
            return visitor._nanoseconds(self.nanoseconds)
        if self._type == 'undecimated' and self.undecimated is not None:
            return visitor._undecimated(self.undecimated)


scout_dataexport_api_ResolutionOption.__name__ = "ResolutionOption"
scout_dataexport_api_ResolutionOption.__qualname__ = "ResolutionOption"
scout_dataexport_api_ResolutionOption.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_ResolutionOptionVisitor:

    @abstractmethod
    def _nanoseconds(self, nanoseconds: int) -> Any:
        pass

    @abstractmethod
    def _undecimated(self, undecimated: "scout_dataexport_api_UndecimatedResolution") -> Any:
        pass


scout_dataexport_api_ResolutionOptionVisitor.__name__ = "ResolutionOptionVisitor"
scout_dataexport_api_ResolutionOptionVisitor.__qualname__ = "ResolutionOptionVisitor"
scout_dataexport_api_ResolutionOptionVisitor.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_TimeDomainChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'column_name': ConjureFieldDefinition('columnName', str),
            'compute_node': ConjureFieldDefinition('computeNode', scout_compute_api_SeriesNode)
        }

    __slots__: List[str] = ['_column_name', '_compute_node']

    def __init__(self, column_name: str, compute_node: "scout_compute_api_SeriesNode") -> None:
        self._column_name = column_name
        self._compute_node = compute_node

    @builtins.property
    def column_name(self) -> str:
        return self._column_name

    @builtins.property
    def compute_node(self) -> "scout_compute_api_SeriesNode":
        return self._compute_node


scout_dataexport_api_TimeDomainChannel.__name__ = "TimeDomainChannel"
scout_dataexport_api_TimeDomainChannel.__qualname__ = "TimeDomainChannel"
scout_dataexport_api_TimeDomainChannel.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_TimestampFormat(ConjureUnionType):
    _iso8601: Optional["scout_dataexport_api_Iso8601TimestampFormat"] = None
    _relative: Optional["scout_dataexport_api_RelativeTimestampFormat"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'iso8601': ConjureFieldDefinition('iso8601', scout_dataexport_api_Iso8601TimestampFormat),
            'relative': ConjureFieldDefinition('relative', scout_dataexport_api_RelativeTimestampFormat)
        }

    def __init__(
            self,
            iso8601: Optional["scout_dataexport_api_Iso8601TimestampFormat"] = None,
            relative: Optional["scout_dataexport_api_RelativeTimestampFormat"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (iso8601 is not None) + (relative is not None) != 1:
                raise ValueError('a union must contain a single member')

            if iso8601 is not None:
                self._iso8601 = iso8601
                self._type = 'iso8601'
            if relative is not None:
                self._relative = relative
                self._type = 'relative'

        elif type_of_union == 'iso8601':
            if iso8601 is None:
                raise ValueError('a union value must not be None')
            self._iso8601 = iso8601
            self._type = 'iso8601'
        elif type_of_union == 'relative':
            if relative is None:
                raise ValueError('a union value must not be None')
            self._relative = relative
            self._type = 'relative'

    @builtins.property
    def iso8601(self) -> Optional["scout_dataexport_api_Iso8601TimestampFormat"]:
        return self._iso8601

    @builtins.property
    def relative(self) -> Optional["scout_dataexport_api_RelativeTimestampFormat"]:
        return self._relative

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_TimestampFormatVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_TimestampFormatVisitor'.format(visitor.__class__.__name__))
        if self._type == 'iso8601' and self.iso8601 is not None:
            return visitor._iso8601(self.iso8601)
        if self._type == 'relative' and self.relative is not None:
            return visitor._relative(self.relative)


scout_dataexport_api_TimestampFormat.__name__ = "TimestampFormat"
scout_dataexport_api_TimestampFormat.__qualname__ = "TimestampFormat"
scout_dataexport_api_TimestampFormat.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_TimestampFormatVisitor:

    @abstractmethod
    def _iso8601(self, iso8601: "scout_dataexport_api_Iso8601TimestampFormat") -> Any:
        pass

    @abstractmethod
    def _relative(self, relative: "scout_dataexport_api_RelativeTimestampFormat") -> Any:
        pass


scout_dataexport_api_TimestampFormatVisitor.__name__ = "TimestampFormatVisitor"
scout_dataexport_api_TimestampFormatVisitor.__qualname__ = "TimestampFormatVisitor"
scout_dataexport_api_TimestampFormatVisitor.__module__ = "scout_service_api.scout_dataexport_api"


class scout_dataexport_api_UndecimatedResolution(ConjureBeanType):
    """
    Full resolution.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_UndecimatedResolution.__name__ = "UndecimatedResolution"
scout_dataexport_api_UndecimatedResolution.__qualname__ = "UndecimatedResolution"
scout_dataexport_api_UndecimatedResolution.__module__ = "scout_service_api.scout_dataexport_api"


class scout_datareview_api_AutomaticCheckEvaluation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_datareview_api_AutomaticCheckEvaluationRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'check_implementation_index': ConjureFieldDefinition('checkImplementationIndex', OptionalTypeWrapper[int]),
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_datareview_api_DataReviewRid),
            'state': ConjureFieldDefinition('state', scout_datareview_api_AutomaticCheckEvaluationState)
        }

    __slots__: List[str] = ['_rid', '_check_rid', '_check_implementation_index', '_data_review_rid', '_state']

    def __init__(self, check_rid: str, data_review_rid: str, rid: str, state: "scout_datareview_api_AutomaticCheckEvaluationState", check_implementation_index: Optional[int] = None) -> None:
        self._rid = rid
        self._check_rid = check_rid
        self._check_implementation_index = check_implementation_index
        self._data_review_rid = data_review_rid
        self._state = state

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def check_implementation_index(self) -> Optional[int]:
        """
        Checks can define a single range computation which can evaluate over multiple implementations of a context.
The check implementation index will correspond to the implementation index of the check condition.
        """
        return self._check_implementation_index

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def state(self) -> "scout_datareview_api_AutomaticCheckEvaluationState":
        return self._state


scout_datareview_api_AutomaticCheckEvaluation.__name__ = "AutomaticCheckEvaluation"
scout_datareview_api_AutomaticCheckEvaluation.__qualname__ = "AutomaticCheckEvaluation"
scout_datareview_api_AutomaticCheckEvaluation.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationAction(ConjureUnionType):
    _execution_finished: Optional["scout_datareview_api_AutomaticCheckExecutionFinished"] = None
    _execution_failed_to_run: Optional["scout_datareview_api_AutomaticCheckExecutionFailedToRun"] = None
    _execution_retriggered: Optional["scout_datareview_api_ExecutionRetriggered"] = None
    _execution_started: Optional["scout_datareview_api_AutomaticCheckExecutionStarted"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'execution_finished': ConjureFieldDefinition('executionFinished', scout_datareview_api_AutomaticCheckExecutionFinished),
            'execution_failed_to_run': ConjureFieldDefinition('executionFailedToRun', scout_datareview_api_AutomaticCheckExecutionFailedToRun),
            'execution_retriggered': ConjureFieldDefinition('executionRetriggered', scout_datareview_api_ExecutionRetriggered),
            'execution_started': ConjureFieldDefinition('executionStarted', scout_datareview_api_AutomaticCheckExecutionStarted)
        }

    def __init__(
            self,
            execution_finished: Optional["scout_datareview_api_AutomaticCheckExecutionFinished"] = None,
            execution_failed_to_run: Optional["scout_datareview_api_AutomaticCheckExecutionFailedToRun"] = None,
            execution_retriggered: Optional["scout_datareview_api_ExecutionRetriggered"] = None,
            execution_started: Optional["scout_datareview_api_AutomaticCheckExecutionStarted"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (execution_finished is not None) + (execution_failed_to_run is not None) + (execution_retriggered is not None) + (execution_started is not None) != 1:
                raise ValueError('a union must contain a single member')

            if execution_finished is not None:
                self._execution_finished = execution_finished
                self._type = 'executionFinished'
            if execution_failed_to_run is not None:
                self._execution_failed_to_run = execution_failed_to_run
                self._type = 'executionFailedToRun'
            if execution_retriggered is not None:
                self._execution_retriggered = execution_retriggered
                self._type = 'executionRetriggered'
            if execution_started is not None:
                self._execution_started = execution_started
                self._type = 'executionStarted'

        elif type_of_union == 'executionFinished':
            if execution_finished is None:
                raise ValueError('a union value must not be None')
            self._execution_finished = execution_finished
            self._type = 'executionFinished'
        elif type_of_union == 'executionFailedToRun':
            if execution_failed_to_run is None:
                raise ValueError('a union value must not be None')
            self._execution_failed_to_run = execution_failed_to_run
            self._type = 'executionFailedToRun'
        elif type_of_union == 'executionRetriggered':
            if execution_retriggered is None:
                raise ValueError('a union value must not be None')
            self._execution_retriggered = execution_retriggered
            self._type = 'executionRetriggered'
        elif type_of_union == 'executionStarted':
            if execution_started is None:
                raise ValueError('a union value must not be None')
            self._execution_started = execution_started
            self._type = 'executionStarted'

    @builtins.property
    def execution_finished(self) -> Optional["scout_datareview_api_AutomaticCheckExecutionFinished"]:
        return self._execution_finished

    @builtins.property
    def execution_failed_to_run(self) -> Optional["scout_datareview_api_AutomaticCheckExecutionFailedToRun"]:
        return self._execution_failed_to_run

    @builtins.property
    def execution_retriggered(self) -> Optional["scout_datareview_api_ExecutionRetriggered"]:
        return self._execution_retriggered

    @builtins.property
    def execution_started(self) -> Optional["scout_datareview_api_AutomaticCheckExecutionStarted"]:
        return self._execution_started

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_AutomaticCheckEvaluationActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_AutomaticCheckEvaluationActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'executionFinished' and self.execution_finished is not None:
            return visitor._execution_finished(self.execution_finished)
        if self._type == 'executionFailedToRun' and self.execution_failed_to_run is not None:
            return visitor._execution_failed_to_run(self.execution_failed_to_run)
        if self._type == 'executionRetriggered' and self.execution_retriggered is not None:
            return visitor._execution_retriggered(self.execution_retriggered)
        if self._type == 'executionStarted' and self.execution_started is not None:
            return visitor._execution_started(self.execution_started)


scout_datareview_api_AutomaticCheckEvaluationAction.__name__ = "AutomaticCheckEvaluationAction"
scout_datareview_api_AutomaticCheckEvaluationAction.__qualname__ = "AutomaticCheckEvaluationAction"
scout_datareview_api_AutomaticCheckEvaluationAction.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationActionVisitor:

    @abstractmethod
    def _execution_finished(self, execution_finished: "scout_datareview_api_AutomaticCheckExecutionFinished") -> Any:
        pass

    @abstractmethod
    def _execution_failed_to_run(self, execution_failed_to_run: "scout_datareview_api_AutomaticCheckExecutionFailedToRun") -> Any:
        pass

    @abstractmethod
    def _execution_retriggered(self, execution_retriggered: "scout_datareview_api_ExecutionRetriggered") -> Any:
        pass

    @abstractmethod
    def _execution_started(self, execution_started: "scout_datareview_api_AutomaticCheckExecutionStarted") -> Any:
        pass


scout_datareview_api_AutomaticCheckEvaluationActionVisitor.__name__ = "AutomaticCheckEvaluationActionVisitor"
scout_datareview_api_AutomaticCheckEvaluationActionVisitor.__qualname__ = "AutomaticCheckEvaluationActionVisitor"
scout_datareview_api_AutomaticCheckEvaluationActionVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationActionLog(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'entries': ConjureFieldDefinition('entries', List[scout_datareview_api_AutomaticCheckEvaluationActionLogEntry])
        }

    __slots__: List[str] = ['_entries']

    def __init__(self, entries: List["scout_datareview_api_AutomaticCheckEvaluationActionLogEntry"]) -> None:
        self._entries = entries

    @builtins.property
    def entries(self) -> List["scout_datareview_api_AutomaticCheckEvaluationActionLogEntry"]:
        return self._entries


scout_datareview_api_AutomaticCheckEvaluationActionLog.__name__ = "AutomaticCheckEvaluationActionLog"
scout_datareview_api_AutomaticCheckEvaluationActionLog.__qualname__ = "AutomaticCheckEvaluationActionLog"
scout_datareview_api_AutomaticCheckEvaluationActionLog.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationActionLogEntry(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'action': ConjureFieldDefinition('action', scout_datareview_api_AutomaticCheckEvaluationAction),
            'timestamp': ConjureFieldDefinition('timestamp', str)
        }

    __slots__: List[str] = ['_action', '_timestamp']

    def __init__(self, action: "scout_datareview_api_AutomaticCheckEvaluationAction", timestamp: str) -> None:
        self._action = action
        self._timestamp = timestamp

    @builtins.property
    def action(self) -> "scout_datareview_api_AutomaticCheckEvaluationAction":
        return self._action

    @builtins.property
    def timestamp(self) -> str:
        return self._timestamp


scout_datareview_api_AutomaticCheckEvaluationActionLogEntry.__name__ = "AutomaticCheckEvaluationActionLogEntry"
scout_datareview_api_AutomaticCheckEvaluationActionLogEntry.__qualname__ = "AutomaticCheckEvaluationActionLogEntry"
scout_datareview_api_AutomaticCheckEvaluationActionLogEntry.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationReviewAction(ConjureUnionType):
    _close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None
    _close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None
    _reopen: Optional["scout_datareview_api_Reopen"] = None
    _reassign: Optional["scout_datareview_api_Reassign"] = None
    _update_notes: Optional["scout_datareview_api_UpdateNotes"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_with_ignore': ConjureFieldDefinition('closeWithIgnore', scout_datareview_api_CloseWithIgnoreAlert),
            'close_with_further_action': ConjureFieldDefinition('closeWithFurtherAction', scout_datareview_api_CloseWithFurtherAction),
            'reopen': ConjureFieldDefinition('reopen', scout_datareview_api_Reopen),
            'reassign': ConjureFieldDefinition('reassign', scout_datareview_api_Reassign),
            'update_notes': ConjureFieldDefinition('updateNotes', scout_datareview_api_UpdateNotes)
        }

    def __init__(
            self,
            close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None,
            close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None,
            reopen: Optional["scout_datareview_api_Reopen"] = None,
            reassign: Optional["scout_datareview_api_Reassign"] = None,
            update_notes: Optional["scout_datareview_api_UpdateNotes"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (close_with_ignore is not None) + (close_with_further_action is not None) + (reopen is not None) + (reassign is not None) + (update_notes is not None) != 1:
                raise ValueError('a union must contain a single member')

            if close_with_ignore is not None:
                self._close_with_ignore = close_with_ignore
                self._type = 'closeWithIgnore'
            if close_with_further_action is not None:
                self._close_with_further_action = close_with_further_action
                self._type = 'closeWithFurtherAction'
            if reopen is not None:
                self._reopen = reopen
                self._type = 'reopen'
            if reassign is not None:
                self._reassign = reassign
                self._type = 'reassign'
            if update_notes is not None:
                self._update_notes = update_notes
                self._type = 'updateNotes'

        elif type_of_union == 'closeWithIgnore':
            if close_with_ignore is None:
                raise ValueError('a union value must not be None')
            self._close_with_ignore = close_with_ignore
            self._type = 'closeWithIgnore'
        elif type_of_union == 'closeWithFurtherAction':
            if close_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._close_with_further_action = close_with_further_action
            self._type = 'closeWithFurtherAction'
        elif type_of_union == 'reopen':
            if reopen is None:
                raise ValueError('a union value must not be None')
            self._reopen = reopen
            self._type = 'reopen'
        elif type_of_union == 'reassign':
            if reassign is None:
                raise ValueError('a union value must not be None')
            self._reassign = reassign
            self._type = 'reassign'
        elif type_of_union == 'updateNotes':
            if update_notes is None:
                raise ValueError('a union value must not be None')
            self._update_notes = update_notes
            self._type = 'updateNotes'

    @builtins.property
    def close_with_ignore(self) -> Optional["scout_datareview_api_CloseWithIgnoreAlert"]:
        return self._close_with_ignore

    @builtins.property
    def close_with_further_action(self) -> Optional["scout_datareview_api_CloseWithFurtherAction"]:
        return self._close_with_further_action

    @builtins.property
    def reopen(self) -> Optional["scout_datareview_api_Reopen"]:
        return self._reopen

    @builtins.property
    def reassign(self) -> Optional["scout_datareview_api_Reassign"]:
        return self._reassign

    @builtins.property
    def update_notes(self) -> Optional["scout_datareview_api_UpdateNotes"]:
        return self._update_notes

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'closeWithIgnore' and self.close_with_ignore is not None:
            return visitor._close_with_ignore(self.close_with_ignore)
        if self._type == 'closeWithFurtherAction' and self.close_with_further_action is not None:
            return visitor._close_with_further_action(self.close_with_further_action)
        if self._type == 'reopen' and self.reopen is not None:
            return visitor._reopen(self.reopen)
        if self._type == 'reassign' and self.reassign is not None:
            return visitor._reassign(self.reassign)
        if self._type == 'updateNotes' and self.update_notes is not None:
            return visitor._update_notes(self.update_notes)


scout_datareview_api_AutomaticCheckEvaluationReviewAction.__name__ = "AutomaticCheckEvaluationReviewAction"
scout_datareview_api_AutomaticCheckEvaluationReviewAction.__qualname__ = "AutomaticCheckEvaluationReviewAction"
scout_datareview_api_AutomaticCheckEvaluationReviewAction.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor:

    @abstractmethod
    def _close_with_ignore(self, close_with_ignore: "scout_datareview_api_CloseWithIgnoreAlert") -> Any:
        pass

    @abstractmethod
    def _close_with_further_action(self, close_with_further_action: "scout_datareview_api_CloseWithFurtherAction") -> Any:
        pass

    @abstractmethod
    def _reopen(self, reopen: "scout_datareview_api_Reopen") -> Any:
        pass

    @abstractmethod
    def _reassign(self, reassign: "scout_datareview_api_Reassign") -> Any:
        pass

    @abstractmethod
    def _update_notes(self, update_notes: "scout_datareview_api_UpdateNotes") -> Any:
        pass


scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor.__name__ = "AutomaticCheckEvaluationReviewActionVisitor"
scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor.__qualname__ = "AutomaticCheckEvaluationReviewActionVisitor"
scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationReviewActionLog(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'entries': ConjureFieldDefinition('entries', List[scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry])
        }

    __slots__: List[str] = ['_entries']

    def __init__(self, entries: List["scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry"]) -> None:
        self._entries = entries

    @builtins.property
    def entries(self) -> List["scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry"]:
        return self._entries


scout_datareview_api_AutomaticCheckEvaluationReviewActionLog.__name__ = "AutomaticCheckEvaluationReviewActionLog"
scout_datareview_api_AutomaticCheckEvaluationReviewActionLog.__qualname__ = "AutomaticCheckEvaluationReviewActionLog"
scout_datareview_api_AutomaticCheckEvaluationReviewActionLog.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'performed_by': ConjureFieldDefinition('performedBy', scout_rids_api_UserRid),
            'action': ConjureFieldDefinition('action', scout_datareview_api_AutomaticCheckEvaluationReviewAction),
            'timestamp': ConjureFieldDefinition('timestamp', str)
        }

    __slots__: List[str] = ['_performed_by', '_action', '_timestamp']

    def __init__(self, action: "scout_datareview_api_AutomaticCheckEvaluationReviewAction", performed_by: str, timestamp: str) -> None:
        self._performed_by = performed_by
        self._action = action
        self._timestamp = timestamp

    @builtins.property
    def performed_by(self) -> str:
        return self._performed_by

    @builtins.property
    def action(self) -> "scout_datareview_api_AutomaticCheckEvaluationReviewAction":
        return self._action

    @builtins.property
    def timestamp(self) -> str:
        return self._timestamp


scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry.__name__ = "AutomaticCheckEvaluationReviewActionLogEntry"
scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry.__qualname__ = "AutomaticCheckEvaluationReviewActionLogEntry"
scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationState(ConjureUnionType):
    _pending_execution: Optional["scout_datareview_api_PendingExecutionState"] = None
    _failed_to_execute: Optional["scout_datareview_api_FailedToExecuteState"] = None
    _passing: Optional["scout_datareview_api_PassingExecutionState"] = None
    _generated_alerts: Optional["scout_datareview_api_GeneratedAlertsState"] = None
    _too_many_alerts: Optional["scout_datareview_api_TooManyAlertsState"] = None
    _executing: Optional["scout_datareview_api_ExecutingState"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_execution': ConjureFieldDefinition('pendingExecution', scout_datareview_api_PendingExecutionState),
            'failed_to_execute': ConjureFieldDefinition('failedToExecute', scout_datareview_api_FailedToExecuteState),
            'passing': ConjureFieldDefinition('passing', scout_datareview_api_PassingExecutionState),
            'generated_alerts': ConjureFieldDefinition('generatedAlerts', scout_datareview_api_GeneratedAlertsState),
            'too_many_alerts': ConjureFieldDefinition('tooManyAlerts', scout_datareview_api_TooManyAlertsState),
            'executing': ConjureFieldDefinition('executing', scout_datareview_api_ExecutingState)
        }

    def __init__(
            self,
            pending_execution: Optional["scout_datareview_api_PendingExecutionState"] = None,
            failed_to_execute: Optional["scout_datareview_api_FailedToExecuteState"] = None,
            passing: Optional["scout_datareview_api_PassingExecutionState"] = None,
            generated_alerts: Optional["scout_datareview_api_GeneratedAlertsState"] = None,
            too_many_alerts: Optional["scout_datareview_api_TooManyAlertsState"] = None,
            executing: Optional["scout_datareview_api_ExecutingState"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pending_execution is not None) + (failed_to_execute is not None) + (passing is not None) + (generated_alerts is not None) + (too_many_alerts is not None) + (executing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pending_execution is not None:
                self._pending_execution = pending_execution
                self._type = 'pendingExecution'
            if failed_to_execute is not None:
                self._failed_to_execute = failed_to_execute
                self._type = 'failedToExecute'
            if passing is not None:
                self._passing = passing
                self._type = 'passing'
            if generated_alerts is not None:
                self._generated_alerts = generated_alerts
                self._type = 'generatedAlerts'
            if too_many_alerts is not None:
                self._too_many_alerts = too_many_alerts
                self._type = 'tooManyAlerts'
            if executing is not None:
                self._executing = executing
                self._type = 'executing'

        elif type_of_union == 'pendingExecution':
            if pending_execution is None:
                raise ValueError('a union value must not be None')
            self._pending_execution = pending_execution
            self._type = 'pendingExecution'
        elif type_of_union == 'failedToExecute':
            if failed_to_execute is None:
                raise ValueError('a union value must not be None')
            self._failed_to_execute = failed_to_execute
            self._type = 'failedToExecute'
        elif type_of_union == 'passing':
            if passing is None:
                raise ValueError('a union value must not be None')
            self._passing = passing
            self._type = 'passing'
        elif type_of_union == 'generatedAlerts':
            if generated_alerts is None:
                raise ValueError('a union value must not be None')
            self._generated_alerts = generated_alerts
            self._type = 'generatedAlerts'
        elif type_of_union == 'tooManyAlerts':
            if too_many_alerts is None:
                raise ValueError('a union value must not be None')
            self._too_many_alerts = too_many_alerts
            self._type = 'tooManyAlerts'
        elif type_of_union == 'executing':
            if executing is None:
                raise ValueError('a union value must not be None')
            self._executing = executing
            self._type = 'executing'

    @builtins.property
    def pending_execution(self) -> Optional["scout_datareview_api_PendingExecutionState"]:
        return self._pending_execution

    @builtins.property
    def failed_to_execute(self) -> Optional["scout_datareview_api_FailedToExecuteState"]:
        return self._failed_to_execute

    @builtins.property
    def passing(self) -> Optional["scout_datareview_api_PassingExecutionState"]:
        return self._passing

    @builtins.property
    def generated_alerts(self) -> Optional["scout_datareview_api_GeneratedAlertsState"]:
        return self._generated_alerts

    @builtins.property
    def too_many_alerts(self) -> Optional["scout_datareview_api_TooManyAlertsState"]:
        return self._too_many_alerts

    @builtins.property
    def executing(self) -> Optional["scout_datareview_api_ExecutingState"]:
        return self._executing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_AutomaticCheckEvaluationStateVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_AutomaticCheckEvaluationStateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pendingExecution' and self.pending_execution is not None:
            return visitor._pending_execution(self.pending_execution)
        if self._type == 'failedToExecute' and self.failed_to_execute is not None:
            return visitor._failed_to_execute(self.failed_to_execute)
        if self._type == 'passing' and self.passing is not None:
            return visitor._passing(self.passing)
        if self._type == 'generatedAlerts' and self.generated_alerts is not None:
            return visitor._generated_alerts(self.generated_alerts)
        if self._type == 'tooManyAlerts' and self.too_many_alerts is not None:
            return visitor._too_many_alerts(self.too_many_alerts)
        if self._type == 'executing' and self.executing is not None:
            return visitor._executing(self.executing)


scout_datareview_api_AutomaticCheckEvaluationState.__name__ = "AutomaticCheckEvaluationState"
scout_datareview_api_AutomaticCheckEvaluationState.__qualname__ = "AutomaticCheckEvaluationState"
scout_datareview_api_AutomaticCheckEvaluationState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationStateVisitor:

    @abstractmethod
    def _pending_execution(self, pending_execution: "scout_datareview_api_PendingExecutionState") -> Any:
        pass

    @abstractmethod
    def _failed_to_execute(self, failed_to_execute: "scout_datareview_api_FailedToExecuteState") -> Any:
        pass

    @abstractmethod
    def _passing(self, passing: "scout_datareview_api_PassingExecutionState") -> Any:
        pass

    @abstractmethod
    def _generated_alerts(self, generated_alerts: "scout_datareview_api_GeneratedAlertsState") -> Any:
        pass

    @abstractmethod
    def _too_many_alerts(self, too_many_alerts: "scout_datareview_api_TooManyAlertsState") -> Any:
        pass

    @abstractmethod
    def _executing(self, executing: "scout_datareview_api_ExecutingState") -> Any:
        pass


scout_datareview_api_AutomaticCheckEvaluationStateVisitor.__name__ = "AutomaticCheckEvaluationStateVisitor"
scout_datareview_api_AutomaticCheckEvaluationStateVisitor.__qualname__ = "AutomaticCheckEvaluationStateVisitor"
scout_datareview_api_AutomaticCheckEvaluationStateVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckExecutionFailedToRun(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_AutomaticCheckExecutionFailedToRun.__name__ = "AutomaticCheckExecutionFailedToRun"
scout_datareview_api_AutomaticCheckExecutionFailedToRun.__qualname__ = "AutomaticCheckExecutionFailedToRun"
scout_datareview_api_AutomaticCheckExecutionFailedToRun.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckExecutionFinished(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid),
            'status': ConjureFieldDefinition('status', scout_datareview_api_Status)
        }

    __slots__: List[str] = ['_job_rid', '_status']

    def __init__(self, job_rid: str, status: "scout_datareview_api_Status") -> None:
        self._job_rid = job_rid
        self._status = status

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid

    @builtins.property
    def status(self) -> "scout_datareview_api_Status":
        return self._status


scout_datareview_api_AutomaticCheckExecutionFinished.__name__ = "AutomaticCheckExecutionFinished"
scout_datareview_api_AutomaticCheckExecutionFinished.__qualname__ = "AutomaticCheckExecutionFinished"
scout_datareview_api_AutomaticCheckExecutionFinished.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckExecutionStarted(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_AutomaticCheckExecutionStarted.__name__ = "AutomaticCheckExecutionStarted"
scout_datareview_api_AutomaticCheckExecutionStarted.__qualname__ = "AutomaticCheckExecutionStarted"
scout_datareview_api_AutomaticCheckExecutionStarted.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_evaluation_action': ConjureFieldDefinition('checkEvaluationAction', scout_datareview_api_AutomaticCheckEvaluationReviewAction),
            'check_evaluation_rids': ConjureFieldDefinition('checkEvaluationRids', List[scout_datareview_api_AutomaticCheckEvaluationRid])
        }

    __slots__: List[str] = ['_check_evaluation_action', '_check_evaluation_rids']

    def __init__(self, check_evaluation_action: "scout_datareview_api_AutomaticCheckEvaluationReviewAction", check_evaluation_rids: List[str]) -> None:
        self._check_evaluation_action = check_evaluation_action
        self._check_evaluation_rids = check_evaluation_rids

    @builtins.property
    def check_evaluation_action(self) -> "scout_datareview_api_AutomaticCheckEvaluationReviewAction":
        return self._check_evaluation_action

    @builtins.property
    def check_evaluation_rids(self) -> List[str]:
        return self._check_evaluation_rids


scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest.__name__ = "BatchAutomaticCheckEvaluationActionRequest"
scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest.__qualname__ = "BatchAutomaticCheckEvaluationActionRequest"
scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_evaluations': ConjureFieldDefinition('checkEvaluations', List[scout_datareview_api_AutomaticCheckEvaluation])
        }

    __slots__: List[str] = ['_check_evaluations']

    def __init__(self, check_evaluations: List["scout_datareview_api_AutomaticCheckEvaluation"]) -> None:
        self._check_evaluations = check_evaluations

    @builtins.property
    def check_evaluations(self) -> List["scout_datareview_api_AutomaticCheckEvaluation"]:
        return self._check_evaluations


scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse.__name__ = "BatchAutomaticCheckEvaluationActionResponse"
scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse.__qualname__ = "BatchAutomaticCheckEvaluationActionResponse"
scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_BatchCheckAlertActionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_alert_action': ConjureFieldDefinition('checkAlertAction', scout_datareview_api_CheckAlertAction),
            'check_alert_rids': ConjureFieldDefinition('checkAlertRids', List[scout_datareview_api_CheckAlertRid])
        }

    __slots__: List[str] = ['_check_alert_action', '_check_alert_rids']

    def __init__(self, check_alert_action: "scout_datareview_api_CheckAlertAction", check_alert_rids: List[str]) -> None:
        self._check_alert_action = check_alert_action
        self._check_alert_rids = check_alert_rids

    @builtins.property
    def check_alert_action(self) -> "scout_datareview_api_CheckAlertAction":
        return self._check_alert_action

    @builtins.property
    def check_alert_rids(self) -> List[str]:
        return self._check_alert_rids


scout_datareview_api_BatchCheckAlertActionRequest.__name__ = "BatchCheckAlertActionRequest"
scout_datareview_api_BatchCheckAlertActionRequest.__qualname__ = "BatchCheckAlertActionRequest"
scout_datareview_api_BatchCheckAlertActionRequest.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_BatchCheckAlertActionResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_alerts': ConjureFieldDefinition('checkAlerts', List[scout_datareview_api_CheckAlert])
        }

    __slots__: List[str] = ['_check_alerts']

    def __init__(self, check_alerts: List["scout_datareview_api_CheckAlert"]) -> None:
        self._check_alerts = check_alerts

    @builtins.property
    def check_alerts(self) -> List["scout_datareview_api_CheckAlert"]:
        return self._check_alerts


scout_datareview_api_BatchCheckAlertActionResponse.__name__ = "BatchCheckAlertActionResponse"
scout_datareview_api_BatchCheckAlertActionResponse.__qualname__ = "BatchCheckAlertActionResponse"
scout_datareview_api_BatchCheckAlertActionResponse.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_BatchInitiateDataReviewRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[scout_datareview_api_CreateDataReviewRequest]),
            'notification_configurations': ConjureFieldDefinition('notificationConfigurations', List[scout_integrations_api_NotificationConfiguration])
        }

    __slots__: List[str] = ['_requests', '_notification_configurations']

    def __init__(self, notification_configurations: List["scout_integrations_api_NotificationConfiguration"], requests: List["scout_datareview_api_CreateDataReviewRequest"]) -> None:
        self._requests = requests
        self._notification_configurations = notification_configurations

    @builtins.property
    def requests(self) -> List["scout_datareview_api_CreateDataReviewRequest"]:
        return self._requests

    @builtins.property
    def notification_configurations(self) -> List["scout_integrations_api_NotificationConfiguration"]:
        """
        If provided, checklist violations will be sent to the specified integrations.
        """
        return self._notification_configurations


scout_datareview_api_BatchInitiateDataReviewRequest.__name__ = "BatchInitiateDataReviewRequest"
scout_datareview_api_BatchInitiateDataReviewRequest.__qualname__ = "BatchInitiateDataReviewRequest"
scout_datareview_api_BatchInitiateDataReviewRequest.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_BatchInitiateDataReviewResponse(ConjureBeanType):
    """
    Responses are returned in the same order as the requests.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_datareview_api_DataReviewRid])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


scout_datareview_api_BatchInitiateDataReviewResponse.__name__ = "BatchInitiateDataReviewResponse"
scout_datareview_api_BatchInitiateDataReviewResponse.__qualname__ = "BatchInitiateDataReviewResponse"
scout_datareview_api_BatchInitiateDataReviewResponse.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_BatchManualCheckEvaluationActionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_alert_action': ConjureFieldDefinition('checkAlertAction', scout_datareview_api_ManualCheckAlertAction),
            'check_evaluation_rids': ConjureFieldDefinition('checkEvaluationRids', List[scout_datareview_api_ManualCheckEvaluationRid])
        }

    __slots__: List[str] = ['_check_alert_action', '_check_evaluation_rids']

    def __init__(self, check_alert_action: "scout_datareview_api_ManualCheckAlertAction", check_evaluation_rids: List[str]) -> None:
        self._check_alert_action = check_alert_action
        self._check_evaluation_rids = check_evaluation_rids

    @builtins.property
    def check_alert_action(self) -> "scout_datareview_api_ManualCheckAlertAction":
        return self._check_alert_action

    @builtins.property
    def check_evaluation_rids(self) -> List[str]:
        return self._check_evaluation_rids


scout_datareview_api_BatchManualCheckEvaluationActionRequest.__name__ = "BatchManualCheckEvaluationActionRequest"
scout_datareview_api_BatchManualCheckEvaluationActionRequest.__qualname__ = "BatchManualCheckEvaluationActionRequest"
scout_datareview_api_BatchManualCheckEvaluationActionRequest.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlert(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_datareview_api_CheckAlertRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'implementation_index': ConjureFieldDefinition('implementationIndex', OptionalTypeWrapper[int]),
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_datareview_api_DataReviewRid),
            'check_evaluation_rid': ConjureFieldDefinition('checkEvaluationRid', scout_datareview_api_AutomaticCheckEvaluationRid),
            'name': ConjureFieldDefinition('name', str),
            'autogenerated_check_title': ConjureFieldDefinition('autogeneratedCheckTitle', OptionalTypeWrapper[str]),
            'autogenerated_check_description': ConjureFieldDefinition('autogeneratedCheckDescription', OptionalTypeWrapper[str]),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', List[scout_rids_api_UserRid]),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[api_Timestamp]),
            'state': ConjureFieldDefinition('state', scout_datareview_api_CheckAlertState),
            'priority': ConjureFieldDefinition('priority', scout_checks_api_Priority),
            'chart': ConjureFieldDefinition('chart', OptionalTypeWrapper[scout_rids_api_VersionedChartRid]),
            'notes': ConjureFieldDefinition('notes', OptionalTypeWrapper[str]),
            'notebook': ConjureFieldDefinition('notebook', OptionalTypeWrapper[scout_rids_api_NotebookRid])
        }

    __slots__: List[str] = ['_rid', '_check_rid', '_implementation_index', '_data_review_rid', '_check_evaluation_rid', '_name', '_autogenerated_check_title', '_autogenerated_check_description', '_assignee_rids', '_start', '_end', '_state', '_priority', '_chart', '_notes', '_notebook']

    def __init__(self, assignee_rids: List[str], check_evaluation_rid: str, check_rid: str, data_review_rid: str, name: str, priority: "scout_checks_api_Priority", rid: str, start: "api_Timestamp", state: "scout_datareview_api_CheckAlertState", autogenerated_check_description: Optional[str] = None, autogenerated_check_title: Optional[str] = None, chart: Optional["scout_rids_api_VersionedChartRid"] = None, end: Optional["api_Timestamp"] = None, implementation_index: Optional[int] = None, notebook: Optional[str] = None, notes: Optional[str] = None) -> None:
        self._rid = rid
        self._check_rid = check_rid
        self._implementation_index = implementation_index
        self._data_review_rid = data_review_rid
        self._check_evaluation_rid = check_evaluation_rid
        self._name = name
        self._autogenerated_check_title = autogenerated_check_title
        self._autogenerated_check_description = autogenerated_check_description
        self._assignee_rids = assignee_rids
        self._start = start
        self._end = end
        self._state = state
        self._priority = priority
        self._chart = chart
        self._notes = notes
        self._notebook = notebook

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def implementation_index(self) -> Optional[int]:
        return self._implementation_index

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def check_evaluation_rid(self) -> str:
        return self._check_evaluation_rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def autogenerated_check_title(self) -> Optional[str]:
        return self._autogenerated_check_title

    @builtins.property
    def autogenerated_check_description(self) -> Optional[str]:
        return self._autogenerated_check_description

    @builtins.property
    def assignee_rids(self) -> List[str]:
        return self._assignee_rids

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> Optional["api_Timestamp"]:
        return self._end

    @builtins.property
    def state(self) -> "scout_datareview_api_CheckAlertState":
        return self._state

    @builtins.property
    def priority(self) -> "scout_checks_api_Priority":
        return self._priority

    @builtins.property
    def chart(self) -> Optional["scout_rids_api_VersionedChartRid"]:
        return self._chart

    @builtins.property
    def notes(self) -> Optional[str]:
        return self._notes

    @builtins.property
    def notebook(self) -> Optional[str]:
        return self._notebook


scout_datareview_api_CheckAlert.__name__ = "CheckAlert"
scout_datareview_api_CheckAlert.__qualname__ = "CheckAlert"
scout_datareview_api_CheckAlert.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertAction(ConjureUnionType):
    _close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None
    _close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None
    _reopen: Optional["scout_datareview_api_Reopen"] = None
    _reassign: Optional["scout_datareview_api_Reassign"] = None
    _update_notes: Optional["scout_datareview_api_UpdateNotes"] = None
    _link_notebook: Optional["scout_datareview_api_LinkNotebook"] = None
    _unlink_notebook: Optional["scout_datareview_api_UnlinkNotebook"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_with_ignore': ConjureFieldDefinition('closeWithIgnore', scout_datareview_api_CloseWithIgnoreAlert),
            'close_with_further_action': ConjureFieldDefinition('closeWithFurtherAction', scout_datareview_api_CloseWithFurtherAction),
            'reopen': ConjureFieldDefinition('reopen', scout_datareview_api_Reopen),
            'reassign': ConjureFieldDefinition('reassign', scout_datareview_api_Reassign),
            'update_notes': ConjureFieldDefinition('updateNotes', scout_datareview_api_UpdateNotes),
            'link_notebook': ConjureFieldDefinition('linkNotebook', scout_datareview_api_LinkNotebook),
            'unlink_notebook': ConjureFieldDefinition('unlinkNotebook', scout_datareview_api_UnlinkNotebook)
        }

    def __init__(
            self,
            close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None,
            close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None,
            reopen: Optional["scout_datareview_api_Reopen"] = None,
            reassign: Optional["scout_datareview_api_Reassign"] = None,
            update_notes: Optional["scout_datareview_api_UpdateNotes"] = None,
            link_notebook: Optional["scout_datareview_api_LinkNotebook"] = None,
            unlink_notebook: Optional["scout_datareview_api_UnlinkNotebook"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (close_with_ignore is not None) + (close_with_further_action is not None) + (reopen is not None) + (reassign is not None) + (update_notes is not None) + (link_notebook is not None) + (unlink_notebook is not None) != 1:
                raise ValueError('a union must contain a single member')

            if close_with_ignore is not None:
                self._close_with_ignore = close_with_ignore
                self._type = 'closeWithIgnore'
            if close_with_further_action is not None:
                self._close_with_further_action = close_with_further_action
                self._type = 'closeWithFurtherAction'
            if reopen is not None:
                self._reopen = reopen
                self._type = 'reopen'
            if reassign is not None:
                self._reassign = reassign
                self._type = 'reassign'
            if update_notes is not None:
                self._update_notes = update_notes
                self._type = 'updateNotes'
            if link_notebook is not None:
                self._link_notebook = link_notebook
                self._type = 'linkNotebook'
            if unlink_notebook is not None:
                self._unlink_notebook = unlink_notebook
                self._type = 'unlinkNotebook'

        elif type_of_union == 'closeWithIgnore':
            if close_with_ignore is None:
                raise ValueError('a union value must not be None')
            self._close_with_ignore = close_with_ignore
            self._type = 'closeWithIgnore'
        elif type_of_union == 'closeWithFurtherAction':
            if close_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._close_with_further_action = close_with_further_action
            self._type = 'closeWithFurtherAction'
        elif type_of_union == 'reopen':
            if reopen is None:
                raise ValueError('a union value must not be None')
            self._reopen = reopen
            self._type = 'reopen'
        elif type_of_union == 'reassign':
            if reassign is None:
                raise ValueError('a union value must not be None')
            self._reassign = reassign
            self._type = 'reassign'
        elif type_of_union == 'updateNotes':
            if update_notes is None:
                raise ValueError('a union value must not be None')
            self._update_notes = update_notes
            self._type = 'updateNotes'
        elif type_of_union == 'linkNotebook':
            if link_notebook is None:
                raise ValueError('a union value must not be None')
            self._link_notebook = link_notebook
            self._type = 'linkNotebook'
        elif type_of_union == 'unlinkNotebook':
            if unlink_notebook is None:
                raise ValueError('a union value must not be None')
            self._unlink_notebook = unlink_notebook
            self._type = 'unlinkNotebook'

    @builtins.property
    def close_with_ignore(self) -> Optional["scout_datareview_api_CloseWithIgnoreAlert"]:
        return self._close_with_ignore

    @builtins.property
    def close_with_further_action(self) -> Optional["scout_datareview_api_CloseWithFurtherAction"]:
        return self._close_with_further_action

    @builtins.property
    def reopen(self) -> Optional["scout_datareview_api_Reopen"]:
        return self._reopen

    @builtins.property
    def reassign(self) -> Optional["scout_datareview_api_Reassign"]:
        return self._reassign

    @builtins.property
    def update_notes(self) -> Optional["scout_datareview_api_UpdateNotes"]:
        return self._update_notes

    @builtins.property
    def link_notebook(self) -> Optional["scout_datareview_api_LinkNotebook"]:
        return self._link_notebook

    @builtins.property
    def unlink_notebook(self) -> Optional["scout_datareview_api_UnlinkNotebook"]:
        return self._unlink_notebook

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CheckAlertActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CheckAlertActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'closeWithIgnore' and self.close_with_ignore is not None:
            return visitor._close_with_ignore(self.close_with_ignore)
        if self._type == 'closeWithFurtherAction' and self.close_with_further_action is not None:
            return visitor._close_with_further_action(self.close_with_further_action)
        if self._type == 'reopen' and self.reopen is not None:
            return visitor._reopen(self.reopen)
        if self._type == 'reassign' and self.reassign is not None:
            return visitor._reassign(self.reassign)
        if self._type == 'updateNotes' and self.update_notes is not None:
            return visitor._update_notes(self.update_notes)
        if self._type == 'linkNotebook' and self.link_notebook is not None:
            return visitor._link_notebook(self.link_notebook)
        if self._type == 'unlinkNotebook' and self.unlink_notebook is not None:
            return visitor._unlink_notebook(self.unlink_notebook)


scout_datareview_api_CheckAlertAction.__name__ = "CheckAlertAction"
scout_datareview_api_CheckAlertAction.__qualname__ = "CheckAlertAction"
scout_datareview_api_CheckAlertAction.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertActionVisitor:

    @abstractmethod
    def _close_with_ignore(self, close_with_ignore: "scout_datareview_api_CloseWithIgnoreAlert") -> Any:
        pass

    @abstractmethod
    def _close_with_further_action(self, close_with_further_action: "scout_datareview_api_CloseWithFurtherAction") -> Any:
        pass

    @abstractmethod
    def _reopen(self, reopen: "scout_datareview_api_Reopen") -> Any:
        pass

    @abstractmethod
    def _reassign(self, reassign: "scout_datareview_api_Reassign") -> Any:
        pass

    @abstractmethod
    def _update_notes(self, update_notes: "scout_datareview_api_UpdateNotes") -> Any:
        pass

    @abstractmethod
    def _link_notebook(self, link_notebook: "scout_datareview_api_LinkNotebook") -> Any:
        pass

    @abstractmethod
    def _unlink_notebook(self, unlink_notebook: "scout_datareview_api_UnlinkNotebook") -> Any:
        pass


scout_datareview_api_CheckAlertActionVisitor.__name__ = "CheckAlertActionVisitor"
scout_datareview_api_CheckAlertActionVisitor.__qualname__ = "CheckAlertActionVisitor"
scout_datareview_api_CheckAlertActionVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertActionLog(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'entries': ConjureFieldDefinition('entries', List[scout_datareview_api_CheckAlertActionLogEntry])
        }

    __slots__: List[str] = ['_entries']

    def __init__(self, entries: List["scout_datareview_api_CheckAlertActionLogEntry"]) -> None:
        self._entries = entries

    @builtins.property
    def entries(self) -> List["scout_datareview_api_CheckAlertActionLogEntry"]:
        return self._entries


scout_datareview_api_CheckAlertActionLog.__name__ = "CheckAlertActionLog"
scout_datareview_api_CheckAlertActionLog.__qualname__ = "CheckAlertActionLog"
scout_datareview_api_CheckAlertActionLog.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertActionLogEntry(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'performed_by': ConjureFieldDefinition('performedBy', scout_rids_api_UserRid),
            'action': ConjureFieldDefinition('action', scout_datareview_api_CheckAlertAction),
            'timestamp': ConjureFieldDefinition('timestamp', str)
        }

    __slots__: List[str] = ['_performed_by', '_action', '_timestamp']

    def __init__(self, action: "scout_datareview_api_CheckAlertAction", performed_by: str, timestamp: str) -> None:
        self._performed_by = performed_by
        self._action = action
        self._timestamp = timestamp

    @builtins.property
    def performed_by(self) -> str:
        return self._performed_by

    @builtins.property
    def action(self) -> "scout_datareview_api_CheckAlertAction":
        return self._action

    @builtins.property
    def timestamp(self) -> str:
        return self._timestamp


scout_datareview_api_CheckAlertActionLogEntry.__name__ = "CheckAlertActionLogEntry"
scout_datareview_api_CheckAlertActionLogEntry.__qualname__ = "CheckAlertActionLogEntry"
scout_datareview_api_CheckAlertActionLogEntry.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertState(ConjureUnionType):
    _pending_review: Optional["scout_datareview_api_PendingReviewAlertState"] = None
    _closed_with_further_action: Optional["scout_datareview_api_ClosedWithFurtherActionAlertState"] = None
    _closed_with_ignore: Optional["scout_datareview_api_ClosedWithIgnoreAlertState"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_review': ConjureFieldDefinition('pendingReview', scout_datareview_api_PendingReviewAlertState),
            'closed_with_further_action': ConjureFieldDefinition('closedWithFurtherAction', scout_datareview_api_ClosedWithFurtherActionAlertState),
            'closed_with_ignore': ConjureFieldDefinition('closedWithIgnore', scout_datareview_api_ClosedWithIgnoreAlertState)
        }

    def __init__(
            self,
            pending_review: Optional["scout_datareview_api_PendingReviewAlertState"] = None,
            closed_with_further_action: Optional["scout_datareview_api_ClosedWithFurtherActionAlertState"] = None,
            closed_with_ignore: Optional["scout_datareview_api_ClosedWithIgnoreAlertState"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pending_review is not None) + (closed_with_further_action is not None) + (closed_with_ignore is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pending_review is not None:
                self._pending_review = pending_review
                self._type = 'pendingReview'
            if closed_with_further_action is not None:
                self._closed_with_further_action = closed_with_further_action
                self._type = 'closedWithFurtherAction'
            if closed_with_ignore is not None:
                self._closed_with_ignore = closed_with_ignore
                self._type = 'closedWithIgnore'

        elif type_of_union == 'pendingReview':
            if pending_review is None:
                raise ValueError('a union value must not be None')
            self._pending_review = pending_review
            self._type = 'pendingReview'
        elif type_of_union == 'closedWithFurtherAction':
            if closed_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._closed_with_further_action = closed_with_further_action
            self._type = 'closedWithFurtherAction'
        elif type_of_union == 'closedWithIgnore':
            if closed_with_ignore is None:
                raise ValueError('a union value must not be None')
            self._closed_with_ignore = closed_with_ignore
            self._type = 'closedWithIgnore'

    @builtins.property
    def pending_review(self) -> Optional["scout_datareview_api_PendingReviewAlertState"]:
        return self._pending_review

    @builtins.property
    def closed_with_further_action(self) -> Optional["scout_datareview_api_ClosedWithFurtherActionAlertState"]:
        return self._closed_with_further_action

    @builtins.property
    def closed_with_ignore(self) -> Optional["scout_datareview_api_ClosedWithIgnoreAlertState"]:
        return self._closed_with_ignore

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CheckAlertStateVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CheckAlertStateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pendingReview' and self.pending_review is not None:
            return visitor._pending_review(self.pending_review)
        if self._type == 'closedWithFurtherAction' and self.closed_with_further_action is not None:
            return visitor._closed_with_further_action(self.closed_with_further_action)
        if self._type == 'closedWithIgnore' and self.closed_with_ignore is not None:
            return visitor._closed_with_ignore(self.closed_with_ignore)


scout_datareview_api_CheckAlertState.__name__ = "CheckAlertState"
scout_datareview_api_CheckAlertState.__qualname__ = "CheckAlertState"
scout_datareview_api_CheckAlertState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertStateVisitor:

    @abstractmethod
    def _pending_review(self, pending_review: "scout_datareview_api_PendingReviewAlertState") -> Any:
        pass

    @abstractmethod
    def _closed_with_further_action(self, closed_with_further_action: "scout_datareview_api_ClosedWithFurtherActionAlertState") -> Any:
        pass

    @abstractmethod
    def _closed_with_ignore(self, closed_with_ignore: "scout_datareview_api_ClosedWithIgnoreAlertState") -> Any:
        pass


scout_datareview_api_CheckAlertStateVisitor.__name__ = "CheckAlertStateVisitor"
scout_datareview_api_CheckAlertStateVisitor.__qualname__ = "CheckAlertStateVisitor"
scout_datareview_api_CheckAlertStateVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertStatus(ConjureEnumType):

    PENDING_REVIEW = 'PENDING_REVIEW'
    '''PENDING_REVIEW'''
    CLOSED_IGNORED = 'CLOSED_IGNORED'
    '''CLOSED_IGNORED'''
    CLOSED_REQUIRES_FURTHER_ACTION = 'CLOSED_REQUIRES_FURTHER_ACTION'
    '''CLOSED_REQUIRES_FURTHER_ACTION'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datareview_api_CheckAlertStatus.__name__ = "CheckAlertStatus"
scout_datareview_api_CheckAlertStatus.__qualname__ = "CheckAlertStatus"
scout_datareview_api_CheckAlertStatus.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsHistogramBuckets(ConjureUnionType):
    _unstacked: Optional["scout_datareview_api_CheckAlertsUnstackedHistogram"] = None
    _priority: Optional["scout_datareview_api_CheckAlertsPriorityHistogram"] = None
    _status: Optional["scout_datareview_api_CheckAlertsStatusHistogram"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unstacked': ConjureFieldDefinition('unstacked', scout_datareview_api_CheckAlertsUnstackedHistogram),
            'priority': ConjureFieldDefinition('priority', scout_datareview_api_CheckAlertsPriorityHistogram),
            'status': ConjureFieldDefinition('status', scout_datareview_api_CheckAlertsStatusHistogram)
        }

    def __init__(
            self,
            unstacked: Optional["scout_datareview_api_CheckAlertsUnstackedHistogram"] = None,
            priority: Optional["scout_datareview_api_CheckAlertsPriorityHistogram"] = None,
            status: Optional["scout_datareview_api_CheckAlertsStatusHistogram"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (unstacked is not None) + (priority is not None) + (status is not None) != 1:
                raise ValueError('a union must contain a single member')

            if unstacked is not None:
                self._unstacked = unstacked
                self._type = 'unstacked'
            if priority is not None:
                self._priority = priority
                self._type = 'priority'
            if status is not None:
                self._status = status
                self._type = 'status'

        elif type_of_union == 'unstacked':
            if unstacked is None:
                raise ValueError('a union value must not be None')
            self._unstacked = unstacked
            self._type = 'unstacked'
        elif type_of_union == 'priority':
            if priority is None:
                raise ValueError('a union value must not be None')
            self._priority = priority
            self._type = 'priority'
        elif type_of_union == 'status':
            if status is None:
                raise ValueError('a union value must not be None')
            self._status = status
            self._type = 'status'

    @builtins.property
    def unstacked(self) -> Optional["scout_datareview_api_CheckAlertsUnstackedHistogram"]:
        return self._unstacked

    @builtins.property
    def priority(self) -> Optional["scout_datareview_api_CheckAlertsPriorityHistogram"]:
        return self._priority

    @builtins.property
    def status(self) -> Optional["scout_datareview_api_CheckAlertsStatusHistogram"]:
        return self._status

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CheckAlertsHistogramBucketsVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CheckAlertsHistogramBucketsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'unstacked' and self.unstacked is not None:
            return visitor._unstacked(self.unstacked)
        if self._type == 'priority' and self.priority is not None:
            return visitor._priority(self.priority)
        if self._type == 'status' and self.status is not None:
            return visitor._status(self.status)


scout_datareview_api_CheckAlertsHistogramBuckets.__name__ = "CheckAlertsHistogramBuckets"
scout_datareview_api_CheckAlertsHistogramBuckets.__qualname__ = "CheckAlertsHistogramBuckets"
scout_datareview_api_CheckAlertsHistogramBuckets.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsHistogramBucketsVisitor:

    @abstractmethod
    def _unstacked(self, unstacked: "scout_datareview_api_CheckAlertsUnstackedHistogram") -> Any:
        pass

    @abstractmethod
    def _priority(self, priority: "scout_datareview_api_CheckAlertsPriorityHistogram") -> Any:
        pass

    @abstractmethod
    def _status(self, status: "scout_datareview_api_CheckAlertsStatusHistogram") -> Any:
        pass


scout_datareview_api_CheckAlertsHistogramBucketsVisitor.__name__ = "CheckAlertsHistogramBucketsVisitor"
scout_datareview_api_CheckAlertsHistogramBucketsVisitor.__qualname__ = "CheckAlertsHistogramBucketsVisitor"
scout_datareview_api_CheckAlertsHistogramBucketsVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsHistogramRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'num_bins': ConjureFieldDefinition('numBins', OptionalTypeWrapper[int]),
            'search_text': ConjureFieldDefinition('searchText', OptionalTypeWrapper[str]),
            'distribution_variable': ConjureFieldDefinition('distributionVariable', scout_datareview_api_HistogramDistributionVariable),
            'sub_group_variable': ConjureFieldDefinition('subGroupVariable', OptionalTypeWrapper[scout_datareview_api_HistogramSubGroupVariable]),
            'start_time_after': ConjureFieldDefinition('startTimeAfter', api_Timestamp),
            'start_time_before': ConjureFieldDefinition('startTimeBefore', api_Timestamp),
            'status': ConjureFieldDefinition('status', OptionalTypeWrapper[List[scout_datareview_api_CheckAlertStatus]]),
            'check_rids': ConjureFieldDefinition('checkRids', OptionalTypeWrapper[List[scout_rids_api_CheckRid]]),
            'data_review_rids': ConjureFieldDefinition('dataReviewRids', OptionalTypeWrapper[List[scout_datareview_api_DataReviewRid]]),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', OptionalTypeWrapper[List[scout_rids_api_UserRid]]),
            'priorities': ConjureFieldDefinition('priorities', OptionalTypeWrapper[List[scout_checks_api_Priority]]),
            'run_rids': ConjureFieldDefinition('runRids', List[scout_run_api_RunRid]),
            'pinned_checklist_refs': ConjureFieldDefinition('pinnedChecklistRefs', OptionalTypeWrapper[List[scout_checks_api_PinnedChecklistRef]]),
            'chart_rids': ConjureFieldDefinition('chartRids', OptionalTypeWrapper[List[scout_rids_api_VersionedChartRid]]),
            'notebook_rids': ConjureFieldDefinition('notebookRids', OptionalTypeWrapper[List[scout_rids_api_NotebookRid]]),
            'show_archived': ConjureFieldDefinition('showArchived', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_num_bins', '_search_text', '_distribution_variable', '_sub_group_variable', '_start_time_after', '_start_time_before', '_status', '_check_rids', '_data_review_rids', '_assignee_rids', '_priorities', '_run_rids', '_pinned_checklist_refs', '_chart_rids', '_notebook_rids', '_show_archived']

    def __init__(self, distribution_variable: "scout_datareview_api_HistogramDistributionVariable", run_rids: List[str], start_time_after: "api_Timestamp", start_time_before: "api_Timestamp", assignee_rids: Optional[List[str]] = None, chart_rids: Optional[List["scout_rids_api_VersionedChartRid"]] = None, check_rids: Optional[List[str]] = None, data_review_rids: Optional[List[str]] = None, notebook_rids: Optional[List[str]] = None, num_bins: Optional[int] = None, pinned_checklist_refs: Optional[List["scout_checks_api_PinnedChecklistRef"]] = None, priorities: Optional[List["scout_checks_api_Priority"]] = None, search_text: Optional[str] = None, show_archived: Optional[bool] = None, status: Optional[List["scout_datareview_api_CheckAlertStatus"]] = None, sub_group_variable: Optional["scout_datareview_api_HistogramSubGroupVariable"] = None) -> None:
        self._num_bins = num_bins
        self._search_text = search_text
        self._distribution_variable = distribution_variable
        self._sub_group_variable = sub_group_variable
        self._start_time_after = start_time_after
        self._start_time_before = start_time_before
        self._status = status
        self._check_rids = check_rids
        self._data_review_rids = data_review_rids
        self._assignee_rids = assignee_rids
        self._priorities = priorities
        self._run_rids = run_rids
        self._pinned_checklist_refs = pinned_checklist_refs
        self._chart_rids = chart_rids
        self._notebook_rids = notebook_rids
        self._show_archived = show_archived

    @builtins.property
    def num_bins(self) -> Optional[int]:
        """
        Defaults to 100. Throws if larger than 1_000.
        """
        return self._num_bins

    @builtins.property
    def search_text(self) -> Optional[str]:
        """
        Matches on check name
        """
        return self._search_text

    @builtins.property
    def distribution_variable(self) -> "scout_datareview_api_HistogramDistributionVariable":
        """
        Represents the data points on the x-axis of a histogram.
        """
        return self._distribution_variable

    @builtins.property
    def sub_group_variable(self) -> Optional["scout_datareview_api_HistogramSubGroupVariable"]:
        """
        The variable that divides the data into distinct groups for comparison within the histogram.
        """
        return self._sub_group_variable

    @builtins.property
    def start_time_after(self) -> "api_Timestamp":
        """
        Filters to start times after this time, inclusive.
        """
        return self._start_time_after

    @builtins.property
    def start_time_before(self) -> "api_Timestamp":
        """
        Filters to start times before this time, exclusive.
        """
        return self._start_time_before

    @builtins.property
    def status(self) -> Optional[List["scout_datareview_api_CheckAlertStatus"]]:
        return self._status

    @builtins.property
    def check_rids(self) -> Optional[List[str]]:
        return self._check_rids

    @builtins.property
    def data_review_rids(self) -> Optional[List[str]]:
        return self._data_review_rids

    @builtins.property
    def assignee_rids(self) -> Optional[List[str]]:
        return self._assignee_rids

    @builtins.property
    def priorities(self) -> Optional[List["scout_checks_api_Priority"]]:
        return self._priorities

    @builtins.property
    def run_rids(self) -> List[str]:
        return self._run_rids

    @builtins.property
    def pinned_checklist_refs(self) -> Optional[List["scout_checks_api_PinnedChecklistRef"]]:
        return self._pinned_checklist_refs

    @builtins.property
    def chart_rids(self) -> Optional[List["scout_rids_api_VersionedChartRid"]]:
        return self._chart_rids

    @builtins.property
    def notebook_rids(self) -> Optional[List[str]]:
        return self._notebook_rids

    @builtins.property
    def show_archived(self) -> Optional[bool]:
        """
        If not present, will not show archived data reviews in search results
        """
        return self._show_archived


scout_datareview_api_CheckAlertsHistogramRequest.__name__ = "CheckAlertsHistogramRequest"
scout_datareview_api_CheckAlertsHistogramRequest.__qualname__ = "CheckAlertsHistogramRequest"
scout_datareview_api_CheckAlertsHistogramRequest.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsHistogramResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', scout_datareview_api_CheckAlertsHistogramBuckets)
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: "scout_datareview_api_CheckAlertsHistogramBuckets") -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> "scout_datareview_api_CheckAlertsHistogramBuckets":
        return self._buckets


scout_datareview_api_CheckAlertsHistogramResponse.__name__ = "CheckAlertsHistogramResponse"
scout_datareview_api_CheckAlertsHistogramResponse.__qualname__ = "CheckAlertsHistogramResponse"
scout_datareview_api_CheckAlertsHistogramResponse.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsPriorityHistogram(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_datareview_api_HistogramPriorityBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_datareview_api_HistogramPriorityBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_datareview_api_HistogramPriorityBucket"]:
        return self._buckets


scout_datareview_api_CheckAlertsPriorityHistogram.__name__ = "CheckAlertsPriorityHistogram"
scout_datareview_api_CheckAlertsPriorityHistogram.__qualname__ = "CheckAlertsPriorityHistogram"
scout_datareview_api_CheckAlertsPriorityHistogram.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsStatusHistogram(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_datareview_api_HistogramStatusBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_datareview_api_HistogramStatusBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_datareview_api_HistogramStatusBucket"]:
        return self._buckets


scout_datareview_api_CheckAlertsStatusHistogram.__name__ = "CheckAlertsStatusHistogram"
scout_datareview_api_CheckAlertsStatusHistogram.__qualname__ = "CheckAlertsStatusHistogram"
scout_datareview_api_CheckAlertsStatusHistogram.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsUnstackedHistogram(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_datareview_api_HistogramBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_datareview_api_HistogramBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_datareview_api_HistogramBucket"]:
        return self._buckets


scout_datareview_api_CheckAlertsUnstackedHistogram.__name__ = "CheckAlertsUnstackedHistogram"
scout_datareview_api_CheckAlertsUnstackedHistogram.__qualname__ = "CheckAlertsUnstackedHistogram"
scout_datareview_api_CheckAlertsUnstackedHistogram.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckEvaluation(ConjureUnionType):
    _automatic_check: Optional["scout_datareview_api_AutomaticCheckEvaluation"] = None
    _manual_check: Optional["scout_datareview_api_ManualCheckEvaluation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'automatic_check': ConjureFieldDefinition('automaticCheck', scout_datareview_api_AutomaticCheckEvaluation),
            'manual_check': ConjureFieldDefinition('manualCheck', scout_datareview_api_ManualCheckEvaluation)
        }

    def __init__(
            self,
            automatic_check: Optional["scout_datareview_api_AutomaticCheckEvaluation"] = None,
            manual_check: Optional["scout_datareview_api_ManualCheckEvaluation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (automatic_check is not None) + (manual_check is not None) != 1:
                raise ValueError('a union must contain a single member')

            if automatic_check is not None:
                self._automatic_check = automatic_check
                self._type = 'automaticCheck'
            if manual_check is not None:
                self._manual_check = manual_check
                self._type = 'manualCheck'

        elif type_of_union == 'automaticCheck':
            if automatic_check is None:
                raise ValueError('a union value must not be None')
            self._automatic_check = automatic_check
            self._type = 'automaticCheck'
        elif type_of_union == 'manualCheck':
            if manual_check is None:
                raise ValueError('a union value must not be None')
            self._manual_check = manual_check
            self._type = 'manualCheck'

    @builtins.property
    def automatic_check(self) -> Optional["scout_datareview_api_AutomaticCheckEvaluation"]:
        return self._automatic_check

    @builtins.property
    def manual_check(self) -> Optional["scout_datareview_api_ManualCheckEvaluation"]:
        return self._manual_check

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CheckEvaluationVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CheckEvaluationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'automaticCheck' and self.automatic_check is not None:
            return visitor._automatic_check(self.automatic_check)
        if self._type == 'manualCheck' and self.manual_check is not None:
            return visitor._manual_check(self.manual_check)


scout_datareview_api_CheckEvaluation.__name__ = "CheckEvaluation"
scout_datareview_api_CheckEvaluation.__qualname__ = "CheckEvaluation"
scout_datareview_api_CheckEvaluation.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CheckEvaluationVisitor:

    @abstractmethod
    def _automatic_check(self, automatic_check: "scout_datareview_api_AutomaticCheckEvaluation") -> Any:
        pass

    @abstractmethod
    def _manual_check(self, manual_check: "scout_datareview_api_ManualCheckEvaluation") -> Any:
        pass


scout_datareview_api_CheckEvaluationVisitor.__name__ = "CheckEvaluationVisitor"
scout_datareview_api_CheckEvaluationVisitor.__qualname__ = "CheckEvaluationVisitor"
scout_datareview_api_CheckEvaluationVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ChecklistEvaluation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist': ConjureFieldDefinition('checklist', scout_checks_api_PinnedChecklistRef),
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_datareview_api_DataReviewRid),
            'checks': ConjureFieldDefinition('checks', List[scout_datareview_api_CheckEvaluation])
        }

    __slots__: List[str] = ['_checklist', '_data_review_rid', '_checks']

    def __init__(self, checklist: "scout_checks_api_PinnedChecklistRef", checks: List["scout_datareview_api_CheckEvaluation"], data_review_rid: str) -> None:
        self._checklist = checklist
        self._data_review_rid = data_review_rid
        self._checks = checks

    @builtins.property
    def checklist(self) -> "scout_checks_api_PinnedChecklistRef":
        return self._checklist

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def checks(self) -> List["scout_datareview_api_CheckEvaluation"]:
        return self._checks


scout_datareview_api_ChecklistEvaluation.__name__ = "ChecklistEvaluation"
scout_datareview_api_ChecklistEvaluation.__qualname__ = "ChecklistEvaluation"
scout_datareview_api_ChecklistEvaluation.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseAction(ConjureUnionType):
    _close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None
    _close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_with_ignore': ConjureFieldDefinition('closeWithIgnore', scout_datareview_api_CloseWithIgnoreAlert),
            'close_with_further_action': ConjureFieldDefinition('closeWithFurtherAction', scout_datareview_api_CloseWithFurtherAction)
        }

    def __init__(
            self,
            close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None,
            close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (close_with_ignore is not None) + (close_with_further_action is not None) != 1:
                raise ValueError('a union must contain a single member')

            if close_with_ignore is not None:
                self._close_with_ignore = close_with_ignore
                self._type = 'closeWithIgnore'
            if close_with_further_action is not None:
                self._close_with_further_action = close_with_further_action
                self._type = 'closeWithFurtherAction'

        elif type_of_union == 'closeWithIgnore':
            if close_with_ignore is None:
                raise ValueError('a union value must not be None')
            self._close_with_ignore = close_with_ignore
            self._type = 'closeWithIgnore'
        elif type_of_union == 'closeWithFurtherAction':
            if close_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._close_with_further_action = close_with_further_action
            self._type = 'closeWithFurtherAction'

    @builtins.property
    def close_with_ignore(self) -> Optional["scout_datareview_api_CloseWithIgnoreAlert"]:
        return self._close_with_ignore

    @builtins.property
    def close_with_further_action(self) -> Optional["scout_datareview_api_CloseWithFurtherAction"]:
        return self._close_with_further_action

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CloseActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CloseActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'closeWithIgnore' and self.close_with_ignore is not None:
            return visitor._close_with_ignore(self.close_with_ignore)
        if self._type == 'closeWithFurtherAction' and self.close_with_further_action is not None:
            return visitor._close_with_further_action(self.close_with_further_action)


scout_datareview_api_CloseAction.__name__ = "CloseAction"
scout_datareview_api_CloseAction.__qualname__ = "CloseAction"
scout_datareview_api_CloseAction.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseActionVisitor:

    @abstractmethod
    def _close_with_ignore(self, close_with_ignore: "scout_datareview_api_CloseWithIgnoreAlert") -> Any:
        pass

    @abstractmethod
    def _close_with_further_action(self, close_with_further_action: "scout_datareview_api_CloseWithFurtherAction") -> Any:
        pass


scout_datareview_api_CloseActionVisitor.__name__ = "CloseActionVisitor"
scout_datareview_api_CloseActionVisitor.__qualname__ = "CloseActionVisitor"
scout_datareview_api_CloseActionVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseAllLinkedAlerts(ConjureBeanType):
    """
    Close all alerts associated with the same notebook with the same comment.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_CloseAllLinkedAlerts.__name__ = "CloseAllLinkedAlerts"
scout_datareview_api_CloseAllLinkedAlerts.__qualname__ = "CloseAllLinkedAlerts"
scout_datareview_api_CloseAllLinkedAlerts.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseAndDetachFromNotebook(ConjureBeanType):
    """
    Close the alert and detach it from the notebook. If the alert is linked to the same notebook as other 
alerts, those alerts will maintain the reference to the notebook and the notebook will remain unlocked.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_CloseAndDetachFromNotebook.__name__ = "CloseAndDetachFromNotebook"
scout_datareview_api_CloseAndDetachFromNotebook.__qualname__ = "CloseAndDetachFromNotebook"
scout_datareview_api_CloseAndDetachFromNotebook.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook(ConjureBeanType):
    """
    Close the alert and detach it from the notebook. If the alert is linked to the same notebook as other 
alerts, the notebook will be duplicated and the alert will be linked to the new notebook. The new notebook
will be locked.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook.__name__ = "CloseAndDuplicatePreviouslyLinkedNotebook"
scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook.__qualname__ = "CloseAndDuplicatePreviouslyLinkedNotebook"
scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseAndLinkToNotebook(ConjureBeanType):
    """
    Close the alert and link to notebook. Throws if the associated notebook has open alerts.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_action': ConjureFieldDefinition('closeAction', scout_datareview_api_CloseAction)
        }

    __slots__: List[str] = ['_close_action']

    def __init__(self, close_action: "scout_datareview_api_CloseAction") -> None:
        self._close_action = close_action

    @builtins.property
    def close_action(self) -> "scout_datareview_api_CloseAction":
        return self._close_action


scout_datareview_api_CloseAndLinkToNotebook.__name__ = "CloseAndLinkToNotebook"
scout_datareview_api_CloseAndLinkToNotebook.__qualname__ = "CloseAndLinkToNotebook"
scout_datareview_api_CloseAndLinkToNotebook.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseStrategy(ConjureUnionType):
    _close_all_linked_alerts: Optional["scout_datareview_api_CloseAllLinkedAlerts"] = None
    _close_and_detach_from_notebook: Optional["scout_datareview_api_CloseAndDetachFromNotebook"] = None
    _close_and_duplicate_previously_linked_notebook: Optional["scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_all_linked_alerts': ConjureFieldDefinition('closeAllLinkedAlerts', scout_datareview_api_CloseAllLinkedAlerts),
            'close_and_detach_from_notebook': ConjureFieldDefinition('closeAndDetachFromNotebook', scout_datareview_api_CloseAndDetachFromNotebook),
            'close_and_duplicate_previously_linked_notebook': ConjureFieldDefinition('closeAndDuplicatePreviouslyLinkedNotebook', scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook)
        }

    def __init__(
            self,
            close_all_linked_alerts: Optional["scout_datareview_api_CloseAllLinkedAlerts"] = None,
            close_and_detach_from_notebook: Optional["scout_datareview_api_CloseAndDetachFromNotebook"] = None,
            close_and_duplicate_previously_linked_notebook: Optional["scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (close_all_linked_alerts is not None) + (close_and_detach_from_notebook is not None) + (close_and_duplicate_previously_linked_notebook is not None) != 1:
                raise ValueError('a union must contain a single member')

            if close_all_linked_alerts is not None:
                self._close_all_linked_alerts = close_all_linked_alerts
                self._type = 'closeAllLinkedAlerts'
            if close_and_detach_from_notebook is not None:
                self._close_and_detach_from_notebook = close_and_detach_from_notebook
                self._type = 'closeAndDetachFromNotebook'
            if close_and_duplicate_previously_linked_notebook is not None:
                self._close_and_duplicate_previously_linked_notebook = close_and_duplicate_previously_linked_notebook
                self._type = 'closeAndDuplicatePreviouslyLinkedNotebook'

        elif type_of_union == 'closeAllLinkedAlerts':
            if close_all_linked_alerts is None:
                raise ValueError('a union value must not be None')
            self._close_all_linked_alerts = close_all_linked_alerts
            self._type = 'closeAllLinkedAlerts'
        elif type_of_union == 'closeAndDetachFromNotebook':
            if close_and_detach_from_notebook is None:
                raise ValueError('a union value must not be None')
            self._close_and_detach_from_notebook = close_and_detach_from_notebook
            self._type = 'closeAndDetachFromNotebook'
        elif type_of_union == 'closeAndDuplicatePreviouslyLinkedNotebook':
            if close_and_duplicate_previously_linked_notebook is None:
                raise ValueError('a union value must not be None')
            self._close_and_duplicate_previously_linked_notebook = close_and_duplicate_previously_linked_notebook
            self._type = 'closeAndDuplicatePreviouslyLinkedNotebook'

    @builtins.property
    def close_all_linked_alerts(self) -> Optional["scout_datareview_api_CloseAllLinkedAlerts"]:
        return self._close_all_linked_alerts

    @builtins.property
    def close_and_detach_from_notebook(self) -> Optional["scout_datareview_api_CloseAndDetachFromNotebook"]:
        return self._close_and_detach_from_notebook

    @builtins.property
    def close_and_duplicate_previously_linked_notebook(self) -> Optional["scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook"]:
        return self._close_and_duplicate_previously_linked_notebook

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CloseStrategyVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CloseStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'closeAllLinkedAlerts' and self.close_all_linked_alerts is not None:
            return visitor._close_all_linked_alerts(self.close_all_linked_alerts)
        if self._type == 'closeAndDetachFromNotebook' and self.close_and_detach_from_notebook is not None:
            return visitor._close_and_detach_from_notebook(self.close_and_detach_from_notebook)
        if self._type == 'closeAndDuplicatePreviouslyLinkedNotebook' and self.close_and_duplicate_previously_linked_notebook is not None:
            return visitor._close_and_duplicate_previously_linked_notebook(self.close_and_duplicate_previously_linked_notebook)


scout_datareview_api_CloseStrategy.__name__ = "CloseStrategy"
scout_datareview_api_CloseStrategy.__qualname__ = "CloseStrategy"
scout_datareview_api_CloseStrategy.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseStrategyVisitor:

    @abstractmethod
    def _close_all_linked_alerts(self, close_all_linked_alerts: "scout_datareview_api_CloseAllLinkedAlerts") -> Any:
        pass

    @abstractmethod
    def _close_and_detach_from_notebook(self, close_and_detach_from_notebook: "scout_datareview_api_CloseAndDetachFromNotebook") -> Any:
        pass

    @abstractmethod
    def _close_and_duplicate_previously_linked_notebook(self, close_and_duplicate_previously_linked_notebook: "scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook") -> Any:
        pass


scout_datareview_api_CloseStrategyVisitor.__name__ = "CloseStrategyVisitor"
scout_datareview_api_CloseStrategyVisitor.__qualname__ = "CloseStrategyVisitor"
scout_datareview_api_CloseStrategyVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseWithFurtherAction(ConjureBeanType):
    """
    Close the alert with further action. If the alert is linked to the same notebook as other alerts, the other 
alerts will also be closed with further action. This will also lock the associated notebook.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'strategy': ConjureFieldDefinition('strategy', OptionalTypeWrapper[scout_datareview_api_CloseStrategy])
        }

    __slots__: List[str] = ['_comment', '_strategy']

    def __init__(self, comment: str, strategy: Optional["scout_datareview_api_CloseStrategy"] = None) -> None:
        self._comment = comment
        self._strategy = strategy

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def strategy(self) -> Optional["scout_datareview_api_CloseStrategy"]:
        """
        Defines the strategy for reopening the alert and any alerts linked via an associated notebook. If not 
provided, the alert will be closed naively and throw if it leaves a linked notebook in an invalid state.
        """
        return self._strategy


scout_datareview_api_CloseWithFurtherAction.__name__ = "CloseWithFurtherAction"
scout_datareview_api_CloseWithFurtherAction.__qualname__ = "CloseWithFurtherAction"
scout_datareview_api_CloseWithFurtherAction.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CloseWithIgnoreAlert(ConjureBeanType):
    """
    Close the alert with ignore. If the alert is linked to the same notebook as other alerts, the other 
alerts will also be closed with ignore. This will also lock the associated notebook.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'strategy': ConjureFieldDefinition('strategy', OptionalTypeWrapper[scout_datareview_api_CloseStrategy])
        }

    __slots__: List[str] = ['_comment', '_strategy']

    def __init__(self, comment: str, strategy: Optional["scout_datareview_api_CloseStrategy"] = None) -> None:
        self._comment = comment
        self._strategy = strategy

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def strategy(self) -> Optional["scout_datareview_api_CloseStrategy"]:
        """
        Defines the strategy for closing the alert and any alerts linked via an associated notebook. If not 
provided, the default strategy is closeAllLinkedAlerts.
        """
        return self._strategy


scout_datareview_api_CloseWithIgnoreAlert.__name__ = "CloseWithIgnoreAlert"
scout_datareview_api_CloseWithIgnoreAlert.__qualname__ = "CloseWithIgnoreAlert"
scout_datareview_api_CloseWithIgnoreAlert.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ClosedWithFurtherActionAlertState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_comment', '_closed_by']

    def __init__(self, closed_by: str, comment: str) -> None:
        self._comment = comment
        self._closed_by = closed_by

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_datareview_api_ClosedWithFurtherActionAlertState.__name__ = "ClosedWithFurtherActionAlertState"
scout_datareview_api_ClosedWithFurtherActionAlertState.__qualname__ = "ClosedWithFurtherActionAlertState"
scout_datareview_api_ClosedWithFurtherActionAlertState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ClosedWithFurtherActionState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_comment', '_closed_by']

    def __init__(self, closed_by: str, comment: str) -> None:
        self._comment = comment
        self._closed_by = closed_by

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_datareview_api_ClosedWithFurtherActionState.__name__ = "ClosedWithFurtherActionState"
scout_datareview_api_ClosedWithFurtherActionState.__qualname__ = "ClosedWithFurtherActionState"
scout_datareview_api_ClosedWithFurtherActionState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ClosedWithIgnoreAlertState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_comment', '_closed_by']

    def __init__(self, closed_by: str, comment: str) -> None:
        self._comment = comment
        self._closed_by = closed_by

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_datareview_api_ClosedWithIgnoreAlertState.__name__ = "ClosedWithIgnoreAlertState"
scout_datareview_api_ClosedWithIgnoreAlertState.__qualname__ = "ClosedWithIgnoreAlertState"
scout_datareview_api_ClosedWithIgnoreAlertState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_CreateDataReviewRequest(ConjureBeanType):
    """
    If commit not is provided, the latest commit on main will be used.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid),
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'commit': ConjureFieldDefinition('commit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_run_rid', '_checklist_rid', '_commit']

    def __init__(self, checklist_rid: str, run_rid: str, commit: Optional[str] = None) -> None:
        self._run_rid = run_rid
        self._checklist_rid = checklist_rid
        self._commit = commit

    @builtins.property
    def run_rid(self) -> str:
        return self._run_rid

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def commit(self) -> Optional[str]:
        return self._commit


scout_datareview_api_CreateDataReviewRequest.__name__ = "CreateDataReviewRequest"
scout_datareview_api_CreateDataReviewRequest.__qualname__ = "CreateDataReviewRequest"
scout_datareview_api_CreateDataReviewRequest.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_DataReview(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_datareview_api_DataReviewRid),
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'checklist': ConjureFieldDefinition('checklist', scout_datareview_api_ChecklistEvaluation),
            'archived': ConjureFieldDefinition('archived', bool)
        }

    __slots__: List[str] = ['_rid', '_run_rid', '_created_at', '_created_by', '_checklist', '_archived']

    def __init__(self, archived: bool, checklist: "scout_datareview_api_ChecklistEvaluation", created_at: str, created_by: str, rid: str, run_rid: str) -> None:
        self._rid = rid
        self._run_rid = run_rid
        self._created_at = created_at
        self._created_by = created_by
        self._checklist = checklist
        self._archived = archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def run_rid(self) -> str:
        return self._run_rid

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def checklist(self) -> "scout_datareview_api_ChecklistEvaluation":
        return self._checklist

    @builtins.property
    def archived(self) -> bool:
        return self._archived


scout_datareview_api_DataReview.__name__ = "DataReview"
scout_datareview_api_DataReview.__qualname__ = "DataReview"
scout_datareview_api_DataReview.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_DataReviewPage(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_reviews': ConjureFieldDefinition('dataReviews', List[scout_datareview_api_DataReview]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_data_reviews', '_next_page_token']

    def __init__(self, data_reviews: List["scout_datareview_api_DataReview"], next_page_token: Optional[str] = None) -> None:
        self._data_reviews = data_reviews
        self._next_page_token = next_page_token

    @builtins.property
    def data_reviews(self) -> List["scout_datareview_api_DataReview"]:
        return self._data_reviews

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_datareview_api_DataReviewPage.__name__ = "DataReviewPage"
scout_datareview_api_DataReviewPage.__qualname__ = "DataReviewPage"
scout_datareview_api_DataReviewPage.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_DataReviewService(Service):
    """
    The data review service manages the evaluation, disposition, and historical record of checks alerts.
    """

    def batch_initiate(self, auth_header: str, request: "scout_datareview_api_BatchInitiateDataReviewRequest") -> "scout_datareview_api_BatchInitiateDataReviewResponse":
        """
        For each request, initiates data review for the requested run and checklist and executes 
the automatic checks against the run.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/data-review/batch-initiate'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_BatchInitiateDataReviewResponse, self._return_none_for_unknown_union_types)

    def rerun_failed_automatic_checks(self, auth_header: str, request: "scout_datareview_api_RerunFailedAutomaticChecksRequest") -> None:
        """
        Re-executes the most recent failed automatic checks for the data review.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/data-review/rerun-failed-automatic-checks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def find_data_reviews(self, auth_header: str, request: "scout_datareview_api_FindDataReviewsRequest") -> "scout_datareview_api_DataReviewPage":
        """
        Returns the data reviews under the provided search parameters.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/data-review/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_DataReviewPage, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, data_review_rid: str) -> "scout_datareview_api_DataReview":
        """
        Throws if not found.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'dataReviewRid': data_review_rid,
        }

        _json: Any = None

        _path = '/scout/v2/data-review/{dataReviewRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_DataReview, self._return_none_for_unknown_union_types)

    def get_check_alert(self, auth_header: str, check_alert_rid: str) -> "scout_datareview_api_CheckAlert":
        """
        Throws if not found.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'checkAlertRid': check_alert_rid,
        }

        _json: Any = None

        _path = '/scout/v2/data-review/check-alerts/{checkAlertRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_CheckAlert, self._return_none_for_unknown_union_types)

    def get_check_alerts_for_data_review(self, auth_header: str, data_review_rid: str) -> List["scout_datareview_api_CheckAlert"]:
        """
        Gets all check alerts from the provided data review.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'dataReviewRid': data_review_rid,
        }

        _json: Any = None

        _path = '/scout/v2/data-review/{dataReviewRid}/check-alerts'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_datareview_api_CheckAlert], self._return_none_for_unknown_union_types)

    def get_check_alerts_histogram(self, auth_header: str, request: "scout_datareview_api_CheckAlertsHistogramRequest") -> "scout_datareview_api_CheckAlertsHistogramResponse":
        """
        Returns a histogram of alerts that occur across the provided runs.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/data-review/check-alerts/histogram'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_CheckAlertsHistogramResponse, self._return_none_for_unknown_union_types)

    def search_check_alerts(self, auth_header: str, request: "scout_datareview_api_SearchCheckAlertsRequest") -> "scout_datareview_api_SearchCheckAlertsResponse":
        """
        Returns the check alerts under the provided search parameters.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/data-review/check-alerts'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_SearchCheckAlertsResponse, self._return_none_for_unknown_union_types)

    def get_check_alert_action_log(self, auth_header: str, check_alert_rid: str) -> "scout_datareview_api_CheckAlertActionLog":
        """
        Returns a record of the historical actions taken on the provided check alert.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'checkAlertRid': check_alert_rid,
        }

        _json: Any = None

        _path = '/scout/v2/data-review/check-alerts/{checkAlertRid}/action-log'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_CheckAlertActionLog, self._return_none_for_unknown_union_types)

    def get_check_alert_counts_for_notebooks(self, auth_header: str, rids: List[str] = None) -> Dict[str, int]:
        """
        Returns the number of alerts attached to each provided notebook.
        """
        rids = rids if rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(rids)

        _path = '/scout/v2/data-review/get-check-alert-counts-for-notebooks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_rids_api_NotebookRid, int], self._return_none_for_unknown_union_types)

    def get_check_alert_status_for_notebooks(self, auth_header: str, rids: List[str] = None) -> Dict[str, Optional["scout_datareview_api_CheckAlertStatus"]]:
        """
        Returns the check alert status of any linked violations for the provided notebooks. If none exist, an empty
optional is returned.
        """
        rids = rids if rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(rids)

        _path = '/scout/v2/data-review/get-check-alert-status-for-notebooks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_rids_api_NotebookRid, OptionalTypeWrapper[scout_datareview_api_CheckAlertStatus]], self._return_none_for_unknown_union_types)

    def perform_check_alert_action(self, auth_header: str, check_alert_rid: str, request: "scout_datareview_api_CheckAlertAction") -> "scout_datareview_api_CheckAlert":
        """
        Applies a check alert action to the specified check alert RID.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'checkAlertRid': check_alert_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/data-review/check-alerts/{checkAlertRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_CheckAlert, self._return_none_for_unknown_union_types)

    def batch_perform_check_alert_action(self, auth_header: str, request: "scout_datareview_api_BatchCheckAlertActionRequest") -> "scout_datareview_api_BatchCheckAlertActionResponse":
        """
        Applies a check alert action to the specified check alert RIDs. If any of the check actions fail,
then none of the check actions will be applied.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/data-review/check-alerts/batch-perform-action'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_BatchCheckAlertActionResponse, self._return_none_for_unknown_union_types)

    def batch_perform_automatic_check_evaluation_review_action(self, auth_header: str, request: "scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest") -> "scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse":
        """
        Applies an action to the specified check evaluation RIDs. If any of the check actions fail,
then none of the actions will be applied.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/data-review/automatic-check-evaluation/batch-perform-action'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse, self._return_none_for_unknown_union_types)

    def get_automatic_check_evaluation_action_log(self, auth_header: str, rid: str) -> "scout_datareview_api_AutomaticCheckEvaluationActionLog":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v2/data-review/automatic-check-evaluation/{rid}/action-log'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_AutomaticCheckEvaluationActionLog, self._return_none_for_unknown_union_types)

    def batch_perform_manual_check_alert_action(self, auth_header: str, request: "scout_datareview_api_BatchManualCheckEvaluationActionRequest") -> None:
        """
        Applies an action to the specified check evaluation RIDs. If any of the check actions fail,
then none of the actions will be applied.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/data-review/manual-check-evaluation/batch-perform-action'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_manual_check_evaluation_action_log(self, auth_header: str, rid: str) -> "scout_datareview_api_ManualCheckEvaluationActionLog":
        """
        Returns a record of the historical manual actions taken on the provided check evaluation.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/scout/v2/data-review/manual-check-evaluation/{rid}/action-log'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_ManualCheckEvaluationActionLog, self._return_none_for_unknown_union_types)

    def archive_data_review(self, auth_header: str, data_review_rid: str) -> bool:

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'dataReviewRid': data_review_rid,
        }

        _json: Any = None

        _path = '/scout/v2/data-review/{dataReviewRid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), bool, self._return_none_for_unknown_union_types)


scout_datareview_api_DataReviewService.__name__ = "DataReviewService"
scout_datareview_api_DataReviewService.__qualname__ = "DataReviewService"
scout_datareview_api_DataReviewService.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_DuplicateAndLinkNotebook(ConjureBeanType):
    """
    Duplicate the notebook and link the alert to it.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_DuplicateAndLinkNotebook.__name__ = "DuplicateAndLinkNotebook"
scout_datareview_api_DuplicateAndLinkNotebook.__qualname__ = "DuplicateAndLinkNotebook"
scout_datareview_api_DuplicateAndLinkNotebook.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ExecutingState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_ExecutingState.__name__ = "ExecutingState"
scout_datareview_api_ExecutingState.__qualname__ = "ExecutingState"
scout_datareview_api_ExecutingState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ExecutionRetriggered(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_ExecutionRetriggered.__name__ = "ExecutionRetriggered"
scout_datareview_api_ExecutionRetriggered.__qualname__ = "ExecutionRetriggered"
scout_datareview_api_ExecutionRetriggered.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_FailedToExecuteState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid),
            'review_state': ConjureFieldDefinition('reviewState', OptionalTypeWrapper[scout_datareview_api_CheckAlertState]),
            'review_notes': ConjureFieldDefinition('reviewNotes', OptionalTypeWrapper[str]),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', List[scout_rids_api_UserRid])
        }

    __slots__: List[str] = ['_job_rid', '_review_state', '_review_notes', '_assignee_rids']

    def __init__(self, assignee_rids: List[str], job_rid: str, review_notes: Optional[str] = None, review_state: Optional["scout_datareview_api_CheckAlertState"] = None) -> None:
        self._job_rid = job_rid
        self._review_state = review_state
        self._review_notes = review_notes
        self._assignee_rids = assignee_rids

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid

    @builtins.property
    def review_state(self) -> Optional["scout_datareview_api_CheckAlertState"]:
        return self._review_state

    @builtins.property
    def review_notes(self) -> Optional[str]:
        return self._review_notes

    @builtins.property
    def assignee_rids(self) -> List[str]:
        return self._assignee_rids


scout_datareview_api_FailedToExecuteState.__name__ = "FailedToExecuteState"
scout_datareview_api_FailedToExecuteState.__qualname__ = "FailedToExecuteState"
scout_datareview_api_FailedToExecuteState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_FindDataReviewsRequest(ConjureBeanType):
    """
    If both sets are empty, an empty page is returned.
If one set is empty, that field is not considered for filtering (like a wildcard).
If commitId is omitted from a ChecklistRef, it will match all commits.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rids': ConjureFieldDefinition('runRids', List[scout_run_api_RunRid]),
            'checklist_refs': ConjureFieldDefinition('checklistRefs', List[scout_checks_api_ChecklistRef]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'show_archived': ConjureFieldDefinition('showArchived', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_run_rids', '_checklist_refs', '_next_page_token', '_page_size', '_show_archived']

    def __init__(self, checklist_refs: List["scout_checks_api_ChecklistRef"], run_rids: List[str], next_page_token: Optional[str] = None, page_size: Optional[int] = None, show_archived: Optional[bool] = None) -> None:
        self._run_rids = run_rids
        self._checklist_refs = checklist_refs
        self._next_page_token = next_page_token
        self._page_size = page_size
        self._show_archived = show_archived

    @builtins.property
    def run_rids(self) -> List[str]:
        return self._run_rids

    @builtins.property
    def checklist_refs(self) -> List["scout_checks_api_ChecklistRef"]:
        return self._checklist_refs

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 1000. Will throw if larger than 1000.
        """
        return self._page_size

    @builtins.property
    def show_archived(self) -> Optional[bool]:
        """
        Defaults to false if not specified.
        """
        return self._show_archived


scout_datareview_api_FindDataReviewsRequest.__name__ = "FindDataReviewsRequest"
scout_datareview_api_FindDataReviewsRequest.__qualname__ = "FindDataReviewsRequest"
scout_datareview_api_FindDataReviewsRequest.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_GeneratedAlertsState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_datareview_api_CheckAlertRid])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


scout_datareview_api_GeneratedAlertsState.__name__ = "GeneratedAlertsState"
scout_datareview_api_GeneratedAlertsState.__qualname__ = "GeneratedAlertsState"
scout_datareview_api_GeneratedAlertsState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', api_Timestamp),
            'end_exclusive': ConjureFieldDefinition('endExclusive', api_Timestamp),
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive', '_count']

    def __init__(self, count: int, end_exclusive: "api_Timestamp", start_inclusive: "api_Timestamp") -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive
        self._count = count

    @builtins.property
    def start_inclusive(self) -> "api_Timestamp":
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> "api_Timestamp":
        return self._end_exclusive

    @builtins.property
    def count(self) -> int:
        return self._count


scout_datareview_api_HistogramBucket.__name__ = "HistogramBucket"
scout_datareview_api_HistogramBucket.__qualname__ = "HistogramBucket"
scout_datareview_api_HistogramBucket.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramDistributionVariable(ConjureUnionType):
    _start_time: Optional["scout_datareview_api_HistogramStartTimeVariable"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', scout_datareview_api_HistogramStartTimeVariable)
        }

    def __init__(
            self,
            start_time: Optional["scout_datareview_api_HistogramStartTimeVariable"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (start_time is not None) != 1:
                raise ValueError('a union must contain a single member')

            if start_time is not None:
                self._start_time = start_time
                self._type = 'startTime'

        elif type_of_union == 'startTime':
            if start_time is None:
                raise ValueError('a union value must not be None')
            self._start_time = start_time
            self._type = 'startTime'

    @builtins.property
    def start_time(self) -> Optional["scout_datareview_api_HistogramStartTimeVariable"]:
        return self._start_time

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_HistogramDistributionVariableVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_HistogramDistributionVariableVisitor'.format(visitor.__class__.__name__))
        if self._type == 'startTime' and self.start_time is not None:
            return visitor._start_time(self.start_time)


scout_datareview_api_HistogramDistributionVariable.__name__ = "HistogramDistributionVariable"
scout_datareview_api_HistogramDistributionVariable.__qualname__ = "HistogramDistributionVariable"
scout_datareview_api_HistogramDistributionVariable.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramDistributionVariableVisitor:

    @abstractmethod
    def _start_time(self, start_time: "scout_datareview_api_HistogramStartTimeVariable") -> Any:
        pass


scout_datareview_api_HistogramDistributionVariableVisitor.__name__ = "HistogramDistributionVariableVisitor"
scout_datareview_api_HistogramDistributionVariableVisitor.__qualname__ = "HistogramDistributionVariableVisitor"
scout_datareview_api_HistogramDistributionVariableVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramEndTimeVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_HistogramEndTimeVariable.__name__ = "HistogramEndTimeVariable"
scout_datareview_api_HistogramEndTimeVariable.__qualname__ = "HistogramEndTimeVariable"
scout_datareview_api_HistogramEndTimeVariable.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramPriorityBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', api_Timestamp),
            'end_exclusive': ConjureFieldDefinition('endExclusive', api_Timestamp),
            'counts': ConjureFieldDefinition('counts', Dict[scout_checks_api_Priority, int])
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive', '_counts']

    def __init__(self, counts: Dict["scout_checks_api_Priority", int], end_exclusive: "api_Timestamp", start_inclusive: "api_Timestamp") -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive
        self._counts = counts

    @builtins.property
    def start_inclusive(self) -> "api_Timestamp":
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> "api_Timestamp":
        return self._end_exclusive

    @builtins.property
    def counts(self) -> Dict["scout_checks_api_Priority", int]:
        return self._counts


scout_datareview_api_HistogramPriorityBucket.__name__ = "HistogramPriorityBucket"
scout_datareview_api_HistogramPriorityBucket.__qualname__ = "HistogramPriorityBucket"
scout_datareview_api_HistogramPriorityBucket.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramPriorityVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_HistogramPriorityVariable.__name__ = "HistogramPriorityVariable"
scout_datareview_api_HistogramPriorityVariable.__qualname__ = "HistogramPriorityVariable"
scout_datareview_api_HistogramPriorityVariable.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramStartTimeVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_HistogramStartTimeVariable.__name__ = "HistogramStartTimeVariable"
scout_datareview_api_HistogramStartTimeVariable.__qualname__ = "HistogramStartTimeVariable"
scout_datareview_api_HistogramStartTimeVariable.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramStatusBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', api_Timestamp),
            'end_exclusive': ConjureFieldDefinition('endExclusive', api_Timestamp),
            'counts': ConjureFieldDefinition('counts', Dict[scout_datareview_api_CheckAlertStatus, int])
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive', '_counts']

    def __init__(self, counts: Dict["scout_datareview_api_CheckAlertStatus", int], end_exclusive: "api_Timestamp", start_inclusive: "api_Timestamp") -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive
        self._counts = counts

    @builtins.property
    def start_inclusive(self) -> "api_Timestamp":
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> "api_Timestamp":
        return self._end_exclusive

    @builtins.property
    def counts(self) -> Dict["scout_datareview_api_CheckAlertStatus", int]:
        return self._counts


scout_datareview_api_HistogramStatusBucket.__name__ = "HistogramStatusBucket"
scout_datareview_api_HistogramStatusBucket.__qualname__ = "HistogramStatusBucket"
scout_datareview_api_HistogramStatusBucket.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramStatusVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_HistogramStatusVariable.__name__ = "HistogramStatusVariable"
scout_datareview_api_HistogramStatusVariable.__qualname__ = "HistogramStatusVariable"
scout_datareview_api_HistogramStatusVariable.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramSubGroupVariable(ConjureUnionType):
    _priority: Optional["scout_datareview_api_HistogramPriorityVariable"] = None
    _status: Optional["scout_datareview_api_HistogramStatusVariable"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'priority': ConjureFieldDefinition('priority', scout_datareview_api_HistogramPriorityVariable),
            'status': ConjureFieldDefinition('status', scout_datareview_api_HistogramStatusVariable)
        }

    def __init__(
            self,
            priority: Optional["scout_datareview_api_HistogramPriorityVariable"] = None,
            status: Optional["scout_datareview_api_HistogramStatusVariable"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (priority is not None) + (status is not None) != 1:
                raise ValueError('a union must contain a single member')

            if priority is not None:
                self._priority = priority
                self._type = 'priority'
            if status is not None:
                self._status = status
                self._type = 'status'

        elif type_of_union == 'priority':
            if priority is None:
                raise ValueError('a union value must not be None')
            self._priority = priority
            self._type = 'priority'
        elif type_of_union == 'status':
            if status is None:
                raise ValueError('a union value must not be None')
            self._status = status
            self._type = 'status'

    @builtins.property
    def priority(self) -> Optional["scout_datareview_api_HistogramPriorityVariable"]:
        return self._priority

    @builtins.property
    def status(self) -> Optional["scout_datareview_api_HistogramStatusVariable"]:
        return self._status

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_HistogramSubGroupVariableVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_HistogramSubGroupVariableVisitor'.format(visitor.__class__.__name__))
        if self._type == 'priority' and self.priority is not None:
            return visitor._priority(self.priority)
        if self._type == 'status' and self.status is not None:
            return visitor._status(self.status)


scout_datareview_api_HistogramSubGroupVariable.__name__ = "HistogramSubGroupVariable"
scout_datareview_api_HistogramSubGroupVariable.__qualname__ = "HistogramSubGroupVariable"
scout_datareview_api_HistogramSubGroupVariable.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_HistogramSubGroupVariableVisitor:

    @abstractmethod
    def _priority(self, priority: "scout_datareview_api_HistogramPriorityVariable") -> Any:
        pass

    @abstractmethod
    def _status(self, status: "scout_datareview_api_HistogramStatusVariable") -> Any:
        pass


scout_datareview_api_HistogramSubGroupVariableVisitor.__name__ = "HistogramSubGroupVariableVisitor"
scout_datareview_api_HistogramSubGroupVariableVisitor.__qualname__ = "HistogramSubGroupVariableVisitor"
scout_datareview_api_HistogramSubGroupVariableVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_LinkNotebook(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_NotebookRid),
            'strategy': ConjureFieldDefinition('strategy', OptionalTypeWrapper[scout_datareview_api_LinkNotebookStrategy])
        }

    __slots__: List[str] = ['_rid', '_strategy']

    def __init__(self, rid: str, strategy: Optional["scout_datareview_api_LinkNotebookStrategy"] = None) -> None:
        self._rid = rid
        self._strategy = strategy

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def strategy(self) -> Optional["scout_datareview_api_LinkNotebookStrategy"]:
        """
        Defines the strategy for reconciling the alert with any linked alerts via the associated notebook. If not 
provided, the alert will be linked naively and throw if it leaves a linked notebook in an invalid state.
        """
        return self._strategy


scout_datareview_api_LinkNotebook.__name__ = "LinkNotebook"
scout_datareview_api_LinkNotebook.__qualname__ = "LinkNotebook"
scout_datareview_api_LinkNotebook.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_LinkNotebookStrategy(ConjureUnionType):
    _duplicate_and_link_to_new_notebook: Optional["scout_datareview_api_DuplicateAndLinkNotebook"] = None
    _close_and_link: Optional["scout_datareview_api_CloseAndLinkToNotebook"] = None
    _reopen_and_link: Optional["scout_datareview_api_ReopenAndLinkToNotebook"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duplicate_and_link_to_new_notebook': ConjureFieldDefinition('duplicateAndLinkToNewNotebook', scout_datareview_api_DuplicateAndLinkNotebook),
            'close_and_link': ConjureFieldDefinition('closeAndLink', scout_datareview_api_CloseAndLinkToNotebook),
            'reopen_and_link': ConjureFieldDefinition('reopenAndLink', scout_datareview_api_ReopenAndLinkToNotebook)
        }

    def __init__(
            self,
            duplicate_and_link_to_new_notebook: Optional["scout_datareview_api_DuplicateAndLinkNotebook"] = None,
            close_and_link: Optional["scout_datareview_api_CloseAndLinkToNotebook"] = None,
            reopen_and_link: Optional["scout_datareview_api_ReopenAndLinkToNotebook"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (duplicate_and_link_to_new_notebook is not None) + (close_and_link is not None) + (reopen_and_link is not None) != 1:
                raise ValueError('a union must contain a single member')

            if duplicate_and_link_to_new_notebook is not None:
                self._duplicate_and_link_to_new_notebook = duplicate_and_link_to_new_notebook
                self._type = 'duplicateAndLinkToNewNotebook'
            if close_and_link is not None:
                self._close_and_link = close_and_link
                self._type = 'closeAndLink'
            if reopen_and_link is not None:
                self._reopen_and_link = reopen_and_link
                self._type = 'reopenAndLink'

        elif type_of_union == 'duplicateAndLinkToNewNotebook':
            if duplicate_and_link_to_new_notebook is None:
                raise ValueError('a union value must not be None')
            self._duplicate_and_link_to_new_notebook = duplicate_and_link_to_new_notebook
            self._type = 'duplicateAndLinkToNewNotebook'
        elif type_of_union == 'closeAndLink':
            if close_and_link is None:
                raise ValueError('a union value must not be None')
            self._close_and_link = close_and_link
            self._type = 'closeAndLink'
        elif type_of_union == 'reopenAndLink':
            if reopen_and_link is None:
                raise ValueError('a union value must not be None')
            self._reopen_and_link = reopen_and_link
            self._type = 'reopenAndLink'

    @builtins.property
    def duplicate_and_link_to_new_notebook(self) -> Optional["scout_datareview_api_DuplicateAndLinkNotebook"]:
        return self._duplicate_and_link_to_new_notebook

    @builtins.property
    def close_and_link(self) -> Optional["scout_datareview_api_CloseAndLinkToNotebook"]:
        return self._close_and_link

    @builtins.property
    def reopen_and_link(self) -> Optional["scout_datareview_api_ReopenAndLinkToNotebook"]:
        return self._reopen_and_link

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_LinkNotebookStrategyVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_LinkNotebookStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'duplicateAndLinkToNewNotebook' and self.duplicate_and_link_to_new_notebook is not None:
            return visitor._duplicate_and_link_to_new_notebook(self.duplicate_and_link_to_new_notebook)
        if self._type == 'closeAndLink' and self.close_and_link is not None:
            return visitor._close_and_link(self.close_and_link)
        if self._type == 'reopenAndLink' and self.reopen_and_link is not None:
            return visitor._reopen_and_link(self.reopen_and_link)


scout_datareview_api_LinkNotebookStrategy.__name__ = "LinkNotebookStrategy"
scout_datareview_api_LinkNotebookStrategy.__qualname__ = "LinkNotebookStrategy"
scout_datareview_api_LinkNotebookStrategy.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_LinkNotebookStrategyVisitor:

    @abstractmethod
    def _duplicate_and_link_to_new_notebook(self, duplicate_and_link_to_new_notebook: "scout_datareview_api_DuplicateAndLinkNotebook") -> Any:
        pass

    @abstractmethod
    def _close_and_link(self, close_and_link: "scout_datareview_api_CloseAndLinkToNotebook") -> Any:
        pass

    @abstractmethod
    def _reopen_and_link(self, reopen_and_link: "scout_datareview_api_ReopenAndLinkToNotebook") -> Any:
        pass


scout_datareview_api_LinkNotebookStrategyVisitor.__name__ = "LinkNotebookStrategyVisitor"
scout_datareview_api_LinkNotebookStrategyVisitor.__qualname__ = "LinkNotebookStrategyVisitor"
scout_datareview_api_LinkNotebookStrategyVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ManualCheckAlertAction(ConjureUnionType):
    _pass_: Optional["scout_datareview_api_Pass"] = None
    _close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None
    _reopen: Optional["scout_datareview_api_Reopen"] = None
    _reassign: Optional["scout_datareview_api_Reassign"] = None
    _update_notes: Optional["scout_datareview_api_UpdateNotes"] = None
    _link_notebook: Optional["scout_datareview_api_LinkNotebook"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pass_': ConjureFieldDefinition('pass', scout_datareview_api_Pass),
            'close_with_further_action': ConjureFieldDefinition('closeWithFurtherAction', scout_datareview_api_CloseWithFurtherAction),
            'reopen': ConjureFieldDefinition('reopen', scout_datareview_api_Reopen),
            'reassign': ConjureFieldDefinition('reassign', scout_datareview_api_Reassign),
            'update_notes': ConjureFieldDefinition('updateNotes', scout_datareview_api_UpdateNotes),
            'link_notebook': ConjureFieldDefinition('linkNotebook', scout_datareview_api_LinkNotebook)
        }

    def __init__(
            self,
            pass_: Optional["scout_datareview_api_Pass"] = None,
            close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None,
            reopen: Optional["scout_datareview_api_Reopen"] = None,
            reassign: Optional["scout_datareview_api_Reassign"] = None,
            update_notes: Optional["scout_datareview_api_UpdateNotes"] = None,
            link_notebook: Optional["scout_datareview_api_LinkNotebook"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pass_ is not None) + (close_with_further_action is not None) + (reopen is not None) + (reassign is not None) + (update_notes is not None) + (link_notebook is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pass_ is not None:
                self._pass_ = pass_
                self._type = 'pass'
            if close_with_further_action is not None:
                self._close_with_further_action = close_with_further_action
                self._type = 'closeWithFurtherAction'
            if reopen is not None:
                self._reopen = reopen
                self._type = 'reopen'
            if reassign is not None:
                self._reassign = reassign
                self._type = 'reassign'
            if update_notes is not None:
                self._update_notes = update_notes
                self._type = 'updateNotes'
            if link_notebook is not None:
                self._link_notebook = link_notebook
                self._type = 'linkNotebook'

        elif type_of_union == 'pass':
            if pass_ is None:
                raise ValueError('a union value must not be None')
            self._pass_ = pass_
            self._type = 'pass'
        elif type_of_union == 'closeWithFurtherAction':
            if close_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._close_with_further_action = close_with_further_action
            self._type = 'closeWithFurtherAction'
        elif type_of_union == 'reopen':
            if reopen is None:
                raise ValueError('a union value must not be None')
            self._reopen = reopen
            self._type = 'reopen'
        elif type_of_union == 'reassign':
            if reassign is None:
                raise ValueError('a union value must not be None')
            self._reassign = reassign
            self._type = 'reassign'
        elif type_of_union == 'updateNotes':
            if update_notes is None:
                raise ValueError('a union value must not be None')
            self._update_notes = update_notes
            self._type = 'updateNotes'
        elif type_of_union == 'linkNotebook':
            if link_notebook is None:
                raise ValueError('a union value must not be None')
            self._link_notebook = link_notebook
            self._type = 'linkNotebook'

    @builtins.property
    def pass_(self) -> Optional["scout_datareview_api_Pass"]:
        return self._pass_

    @builtins.property
    def close_with_further_action(self) -> Optional["scout_datareview_api_CloseWithFurtherAction"]:
        return self._close_with_further_action

    @builtins.property
    def reopen(self) -> Optional["scout_datareview_api_Reopen"]:
        return self._reopen

    @builtins.property
    def reassign(self) -> Optional["scout_datareview_api_Reassign"]:
        return self._reassign

    @builtins.property
    def update_notes(self) -> Optional["scout_datareview_api_UpdateNotes"]:
        return self._update_notes

    @builtins.property
    def link_notebook(self) -> Optional["scout_datareview_api_LinkNotebook"]:
        return self._link_notebook

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_ManualCheckAlertActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_ManualCheckAlertActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pass' and self.pass_ is not None:
            return visitor._pass(self.pass_)
        if self._type == 'closeWithFurtherAction' and self.close_with_further_action is not None:
            return visitor._close_with_further_action(self.close_with_further_action)
        if self._type == 'reopen' and self.reopen is not None:
            return visitor._reopen(self.reopen)
        if self._type == 'reassign' and self.reassign is not None:
            return visitor._reassign(self.reassign)
        if self._type == 'updateNotes' and self.update_notes is not None:
            return visitor._update_notes(self.update_notes)
        if self._type == 'linkNotebook' and self.link_notebook is not None:
            return visitor._link_notebook(self.link_notebook)


scout_datareview_api_ManualCheckAlertAction.__name__ = "ManualCheckAlertAction"
scout_datareview_api_ManualCheckAlertAction.__qualname__ = "ManualCheckAlertAction"
scout_datareview_api_ManualCheckAlertAction.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ManualCheckAlertActionVisitor:

    @abstractmethod
    def _pass(self, pass_: "scout_datareview_api_Pass") -> Any:
        pass

    @abstractmethod
    def _close_with_further_action(self, close_with_further_action: "scout_datareview_api_CloseWithFurtherAction") -> Any:
        pass

    @abstractmethod
    def _reopen(self, reopen: "scout_datareview_api_Reopen") -> Any:
        pass

    @abstractmethod
    def _reassign(self, reassign: "scout_datareview_api_Reassign") -> Any:
        pass

    @abstractmethod
    def _update_notes(self, update_notes: "scout_datareview_api_UpdateNotes") -> Any:
        pass

    @abstractmethod
    def _link_notebook(self, link_notebook: "scout_datareview_api_LinkNotebook") -> Any:
        pass


scout_datareview_api_ManualCheckAlertActionVisitor.__name__ = "ManualCheckAlertActionVisitor"
scout_datareview_api_ManualCheckAlertActionVisitor.__qualname__ = "ManualCheckAlertActionVisitor"
scout_datareview_api_ManualCheckAlertActionVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_datareview_api_ManualCheckEvaluationRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_datareview_api_DataReviewRid),
            'state': ConjureFieldDefinition('state', scout_datareview_api_ManualCheckEvaluationState),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', List[scout_rids_api_UserRid]),
            'chart': ConjureFieldDefinition('chart', OptionalTypeWrapper[scout_rids_api_VersionedChartRid]),
            'notes': ConjureFieldDefinition('notes', OptionalTypeWrapper[str]),
            'notebook': ConjureFieldDefinition('notebook', OptionalTypeWrapper[scout_rids_api_NotebookRid])
        }

    __slots__: List[str] = ['_rid', '_check_rid', '_data_review_rid', '_state', '_assignee_rids', '_chart', '_notes', '_notebook']

    def __init__(self, assignee_rids: List[str], check_rid: str, data_review_rid: str, rid: str, state: "scout_datareview_api_ManualCheckEvaluationState", chart: Optional["scout_rids_api_VersionedChartRid"] = None, notebook: Optional[str] = None, notes: Optional[str] = None) -> None:
        self._rid = rid
        self._check_rid = check_rid
        self._data_review_rid = data_review_rid
        self._state = state
        self._assignee_rids = assignee_rids
        self._chart = chart
        self._notes = notes
        self._notebook = notebook

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def state(self) -> "scout_datareview_api_ManualCheckEvaluationState":
        return self._state

    @builtins.property
    def assignee_rids(self) -> List[str]:
        return self._assignee_rids

    @builtins.property
    def chart(self) -> Optional["scout_rids_api_VersionedChartRid"]:
        return self._chart

    @builtins.property
    def notes(self) -> Optional[str]:
        return self._notes

    @builtins.property
    def notebook(self) -> Optional[str]:
        return self._notebook


scout_datareview_api_ManualCheckEvaluation.__name__ = "ManualCheckEvaluation"
scout_datareview_api_ManualCheckEvaluation.__qualname__ = "ManualCheckEvaluation"
scout_datareview_api_ManualCheckEvaluation.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluationActionLog(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'entries': ConjureFieldDefinition('entries', List[scout_datareview_api_ManualCheckEvaluationActionLogEntry])
        }

    __slots__: List[str] = ['_entries']

    def __init__(self, entries: List["scout_datareview_api_ManualCheckEvaluationActionLogEntry"]) -> None:
        self._entries = entries

    @builtins.property
    def entries(self) -> List["scout_datareview_api_ManualCheckEvaluationActionLogEntry"]:
        return self._entries


scout_datareview_api_ManualCheckEvaluationActionLog.__name__ = "ManualCheckEvaluationActionLog"
scout_datareview_api_ManualCheckEvaluationActionLog.__qualname__ = "ManualCheckEvaluationActionLog"
scout_datareview_api_ManualCheckEvaluationActionLog.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluationActionLogEntry(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'performed_by': ConjureFieldDefinition('performedBy', scout_rids_api_UserRid),
            'action': ConjureFieldDefinition('action', scout_datareview_api_ManualCheckAlertAction),
            'timestamp': ConjureFieldDefinition('timestamp', str)
        }

    __slots__: List[str] = ['_performed_by', '_action', '_timestamp']

    def __init__(self, action: "scout_datareview_api_ManualCheckAlertAction", performed_by: str, timestamp: str) -> None:
        self._performed_by = performed_by
        self._action = action
        self._timestamp = timestamp

    @builtins.property
    def performed_by(self) -> str:
        return self._performed_by

    @builtins.property
    def action(self) -> "scout_datareview_api_ManualCheckAlertAction":
        return self._action

    @builtins.property
    def timestamp(self) -> str:
        return self._timestamp


scout_datareview_api_ManualCheckEvaluationActionLogEntry.__name__ = "ManualCheckEvaluationActionLogEntry"
scout_datareview_api_ManualCheckEvaluationActionLogEntry.__qualname__ = "ManualCheckEvaluationActionLogEntry"
scout_datareview_api_ManualCheckEvaluationActionLogEntry.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluationState(ConjureUnionType):
    _pending_review: Optional["scout_datareview_api_PendingReviewState"] = None
    _closed_with_further_action: Optional["scout_datareview_api_ClosedWithFurtherActionState"] = None
    _passing: Optional["scout_datareview_api_PassState"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_review': ConjureFieldDefinition('pendingReview', scout_datareview_api_PendingReviewState),
            'closed_with_further_action': ConjureFieldDefinition('closedWithFurtherAction', scout_datareview_api_ClosedWithFurtherActionState),
            'passing': ConjureFieldDefinition('passing', scout_datareview_api_PassState)
        }

    def __init__(
            self,
            pending_review: Optional["scout_datareview_api_PendingReviewState"] = None,
            closed_with_further_action: Optional["scout_datareview_api_ClosedWithFurtherActionState"] = None,
            passing: Optional["scout_datareview_api_PassState"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pending_review is not None) + (closed_with_further_action is not None) + (passing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pending_review is not None:
                self._pending_review = pending_review
                self._type = 'pendingReview'
            if closed_with_further_action is not None:
                self._closed_with_further_action = closed_with_further_action
                self._type = 'closedWithFurtherAction'
            if passing is not None:
                self._passing = passing
                self._type = 'passing'

        elif type_of_union == 'pendingReview':
            if pending_review is None:
                raise ValueError('a union value must not be None')
            self._pending_review = pending_review
            self._type = 'pendingReview'
        elif type_of_union == 'closedWithFurtherAction':
            if closed_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._closed_with_further_action = closed_with_further_action
            self._type = 'closedWithFurtherAction'
        elif type_of_union == 'passing':
            if passing is None:
                raise ValueError('a union value must not be None')
            self._passing = passing
            self._type = 'passing'

    @builtins.property
    def pending_review(self) -> Optional["scout_datareview_api_PendingReviewState"]:
        return self._pending_review

    @builtins.property
    def closed_with_further_action(self) -> Optional["scout_datareview_api_ClosedWithFurtherActionState"]:
        return self._closed_with_further_action

    @builtins.property
    def passing(self) -> Optional["scout_datareview_api_PassState"]:
        return self._passing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_ManualCheckEvaluationStateVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_ManualCheckEvaluationStateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pendingReview' and self.pending_review is not None:
            return visitor._pending_review(self.pending_review)
        if self._type == 'closedWithFurtherAction' and self.closed_with_further_action is not None:
            return visitor._closed_with_further_action(self.closed_with_further_action)
        if self._type == 'passing' and self.passing is not None:
            return visitor._passing(self.passing)


scout_datareview_api_ManualCheckEvaluationState.__name__ = "ManualCheckEvaluationState"
scout_datareview_api_ManualCheckEvaluationState.__qualname__ = "ManualCheckEvaluationState"
scout_datareview_api_ManualCheckEvaluationState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluationStateVisitor:

    @abstractmethod
    def _pending_review(self, pending_review: "scout_datareview_api_PendingReviewState") -> Any:
        pass

    @abstractmethod
    def _closed_with_further_action(self, closed_with_further_action: "scout_datareview_api_ClosedWithFurtherActionState") -> Any:
        pass

    @abstractmethod
    def _passing(self, passing: "scout_datareview_api_PassState") -> Any:
        pass


scout_datareview_api_ManualCheckEvaluationStateVisitor.__name__ = "ManualCheckEvaluationStateVisitor"
scout_datareview_api_ManualCheckEvaluationStateVisitor.__qualname__ = "ManualCheckEvaluationStateVisitor"
scout_datareview_api_ManualCheckEvaluationStateVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_Pass(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str)
        }

    __slots__: List[str] = ['_comment']

    def __init__(self, comment: str) -> None:
        self._comment = comment

    @builtins.property
    def comment(self) -> str:
        return self._comment


scout_datareview_api_Pass.__name__ = "Pass"
scout_datareview_api_Pass.__qualname__ = "Pass"
scout_datareview_api_Pass.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_PassState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_comment', '_closed_by']

    def __init__(self, closed_by: str, comment: str) -> None:
        self._comment = comment
        self._closed_by = closed_by

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_datareview_api_PassState.__name__ = "PassState"
scout_datareview_api_PassState.__qualname__ = "PassState"
scout_datareview_api_PassState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_PassingExecutionState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_PassingExecutionState.__name__ = "PassingExecutionState"
scout_datareview_api_PassingExecutionState.__qualname__ = "PassingExecutionState"
scout_datareview_api_PassingExecutionState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_PendingExecutionState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_PendingExecutionState.__name__ = "PendingExecutionState"
scout_datareview_api_PendingExecutionState.__qualname__ = "PendingExecutionState"
scout_datareview_api_PendingExecutionState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_PendingReviewAlertState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_PendingReviewAlertState.__name__ = "PendingReviewAlertState"
scout_datareview_api_PendingReviewAlertState.__qualname__ = "PendingReviewAlertState"
scout_datareview_api_PendingReviewAlertState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_PendingReviewState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_PendingReviewState.__name__ = "PendingReviewState"
scout_datareview_api_PendingReviewState.__qualname__ = "PendingReviewState"
scout_datareview_api_PendingReviewState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_Reassign(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'assignee_rids': ConjureFieldDefinition('assigneeRids', List[scout_rids_api_UserRid])
        }

    __slots__: List[str] = ['_assignee_rids']

    def __init__(self, assignee_rids: List[str]) -> None:
        self._assignee_rids = assignee_rids

    @builtins.property
    def assignee_rids(self) -> List[str]:
        return self._assignee_rids


scout_datareview_api_Reassign.__name__ = "Reassign"
scout_datareview_api_Reassign.__qualname__ = "Reassign"
scout_datareview_api_Reassign.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_Reopen(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'strategy': ConjureFieldDefinition('strategy', OptionalTypeWrapper[scout_datareview_api_ReopenStrategy])
        }

    __slots__: List[str] = ['_comment', '_strategy']

    def __init__(self, comment: str, strategy: Optional["scout_datareview_api_ReopenStrategy"] = None) -> None:
        self._comment = comment
        self._strategy = strategy

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def strategy(self) -> Optional["scout_datareview_api_ReopenStrategy"]:
        """
        Defines the strategy for reopening the alert and any alerts linked via an associated notebook. If not 
provided, the default strategy is reopenAllLinkedAlerts.
        """
        return self._strategy


scout_datareview_api_Reopen.__name__ = "Reopen"
scout_datareview_api_Reopen.__qualname__ = "Reopen"
scout_datareview_api_Reopen.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ReopenAllLinkedAlerts(ConjureBeanType):
    """
    Reopen all alerts associated with the same notebook and unlock the notebook.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_ReopenAllLinkedAlerts.__name__ = "ReopenAllLinkedAlerts"
scout_datareview_api_ReopenAllLinkedAlerts.__qualname__ = "ReopenAllLinkedAlerts"
scout_datareview_api_ReopenAllLinkedAlerts.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ReopenAndDetachFromNotebook(ConjureBeanType):
    """
    Reopen the alert and detach it from the notebook. If the alert is linked to the same notebook as other 
alerts, those alerts will maintain the reference to the notebook and the notebook will remain locked.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_ReopenAndDetachFromNotebook.__name__ = "ReopenAndDetachFromNotebook"
scout_datareview_api_ReopenAndDetachFromNotebook.__qualname__ = "ReopenAndDetachFromNotebook"
scout_datareview_api_ReopenAndDetachFromNotebook.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook(ConjureBeanType):
    """
    Reopen the alert and detach it from the notebook. If the alert is linked to the same notebook as other 
alerts, the notebook will be duplicated and the alert will be linked to the new notebook. The new notebook
will be unlocked.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook.__name__ = "ReopenAndDuplicatePreviouslyLinkedNotebook"
scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook.__qualname__ = "ReopenAndDuplicatePreviouslyLinkedNotebook"
scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ReopenAndLinkToNotebook(ConjureBeanType):
    """
    Reopen the alert and link to notebook. Throws if the associated notebook has closed alerts.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str)
        }

    __slots__: List[str] = ['_comment']

    def __init__(self, comment: str) -> None:
        self._comment = comment

    @builtins.property
    def comment(self) -> str:
        return self._comment


scout_datareview_api_ReopenAndLinkToNotebook.__name__ = "ReopenAndLinkToNotebook"
scout_datareview_api_ReopenAndLinkToNotebook.__qualname__ = "ReopenAndLinkToNotebook"
scout_datareview_api_ReopenAndLinkToNotebook.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ReopenStrategy(ConjureUnionType):
    _reopen_all_linked_alerts: Optional["scout_datareview_api_ReopenAllLinkedAlerts"] = None
    _reopen_and_detach_from_notebook: Optional["scout_datareview_api_ReopenAndDetachFromNotebook"] = None
    _reopen_and_duplicate_previously_linked_notebook: Optional["scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'reopen_all_linked_alerts': ConjureFieldDefinition('reopenAllLinkedAlerts', scout_datareview_api_ReopenAllLinkedAlerts),
            'reopen_and_detach_from_notebook': ConjureFieldDefinition('reopenAndDetachFromNotebook', scout_datareview_api_ReopenAndDetachFromNotebook),
            'reopen_and_duplicate_previously_linked_notebook': ConjureFieldDefinition('reopenAndDuplicatePreviouslyLinkedNotebook', scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook)
        }

    def __init__(
            self,
            reopen_all_linked_alerts: Optional["scout_datareview_api_ReopenAllLinkedAlerts"] = None,
            reopen_and_detach_from_notebook: Optional["scout_datareview_api_ReopenAndDetachFromNotebook"] = None,
            reopen_and_duplicate_previously_linked_notebook: Optional["scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (reopen_all_linked_alerts is not None) + (reopen_and_detach_from_notebook is not None) + (reopen_and_duplicate_previously_linked_notebook is not None) != 1:
                raise ValueError('a union must contain a single member')

            if reopen_all_linked_alerts is not None:
                self._reopen_all_linked_alerts = reopen_all_linked_alerts
                self._type = 'reopenAllLinkedAlerts'
            if reopen_and_detach_from_notebook is not None:
                self._reopen_and_detach_from_notebook = reopen_and_detach_from_notebook
                self._type = 'reopenAndDetachFromNotebook'
            if reopen_and_duplicate_previously_linked_notebook is not None:
                self._reopen_and_duplicate_previously_linked_notebook = reopen_and_duplicate_previously_linked_notebook
                self._type = 'reopenAndDuplicatePreviouslyLinkedNotebook'

        elif type_of_union == 'reopenAllLinkedAlerts':
            if reopen_all_linked_alerts is None:
                raise ValueError('a union value must not be None')
            self._reopen_all_linked_alerts = reopen_all_linked_alerts
            self._type = 'reopenAllLinkedAlerts'
        elif type_of_union == 'reopenAndDetachFromNotebook':
            if reopen_and_detach_from_notebook is None:
                raise ValueError('a union value must not be None')
            self._reopen_and_detach_from_notebook = reopen_and_detach_from_notebook
            self._type = 'reopenAndDetachFromNotebook'
        elif type_of_union == 'reopenAndDuplicatePreviouslyLinkedNotebook':
            if reopen_and_duplicate_previously_linked_notebook is None:
                raise ValueError('a union value must not be None')
            self._reopen_and_duplicate_previously_linked_notebook = reopen_and_duplicate_previously_linked_notebook
            self._type = 'reopenAndDuplicatePreviouslyLinkedNotebook'

    @builtins.property
    def reopen_all_linked_alerts(self) -> Optional["scout_datareview_api_ReopenAllLinkedAlerts"]:
        return self._reopen_all_linked_alerts

    @builtins.property
    def reopen_and_detach_from_notebook(self) -> Optional["scout_datareview_api_ReopenAndDetachFromNotebook"]:
        return self._reopen_and_detach_from_notebook

    @builtins.property
    def reopen_and_duplicate_previously_linked_notebook(self) -> Optional["scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook"]:
        return self._reopen_and_duplicate_previously_linked_notebook

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_ReopenStrategyVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_ReopenStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'reopenAllLinkedAlerts' and self.reopen_all_linked_alerts is not None:
            return visitor._reopen_all_linked_alerts(self.reopen_all_linked_alerts)
        if self._type == 'reopenAndDetachFromNotebook' and self.reopen_and_detach_from_notebook is not None:
            return visitor._reopen_and_detach_from_notebook(self.reopen_and_detach_from_notebook)
        if self._type == 'reopenAndDuplicatePreviouslyLinkedNotebook' and self.reopen_and_duplicate_previously_linked_notebook is not None:
            return visitor._reopen_and_duplicate_previously_linked_notebook(self.reopen_and_duplicate_previously_linked_notebook)


scout_datareview_api_ReopenStrategy.__name__ = "ReopenStrategy"
scout_datareview_api_ReopenStrategy.__qualname__ = "ReopenStrategy"
scout_datareview_api_ReopenStrategy.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_ReopenStrategyVisitor:

    @abstractmethod
    def _reopen_all_linked_alerts(self, reopen_all_linked_alerts: "scout_datareview_api_ReopenAllLinkedAlerts") -> Any:
        pass

    @abstractmethod
    def _reopen_and_detach_from_notebook(self, reopen_and_detach_from_notebook: "scout_datareview_api_ReopenAndDetachFromNotebook") -> Any:
        pass

    @abstractmethod
    def _reopen_and_duplicate_previously_linked_notebook(self, reopen_and_duplicate_previously_linked_notebook: "scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook") -> Any:
        pass


scout_datareview_api_ReopenStrategyVisitor.__name__ = "ReopenStrategyVisitor"
scout_datareview_api_ReopenStrategyVisitor.__qualname__ = "ReopenStrategyVisitor"
scout_datareview_api_ReopenStrategyVisitor.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_RerunFailedAutomaticChecksRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_datareview_api_DataReviewRid)
        }

    __slots__: List[str] = ['_data_review_rid']

    def __init__(self, data_review_rid: str) -> None:
        self._data_review_rid = data_review_rid

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid


scout_datareview_api_RerunFailedAutomaticChecksRequest.__name__ = "RerunFailedAutomaticChecksRequest"
scout_datareview_api_RerunFailedAutomaticChecksRequest.__qualname__ = "RerunFailedAutomaticChecksRequest"
scout_datareview_api_RerunFailedAutomaticChecksRequest.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_SearchCheckAlertsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[scout_datareview_api_SearchCheckAlertsSortOptions]),
            'search_text': ConjureFieldDefinition('searchText', OptionalTypeWrapper[str]),
            'after': ConjureFieldDefinition('after', OptionalTypeWrapper[api_Timestamp]),
            'before': ConjureFieldDefinition('before', OptionalTypeWrapper[api_Timestamp]),
            'status': ConjureFieldDefinition('status', OptionalTypeWrapper[List[scout_datareview_api_CheckAlertStatus]]),
            'check_rids': ConjureFieldDefinition('checkRids', OptionalTypeWrapper[List[scout_rids_api_CheckRid]]),
            'data_review_rids': ConjureFieldDefinition('dataReviewRids', OptionalTypeWrapper[List[scout_datareview_api_DataReviewRid]]),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', OptionalTypeWrapper[List[scout_rids_api_UserRid]]),
            'priorities': ConjureFieldDefinition('priorities', OptionalTypeWrapper[List[scout_checks_api_Priority]]),
            'run_rids': ConjureFieldDefinition('runRids', List[scout_run_api_RunRid]),
            'pinned_checklist_refs': ConjureFieldDefinition('pinnedChecklistRefs', OptionalTypeWrapper[List[scout_checks_api_PinnedChecklistRef]]),
            'chart_rids': ConjureFieldDefinition('chartRids', OptionalTypeWrapper[List[scout_rids_api_VersionedChartRid]]),
            'notebook_rids': ConjureFieldDefinition('notebookRids', OptionalTypeWrapper[List[scout_rids_api_NotebookRid]]),
            'show_archived': ConjureFieldDefinition('showArchived', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_next_page_token', '_page_size', '_sort_by', '_search_text', '_after', '_before', '_status', '_check_rids', '_data_review_rids', '_assignee_rids', '_priorities', '_run_rids', '_pinned_checklist_refs', '_chart_rids', '_notebook_rids', '_show_archived']

    def __init__(self, run_rids: List[str], after: Optional["api_Timestamp"] = None, assignee_rids: Optional[List[str]] = None, before: Optional["api_Timestamp"] = None, chart_rids: Optional[List["scout_rids_api_VersionedChartRid"]] = None, check_rids: Optional[List[str]] = None, data_review_rids: Optional[List[str]] = None, next_page_token: Optional[str] = None, notebook_rids: Optional[List[str]] = None, page_size: Optional[int] = None, pinned_checklist_refs: Optional[List["scout_checks_api_PinnedChecklistRef"]] = None, priorities: Optional[List["scout_checks_api_Priority"]] = None, search_text: Optional[str] = None, show_archived: Optional[bool] = None, sort_by: Optional["scout_datareview_api_SearchCheckAlertsSortOptions"] = None, status: Optional[List["scout_datareview_api_CheckAlertStatus"]] = None) -> None:
        self._next_page_token = next_page_token
        self._page_size = page_size
        self._sort_by = sort_by
        self._search_text = search_text
        self._after = after
        self._before = before
        self._status = status
        self._check_rids = check_rids
        self._data_review_rids = data_review_rids
        self._assignee_rids = assignee_rids
        self._priorities = priorities
        self._run_rids = run_rids
        self._pinned_checklist_refs = pinned_checklist_refs
        self._chart_rids = chart_rids
        self._notebook_rids = notebook_rids
        self._show_archived = show_archived

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size

    @builtins.property
    def sort_by(self) -> Optional["scout_datareview_api_SearchCheckAlertsSortOptions"]:
        """
        If not present, will sort by start time in descending order.
        """
        return self._sort_by

    @builtins.property
    def search_text(self) -> Optional[str]:
        """
        Matches on check name
        """
        return self._search_text

    @builtins.property
    def after(self) -> Optional["api_Timestamp"]:
        """
        Filters to start times after this time, inclusive.
        """
        return self._after

    @builtins.property
    def before(self) -> Optional["api_Timestamp"]:
        """
        Filters to start times before this time, exclusive.
        """
        return self._before

    @builtins.property
    def status(self) -> Optional[List["scout_datareview_api_CheckAlertStatus"]]:
        return self._status

    @builtins.property
    def check_rids(self) -> Optional[List[str]]:
        return self._check_rids

    @builtins.property
    def data_review_rids(self) -> Optional[List[str]]:
        return self._data_review_rids

    @builtins.property
    def assignee_rids(self) -> Optional[List[str]]:
        return self._assignee_rids

    @builtins.property
    def priorities(self) -> Optional[List["scout_checks_api_Priority"]]:
        return self._priorities

    @builtins.property
    def run_rids(self) -> List[str]:
        return self._run_rids

    @builtins.property
    def pinned_checklist_refs(self) -> Optional[List["scout_checks_api_PinnedChecklistRef"]]:
        return self._pinned_checklist_refs

    @builtins.property
    def chart_rids(self) -> Optional[List["scout_rids_api_VersionedChartRid"]]:
        return self._chart_rids

    @builtins.property
    def notebook_rids(self) -> Optional[List[str]]:
        return self._notebook_rids

    @builtins.property
    def show_archived(self) -> Optional[bool]:
        """
        If not present, will not show archived data reviews in search results
        """
        return self._show_archived


scout_datareview_api_SearchCheckAlertsRequest.__name__ = "SearchCheckAlertsRequest"
scout_datareview_api_SearchCheckAlertsRequest.__qualname__ = "SearchCheckAlertsRequest"
scout_datareview_api_SearchCheckAlertsRequest.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_SearchCheckAlertsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'check_alerts': ConjureFieldDefinition('checkAlerts', List[scout_datareview_api_CheckAlert])
        }

    __slots__: List[str] = ['_next_page_token', '_check_alerts']

    def __init__(self, check_alerts: List["scout_datareview_api_CheckAlert"], next_page_token: Optional[str] = None) -> None:
        self._next_page_token = next_page_token
        self._check_alerts = check_alerts

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def check_alerts(self) -> List["scout_datareview_api_CheckAlert"]:
        return self._check_alerts


scout_datareview_api_SearchCheckAlertsResponse.__name__ = "SearchCheckAlertsResponse"
scout_datareview_api_SearchCheckAlertsResponse.__qualname__ = "SearchCheckAlertsResponse"
scout_datareview_api_SearchCheckAlertsResponse.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_SearchCheckAlertsSortField(ConjureEnumType):

    CHECK_NAME = 'CHECK_NAME'
    '''CHECK_NAME'''
    START = 'START'
    '''START'''
    END = 'END'
    '''END'''
    STATUS = 'STATUS'
    '''STATUS'''
    PRIORITY = 'PRIORITY'
    '''PRIORITY'''
    DURATION = 'DURATION'
    '''DURATION'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datareview_api_SearchCheckAlertsSortField.__name__ = "SearchCheckAlertsSortField"
scout_datareview_api_SearchCheckAlertsSortField.__qualname__ = "SearchCheckAlertsSortField"
scout_datareview_api_SearchCheckAlertsSortField.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_SearchCheckAlertsSortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_datareview_api_SearchCheckAlertsSortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_datareview_api_SearchCheckAlertsSortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_datareview_api_SearchCheckAlertsSortField":
        return self._field


scout_datareview_api_SearchCheckAlertsSortOptions.__name__ = "SearchCheckAlertsSortOptions"
scout_datareview_api_SearchCheckAlertsSortOptions.__qualname__ = "SearchCheckAlertsSortOptions"
scout_datareview_api_SearchCheckAlertsSortOptions.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_Status(ConjureEnumType):

    PASS = 'PASS'
    '''PASS'''
    FAIL = 'FAIL'
    '''FAIL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datareview_api_Status.__name__ = "Status"
scout_datareview_api_Status.__qualname__ = "Status"
scout_datareview_api_Status.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_TooManyAlertsState(ConjureBeanType):
    """
    The number of generated alerts is greater than the maximum. The check is likely misconfigured.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_TooManyAlertsState.__name__ = "TooManyAlertsState"
scout_datareview_api_TooManyAlertsState.__qualname__ = "TooManyAlertsState"
scout_datareview_api_TooManyAlertsState.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_UnlinkNotebook(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_UnlinkNotebook.__name__ = "UnlinkNotebook"
scout_datareview_api_UnlinkNotebook.__qualname__ = "UnlinkNotebook"
scout_datareview_api_UnlinkNotebook.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_UpdateChart(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'chart': ConjureFieldDefinition('chart', scout_rids_api_VersionedChartRid)
        }

    __slots__: List[str] = ['_chart']

    def __init__(self, chart: "scout_rids_api_VersionedChartRid") -> None:
        self._chart = chart

    @builtins.property
    def chart(self) -> "scout_rids_api_VersionedChartRid":
        return self._chart


scout_datareview_api_UpdateChart.__name__ = "UpdateChart"
scout_datareview_api_UpdateChart.__qualname__ = "UpdateChart"
scout_datareview_api_UpdateChart.__module__ = "scout_service_api.scout_datareview_api"


class scout_datareview_api_UpdateNotes(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'notes': ConjureFieldDefinition('notes', str)
        }

    __slots__: List[str] = ['_notes']

    def __init__(self, notes: str) -> None:
        self._notes = notes

    @builtins.property
    def notes(self) -> str:
        return self._notes


scout_datareview_api_UpdateNotes.__name__ = "UpdateNotes"
scout_datareview_api_UpdateNotes.__qualname__ = "UpdateNotes"
scout_datareview_api_UpdateNotes.__module__ = "scout_service_api.scout_datareview_api"


class scout_datasource_DataSourceService(Service):
    """
    Data sources are data input to runs, including databases, CSV, video, and streaming data. They contain channels that represent the series data.
The DataSource Service is responsible for indexing and searching channels across data sources.
    """

    def search_channels(self, auth_header: str, query: "datasource_api_SearchChannelsRequest") -> "datasource_api_SearchChannelsResponse":
        """
        Returns channels that match the search criteria. Results are sorted by similarity score.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(query)

        _path = '/data-source/v1/data-sources/search-channels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_SearchChannelsResponse, self._return_none_for_unknown_union_types)

    def search_filtered_channels(self, auth_header: str, query: "datasource_api_SearchFilteredChannelsRequest") -> "datasource_api_SearchFilteredChannelsResponse":
        """
        Returns channels that match the search criteria. Results are sorted by similarity score.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(query)

        _path = '/data-source/v1/data-sources/search-filtered-channels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_SearchFilteredChannelsResponse, self._return_none_for_unknown_union_types)

    def search_hierarchical_channels(self, auth_header: str, query: "datasource_api_SearchHierarchicalChannelsRequest") -> "datasource_api_SearchHierarchicalChannelsResponse":
        """
        Returns only channels that are direct children of the parent. Returns results sorted alphabetically.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(query)

        _path = '/data-source/v1/data-sources/search-hierarchical-channels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_SearchHierarchicalChannelsResponse, self._return_none_for_unknown_union_types)

    def index_channel_prefix_tree(self, auth_header: str, request: "datasource_api_IndexChannelPrefixTreeRequest") -> "datasource_api_ChannelPrefixTree":
        """
        Indexes the channel prefix tree for a specified data source. This operation constructs a prefix tree from the 
channels available in the data source.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/v1/data-sources/index-channel-prefix-tree'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_ChannelPrefixTree, self._return_none_for_unknown_union_types)

    def batch_get_channel_prefix_trees(self, auth_header: str, request: "datasource_api_BatchGetChannelPrefixTreeRequest") -> "datasource_api_BatchGetChannelPrefixTreeResponse":
        """
        Returns the channel prefix tree for each of the specified data sources. If the tree for a data source has not
been indexed, it will be omitted from the map.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/v1/data-sources/batch-get-channel-prefix-tree'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_BatchGetChannelPrefixTreeResponse, self._return_none_for_unknown_union_types)


scout_datasource_DataSourceService.__name__ = "DataSourceService"
scout_datasource_DataSourceService.__qualname__ = "DataSourceService"
scout_datasource_DataSourceService.__module__ = "scout_service_api.scout_datasource"


class scout_datasource_connection_ConnectionBootstrapperService(Service):
    """
    Nominal periodically scrapes connected databases (Connections) in order to maintain a database of all
series that can be read from that database. This service is responsible for executing the scrape, and can
be used manually to trigger a rescrape for any reason (for example, when updating a schema).
    """

    def populate_series(self, auth_header: str, request: "scout_datasource_connection_api_PopulateSeriesRequest", rid: str) -> None:
        """
        Populates the connection with series, by querying within the requested time range. If start or end are both omitted,
will query the last 7 days by default. If one of start or end is omitted, will query a 7 day range from the provided
start or end. Will throw if the requested range is larger than 30 days.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/connection/v1/{rid}/populateSeries'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_datasource_connection_ConnectionBootstrapperService.__name__ = "ConnectionBootstrapperService"
scout_datasource_connection_ConnectionBootstrapperService.__qualname__ = "ConnectionBootstrapperService"
scout_datasource_connection_ConnectionBootstrapperService.__module__ = "scout_service_api.scout_datasource_connection"


class scout_datasource_connection_ConnectionService(Service):
    """
    A Connection contains the relevant metadata and information to be used as a data source for runs.
The Connection Service is responsible for creating, updating, and retrieving database connections.
    """

    def create_connection(self, auth_header: str, create_connection: "scout_datasource_connection_api_CreateConnection") -> "scout_datasource_connection_api_Connection":
        """
        Creates a new connection.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(create_connection)

        _path = '/data-source/connection/v1/connections'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datasource_connection_api_Connection, self._return_none_for_unknown_union_types)

    def update_connection(self, auth_header: str, request: "scout_datasource_connection_api_UpdateConnectionRequest", rid: str) -> "scout_datasource_connection_api_Connection":
        """
        Updates an existing connection.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/connection/v1/connection/{rid}/details'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datasource_connection_api_Connection, self._return_none_for_unknown_union_types)

    def update_connection_status(self, auth_header: str, request: "scout_datasource_connection_api_ConnectionStatus", rid: str) -> None:
        """
        Updates an existing connection status.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/data-source/connection/v1/connection/{rid}/status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def add_available_tags(self, auth_header: str, rid: str, tags: Dict[str, List[str]]) -> "scout_datasource_connection_api_Connection":
        """
        Adds available tag key/value pairs to the connection. If a tag name already exists, the values will be merged.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(tags)

        _path = '/data-source/connection/v1/connection/{rid}/available-tags'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datasource_connection_api_Connection, self._return_none_for_unknown_union_types)

    def get_connection(self, auth_header: str, rid: str) -> "scout_datasource_connection_api_Connection":
        """
        Gets a connection by its RID.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/data-source/connection/v1/connection/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datasource_connection_api_Connection, self._return_none_for_unknown_union_types)

    def get_connections(self, auth_header: str, rids: List[str] = None) -> List["scout_datasource_connection_api_Connection"]:
        """
        Gets a set of connections by their RIDs.
        """
        rids = rids if rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(rids)

        _path = '/data-source/connection/v1/connection/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_datasource_connection_api_Connection], self._return_none_for_unknown_union_types)

    def list_connections(self, auth_header: str) -> List["scout_datasource_connection_api_Connection"]:
        """
        Lists all connections.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/data-source/connection/v1/connections'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_datasource_connection_api_Connection], self._return_none_for_unknown_union_types)

    def archive_connection(self, auth_header: str, rid: str) -> None:
        """
        Archives a connection, which simply tags the connection for a client to filter.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/data-source/connection/v1/connections/{rid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive_connection(self, auth_header: str, rid: str) -> None:
        """
        Undoes the archiving of a connection.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/data-source/connection/v1/connections/{rid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_datasource_connection_ConnectionService.__name__ = "ConnectionService"
scout_datasource_connection_ConnectionService.__qualname__ = "ConnectionService"
scout_datasource_connection_ConnectionService.__module__ = "scout_service_api.scout_datasource_connection"


class scout_datasource_connection_api_Connection(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_datasource_connection_api_ConnectionRid),
            'display_name': ConjureFieldDefinition('displayName', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'connection_details': ConjureFieldDefinition('connectionDetails', scout_datasource_connection_api_ConnectionDetails),
            'required_tag_names': ConjureFieldDefinition('requiredTagNames', List[api_TagName]),
            'available_tag_values': ConjureFieldDefinition('availableTagValues', Dict[api_TagName, List[api_TagValue]]),
            'metadata': ConjureFieldDefinition('metadata', Dict[str, str]),
            'scraping': ConjureFieldDefinition('scraping', OptionalTypeWrapper[scout_datasource_connection_api_ScrapingConfig]),
            'should_scrape': ConjureFieldDefinition('shouldScrape', bool),
            'limits': ConjureFieldDefinition('limits', OptionalTypeWrapper[scout_datasource_connection_api_LimitsConfig]),
            'connection_status': ConjureFieldDefinition('connectionStatus', scout_datasource_connection_api_ConnectionStatus),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_display_name', '_description', '_connection_details', '_required_tag_names', '_available_tag_values', '_metadata', '_scraping', '_should_scrape', '_limits', '_connection_status', '_is_archived']

    def __init__(self, available_tag_values: Dict[str, List[str]], connection_details: "scout_datasource_connection_api_ConnectionDetails", connection_status: "scout_datasource_connection_api_ConnectionStatus", display_name: str, is_archived: bool, metadata: Dict[str, str], required_tag_names: List[str], rid: str, should_scrape: bool, description: Optional[str] = None, limits: Optional["scout_datasource_connection_api_LimitsConfig"] = None, scraping: Optional["scout_datasource_connection_api_ScrapingConfig"] = None) -> None:
        self._rid = rid
        self._display_name = display_name
        self._description = description
        self._connection_details = connection_details
        self._required_tag_names = required_tag_names
        self._available_tag_values = available_tag_values
        self._metadata = metadata
        self._scraping = scraping
        self._should_scrape = should_scrape
        self._limits = limits
        self._connection_status = connection_status
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def display_name(self) -> str:
        """
        The display name of the connection. For example: "Nominal production TimescaleDB"
        """
        return self._display_name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def connection_details(self) -> "scout_datasource_connection_api_ConnectionDetails":
        return self._connection_details

    @builtins.property
    def required_tag_names(self) -> List[str]:
        """
        Additional tag names that should be supplied to construct a fully qualified series. These are suggested,
rather than strictly required.
        """
        return self._required_tag_names

    @builtins.property
    def available_tag_values(self) -> Dict[str, List[str]]:
        return self._available_tag_values

    @builtins.property
    def metadata(self) -> Dict[str, str]:
        return self._metadata

    @builtins.property
    def scraping(self) -> Optional["scout_datasource_connection_api_ScrapingConfig"]:
        """
        
        """
        return self._scraping

    @builtins.property
    def should_scrape(self) -> bool:
        """
        The connection will be scraped iff this flag is set and scrapingConfig is present.
        """
        return self._should_scrape

    @builtins.property
    def limits(self) -> Optional["scout_datasource_connection_api_LimitsConfig"]:
        return self._limits

    @builtins.property
    def connection_status(self) -> "scout_datasource_connection_api_ConnectionStatus":
        return self._connection_status

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


scout_datasource_connection_api_Connection.__name__ = "Connection"
scout_datasource_connection_api_Connection.__qualname__ = "Connection"
scout_datasource_connection_api_Connection.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ConnectionDetails(ConjureUnionType):
    _timescale: Optional["scout_datasource_connection_api_TimescaleConnectionDetails"] = None
    _influx: Optional["scout_datasource_connection_api_Influx2ConnectionDetails"] = None
    _influx1: Optional["scout_datasource_connection_api_Influx1ConnectionDetails"] = None
    _nominal: Optional["scout_datasource_connection_api_NominalConnectionDetails"] = None
    _timestream: Optional["scout_datasource_connection_api_TimestreamConnectionDetails"] = None
    _visual_crossing: Optional["scout_datasource_connection_api_VisualCrossingConnectionDetails"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timescale': ConjureFieldDefinition('timescale', scout_datasource_connection_api_TimescaleConnectionDetails),
            'influx': ConjureFieldDefinition('influx', scout_datasource_connection_api_Influx2ConnectionDetails),
            'influx1': ConjureFieldDefinition('influx1', scout_datasource_connection_api_Influx1ConnectionDetails),
            'nominal': ConjureFieldDefinition('nominal', scout_datasource_connection_api_NominalConnectionDetails),
            'timestream': ConjureFieldDefinition('timestream', scout_datasource_connection_api_TimestreamConnectionDetails),
            'visual_crossing': ConjureFieldDefinition('visualCrossing', scout_datasource_connection_api_VisualCrossingConnectionDetails)
        }

    def __init__(
            self,
            timescale: Optional["scout_datasource_connection_api_TimescaleConnectionDetails"] = None,
            influx: Optional["scout_datasource_connection_api_Influx2ConnectionDetails"] = None,
            influx1: Optional["scout_datasource_connection_api_Influx1ConnectionDetails"] = None,
            nominal: Optional["scout_datasource_connection_api_NominalConnectionDetails"] = None,
            timestream: Optional["scout_datasource_connection_api_TimestreamConnectionDetails"] = None,
            visual_crossing: Optional["scout_datasource_connection_api_VisualCrossingConnectionDetails"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (timescale is not None) + (influx is not None) + (influx1 is not None) + (nominal is not None) + (timestream is not None) + (visual_crossing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if timescale is not None:
                self._timescale = timescale
                self._type = 'timescale'
            if influx is not None:
                self._influx = influx
                self._type = 'influx'
            if influx1 is not None:
                self._influx1 = influx1
                self._type = 'influx1'
            if nominal is not None:
                self._nominal = nominal
                self._type = 'nominal'
            if timestream is not None:
                self._timestream = timestream
                self._type = 'timestream'
            if visual_crossing is not None:
                self._visual_crossing = visual_crossing
                self._type = 'visualCrossing'

        elif type_of_union == 'timescale':
            if timescale is None:
                raise ValueError('a union value must not be None')
            self._timescale = timescale
            self._type = 'timescale'
        elif type_of_union == 'influx':
            if influx is None:
                raise ValueError('a union value must not be None')
            self._influx = influx
            self._type = 'influx'
        elif type_of_union == 'influx1':
            if influx1 is None:
                raise ValueError('a union value must not be None')
            self._influx1 = influx1
            self._type = 'influx1'
        elif type_of_union == 'nominal':
            if nominal is None:
                raise ValueError('a union value must not be None')
            self._nominal = nominal
            self._type = 'nominal'
        elif type_of_union == 'timestream':
            if timestream is None:
                raise ValueError('a union value must not be None')
            self._timestream = timestream
            self._type = 'timestream'
        elif type_of_union == 'visualCrossing':
            if visual_crossing is None:
                raise ValueError('a union value must not be None')
            self._visual_crossing = visual_crossing
            self._type = 'visualCrossing'

    @builtins.property
    def timescale(self) -> Optional["scout_datasource_connection_api_TimescaleConnectionDetails"]:
        return self._timescale

    @builtins.property
    def influx(self) -> Optional["scout_datasource_connection_api_Influx2ConnectionDetails"]:
        return self._influx

    @builtins.property
    def influx1(self) -> Optional["scout_datasource_connection_api_Influx1ConnectionDetails"]:
        return self._influx1

    @builtins.property
    def nominal(self) -> Optional["scout_datasource_connection_api_NominalConnectionDetails"]:
        return self._nominal

    @builtins.property
    def timestream(self) -> Optional["scout_datasource_connection_api_TimestreamConnectionDetails"]:
        return self._timestream

    @builtins.property
    def visual_crossing(self) -> Optional["scout_datasource_connection_api_VisualCrossingConnectionDetails"]:
        return self._visual_crossing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_ConnectionDetailsVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_ConnectionDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timescale' and self.timescale is not None:
            return visitor._timescale(self.timescale)
        if self._type == 'influx' and self.influx is not None:
            return visitor._influx(self.influx)
        if self._type == 'influx1' and self.influx1 is not None:
            return visitor._influx1(self.influx1)
        if self._type == 'nominal' and self.nominal is not None:
            return visitor._nominal(self.nominal)
        if self._type == 'timestream' and self.timestream is not None:
            return visitor._timestream(self.timestream)
        if self._type == 'visualCrossing' and self.visual_crossing is not None:
            return visitor._visual_crossing(self.visual_crossing)


scout_datasource_connection_api_ConnectionDetails.__name__ = "ConnectionDetails"
scout_datasource_connection_api_ConnectionDetails.__qualname__ = "ConnectionDetails"
scout_datasource_connection_api_ConnectionDetails.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ConnectionDetailsVisitor:

    @abstractmethod
    def _timescale(self, timescale: "scout_datasource_connection_api_TimescaleConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _influx(self, influx: "scout_datasource_connection_api_Influx2ConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _influx1(self, influx1: "scout_datasource_connection_api_Influx1ConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _nominal(self, nominal: "scout_datasource_connection_api_NominalConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _timestream(self, timestream: "scout_datasource_connection_api_TimestreamConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _visual_crossing(self, visual_crossing: "scout_datasource_connection_api_VisualCrossingConnectionDetails") -> Any:
        pass


scout_datasource_connection_api_ConnectionDetailsVisitor.__name__ = "ConnectionDetailsVisitor"
scout_datasource_connection_api_ConnectionDetailsVisitor.__qualname__ = "ConnectionDetailsVisitor"
scout_datasource_connection_api_ConnectionDetailsVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ConnectionPlottingConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'max_undecimated_points_per_page': ConjureFieldDefinition('maxUndecimatedPointsPerPage', OptionalTypeWrapper[int]),
            'max_unbounded_range': ConjureFieldDefinition('maxUnboundedRange', OptionalTypeWrapper[int]),
            'max_undecimated_page_reads_per_second': ConjureFieldDefinition('maxUndecimatedPageReadsPerSecond', OptionalTypeWrapper[float]),
            'max_permits_per_second': ConjureFieldDefinition('maxPermitsPerSecond', OptionalTypeWrapper[float]),
            'max_connections': ConjureFieldDefinition('maxConnections', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_max_undecimated_points_per_page', '_max_unbounded_range', '_max_undecimated_page_reads_per_second', '_max_permits_per_second', '_max_connections']

    def __init__(self, max_connections: Optional[int] = None, max_permits_per_second: Optional[float] = None, max_unbounded_range: Optional[int] = None, max_undecimated_page_reads_per_second: Optional[float] = None, max_undecimated_points_per_page: Optional[int] = None) -> None:
        self._max_undecimated_points_per_page = max_undecimated_points_per_page
        self._max_unbounded_range = max_unbounded_range
        self._max_undecimated_page_reads_per_second = max_undecimated_page_reads_per_second
        self._max_permits_per_second = max_permits_per_second
        self._max_connections = max_connections

    @builtins.property
    def max_undecimated_points_per_page(self) -> Optional[int]:
        """
        The maximum number of points to return per page for undecimated queries
        """
        return self._max_undecimated_points_per_page

    @builtins.property
    def max_unbounded_range(self) -> Optional[int]:
        """
        The maximum range (in nanoseconds) for unbounded queries
        """
        return self._max_unbounded_range

    @builtins.property
    def max_undecimated_page_reads_per_second(self) -> Optional[float]:
        """
        The maximum number of page reads per second for undecimated queries
        """
        return self._max_undecimated_page_reads_per_second

    @builtins.property
    def max_permits_per_second(self) -> Optional[float]:
        """
        The maximum number of permits per second for queries
        """
        return self._max_permits_per_second

    @builtins.property
    def max_connections(self) -> Optional[int]:
        """
        The maximum number of connections to the database
        """
        return self._max_connections


scout_datasource_connection_api_ConnectionPlottingConfiguration.__name__ = "ConnectionPlottingConfiguration"
scout_datasource_connection_api_ConnectionPlottingConfiguration.__qualname__ = "ConnectionPlottingConfiguration"
scout_datasource_connection_api_ConnectionPlottingConfiguration.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ConnectionStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_connected': ConjureFieldDefinition('isConnected', bool)
        }

    __slots__: List[str] = ['_is_connected']

    def __init__(self, is_connected: bool) -> None:
        self._is_connected = is_connected

    @builtins.property
    def is_connected(self) -> bool:
        return self._is_connected


scout_datasource_connection_api_ConnectionStatus.__name__ = "ConnectionStatus"
scout_datasource_connection_api_ConnectionStatus.__qualname__ = "ConnectionStatus"
scout_datasource_connection_api_ConnectionStatus.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_CreateConnection(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'connection_details': ConjureFieldDefinition('connectionDetails', scout_datasource_connection_api_ConnectionDetails),
            'metadata': ConjureFieldDefinition('metadata', Dict[str, str]),
            'required_tag_names': ConjureFieldDefinition('requiredTagNames', List[api_TagName]),
            'available_tag_values': ConjureFieldDefinition('availableTagValues', Dict[api_TagName, List[api_TagValue]]),
            'scraping': ConjureFieldDefinition('scraping', OptionalTypeWrapper[scout_datasource_connection_api_ScrapingConfig]),
            'should_scrape': ConjureFieldDefinition('shouldScrape', bool),
            'limits': ConjureFieldDefinition('limits', OptionalTypeWrapper[scout_datasource_connection_api_LimitsConfig])
        }

    __slots__: List[str] = ['_name', '_description', '_connection_details', '_metadata', '_required_tag_names', '_available_tag_values', '_scraping', '_should_scrape', '_limits']

    def __init__(self, available_tag_values: Dict[str, List[str]], connection_details: "scout_datasource_connection_api_ConnectionDetails", metadata: Dict[str, str], name: str, required_tag_names: List[str], should_scrape: bool, description: Optional[str] = None, limits: Optional["scout_datasource_connection_api_LimitsConfig"] = None, scraping: Optional["scout_datasource_connection_api_ScrapingConfig"] = None) -> None:
        self._name = name
        self._description = description
        self._connection_details = connection_details
        self._metadata = metadata
        self._required_tag_names = required_tag_names
        self._available_tag_values = available_tag_values
        self._scraping = scraping
        self._should_scrape = should_scrape
        self._limits = limits

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def connection_details(self) -> "scout_datasource_connection_api_ConnectionDetails":
        return self._connection_details

    @builtins.property
    def metadata(self) -> Dict[str, str]:
        """
        Metadata information about the connection which is not relevant to the DB connection itself.
        """
        return self._metadata

    @builtins.property
    def required_tag_names(self) -> List[str]:
        """
        Additional tag name that are required to construct a fully qualified series.
        """
        return self._required_tag_names

    @builtins.property
    def available_tag_values(self) -> Dict[str, List[str]]:
        return self._available_tag_values

    @builtins.property
    def scraping(self) -> Optional["scout_datasource_connection_api_ScrapingConfig"]:
        return self._scraping

    @builtins.property
    def should_scrape(self) -> bool:
        return self._should_scrape

    @builtins.property
    def limits(self) -> Optional["scout_datasource_connection_api_LimitsConfig"]:
        return self._limits


scout_datasource_connection_api_CreateConnection.__name__ = "CreateConnection"
scout_datasource_connection_api_CreateConnection.__qualname__ = "CreateConnection"
scout_datasource_connection_api_CreateConnection.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_Duration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unit': ConjureFieldDefinition('unit', scout_datasource_connection_api_TemporalUnit),
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_unit', '_count']

    def __init__(self, count: int, unit: "scout_datasource_connection_api_TemporalUnit") -> None:
        self._unit = unit
        self._count = count

    @builtins.property
    def unit(self) -> "scout_datasource_connection_api_TemporalUnit":
        return self._unit

    @builtins.property
    def count(self) -> int:
        return self._count


scout_datasource_connection_api_Duration.__name__ = "Duration"
scout_datasource_connection_api_Duration.__qualname__ = "Duration"
scout_datasource_connection_api_Duration.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_Empty(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datasource_connection_api_Empty.__name__ = "Empty"
scout_datasource_connection_api_Empty.__qualname__ = "Empty"
scout_datasource_connection_api_Empty.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_HeaderValue(ConjureUnionType):
    _plain: Optional[str] = None
    _secret_rid: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plain': ConjureFieldDefinition('plain', str),
            'secret_rid': ConjureFieldDefinition('secretRid', scout_datasource_connection_api_SecretRid)
        }

    def __init__(
            self,
            plain: Optional[str] = None,
            secret_rid: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (plain is not None) + (secret_rid is not None) != 1:
                raise ValueError('a union must contain a single member')

            if plain is not None:
                self._plain = plain
                self._type = 'plain'
            if secret_rid is not None:
                self._secret_rid = secret_rid
                self._type = 'secretRid'

        elif type_of_union == 'plain':
            if plain is None:
                raise ValueError('a union value must not be None')
            self._plain = plain
            self._type = 'plain'
        elif type_of_union == 'secretRid':
            if secret_rid is None:
                raise ValueError('a union value must not be None')
            self._secret_rid = secret_rid
            self._type = 'secretRid'

    @builtins.property
    def plain(self) -> Optional[str]:
        return self._plain

    @builtins.property
    def secret_rid(self) -> Optional[str]:
        return self._secret_rid

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_HeaderValueVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_HeaderValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'plain' and self.plain is not None:
            return visitor._plain(self.plain)
        if self._type == 'secretRid' and self.secret_rid is not None:
            return visitor._secret_rid(self.secret_rid)


scout_datasource_connection_api_HeaderValue.__name__ = "HeaderValue"
scout_datasource_connection_api_HeaderValue.__qualname__ = "HeaderValue"
scout_datasource_connection_api_HeaderValue.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_HeaderValueVisitor:

    @abstractmethod
    def _plain(self, plain: str) -> Any:
        pass

    @abstractmethod
    def _secret_rid(self, secret_rid: str) -> Any:
        pass


scout_datasource_connection_api_HeaderValueVisitor.__name__ = "HeaderValueVisitor"
scout_datasource_connection_api_HeaderValueVisitor.__qualname__ = "HeaderValueVisitor"
scout_datasource_connection_api_HeaderValueVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_Influx1ConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'host': ConjureFieldDefinition('host', str),
            'port': ConjureFieldDefinition('port', int),
            'headers': ConjureFieldDefinition('headers', Dict[str, scout_datasource_connection_api_HeaderValue]),
            'credentials': ConjureFieldDefinition('credentials', OptionalTypeWrapper[scout_datasource_connection_api_PasswordCredentials])
        }

    __slots__: List[str] = ['_host', '_port', '_headers', '_credentials']

    def __init__(self, headers: Dict[str, "scout_datasource_connection_api_HeaderValue"], host: str, port: int, credentials: Optional["scout_datasource_connection_api_PasswordCredentials"] = None) -> None:
        self._host = host
        self._port = port
        self._headers = headers
        self._credentials = credentials

    @builtins.property
    def host(self) -> str:
        return self._host

    @builtins.property
    def port(self) -> int:
        return self._port

    @builtins.property
    def headers(self) -> Dict[str, "scout_datasource_connection_api_HeaderValue"]:
        """
        A map of header name to value
        """
        return self._headers

    @builtins.property
    def credentials(self) -> Optional["scout_datasource_connection_api_PasswordCredentials"]:
        return self._credentials


scout_datasource_connection_api_Influx1ConnectionDetails.__name__ = "Influx1ConnectionDetails"
scout_datasource_connection_api_Influx1ConnectionDetails.__qualname__ = "Influx1ConnectionDetails"
scout_datasource_connection_api_Influx1ConnectionDetails.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_Influx2ConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'host': ConjureFieldDefinition('host', str),
            'port': ConjureFieldDefinition('port', int),
            'headers': ConjureFieldDefinition('headers', Dict[str, scout_datasource_connection_api_HeaderValue]),
            'org': ConjureFieldDefinition('org', scout_datasource_connection_api_influx_OrgId),
            'token_secret_rid': ConjureFieldDefinition('tokenSecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_host', '_port', '_headers', '_org', '_token_secret_rid']

    def __init__(self, headers: Dict[str, "scout_datasource_connection_api_HeaderValue"], host: str, org: str, port: int, token_secret_rid: str) -> None:
        self._host = host
        self._port = port
        self._headers = headers
        self._org = org
        self._token_secret_rid = token_secret_rid

    @builtins.property
    def host(self) -> str:
        return self._host

    @builtins.property
    def port(self) -> int:
        return self._port

    @builtins.property
    def headers(self) -> Dict[str, "scout_datasource_connection_api_HeaderValue"]:
        """
        A map of header name to value
        """
        return self._headers

    @builtins.property
    def org(self) -> str:
        return self._org

    @builtins.property
    def token_secret_rid(self) -> str:
        """
        Secret Rid of token secret stored in Secrets Service.
        """
        return self._token_secret_rid


scout_datasource_connection_api_Influx2ConnectionDetails.__name__ = "Influx2ConnectionDetails"
scout_datasource_connection_api_Influx2ConnectionDetails.__qualname__ = "Influx2ConnectionDetails"
scout_datasource_connection_api_Influx2ConnectionDetails.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxChannelNameComponent(ConjureUnionType):
    _bucket: Optional["scout_datasource_connection_api_Empty"] = None
    _measurement: Optional["scout_datasource_connection_api_Empty"] = None
    _field: Optional["scout_datasource_connection_api_Empty"] = None
    _tag_value: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket': ConjureFieldDefinition('bucket', scout_datasource_connection_api_Empty),
            'measurement': ConjureFieldDefinition('measurement', scout_datasource_connection_api_Empty),
            'field': ConjureFieldDefinition('field', scout_datasource_connection_api_Empty),
            'tag_value': ConjureFieldDefinition('tagValue', api_TagName)
        }

    def __init__(
            self,
            bucket: Optional["scout_datasource_connection_api_Empty"] = None,
            measurement: Optional["scout_datasource_connection_api_Empty"] = None,
            field: Optional["scout_datasource_connection_api_Empty"] = None,
            tag_value: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (bucket is not None) + (measurement is not None) + (field is not None) + (tag_value is not None) != 1:
                raise ValueError('a union must contain a single member')

            if bucket is not None:
                self._bucket = bucket
                self._type = 'bucket'
            if measurement is not None:
                self._measurement = measurement
                self._type = 'measurement'
            if field is not None:
                self._field = field
                self._type = 'field'
            if tag_value is not None:
                self._tag_value = tag_value
                self._type = 'tagValue'

        elif type_of_union == 'bucket':
            if bucket is None:
                raise ValueError('a union value must not be None')
            self._bucket = bucket
            self._type = 'bucket'
        elif type_of_union == 'measurement':
            if measurement is None:
                raise ValueError('a union value must not be None')
            self._measurement = measurement
            self._type = 'measurement'
        elif type_of_union == 'field':
            if field is None:
                raise ValueError('a union value must not be None')
            self._field = field
            self._type = 'field'
        elif type_of_union == 'tagValue':
            if tag_value is None:
                raise ValueError('a union value must not be None')
            self._tag_value = tag_value
            self._type = 'tagValue'

    @builtins.property
    def bucket(self) -> Optional["scout_datasource_connection_api_Empty"]:
        return self._bucket

    @builtins.property
    def measurement(self) -> Optional["scout_datasource_connection_api_Empty"]:
        return self._measurement

    @builtins.property
    def field(self) -> Optional["scout_datasource_connection_api_Empty"]:
        return self._field

    @builtins.property
    def tag_value(self) -> Optional[str]:
        """
        The value for the specified TagName will be used. If the tag is not present, it will be omitted.
        """
        return self._tag_value

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_InfluxChannelNameComponentVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_InfluxChannelNameComponentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'bucket' and self.bucket is not None:
            return visitor._bucket(self.bucket)
        if self._type == 'measurement' and self.measurement is not None:
            return visitor._measurement(self.measurement)
        if self._type == 'field' and self.field is not None:
            return visitor._field(self.field)
        if self._type == 'tagValue' and self.tag_value is not None:
            return visitor._tag_value(self.tag_value)


scout_datasource_connection_api_InfluxChannelNameComponent.__name__ = "InfluxChannelNameComponent"
scout_datasource_connection_api_InfluxChannelNameComponent.__qualname__ = "InfluxChannelNameComponent"
scout_datasource_connection_api_InfluxChannelNameComponent.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxChannelNameComponentVisitor:

    @abstractmethod
    def _bucket(self, bucket: "scout_datasource_connection_api_Empty") -> Any:
        pass

    @abstractmethod
    def _measurement(self, measurement: "scout_datasource_connection_api_Empty") -> Any:
        pass

    @abstractmethod
    def _field(self, field: "scout_datasource_connection_api_Empty") -> Any:
        pass

    @abstractmethod
    def _tag_value(self, tag_value: str) -> Any:
        pass


scout_datasource_connection_api_InfluxChannelNameComponentVisitor.__name__ = "InfluxChannelNameComponentVisitor"
scout_datasource_connection_api_InfluxChannelNameComponentVisitor.__qualname__ = "InfluxChannelNameComponentVisitor"
scout_datasource_connection_api_InfluxChannelNameComponentVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filter': ConjureFieldDefinition('filter', List[scout_datasource_connection_api_InfluxScrapingFilter]),
            'series_archetype_construction': ConjureFieldDefinition('seriesArchetypeConstruction', scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig)
        }

    __slots__: List[str] = ['_filter', '_series_archetype_construction']

    def __init__(self, filter: List["scout_datasource_connection_api_InfluxScrapingFilter"], series_archetype_construction: "scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig") -> None:
        self._filter = filter
        self._series_archetype_construction = series_archetype_construction

    @builtins.property
    def filter(self) -> List["scout_datasource_connection_api_InfluxScrapingFilter"]:
        """
        Filters are ANDed together
        """
        return self._filter

    @builtins.property
    def series_archetype_construction(self) -> "scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig":
        return self._series_archetype_construction


scout_datasource_connection_api_InfluxScrapingConfig.__name__ = "InfluxScrapingConfig"
scout_datasource_connection_api_InfluxScrapingConfig.__qualname__ = "InfluxScrapingConfig"
scout_datasource_connection_api_InfluxScrapingConfig.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxScrapingFilter(ConjureUnionType):
    _not_: Optional["scout_datasource_connection_api_InfluxScrapingFilter"] = None
    _match_bucket: Optional[List[str]] = None
    _match_measurement: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'not_': ConjureFieldDefinition('not', scout_datasource_connection_api_InfluxScrapingFilter),
            'match_bucket': ConjureFieldDefinition('matchBucket', List[scout_datasource_connection_api_BucketName]),
            'match_measurement': ConjureFieldDefinition('matchMeasurement', List[scout_datasource_connection_api_MeasurementName])
        }

    def __init__(
            self,
            not_: Optional["scout_datasource_connection_api_InfluxScrapingFilter"] = None,
            match_bucket: Optional[List[str]] = None,
            match_measurement: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (not_ is not None) + (match_bucket is not None) + (match_measurement is not None) != 1:
                raise ValueError('a union must contain a single member')

            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if match_bucket is not None:
                self._match_bucket = match_bucket
                self._type = 'matchBucket'
            if match_measurement is not None:
                self._match_measurement = match_measurement
                self._type = 'matchMeasurement'

        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'matchBucket':
            if match_bucket is None:
                raise ValueError('a union value must not be None')
            self._match_bucket = match_bucket
            self._type = 'matchBucket'
        elif type_of_union == 'matchMeasurement':
            if match_measurement is None:
                raise ValueError('a union value must not be None')
            self._match_measurement = match_measurement
            self._type = 'matchMeasurement'

    @builtins.property
    def not_(self) -> Optional["scout_datasource_connection_api_InfluxScrapingFilter"]:
        return self._not_

    @builtins.property
    def match_bucket(self) -> Optional[List[str]]:
        """
        Match any of the specified buckets
        """
        return self._match_bucket

    @builtins.property
    def match_measurement(self) -> Optional[List[str]]:
        """
        Match any of the specified measurements
        """
        return self._match_measurement

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_InfluxScrapingFilterVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_InfluxScrapingFilterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'matchBucket' and self.match_bucket is not None:
            return visitor._match_bucket(self.match_bucket)
        if self._type == 'matchMeasurement' and self.match_measurement is not None:
            return visitor._match_measurement(self.match_measurement)


scout_datasource_connection_api_InfluxScrapingFilter.__name__ = "InfluxScrapingFilter"
scout_datasource_connection_api_InfluxScrapingFilter.__qualname__ = "InfluxScrapingFilter"
scout_datasource_connection_api_InfluxScrapingFilter.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxScrapingFilterVisitor:

    @abstractmethod
    def _not(self, not_: "scout_datasource_connection_api_InfluxScrapingFilter") -> Any:
        pass

    @abstractmethod
    def _match_bucket(self, match_bucket: List[str]) -> Any:
        pass

    @abstractmethod
    def _match_measurement(self, match_measurement: List[str]) -> Any:
        pass


scout_datasource_connection_api_InfluxScrapingFilterVisitor.__name__ = "InfluxScrapingFilterVisitor"
scout_datasource_connection_api_InfluxScrapingFilterVisitor.__qualname__ = "InfluxScrapingFilterVisitor"
scout_datasource_connection_api_InfluxScrapingFilterVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig(ConjureBeanType):
    """
    For example, for config of the form {components: [measurement, field, tag: vehicle], separator: "."} will construct a
channel that looks like vehicle_a.measurement.field. Tags will automatically be specified inside of the archetype.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_name_components': ConjureFieldDefinition('channelNameComponents', List[scout_datasource_connection_api_InfluxChannelNameComponent]),
            'separator': ConjureFieldDefinition('separator', str)
        }

    __slots__: List[str] = ['_channel_name_components', '_separator']

    def __init__(self, channel_name_components: List["scout_datasource_connection_api_InfluxChannelNameComponent"], separator: str) -> None:
        self._channel_name_components = channel_name_components
        self._separator = separator

    @builtins.property
    def channel_name_components(self) -> List["scout_datasource_connection_api_InfluxChannelNameComponent"]:
        return self._channel_name_components

    @builtins.property
    def separator(self) -> str:
        return self._separator


scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig.__name__ = "InfluxSeriesArchetypeConstructionConfig"
scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig.__qualname__ = "InfluxSeriesArchetypeConstructionConfig"
scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_LimitsConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'max_query_range': ConjureFieldDefinition('maxQueryRange', OptionalTypeWrapper[scout_datasource_connection_api_Duration])
        }

    __slots__: List[str] = ['_max_query_range']

    def __init__(self, max_query_range: Optional["scout_datasource_connection_api_Duration"] = None) -> None:
        self._max_query_range = max_query_range

    @builtins.property
    def max_query_range(self) -> Optional["scout_datasource_connection_api_Duration"]:
        return self._max_query_range


scout_datasource_connection_api_LimitsConfig.__name__ = "LimitsConfig"
scout_datasource_connection_api_LimitsConfig.__qualname__ = "LimitsConfig"
scout_datasource_connection_api_LimitsConfig.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_NominalChannelNameComponent(ConjureUnionType):
    _channel: Optional["scout_datasource_connection_api_Empty"] = None
    _value_of_tag_with_name: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', scout_datasource_connection_api_Empty),
            'value_of_tag_with_name': ConjureFieldDefinition('valueOfTagWithName', api_TagName)
        }

    def __init__(
            self,
            channel: Optional["scout_datasource_connection_api_Empty"] = None,
            value_of_tag_with_name: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (channel is not None) + (value_of_tag_with_name is not None) != 1:
                raise ValueError('a union must contain a single member')

            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if value_of_tag_with_name is not None:
                self._value_of_tag_with_name = value_of_tag_with_name
                self._type = 'valueOfTagWithName'

        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'valueOfTagWithName':
            if value_of_tag_with_name is None:
                raise ValueError('a union value must not be None')
            self._value_of_tag_with_name = value_of_tag_with_name
            self._type = 'valueOfTagWithName'

    @builtins.property
    def channel(self) -> Optional["scout_datasource_connection_api_Empty"]:
        return self._channel

    @builtins.property
    def value_of_tag_with_name(self) -> Optional[str]:
        """
        The value of the specified TagName will be used. If the tag is not present, it will be omitted.
        """
        return self._value_of_tag_with_name

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_NominalChannelNameComponentVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_NominalChannelNameComponentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'valueOfTagWithName' and self.value_of_tag_with_name is not None:
            return visitor._value_of_tag_with_name(self.value_of_tag_with_name)


scout_datasource_connection_api_NominalChannelNameComponent.__name__ = "NominalChannelNameComponent"
scout_datasource_connection_api_NominalChannelNameComponent.__qualname__ = "NominalChannelNameComponent"
scout_datasource_connection_api_NominalChannelNameComponent.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_NominalChannelNameComponentVisitor:

    @abstractmethod
    def _channel(self, channel: "scout_datasource_connection_api_Empty") -> Any:
        pass

    @abstractmethod
    def _value_of_tag_with_name(self, value_of_tag_with_name: str) -> Any:
        pass


scout_datasource_connection_api_NominalChannelNameComponentVisitor.__name__ = "NominalChannelNameComponentVisitor"
scout_datasource_connection_api_NominalChannelNameComponentVisitor.__qualname__ = "NominalChannelNameComponentVisitor"
scout_datasource_connection_api_NominalChannelNameComponentVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_NominalConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'nominal_data_source_rid': ConjureFieldDefinition('nominalDataSourceRid', scout_datasource_connection_api_NominalDataSourceRid)
        }

    __slots__: List[str] = ['_nominal_data_source_rid']

    def __init__(self, nominal_data_source_rid: str) -> None:
        self._nominal_data_source_rid = nominal_data_source_rid

    @builtins.property
    def nominal_data_source_rid(self) -> str:
        return self._nominal_data_source_rid


scout_datasource_connection_api_NominalConnectionDetails.__name__ = "NominalConnectionDetails"
scout_datasource_connection_api_NominalConnectionDetails.__qualname__ = "NominalConnectionDetails"
scout_datasource_connection_api_NominalConnectionDetails.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_NominalScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_name_components': ConjureFieldDefinition('channelNameComponents', List[scout_datasource_connection_api_NominalChannelNameComponent]),
            'separator': ConjureFieldDefinition('separator', str)
        }

    __slots__: List[str] = ['_channel_name_components', '_separator']

    def __init__(self, channel_name_components: List["scout_datasource_connection_api_NominalChannelNameComponent"], separator: str) -> None:
        self._channel_name_components = channel_name_components
        self._separator = separator

    @builtins.property
    def channel_name_components(self) -> List["scout_datasource_connection_api_NominalChannelNameComponent"]:
        """
        channelNameComponents will be combined, together with separator, to form
a fully qualified channel name.
        """
        return self._channel_name_components

    @builtins.property
    def separator(self) -> str:
        return self._separator


scout_datasource_connection_api_NominalScrapingConfig.__name__ = "NominalScrapingConfig"
scout_datasource_connection_api_NominalScrapingConfig.__qualname__ = "NominalScrapingConfig"
scout_datasource_connection_api_NominalScrapingConfig.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PasswordCredentials(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'username': ConjureFieldDefinition('username', str),
            'password_secret_rid': ConjureFieldDefinition('passwordSecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_username', '_password_secret_rid']

    def __init__(self, password_secret_rid: str, username: str) -> None:
        self._username = username
        self._password_secret_rid = password_secret_rid

    @builtins.property
    def username(self) -> str:
        return self._username

    @builtins.property
    def password_secret_rid(self) -> str:
        """
        Secret Rid of password secret stored in Secrets Service.
        """
        return self._password_secret_rid


scout_datasource_connection_api_PasswordCredentials.__name__ = "PasswordCredentials"
scout_datasource_connection_api_PasswordCredentials.__qualname__ = "PasswordCredentials"
scout_datasource_connection_api_PasswordCredentials.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PivotedTimescaleChannelNameComponent(ConjureUnionType):
    _table: Optional["scout_datasource_connection_api_Empty"] = None
    _name: Optional["scout_datasource_connection_api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', scout_datasource_connection_api_Empty),
            'name': ConjureFieldDefinition('name', scout_datasource_connection_api_Empty)
        }

    def __init__(
            self,
            table: Optional["scout_datasource_connection_api_Empty"] = None,
            name: Optional["scout_datasource_connection_api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (table is not None) + (name is not None) != 1:
                raise ValueError('a union must contain a single member')

            if table is not None:
                self._table = table
                self._type = 'table'
            if name is not None:
                self._name = name
                self._type = 'name'

        elif type_of_union == 'table':
            if table is None:
                raise ValueError('a union value must not be None')
            self._table = table
            self._type = 'table'
        elif type_of_union == 'name':
            if name is None:
                raise ValueError('a union value must not be None')
            self._name = name
            self._type = 'name'

    @builtins.property
    def table(self) -> Optional["scout_datasource_connection_api_Empty"]:
        return self._table

    @builtins.property
    def name(self) -> Optional["scout_datasource_connection_api_Empty"]:
        """
        The value of the name column.
        """
        return self._name

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'table' and self.table is not None:
            return visitor._table(self.table)
        if self._type == 'name' and self.name is not None:
            return visitor._name(self.name)


scout_datasource_connection_api_PivotedTimescaleChannelNameComponent.__name__ = "PivotedTimescaleChannelNameComponent"
scout_datasource_connection_api_PivotedTimescaleChannelNameComponent.__qualname__ = "PivotedTimescaleChannelNameComponent"
scout_datasource_connection_api_PivotedTimescaleChannelNameComponent.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor:

    @abstractmethod
    def _table(self, table: "scout_datasource_connection_api_Empty") -> Any:
        pass

    @abstractmethod
    def _name(self, name: "scout_datasource_connection_api_Empty") -> Any:
        pass


scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor.__name__ = "PivotedTimescaleChannelNameComponentVisitor"
scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor.__qualname__ = "PivotedTimescaleChannelNameComponentVisitor"
scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PivotedTimescaleScrapingConfig(ConjureBeanType):
    """
    This config is used to scrape data from a Timescale database that has a pivoted schema.
time | name           | value | device
 1   | temperature    | 1     | a
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filter': ConjureFieldDefinition('filter', List[scout_datasource_connection_api_TimescaleScrapingFilter]),
            'time_column': ConjureFieldDefinition('timeColumn', scout_datasource_connection_api_ColumnName),
            'name_column': ConjureFieldDefinition('nameColumn', scout_datasource_connection_api_ColumnName),
            'value_column': ConjureFieldDefinition('valueColumn', scout_datasource_connection_api_ColumnName),
            'dimension_columns': ConjureFieldDefinition('dimensionColumns', List[scout_datasource_connection_api_ColumnName]),
            'channel_name_components': ConjureFieldDefinition('channelNameComponents', List[scout_datasource_connection_api_PivotedTimescaleChannelNameComponent]),
            'separator': ConjureFieldDefinition('separator', str)
        }

    __slots__: List[str] = ['_filter', '_time_column', '_name_column', '_value_column', '_dimension_columns', '_channel_name_components', '_separator']

    def __init__(self, channel_name_components: List["scout_datasource_connection_api_PivotedTimescaleChannelNameComponent"], dimension_columns: List[str], filter: List["scout_datasource_connection_api_TimescaleScrapingFilter"], name_column: str, separator: str, time_column: str, value_column: str) -> None:
        self._filter = filter
        self._time_column = time_column
        self._name_column = name_column
        self._value_column = value_column
        self._dimension_columns = dimension_columns
        self._channel_name_components = channel_name_components
        self._separator = separator

    @builtins.property
    def filter(self) -> List["scout_datasource_connection_api_TimescaleScrapingFilter"]:
        """
        In order for data to be picked up by the scraper, it must match all
filters in this list. To exclude chunks of data, it's possible to use 
a not filter.
        """
        return self._filter

    @builtins.property
    def time_column(self) -> str:
        """
        The name of the column that holds the timestamp.
        """
        return self._time_column

    @builtins.property
    def name_column(self) -> str:
        """
        The name of the column that holds the series name.
        """
        return self._name_column

    @builtins.property
    def value_column(self) -> str:
        """
        The name of the column that holds the series values.
        """
        return self._value_column

    @builtins.property
    def dimension_columns(self) -> List[str]:
        """
        The names of the columns that comprise a dimension. They should have a database index for efficient filtering. We do not discover
dimensions based on hypertable schema because they are not necessarily configured properly.
        """
        return self._dimension_columns

    @builtins.property
    def channel_name_components(self) -> List["scout_datasource_connection_api_PivotedTimescaleChannelNameComponent"]:
        """
        channelNameComponents will be combined, together with separator, to form
a fully qualified channel name.
        """
        return self._channel_name_components

    @builtins.property
    def separator(self) -> str:
        return self._separator


scout_datasource_connection_api_PivotedTimescaleScrapingConfig.__name__ = "PivotedTimescaleScrapingConfig"
scout_datasource_connection_api_PivotedTimescaleScrapingConfig.__qualname__ = "PivotedTimescaleScrapingConfig"
scout_datasource_connection_api_PivotedTimescaleScrapingConfig.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PopulateSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[str]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_start_time', '_end_time']

    def __init__(self, end_time: Optional[str] = None, start_time: Optional[str] = None) -> None:
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def start_time(self) -> Optional[str]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional[str]:
        return self._end_time


scout_datasource_connection_api_PopulateSeriesRequest.__name__ = "PopulateSeriesRequest"
scout_datasource_connection_api_PopulateSeriesRequest.__qualname__ = "PopulateSeriesRequest"
scout_datasource_connection_api_PopulateSeriesRequest.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ScrapingConfig(ConjureUnionType):
    _influx: Optional["scout_datasource_connection_api_InfluxScrapingConfig"] = None
    _nominal: Optional["scout_datasource_connection_api_NominalScrapingConfig"] = None
    _timestream: Optional["scout_datasource_connection_api_TimestreamScrapingConfig"] = None
    _timescale: Optional["scout_datasource_connection_api_PivotedTimescaleScrapingConfig"] = None
    _visual_crossing: Optional["scout_datasource_connection_api_VisualCrossingScrapingConfig"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'influx': ConjureFieldDefinition('influx', scout_datasource_connection_api_InfluxScrapingConfig),
            'nominal': ConjureFieldDefinition('nominal', scout_datasource_connection_api_NominalScrapingConfig),
            'timestream': ConjureFieldDefinition('timestream', scout_datasource_connection_api_TimestreamScrapingConfig),
            'timescale': ConjureFieldDefinition('timescale', scout_datasource_connection_api_PivotedTimescaleScrapingConfig),
            'visual_crossing': ConjureFieldDefinition('visualCrossing', scout_datasource_connection_api_VisualCrossingScrapingConfig)
        }

    def __init__(
            self,
            influx: Optional["scout_datasource_connection_api_InfluxScrapingConfig"] = None,
            nominal: Optional["scout_datasource_connection_api_NominalScrapingConfig"] = None,
            timestream: Optional["scout_datasource_connection_api_TimestreamScrapingConfig"] = None,
            timescale: Optional["scout_datasource_connection_api_PivotedTimescaleScrapingConfig"] = None,
            visual_crossing: Optional["scout_datasource_connection_api_VisualCrossingScrapingConfig"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (influx is not None) + (nominal is not None) + (timestream is not None) + (timescale is not None) + (visual_crossing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if influx is not None:
                self._influx = influx
                self._type = 'influx'
            if nominal is not None:
                self._nominal = nominal
                self._type = 'nominal'
            if timestream is not None:
                self._timestream = timestream
                self._type = 'timestream'
            if timescale is not None:
                self._timescale = timescale
                self._type = 'timescale'
            if visual_crossing is not None:
                self._visual_crossing = visual_crossing
                self._type = 'visualCrossing'

        elif type_of_union == 'influx':
            if influx is None:
                raise ValueError('a union value must not be None')
            self._influx = influx
            self._type = 'influx'
        elif type_of_union == 'nominal':
            if nominal is None:
                raise ValueError('a union value must not be None')
            self._nominal = nominal
            self._type = 'nominal'
        elif type_of_union == 'timestream':
            if timestream is None:
                raise ValueError('a union value must not be None')
            self._timestream = timestream
            self._type = 'timestream'
        elif type_of_union == 'timescale':
            if timescale is None:
                raise ValueError('a union value must not be None')
            self._timescale = timescale
            self._type = 'timescale'
        elif type_of_union == 'visualCrossing':
            if visual_crossing is None:
                raise ValueError('a union value must not be None')
            self._visual_crossing = visual_crossing
            self._type = 'visualCrossing'

    @builtins.property
    def influx(self) -> Optional["scout_datasource_connection_api_InfluxScrapingConfig"]:
        return self._influx

    @builtins.property
    def nominal(self) -> Optional["scout_datasource_connection_api_NominalScrapingConfig"]:
        return self._nominal

    @builtins.property
    def timestream(self) -> Optional["scout_datasource_connection_api_TimestreamScrapingConfig"]:
        return self._timestream

    @builtins.property
    def timescale(self) -> Optional["scout_datasource_connection_api_PivotedTimescaleScrapingConfig"]:
        return self._timescale

    @builtins.property
    def visual_crossing(self) -> Optional["scout_datasource_connection_api_VisualCrossingScrapingConfig"]:
        return self._visual_crossing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_ScrapingConfigVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_ScrapingConfigVisitor'.format(visitor.__class__.__name__))
        if self._type == 'influx' and self.influx is not None:
            return visitor._influx(self.influx)
        if self._type == 'nominal' and self.nominal is not None:
            return visitor._nominal(self.nominal)
        if self._type == 'timestream' and self.timestream is not None:
            return visitor._timestream(self.timestream)
        if self._type == 'timescale' and self.timescale is not None:
            return visitor._timescale(self.timescale)
        if self._type == 'visualCrossing' and self.visual_crossing is not None:
            return visitor._visual_crossing(self.visual_crossing)


scout_datasource_connection_api_ScrapingConfig.__name__ = "ScrapingConfig"
scout_datasource_connection_api_ScrapingConfig.__qualname__ = "ScrapingConfig"
scout_datasource_connection_api_ScrapingConfig.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ScrapingConfigVisitor:

    @abstractmethod
    def _influx(self, influx: "scout_datasource_connection_api_InfluxScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _nominal(self, nominal: "scout_datasource_connection_api_NominalScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _timestream(self, timestream: "scout_datasource_connection_api_TimestreamScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _timescale(self, timescale: "scout_datasource_connection_api_PivotedTimescaleScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _visual_crossing(self, visual_crossing: "scout_datasource_connection_api_VisualCrossingScrapingConfig") -> Any:
        pass


scout_datasource_connection_api_ScrapingConfigVisitor.__name__ = "ScrapingConfigVisitor"
scout_datasource_connection_api_ScrapingConfigVisitor.__qualname__ = "ScrapingConfigVisitor"
scout_datasource_connection_api_ScrapingConfigVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TemporalUnit(ConjureEnumType):

    HOURS = 'HOURS'
    '''HOURS'''
    DAYS = 'DAYS'
    '''DAYS'''
    WEEKS = 'WEEKS'
    '''WEEKS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datasource_connection_api_TemporalUnit.__name__ = "TemporalUnit"
scout_datasource_connection_api_TemporalUnit.__qualname__ = "TemporalUnit"
scout_datasource_connection_api_TemporalUnit.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimescaleConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'database': ConjureFieldDefinition('database', str),
            'host': ConjureFieldDefinition('host', str),
            'port': ConjureFieldDefinition('port', int),
            'username': ConjureFieldDefinition('username', str),
            'password_secret_rid': ConjureFieldDefinition('passwordSecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_database', '_host', '_port', '_username', '_password_secret_rid']

    def __init__(self, database: str, host: str, password_secret_rid: str, port: int, username: str) -> None:
        self._database = database
        self._host = host
        self._port = port
        self._username = username
        self._password_secret_rid = password_secret_rid

    @builtins.property
    def database(self) -> str:
        return self._database

    @builtins.property
    def host(self) -> str:
        return self._host

    @builtins.property
    def port(self) -> int:
        return self._port

    @builtins.property
    def username(self) -> str:
        """
        This is also the reference to the secret containing the password
        """
        return self._username

    @builtins.property
    def password_secret_rid(self) -> str:
        """
        Secret Rid of password secret stored in Secrets Service.
        """
        return self._password_secret_rid


scout_datasource_connection_api_TimescaleConnectionDetails.__name__ = "TimescaleConnectionDetails"
scout_datasource_connection_api_TimescaleConnectionDetails.__qualname__ = "TimescaleConnectionDetails"
scout_datasource_connection_api_TimescaleConnectionDetails.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimescaleScrapingFilter(ConjureUnionType):
    _not_: Optional["scout_datasource_connection_api_TimescaleScrapingFilter"] = None
    _match_table: Optional[List[str]] = None
    _match_schema: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'not_': ConjureFieldDefinition('not', scout_datasource_connection_api_TimescaleScrapingFilter),
            'match_table': ConjureFieldDefinition('matchTable', List[scout_datasource_connection_api_TableName]),
            'match_schema': ConjureFieldDefinition('matchSchema', List[scout_datasource_connection_api_SchemaName])
        }

    def __init__(
            self,
            not_: Optional["scout_datasource_connection_api_TimescaleScrapingFilter"] = None,
            match_table: Optional[List[str]] = None,
            match_schema: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (not_ is not None) + (match_table is not None) + (match_schema is not None) != 1:
                raise ValueError('a union must contain a single member')

            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if match_table is not None:
                self._match_table = match_table
                self._type = 'matchTable'
            if match_schema is not None:
                self._match_schema = match_schema
                self._type = 'matchSchema'

        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'matchTable':
            if match_table is None:
                raise ValueError('a union value must not be None')
            self._match_table = match_table
            self._type = 'matchTable'
        elif type_of_union == 'matchSchema':
            if match_schema is None:
                raise ValueError('a union value must not be None')
            self._match_schema = match_schema
            self._type = 'matchSchema'

    @builtins.property
    def not_(self) -> Optional["scout_datasource_connection_api_TimescaleScrapingFilter"]:
        return self._not_

    @builtins.property
    def match_table(self) -> Optional[List[str]]:
        """
        Match any of the specified tables in the database.
        """
        return self._match_table

    @builtins.property
    def match_schema(self) -> Optional[List[str]]:
        """
        Match any of the specified schemas in the database.
        """
        return self._match_schema

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_TimescaleScrapingFilterVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_TimescaleScrapingFilterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'matchTable' and self.match_table is not None:
            return visitor._match_table(self.match_table)
        if self._type == 'matchSchema' and self.match_schema is not None:
            return visitor._match_schema(self.match_schema)


scout_datasource_connection_api_TimescaleScrapingFilter.__name__ = "TimescaleScrapingFilter"
scout_datasource_connection_api_TimescaleScrapingFilter.__qualname__ = "TimescaleScrapingFilter"
scout_datasource_connection_api_TimescaleScrapingFilter.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimescaleScrapingFilterVisitor:

    @abstractmethod
    def _not(self, not_: "scout_datasource_connection_api_TimescaleScrapingFilter") -> Any:
        pass

    @abstractmethod
    def _match_table(self, match_table: List[str]) -> Any:
        pass

    @abstractmethod
    def _match_schema(self, match_schema: List[str]) -> Any:
        pass


scout_datasource_connection_api_TimescaleScrapingFilterVisitor.__name__ = "TimescaleScrapingFilterVisitor"
scout_datasource_connection_api_TimescaleScrapingFilterVisitor.__qualname__ = "TimescaleScrapingFilterVisitor"
scout_datasource_connection_api_TimescaleScrapingFilterVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamChannelNameComponent(ConjureUnionType):
    _table: Optional["scout_datasource_connection_api_Empty"] = None
    _measure: Optional["scout_datasource_connection_api_Empty"] = None
    _attribute: Optional["scout_datasource_connection_api_Empty"] = None
    _value_of_tag_with_name: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', scout_datasource_connection_api_Empty),
            'measure': ConjureFieldDefinition('measure', scout_datasource_connection_api_Empty),
            'attribute': ConjureFieldDefinition('attribute', scout_datasource_connection_api_Empty),
            'value_of_tag_with_name': ConjureFieldDefinition('valueOfTagWithName', api_TagName)
        }

    def __init__(
            self,
            table: Optional["scout_datasource_connection_api_Empty"] = None,
            measure: Optional["scout_datasource_connection_api_Empty"] = None,
            attribute: Optional["scout_datasource_connection_api_Empty"] = None,
            value_of_tag_with_name: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (table is not None) + (measure is not None) + (attribute is not None) + (value_of_tag_with_name is not None) != 1:
                raise ValueError('a union must contain a single member')

            if table is not None:
                self._table = table
                self._type = 'table'
            if measure is not None:
                self._measure = measure
                self._type = 'measure'
            if attribute is not None:
                self._attribute = attribute
                self._type = 'attribute'
            if value_of_tag_with_name is not None:
                self._value_of_tag_with_name = value_of_tag_with_name
                self._type = 'valueOfTagWithName'

        elif type_of_union == 'table':
            if table is None:
                raise ValueError('a union value must not be None')
            self._table = table
            self._type = 'table'
        elif type_of_union == 'measure':
            if measure is None:
                raise ValueError('a union value must not be None')
            self._measure = measure
            self._type = 'measure'
        elif type_of_union == 'attribute':
            if attribute is None:
                raise ValueError('a union value must not be None')
            self._attribute = attribute
            self._type = 'attribute'
        elif type_of_union == 'valueOfTagWithName':
            if value_of_tag_with_name is None:
                raise ValueError('a union value must not be None')
            self._value_of_tag_with_name = value_of_tag_with_name
            self._type = 'valueOfTagWithName'

    @builtins.property
    def table(self) -> Optional["scout_datasource_connection_api_Empty"]:
        return self._table

    @builtins.property
    def measure(self) -> Optional["scout_datasource_connection_api_Empty"]:
        return self._measure

    @builtins.property
    def attribute(self) -> Optional["scout_datasource_connection_api_Empty"]:
        return self._attribute

    @builtins.property
    def value_of_tag_with_name(self) -> Optional[str]:
        """
        The value of the specified TagName will be used. If the tag is not present, it will be omitted.
        """
        return self._value_of_tag_with_name

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_TimestreamChannelNameComponentVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_TimestreamChannelNameComponentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'table' and self.table is not None:
            return visitor._table(self.table)
        if self._type == 'measure' and self.measure is not None:
            return visitor._measure(self.measure)
        if self._type == 'attribute' and self.attribute is not None:
            return visitor._attribute(self.attribute)
        if self._type == 'valueOfTagWithName' and self.value_of_tag_with_name is not None:
            return visitor._value_of_tag_with_name(self.value_of_tag_with_name)


scout_datasource_connection_api_TimestreamChannelNameComponent.__name__ = "TimestreamChannelNameComponent"
scout_datasource_connection_api_TimestreamChannelNameComponent.__qualname__ = "TimestreamChannelNameComponent"
scout_datasource_connection_api_TimestreamChannelNameComponent.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamChannelNameComponentVisitor:

    @abstractmethod
    def _table(self, table: "scout_datasource_connection_api_Empty") -> Any:
        pass

    @abstractmethod
    def _measure(self, measure: "scout_datasource_connection_api_Empty") -> Any:
        pass

    @abstractmethod
    def _attribute(self, attribute: "scout_datasource_connection_api_Empty") -> Any:
        pass

    @abstractmethod
    def _value_of_tag_with_name(self, value_of_tag_with_name: str) -> Any:
        pass


scout_datasource_connection_api_TimestreamChannelNameComponentVisitor.__name__ = "TimestreamChannelNameComponentVisitor"
scout_datasource_connection_api_TimestreamChannelNameComponentVisitor.__qualname__ = "TimestreamChannelNameComponentVisitor"
scout_datasource_connection_api_TimestreamChannelNameComponentVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'nominal_role_arn': ConjureFieldDefinition('nominalRoleArn', str),
            'nominal_role_region': ConjureFieldDefinition('nominalRoleRegion', str),
            'external_region': ConjureFieldDefinition('externalRegion', str),
            'external_role_arn': ConjureFieldDefinition('externalRoleArn', str),
            'database': ConjureFieldDefinition('database', str)
        }

    __slots__: List[str] = ['_nominal_role_arn', '_nominal_role_region', '_external_region', '_external_role_arn', '_database']

    def __init__(self, database: str, external_region: str, external_role_arn: str, nominal_role_arn: str, nominal_role_region: str) -> None:
        self._nominal_role_arn = nominal_role_arn
        self._nominal_role_region = nominal_role_region
        self._external_region = external_region
        self._external_role_arn = external_role_arn
        self._database = database

    @builtins.property
    def nominal_role_arn(self) -> str:
        """
        The role ARN owned by Nominal that has permission to assume the externalRoleArn.
        """
        return self._nominal_role_arn

    @builtins.property
    def nominal_role_region(self) -> str:
        """
        AWS region that contains the Nominal role.
        """
        return self._nominal_role_region

    @builtins.property
    def external_region(self) -> str:
        """
        AWS region that contains the Timestream instance.
        """
        return self._external_region

    @builtins.property
    def external_role_arn(self) -> str:
        """
        The role ARN used to make queries to Timestream. This role is owned by the AWS account that owns the Timestream instance.
        """
        return self._external_role_arn

    @builtins.property
    def database(self) -> str:
        """
        Database inside of the Timestream instance to connect to.
        """
        return self._database


scout_datasource_connection_api_TimestreamConnectionDetails.__name__ = "TimestreamConnectionDetails"
scout_datasource_connection_api_TimestreamConnectionDetails.__qualname__ = "TimestreamConnectionDetails"
scout_datasource_connection_api_TimestreamConnectionDetails.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filter': ConjureFieldDefinition('filter', List[scout_datasource_connection_api_TimestreamScrapingFilter]),
            'channel_name_components': ConjureFieldDefinition('channelNameComponents', List[scout_datasource_connection_api_TimestreamChannelNameComponent]),
            'separator': ConjureFieldDefinition('separator', str),
            'max_look_back_period_hours': ConjureFieldDefinition('maxLookBackPeriodHours', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_filter', '_channel_name_components', '_separator', '_max_look_back_period_hours']

    def __init__(self, channel_name_components: List["scout_datasource_connection_api_TimestreamChannelNameComponent"], filter: List["scout_datasource_connection_api_TimestreamScrapingFilter"], separator: str, max_look_back_period_hours: Optional[int] = None) -> None:
        self._filter = filter
        self._channel_name_components = channel_name_components
        self._separator = separator
        self._max_look_back_period_hours = max_look_back_period_hours

    @builtins.property
    def filter(self) -> List["scout_datasource_connection_api_TimestreamScrapingFilter"]:
        """
        In order for data to be picked up by the scraper, it must match all
filters in this list.
        """
        return self._filter

    @builtins.property
    def channel_name_components(self) -> List["scout_datasource_connection_api_TimestreamChannelNameComponent"]:
        """
        channelNameComponents will be combined, together with separator, to form
a fully qualified channel name.
        """
        return self._channel_name_components

    @builtins.property
    def separator(self) -> str:
        return self._separator

    @builtins.property
    def max_look_back_period_hours(self) -> Optional[int]:
        """
        The maximum time in hours to look back over series data to find unique measure and tag combinations.
If not specified, the default look back period will be used.
        """
        return self._max_look_back_period_hours


scout_datasource_connection_api_TimestreamScrapingConfig.__name__ = "TimestreamScrapingConfig"
scout_datasource_connection_api_TimestreamScrapingConfig.__qualname__ = "TimestreamScrapingConfig"
scout_datasource_connection_api_TimestreamScrapingConfig.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamScrapingFilter(ConjureUnionType):
    _match_table: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'match_table': ConjureFieldDefinition('matchTable', List[scout_datasource_connection_api_TableName])
        }

    def __init__(
            self,
            match_table: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (match_table is not None) != 1:
                raise ValueError('a union must contain a single member')

            if match_table is not None:
                self._match_table = match_table
                self._type = 'matchTable'

        elif type_of_union == 'matchTable':
            if match_table is None:
                raise ValueError('a union value must not be None')
            self._match_table = match_table
            self._type = 'matchTable'

    @builtins.property
    def match_table(self) -> Optional[List[str]]:
        """
        Match any of the specified tables in the database.
        """
        return self._match_table

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_TimestreamScrapingFilterVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_TimestreamScrapingFilterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'matchTable' and self.match_table is not None:
            return visitor._match_table(self.match_table)


scout_datasource_connection_api_TimestreamScrapingFilter.__name__ = "TimestreamScrapingFilter"
scout_datasource_connection_api_TimestreamScrapingFilter.__qualname__ = "TimestreamScrapingFilter"
scout_datasource_connection_api_TimestreamScrapingFilter.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamScrapingFilterVisitor:

    @abstractmethod
    def _match_table(self, match_table: List[str]) -> Any:
        pass


scout_datasource_connection_api_TimestreamScrapingFilterVisitor.__name__ = "TimestreamScrapingFilterVisitor"
scout_datasource_connection_api_TimestreamScrapingFilterVisitor.__qualname__ = "TimestreamScrapingFilterVisitor"
scout_datasource_connection_api_TimestreamScrapingFilterVisitor.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_UpdateConnectionRequest(ConjureBeanType):
    """
    Fields that are empty will be treated as a no-op update.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'metadata': ConjureFieldDefinition('metadata', OptionalTypeWrapper[Dict[str, str]]),
            'connection_details': ConjureFieldDefinition('connectionDetails', OptionalTypeWrapper[scout_datasource_connection_api_ConnectionDetails]),
            'required_tag_names': ConjureFieldDefinition('requiredTagNames', OptionalTypeWrapper[List[api_TagName]]),
            'available_tag_values': ConjureFieldDefinition('availableTagValues', OptionalTypeWrapper[Dict[api_TagName, List[api_TagValue]]]),
            'scraping': ConjureFieldDefinition('scraping', OptionalTypeWrapper[scout_datasource_connection_api_ScrapingConfig]),
            'should_scrape': ConjureFieldDefinition('shouldScrape', OptionalTypeWrapper[bool]),
            'limits': ConjureFieldDefinition('limits', OptionalTypeWrapper[scout_datasource_connection_api_LimitsConfig])
        }

    __slots__: List[str] = ['_name', '_description', '_metadata', '_connection_details', '_required_tag_names', '_available_tag_values', '_scraping', '_should_scrape', '_limits']

    def __init__(self, available_tag_values: Optional[Dict[str, List[str]]] = None, connection_details: Optional["scout_datasource_connection_api_ConnectionDetails"] = None, description: Optional[str] = None, limits: Optional["scout_datasource_connection_api_LimitsConfig"] = None, metadata: Optional[Dict[str, str]] = None, name: Optional[str] = None, required_tag_names: Optional[List[str]] = None, scraping: Optional["scout_datasource_connection_api_ScrapingConfig"] = None, should_scrape: Optional[bool] = None) -> None:
        self._name = name
        self._description = description
        self._metadata = metadata
        self._connection_details = connection_details
        self._required_tag_names = required_tag_names
        self._available_tag_values = available_tag_values
        self._scraping = scraping
        self._should_scrape = should_scrape
        self._limits = limits

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def metadata(self) -> Optional[Dict[str, str]]:
        return self._metadata

    @builtins.property
    def connection_details(self) -> Optional["scout_datasource_connection_api_ConnectionDetails"]:
        return self._connection_details

    @builtins.property
    def required_tag_names(self) -> Optional[List[str]]:
        return self._required_tag_names

    @builtins.property
    def available_tag_values(self) -> Optional[Dict[str, List[str]]]:
        return self._available_tag_values

    @builtins.property
    def scraping(self) -> Optional["scout_datasource_connection_api_ScrapingConfig"]:
        return self._scraping

    @builtins.property
    def should_scrape(self) -> Optional[bool]:
        return self._should_scrape

    @builtins.property
    def limits(self) -> Optional["scout_datasource_connection_api_LimitsConfig"]:
        return self._limits


scout_datasource_connection_api_UpdateConnectionRequest.__name__ = "UpdateConnectionRequest"
scout_datasource_connection_api_UpdateConnectionRequest.__qualname__ = "UpdateConnectionRequest"
scout_datasource_connection_api_UpdateConnectionRequest.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_VisualCrossingAvailableSeries(ConjureBeanType):
    """
    Deprecated and not used for anything anymore, see record VisualCrossingAvailableSeries instead.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', scout_datasource_connection_api_Channel),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[scout_datasource_connection_api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'type': ConjureFieldDefinition('type', scout_datasource_connection_api_VisualCrossingType)
        }

    __slots__: List[str] = ['_channel', '_unit', '_description', '_type']

    def __init__(self, channel: str, type: "scout_datasource_connection_api_VisualCrossingType", description: Optional[str] = None, unit: Optional[str] = None) -> None:
        self._channel = channel
        self._unit = unit
        self._description = description
        self._type = type

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def type(self) -> "scout_datasource_connection_api_VisualCrossingType":
        return self._type


scout_datasource_connection_api_VisualCrossingAvailableSeries.__name__ = "VisualCrossingAvailableSeries"
scout_datasource_connection_api_VisualCrossingAvailableSeries.__qualname__ = "VisualCrossingAvailableSeries"
scout_datasource_connection_api_VisualCrossingAvailableSeries.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_VisualCrossingConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_key_secret_rid': ConjureFieldDefinition('apiKeySecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_api_key_secret_rid']

    def __init__(self, api_key_secret_rid: str) -> None:
        self._api_key_secret_rid = api_key_secret_rid

    @builtins.property
    def api_key_secret_rid(self) -> str:
        """
        Secret Rid of API key stored in Secrets Service.
        """
        return self._api_key_secret_rid


scout_datasource_connection_api_VisualCrossingConnectionDetails.__name__ = "VisualCrossingConnectionDetails"
scout_datasource_connection_api_VisualCrossingConnectionDetails.__qualname__ = "VisualCrossingConnectionDetails"
scout_datasource_connection_api_VisualCrossingConnectionDetails.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_VisualCrossingScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'available_series': ConjureFieldDefinition('availableSeries', List[scout_datasource_connection_api_VisualCrossingAvailableSeries])
        }

    __slots__: List[str] = ['_available_series']

    def __init__(self, available_series: List["scout_datasource_connection_api_VisualCrossingAvailableSeries"]) -> None:
        self._available_series = available_series

    @builtins.property
    def available_series(self) -> List["scout_datasource_connection_api_VisualCrossingAvailableSeries"]:
        """
        list of available channels
        """
        return self._available_series


scout_datasource_connection_api_VisualCrossingScrapingConfig.__name__ = "VisualCrossingScrapingConfig"
scout_datasource_connection_api_VisualCrossingScrapingConfig.__qualname__ = "VisualCrossingScrapingConfig"
scout_datasource_connection_api_VisualCrossingScrapingConfig.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_datasource_connection_api_VisualCrossingType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datasource_connection_api_VisualCrossingType.__name__ = "VisualCrossingType"
scout_datasource_connection_api_VisualCrossingType.__qualname__ = "VisualCrossingType"
scout_datasource_connection_api_VisualCrossingType.__module__ = "scout_service_api.scout_datasource_connection_api"


class scout_integrations_api_CreateIntegrationDetails(ConjureUnionType):
    _create_simple_webhook_details: Optional["scout_integrations_api_CreateSimpleWebhookDetails"] = None
    _create_opsgenie_integration_details: Optional["scout_integrations_api_CreateOpsgenieIntegrationDetails"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'create_simple_webhook_details': ConjureFieldDefinition('createSimpleWebhookDetails', scout_integrations_api_CreateSimpleWebhookDetails),
            'create_opsgenie_integration_details': ConjureFieldDefinition('createOpsgenieIntegrationDetails', scout_integrations_api_CreateOpsgenieIntegrationDetails)
        }

    def __init__(
            self,
            create_simple_webhook_details: Optional["scout_integrations_api_CreateSimpleWebhookDetails"] = None,
            create_opsgenie_integration_details: Optional["scout_integrations_api_CreateOpsgenieIntegrationDetails"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (create_simple_webhook_details is not None) + (create_opsgenie_integration_details is not None) != 1:
                raise ValueError('a union must contain a single member')

            if create_simple_webhook_details is not None:
                self._create_simple_webhook_details = create_simple_webhook_details
                self._type = 'createSimpleWebhookDetails'
            if create_opsgenie_integration_details is not None:
                self._create_opsgenie_integration_details = create_opsgenie_integration_details
                self._type = 'createOpsgenieIntegrationDetails'

        elif type_of_union == 'createSimpleWebhookDetails':
            if create_simple_webhook_details is None:
                raise ValueError('a union value must not be None')
            self._create_simple_webhook_details = create_simple_webhook_details
            self._type = 'createSimpleWebhookDetails'
        elif type_of_union == 'createOpsgenieIntegrationDetails':
            if create_opsgenie_integration_details is None:
                raise ValueError('a union value must not be None')
            self._create_opsgenie_integration_details = create_opsgenie_integration_details
            self._type = 'createOpsgenieIntegrationDetails'

    @builtins.property
    def create_simple_webhook_details(self) -> Optional["scout_integrations_api_CreateSimpleWebhookDetails"]:
        return self._create_simple_webhook_details

    @builtins.property
    def create_opsgenie_integration_details(self) -> Optional["scout_integrations_api_CreateOpsgenieIntegrationDetails"]:
        return self._create_opsgenie_integration_details

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_integrations_api_CreateIntegrationDetailsVisitor):
            raise ValueError('{} is not an instance of scout_integrations_api_CreateIntegrationDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'createSimpleWebhookDetails' and self.create_simple_webhook_details is not None:
            return visitor._create_simple_webhook_details(self.create_simple_webhook_details)
        if self._type == 'createOpsgenieIntegrationDetails' and self.create_opsgenie_integration_details is not None:
            return visitor._create_opsgenie_integration_details(self.create_opsgenie_integration_details)


scout_integrations_api_CreateIntegrationDetails.__name__ = "CreateIntegrationDetails"
scout_integrations_api_CreateIntegrationDetails.__qualname__ = "CreateIntegrationDetails"
scout_integrations_api_CreateIntegrationDetails.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_CreateIntegrationDetailsVisitor:

    @abstractmethod
    def _create_simple_webhook_details(self, create_simple_webhook_details: "scout_integrations_api_CreateSimpleWebhookDetails") -> Any:
        pass

    @abstractmethod
    def _create_opsgenie_integration_details(self, create_opsgenie_integration_details: "scout_integrations_api_CreateOpsgenieIntegrationDetails") -> Any:
        pass


scout_integrations_api_CreateIntegrationDetailsVisitor.__name__ = "CreateIntegrationDetailsVisitor"
scout_integrations_api_CreateIntegrationDetailsVisitor.__qualname__ = "CreateIntegrationDetailsVisitor"
scout_integrations_api_CreateIntegrationDetailsVisitor.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_CreateIntegrationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'create_integration_details': ConjureFieldDefinition('createIntegrationDetails', scout_integrations_api_CreateIntegrationDetails)
        }

    __slots__: List[str] = ['_name', '_description', '_create_integration_details']

    def __init__(self, create_integration_details: "scout_integrations_api_CreateIntegrationDetails", name: str, description: Optional[str] = None) -> None:
        self._name = name
        self._description = description
        self._create_integration_details = create_integration_details

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def create_integration_details(self) -> "scout_integrations_api_CreateIntegrationDetails":
        return self._create_integration_details


scout_integrations_api_CreateIntegrationRequest.__name__ = "CreateIntegrationRequest"
scout_integrations_api_CreateIntegrationRequest.__qualname__ = "CreateIntegrationRequest"
scout_integrations_api_CreateIntegrationRequest.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_CreateOpsgenieIntegrationDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_key': ConjureFieldDefinition('apiKey', str),
            'region': ConjureFieldDefinition('region', scout_integrations_api_OpsgenieRegion)
        }

    __slots__: List[str] = ['_api_key', '_region']

    def __init__(self, api_key: str, region: "scout_integrations_api_OpsgenieRegion") -> None:
        self._api_key = api_key
        self._region = region

    @builtins.property
    def api_key(self) -> str:
        return self._api_key

    @builtins.property
    def region(self) -> "scout_integrations_api_OpsgenieRegion":
        return self._region


scout_integrations_api_CreateOpsgenieIntegrationDetails.__name__ = "CreateOpsgenieIntegrationDetails"
scout_integrations_api_CreateOpsgenieIntegrationDetails.__qualname__ = "CreateOpsgenieIntegrationDetails"
scout_integrations_api_CreateOpsgenieIntegrationDetails.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_CreateSimpleWebhookDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'webhook': ConjureFieldDefinition('webhook', str)
        }

    __slots__: List[str] = ['_webhook']

    def __init__(self, webhook: str) -> None:
        self._webhook = webhook

    @builtins.property
    def webhook(self) -> str:
        return self._webhook


scout_integrations_api_CreateSimpleWebhookDetails.__name__ = "CreateSimpleWebhookDetails"
scout_integrations_api_CreateSimpleWebhookDetails.__qualname__ = "CreateSimpleWebhookDetails"
scout_integrations_api_CreateSimpleWebhookDetails.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_GenerateSlackWebhookResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'url': ConjureFieldDefinition('url', str)
        }

    __slots__: List[str] = ['_url']

    def __init__(self, url: str) -> None:
        self._url = url

    @builtins.property
    def url(self) -> str:
        return self._url


scout_integrations_api_GenerateSlackWebhookResponse.__name__ = "GenerateSlackWebhookResponse"
scout_integrations_api_GenerateSlackWebhookResponse.__qualname__ = "GenerateSlackWebhookResponse"
scout_integrations_api_GenerateSlackWebhookResponse.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_Integration(ConjureBeanType):
    """
    Configuration details used to connect to an external service.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_integrations_api_IntegrationRid),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'integration_details': ConjureFieldDefinition('integrationDetails', scout_integrations_api_IntegrationDetails),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'created_by': ConjureFieldDefinition('createdBy', str)
        }

    __slots__: List[str] = ['_rid', '_name', '_description', '_integration_details', '_created_at', '_created_by']

    def __init__(self, created_at: str, created_by: str, integration_details: "scout_integrations_api_IntegrationDetails", name: str, rid: str, description: Optional[str] = None) -> None:
        self._rid = rid
        self._name = name
        self._description = description
        self._integration_details = integration_details
        self._created_at = created_at
        self._created_by = created_by

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def integration_details(self) -> "scout_integrations_api_IntegrationDetails":
        return self._integration_details

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def created_by(self) -> str:
        return self._created_by


scout_integrations_api_Integration.__name__ = "Integration"
scout_integrations_api_Integration.__qualname__ = "Integration"
scout_integrations_api_Integration.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_IntegrationDetails(ConjureUnionType):
    _slack_webhook_integration: Optional["scout_integrations_api_SlackWebhookIntegration"] = None
    _opsgenie_integration: Optional["scout_integrations_api_OpsgenieIntegration"] = None
    _simple_webhook_integration: Optional["scout_integrations_api_SimpleWebhookIntegration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'slack_webhook_integration': ConjureFieldDefinition('slackWebhookIntegration', scout_integrations_api_SlackWebhookIntegration),
            'opsgenie_integration': ConjureFieldDefinition('opsgenieIntegration', scout_integrations_api_OpsgenieIntegration),
            'simple_webhook_integration': ConjureFieldDefinition('simpleWebhookIntegration', scout_integrations_api_SimpleWebhookIntegration)
        }

    def __init__(
            self,
            slack_webhook_integration: Optional["scout_integrations_api_SlackWebhookIntegration"] = None,
            opsgenie_integration: Optional["scout_integrations_api_OpsgenieIntegration"] = None,
            simple_webhook_integration: Optional["scout_integrations_api_SimpleWebhookIntegration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (slack_webhook_integration is not None) + (opsgenie_integration is not None) + (simple_webhook_integration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if slack_webhook_integration is not None:
                self._slack_webhook_integration = slack_webhook_integration
                self._type = 'slackWebhookIntegration'
            if opsgenie_integration is not None:
                self._opsgenie_integration = opsgenie_integration
                self._type = 'opsgenieIntegration'
            if simple_webhook_integration is not None:
                self._simple_webhook_integration = simple_webhook_integration
                self._type = 'simpleWebhookIntegration'

        elif type_of_union == 'slackWebhookIntegration':
            if slack_webhook_integration is None:
                raise ValueError('a union value must not be None')
            self._slack_webhook_integration = slack_webhook_integration
            self._type = 'slackWebhookIntegration'
        elif type_of_union == 'opsgenieIntegration':
            if opsgenie_integration is None:
                raise ValueError('a union value must not be None')
            self._opsgenie_integration = opsgenie_integration
            self._type = 'opsgenieIntegration'
        elif type_of_union == 'simpleWebhookIntegration':
            if simple_webhook_integration is None:
                raise ValueError('a union value must not be None')
            self._simple_webhook_integration = simple_webhook_integration
            self._type = 'simpleWebhookIntegration'

    @builtins.property
    def slack_webhook_integration(self) -> Optional["scout_integrations_api_SlackWebhookIntegration"]:
        return self._slack_webhook_integration

    @builtins.property
    def opsgenie_integration(self) -> Optional["scout_integrations_api_OpsgenieIntegration"]:
        return self._opsgenie_integration

    @builtins.property
    def simple_webhook_integration(self) -> Optional["scout_integrations_api_SimpleWebhookIntegration"]:
        return self._simple_webhook_integration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_integrations_api_IntegrationDetailsVisitor):
            raise ValueError('{} is not an instance of scout_integrations_api_IntegrationDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'slackWebhookIntegration' and self.slack_webhook_integration is not None:
            return visitor._slack_webhook_integration(self.slack_webhook_integration)
        if self._type == 'opsgenieIntegration' and self.opsgenie_integration is not None:
            return visitor._opsgenie_integration(self.opsgenie_integration)
        if self._type == 'simpleWebhookIntegration' and self.simple_webhook_integration is not None:
            return visitor._simple_webhook_integration(self.simple_webhook_integration)


scout_integrations_api_IntegrationDetails.__name__ = "IntegrationDetails"
scout_integrations_api_IntegrationDetails.__qualname__ = "IntegrationDetails"
scout_integrations_api_IntegrationDetails.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_IntegrationDetailsVisitor:

    @abstractmethod
    def _slack_webhook_integration(self, slack_webhook_integration: "scout_integrations_api_SlackWebhookIntegration") -> Any:
        pass

    @abstractmethod
    def _opsgenie_integration(self, opsgenie_integration: "scout_integrations_api_OpsgenieIntegration") -> Any:
        pass

    @abstractmethod
    def _simple_webhook_integration(self, simple_webhook_integration: "scout_integrations_api_SimpleWebhookIntegration") -> Any:
        pass


scout_integrations_api_IntegrationDetailsVisitor.__name__ = "IntegrationDetailsVisitor"
scout_integrations_api_IntegrationDetailsVisitor.__qualname__ = "IntegrationDetailsVisitor"
scout_integrations_api_IntegrationDetailsVisitor.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_IntegrationsService(Service):
    """
    Service for managing integrations with external services.
    """

    def generate_slack_webhook_link(self, auth_header: str) -> "scout_integrations_api_GenerateSlackWebhookResponse":
        """
        Generates link to request permissions for Slack bot to join workspaces and use a webhook.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/scout/v2/integrations/slack-oauth/init-webhook'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_integrations_api_GenerateSlackWebhookResponse, self._return_none_for_unknown_union_types)

    def create_slack_webhook(self, auth_header: str, code: str, state: str) -> None:
        """
        Creates a new Slack integration. Called internally after Slack authorization.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'code': code,
            'state': state,
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/scout/v2/integrations/slack-oauth/redirect'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def create_integration(self, auth_header: str, create_integration_request: "scout_integrations_api_CreateIntegrationRequest") -> "scout_integrations_api_Integration":
        """
        Creates a new integration.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(create_integration_request)

        _path = '/scout/v2/integrations'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_integrations_api_Integration, self._return_none_for_unknown_union_types)

    def delete_integration(self, auth_header: str, integration_rid: str) -> None:
        """
        Deletes an integration.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'integrationRid': integration_rid,
        }

        _json: Any = None

        _path = '/scout/v2/integrations/{integrationRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def update_integration_metadata(self, auth_header: str, integration_rid: str, request: "scout_integrations_api_UpdateIntegrationRequest") -> "scout_integrations_api_Integration":
        """
        Updates the metadata of an integration.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'integrationRid': integration_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/integrations/{integrationRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_integrations_api_Integration, self._return_none_for_unknown_union_types)

    def get_integration(self, auth_header: str, integration_rid: str) -> "scout_integrations_api_Integration":
        """
        Retrieves an integration with the specified integration RID.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'integrationRid': integration_rid,
        }

        _json: Any = None

        _path = '/scout/v2/integrations/{integrationRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_integrations_api_Integration, self._return_none_for_unknown_union_types)

    def list_integrations(self, auth_header: str) -> List["scout_integrations_api_Integration"]:
        """
        Lists all integrations.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = None

        _path = '/scout/v2/integrations/list'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_integrations_api_Integration], self._return_none_for_unknown_union_types)

    def send_message(self, auth_header: str, request: "scout_integrations_api_SendMessageRequest") -> None:
        """
        Sends a string message to the specified integration from a checklist execution.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v2/integrations/send-message'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_integrations_api_IntegrationsService.__name__ = "IntegrationsService"
scout_integrations_api_IntegrationsService.__qualname__ = "IntegrationsService"
scout_integrations_api_IntegrationsService.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_NotificationConfiguration(ConjureBeanType):
    """
    Configuration details to send notifications to a linked integration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'integration_rid': ConjureFieldDefinition('integrationRid', scout_integrations_api_IntegrationRid)
        }

    __slots__: List[str] = ['_integration_rid']

    def __init__(self, integration_rid: str) -> None:
        self._integration_rid = integration_rid

    @builtins.property
    def integration_rid(self) -> str:
        return self._integration_rid


scout_integrations_api_NotificationConfiguration.__name__ = "NotificationConfiguration"
scout_integrations_api_NotificationConfiguration.__qualname__ = "NotificationConfiguration"
scout_integrations_api_NotificationConfiguration.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_OpsgenieIntegration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'region': ConjureFieldDefinition('region', scout_integrations_api_OpsgenieRegion)
        }

    __slots__: List[str] = ['_region']

    def __init__(self, region: "scout_integrations_api_OpsgenieRegion") -> None:
        self._region = region

    @builtins.property
    def region(self) -> "scout_integrations_api_OpsgenieRegion":
        return self._region


scout_integrations_api_OpsgenieIntegration.__name__ = "OpsgenieIntegration"
scout_integrations_api_OpsgenieIntegration.__qualname__ = "OpsgenieIntegration"
scout_integrations_api_OpsgenieIntegration.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_OpsgenieRegion(ConjureEnumType):
    """
    Opsgenie region for the account linked to the provided API key.
    """

    US = 'US'
    '''US'''
    EU = 'EU'
    '''EU'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_integrations_api_OpsgenieRegion.__name__ = "OpsgenieRegion"
scout_integrations_api_OpsgenieRegion.__qualname__ = "OpsgenieRegion"
scout_integrations_api_OpsgenieRegion.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_SendMessageRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'message': ConjureFieldDefinition('message', str),
            'integration_rid': ConjureFieldDefinition('integrationRid', scout_integrations_api_IntegrationRid),
            'priority': ConjureFieldDefinition('priority', OptionalTypeWrapper[scout_checks_api_Priority])
        }

    __slots__: List[str] = ['_message', '_integration_rid', '_priority']

    def __init__(self, integration_rid: str, message: str, priority: Optional["scout_checks_api_Priority"] = None) -> None:
        self._message = message
        self._integration_rid = integration_rid
        self._priority = priority

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def integration_rid(self) -> str:
        return self._integration_rid

    @builtins.property
    def priority(self) -> Optional["scout_checks_api_Priority"]:
        return self._priority


scout_integrations_api_SendMessageRequest.__name__ = "SendMessageRequest"
scout_integrations_api_SendMessageRequest.__qualname__ = "SendMessageRequest"
scout_integrations_api_SendMessageRequest.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_SimpleWebhookIntegration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_integrations_api_SimpleWebhookIntegration.__name__ = "SimpleWebhookIntegration"
scout_integrations_api_SimpleWebhookIntegration.__qualname__ = "SimpleWebhookIntegration"
scout_integrations_api_SimpleWebhookIntegration.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_SlackWebhookIntegration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'team_name': ConjureFieldDefinition('teamName', str),
            'channel': ConjureFieldDefinition('channel', str),
            'channel_id': ConjureFieldDefinition('channelId', str)
        }

    __slots__: List[str] = ['_team_name', '_channel', '_channel_id']

    def __init__(self, channel: str, channel_id: str, team_name: str) -> None:
        self._team_name = team_name
        self._channel = channel
        self._channel_id = channel_id

    @builtins.property
    def team_name(self) -> str:
        return self._team_name

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def channel_id(self) -> str:
        return self._channel_id


scout_integrations_api_SlackWebhookIntegration.__name__ = "SlackWebhookIntegration"
scout_integrations_api_SlackWebhookIntegration.__qualname__ = "SlackWebhookIntegration"
scout_integrations_api_SlackWebhookIntegration.__module__ = "scout_service_api.scout_integrations_api"


class scout_integrations_api_UpdateIntegrationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_name', '_description']

    def __init__(self, description: Optional[str] = None, name: Optional[str] = None) -> None:
        self._name = name
        self._description = description

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description


scout_integrations_api_UpdateIntegrationRequest.__name__ = "UpdateIntegrationRequest"
scout_integrations_api_UpdateIntegrationRequest.__qualname__ = "UpdateIntegrationRequest"
scout_integrations_api_UpdateIntegrationRequest.__module__ = "scout_service_api.scout_integrations_api"


class scout_internal_search_api_DateTimeField(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'value': ConjureFieldDefinition('value', str),
            'operator': ConjureFieldDefinition('operator', scout_internal_search_api_Operator)
        }

    __slots__: List[str] = ['_name', '_value', '_operator']

    def __init__(self, name: str, operator: "scout_internal_search_api_Operator", value: str) -> None:
        self._name = name
        self._value = value
        self._operator = operator

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value

    @builtins.property
    def operator(self) -> "scout_internal_search_api_Operator":
        return self._operator


scout_internal_search_api_DateTimeField.__name__ = "DateTimeField"
scout_internal_search_api_DateTimeField.__qualname__ = "DateTimeField"
scout_internal_search_api_DateTimeField.__module__ = "scout_service_api.scout_internal_search_api"


class scout_internal_search_api_Operator(ConjureEnumType):

    LEQ = 'LEQ'
    '''LEQ'''
    LT = 'LT'
    '''LT'''
    GEQ = 'GEQ'
    '''GEQ'''
    GT = 'GT'
    '''GT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_internal_search_api_Operator.__name__ = "Operator"
scout_internal_search_api_Operator.__qualname__ = "Operator"
scout_internal_search_api_Operator.__module__ = "scout_service_api.scout_internal_search_api"


class scout_internal_search_api_SearchQuery(ConjureUnionType):
    _date_time_field: Optional["scout_internal_search_api_DateTimeField"] = None
    _string_field: Optional["scout_internal_search_api_StringField"] = None
    _timestamp_field: Optional["scout_internal_search_api_TimestampField"] = None
    _exact_match: Optional[str] = None
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["scout_run_api_Property"] = None
    _and_: Optional[List["scout_internal_search_api_SearchQuery"]] = None
    _or_: Optional[List["scout_internal_search_api_SearchQuery"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'date_time_field': ConjureFieldDefinition('dateTimeField', scout_internal_search_api_DateTimeField),
            'string_field': ConjureFieldDefinition('stringField', scout_internal_search_api_StringField),
            'timestamp_field': ConjureFieldDefinition('timestampField', scout_internal_search_api_TimestampField),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', scout_run_api_Label),
            'property': ConjureFieldDefinition('property', scout_run_api_Property),
            'and_': ConjureFieldDefinition('and', List[scout_internal_search_api_SearchQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_internal_search_api_SearchQuery])
        }

    def __init__(
            self,
            date_time_field: Optional["scout_internal_search_api_DateTimeField"] = None,
            string_field: Optional["scout_internal_search_api_StringField"] = None,
            timestamp_field: Optional["scout_internal_search_api_TimestampField"] = None,
            exact_match: Optional[str] = None,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["scout_run_api_Property"] = None,
            and_: Optional[List["scout_internal_search_api_SearchQuery"]] = None,
            or_: Optional[List["scout_internal_search_api_SearchQuery"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (date_time_field is not None) + (string_field is not None) + (timestamp_field is not None) + (exact_match is not None) + (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if date_time_field is not None:
                self._date_time_field = date_time_field
                self._type = 'dateTimeField'
            if string_field is not None:
                self._string_field = string_field
                self._type = 'stringField'
            if timestamp_field is not None:
                self._timestamp_field = timestamp_field
                self._type = 'timestampField'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'

        elif type_of_union == 'dateTimeField':
            if date_time_field is None:
                raise ValueError('a union value must not be None')
            self._date_time_field = date_time_field
            self._type = 'dateTimeField'
        elif type_of_union == 'stringField':
            if string_field is None:
                raise ValueError('a union value must not be None')
            self._string_field = string_field
            self._type = 'stringField'
        elif type_of_union == 'timestampField':
            if timestamp_field is None:
                raise ValueError('a union value must not be None')
            self._timestamp_field = timestamp_field
            self._type = 'timestampField'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'

    @builtins.property
    def date_time_field(self) -> Optional["scout_internal_search_api_DateTimeField"]:
        return self._date_time_field

    @builtins.property
    def string_field(self) -> Optional["scout_internal_search_api_StringField"]:
        return self._string_field

    @builtins.property
    def timestamp_field(self) -> Optional["scout_internal_search_api_TimestampField"]:
        return self._timestamp_field

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """
        Performs case insensitive exact match search on the title.
        """
        return self._exact_match

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["scout_run_api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["scout_internal_search_api_SearchQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_internal_search_api_SearchQuery"]]:
        return self._or_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_internal_search_api_SearchQueryVisitor):
            raise ValueError('{} is not an instance of scout_internal_search_api_SearchQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'dateTimeField' and self.date_time_field is not None:
            return visitor._date_time_field(self.date_time_field)
        if self._type == 'stringField' and self.string_field is not None:
            return visitor._string_field(self.string_field)
        if self._type == 'timestampField' and self.timestamp_field is not None:
            return visitor._timestamp_field(self.timestamp_field)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)


scout_internal_search_api_SearchQuery.__name__ = "SearchQuery"
scout_internal_search_api_SearchQuery.__qualname__ = "SearchQuery"
scout_internal_search_api_SearchQuery.__module__ = "scout_service_api.scout_internal_search_api"


class scout_internal_search_api_SearchQueryVisitor:

    @abstractmethod
    def _date_time_field(self, date_time_field: "scout_internal_search_api_DateTimeField") -> Any:
        pass

    @abstractmethod
    def _string_field(self, string_field: "scout_internal_search_api_StringField") -> Any:
        pass

    @abstractmethod
    def _timestamp_field(self, timestamp_field: "scout_internal_search_api_TimestampField") -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_run_api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_internal_search_api_SearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_internal_search_api_SearchQuery"]) -> Any:
        pass


scout_internal_search_api_SearchQueryVisitor.__name__ = "SearchQueryVisitor"
scout_internal_search_api_SearchQueryVisitor.__qualname__ = "SearchQueryVisitor"
scout_internal_search_api_SearchQueryVisitor.__module__ = "scout_service_api.scout_internal_search_api"


class scout_internal_search_api_StringField(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


scout_internal_search_api_StringField.__name__ = "StringField"
scout_internal_search_api_StringField.__qualname__ = "StringField"
scout_internal_search_api_StringField.__module__ = "scout_service_api.scout_internal_search_api"


class scout_internal_search_api_TimestampField(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'operator': ConjureFieldDefinition('operator', scout_internal_search_api_Operator)
        }

    __slots__: List[str] = ['_name', '_timestamp', '_operator']

    def __init__(self, name: str, operator: "scout_internal_search_api_Operator", timestamp: "api_Timestamp") -> None:
        self._name = name
        self._timestamp = timestamp
        self._operator = operator

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def operator(self) -> "scout_internal_search_api_Operator":
        return self._operator


scout_internal_search_api_TimestampField.__name__ = "TimestampField"
scout_internal_search_api_TimestampField.__qualname__ = "TimestampField"
scout_internal_search_api_TimestampField.__module__ = "scout_service_api.scout_internal_search_api"


class scout_jobs_api_JobService(Service):
    """
    The Job Service is responsible for running jobs for checklist executions.
    """

    def submit_jobs(self, auth_header: str, request: "scout_checks_api_SubmitJobsRequest") -> "scout_checks_api_SubmitJobsResponse":
        """
        Runs the requested job specs.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/jobs/v1/submitJobs'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_SubmitJobsResponse, self._return_none_for_unknown_union_types)

    def get_job_report(self, auth_header: str, job_rid: str) -> "scout_checks_api_JobReport":
        """
        Fetches the job report for a job RID. Throws ResourcesNotFound if no job exists with this job RID.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'jobRid': job_rid,
        }

        _json: Any = None

        _path = '/jobs/v1/{jobRid}/job-report'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_JobReport, self._return_none_for_unknown_union_types)

    def batch_get_job_reports(self, auth_header: str, request: "scout_checks_api_BatchGetJobReportsRequest") -> "scout_checks_api_BatchGetJobReportsResponse":
        """
        Fetches the job reports for a set of job RIDs. Omits any job reports the user is not permitted to see from
the response.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/jobs/v1/batch-get-job-reports'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_BatchGetJobReportsResponse, self._return_none_for_unknown_union_types)


scout_jobs_api_JobService.__name__ = "JobService"
scout_jobs_api_JobService.__qualname__ = "JobService"
scout_jobs_api_JobService.__module__ = "scout_service_api.scout_jobs_api"


class scout_layout_api_ChartPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_ChartPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_ChartPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_ChartPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_ChartPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_ChartPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_ChartPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_ChartPanel.__name__ = "ChartPanel"
scout_layout_api_ChartPanel.__qualname__ = "ChartPanel"
scout_layout_api_ChartPanel.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_ChartPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_ChartPanelV1") -> Any:
        pass


scout_layout_api_ChartPanelVisitor.__name__ = "ChartPanelVisitor"
scout_layout_api_ChartPanelVisitor.__qualname__ = "ChartPanelVisitor"
scout_layout_api_ChartPanelVisitor.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_ChartPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId),
            'chart_rid': ConjureFieldDefinition('chartRid', scout_rids_api_VersionedChartRid),
            'hide_legend': ConjureFieldDefinition('hideLegend', bool)
        }

    __slots__: List[str] = ['_id', '_chart_rid', '_hide_legend']

    def __init__(self, chart_rid: "scout_rids_api_VersionedChartRid", hide_legend: bool, id: str) -> None:
        self._id = id
        self._chart_rid = chart_rid
        self._hide_legend = hide_legend

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def chart_rid(self) -> "scout_rids_api_VersionedChartRid":
        return self._chart_rid

    @builtins.property
    def hide_legend(self) -> bool:
        return self._hide_legend


scout_layout_api_ChartPanelV1.__name__ = "ChartPanelV1"
scout_layout_api_ChartPanelV1.__qualname__ = "ChartPanelV1"
scout_layout_api_ChartPanelV1.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_EmptyPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_EmptyPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_EmptyPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_EmptyPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_EmptyPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_EmptyPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_EmptyPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_EmptyPanel.__name__ = "EmptyPanel"
scout_layout_api_EmptyPanel.__qualname__ = "EmptyPanel"
scout_layout_api_EmptyPanel.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_EmptyPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_EmptyPanelV1") -> Any:
        pass


scout_layout_api_EmptyPanelVisitor.__name__ = "EmptyPanelVisitor"
scout_layout_api_EmptyPanelVisitor.__qualname__ = "EmptyPanelVisitor"
scout_layout_api_EmptyPanelVisitor.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_EmptyPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId)
        }

    __slots__: List[str] = ['_id']

    def __init__(self, id: str) -> None:
        self._id = id

    @builtins.property
    def id(self) -> str:
        return self._id


scout_layout_api_EmptyPanelV1.__name__ = "EmptyPanelV1"
scout_layout_api_EmptyPanelV1.__qualname__ = "EmptyPanelV1"
scout_layout_api_EmptyPanelV1.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_Panel(ConjureUnionType):
    _viz: Optional["scout_layout_api_VizPanel"] = None
    _chart: Optional["scout_layout_api_ChartPanel"] = None
    _empty: Optional["scout_layout_api_EmptyPanel"] = None
    _split: Optional["scout_layout_api_SplitPanel"] = None
    _tabbed: Optional["scout_layout_api_TabbedPanel"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'viz': ConjureFieldDefinition('viz', scout_layout_api_VizPanel),
            'chart': ConjureFieldDefinition('chart', scout_layout_api_ChartPanel),
            'empty': ConjureFieldDefinition('empty', scout_layout_api_EmptyPanel),
            'split': ConjureFieldDefinition('split', scout_layout_api_SplitPanel),
            'tabbed': ConjureFieldDefinition('tabbed', scout_layout_api_TabbedPanel)
        }

    def __init__(
            self,
            viz: Optional["scout_layout_api_VizPanel"] = None,
            chart: Optional["scout_layout_api_ChartPanel"] = None,
            empty: Optional["scout_layout_api_EmptyPanel"] = None,
            split: Optional["scout_layout_api_SplitPanel"] = None,
            tabbed: Optional["scout_layout_api_TabbedPanel"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (viz is not None) + (chart is not None) + (empty is not None) + (split is not None) + (tabbed is not None) != 1:
                raise ValueError('a union must contain a single member')

            if viz is not None:
                self._viz = viz
                self._type = 'viz'
            if chart is not None:
                self._chart = chart
                self._type = 'chart'
            if empty is not None:
                self._empty = empty
                self._type = 'empty'
            if split is not None:
                self._split = split
                self._type = 'split'
            if tabbed is not None:
                self._tabbed = tabbed
                self._type = 'tabbed'

        elif type_of_union == 'viz':
            if viz is None:
                raise ValueError('a union value must not be None')
            self._viz = viz
            self._type = 'viz'
        elif type_of_union == 'chart':
            if chart is None:
                raise ValueError('a union value must not be None')
            self._chart = chart
            self._type = 'chart'
        elif type_of_union == 'empty':
            if empty is None:
                raise ValueError('a union value must not be None')
            self._empty = empty
            self._type = 'empty'
        elif type_of_union == 'split':
            if split is None:
                raise ValueError('a union value must not be None')
            self._split = split
            self._type = 'split'
        elif type_of_union == 'tabbed':
            if tabbed is None:
                raise ValueError('a union value must not be None')
            self._tabbed = tabbed
            self._type = 'tabbed'

    @builtins.property
    def viz(self) -> Optional["scout_layout_api_VizPanel"]:
        return self._viz

    @builtins.property
    def chart(self) -> Optional["scout_layout_api_ChartPanel"]:
        return self._chart

    @builtins.property
    def empty(self) -> Optional["scout_layout_api_EmptyPanel"]:
        return self._empty

    @builtins.property
    def split(self) -> Optional["scout_layout_api_SplitPanel"]:
        return self._split

    @builtins.property
    def tabbed(self) -> Optional["scout_layout_api_TabbedPanel"]:
        return self._tabbed

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_PanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_PanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'viz' and self.viz is not None:
            return visitor._viz(self.viz)
        if self._type == 'chart' and self.chart is not None:
            return visitor._chart(self.chart)
        if self._type == 'empty' and self.empty is not None:
            return visitor._empty(self.empty)
        if self._type == 'split' and self.split is not None:
            return visitor._split(self.split)
        if self._type == 'tabbed' and self.tabbed is not None:
            return visitor._tabbed(self.tabbed)


scout_layout_api_Panel.__name__ = "Panel"
scout_layout_api_Panel.__qualname__ = "Panel"
scout_layout_api_Panel.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_PanelVisitor:

    @abstractmethod
    def _viz(self, viz: "scout_layout_api_VizPanel") -> Any:
        pass

    @abstractmethod
    def _chart(self, chart: "scout_layout_api_ChartPanel") -> Any:
        pass

    @abstractmethod
    def _empty(self, empty: "scout_layout_api_EmptyPanel") -> Any:
        pass

    @abstractmethod
    def _split(self, split: "scout_layout_api_SplitPanel") -> Any:
        pass

    @abstractmethod
    def _tabbed(self, tabbed: "scout_layout_api_TabbedPanel") -> Any:
        pass


scout_layout_api_PanelVisitor.__name__ = "PanelVisitor"
scout_layout_api_PanelVisitor.__qualname__ = "PanelVisitor"
scout_layout_api_PanelVisitor.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_SingleTab(ConjureUnionType):
    _v1: Optional["scout_layout_api_SingleTabV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_SingleTabV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_SingleTabV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_SingleTabV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_SingleTabVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_SingleTabVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_SingleTab.__name__ = "SingleTab"
scout_layout_api_SingleTab.__qualname__ = "SingleTab"
scout_layout_api_SingleTab.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_SingleTabVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_SingleTabV1") -> Any:
        pass


scout_layout_api_SingleTabVisitor.__name__ = "SingleTabVisitor"
scout_layout_api_SingleTabVisitor.__qualname__ = "SingleTabVisitor"
scout_layout_api_SingleTabVisitor.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_SingleTabV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'panel': ConjureFieldDefinition('panel', scout_layout_api_Panel)
        }

    __slots__: List[str] = ['_title', '_panel']

    def __init__(self, panel: "scout_layout_api_Panel", title: str) -> None:
        self._title = title
        self._panel = panel

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def panel(self) -> "scout_layout_api_Panel":
        return self._panel


scout_layout_api_SingleTabV1.__name__ = "SingleTabV1"
scout_layout_api_SingleTabV1.__qualname__ = "SingleTabV1"
scout_layout_api_SingleTabV1.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_SplitPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_SplitPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_SplitPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_SplitPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_SplitPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_SplitPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_SplitPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_SplitPanel.__name__ = "SplitPanel"
scout_layout_api_SplitPanel.__qualname__ = "SplitPanel"
scout_layout_api_SplitPanel.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_SplitPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_SplitPanelV1") -> Any:
        pass


scout_layout_api_SplitPanelVisitor.__name__ = "SplitPanelVisitor"
scout_layout_api_SplitPanelVisitor.__qualname__ = "SplitPanelVisitor"
scout_layout_api_SplitPanelVisitor.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_SplitPanelOrientation(ConjureEnumType):

    HORIZONTAL = 'HORIZONTAL'
    '''HORIZONTAL'''
    VERTICAL = 'VERTICAL'
    '''VERTICAL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_layout_api_SplitPanelOrientation.__name__ = "SplitPanelOrientation"
scout_layout_api_SplitPanelOrientation.__qualname__ = "SplitPanelOrientation"
scout_layout_api_SplitPanelOrientation.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_SplitPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId),
            'orientation': ConjureFieldDefinition('orientation', scout_layout_api_SplitPanelOrientation),
            'side_one': ConjureFieldDefinition('sideOne', scout_layout_api_Panel),
            'side_two': ConjureFieldDefinition('sideTwo', scout_layout_api_Panel)
        }

    __slots__: List[str] = ['_id', '_orientation', '_side_one', '_side_two']

    def __init__(self, id: str, orientation: "scout_layout_api_SplitPanelOrientation", side_one: "scout_layout_api_Panel", side_two: "scout_layout_api_Panel") -> None:
        self._id = id
        self._orientation = orientation
        self._side_one = side_one
        self._side_two = side_two

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def orientation(self) -> "scout_layout_api_SplitPanelOrientation":
        return self._orientation

    @builtins.property
    def side_one(self) -> "scout_layout_api_Panel":
        return self._side_one

    @builtins.property
    def side_two(self) -> "scout_layout_api_Panel":
        return self._side_two


scout_layout_api_SplitPanelV1.__name__ = "SplitPanelV1"
scout_layout_api_SplitPanelV1.__qualname__ = "SplitPanelV1"
scout_layout_api_SplitPanelV1.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_TabbedPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_TabbedPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_TabbedPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_TabbedPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_TabbedPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_TabbedPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_TabbedPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_TabbedPanel.__name__ = "TabbedPanel"
scout_layout_api_TabbedPanel.__qualname__ = "TabbedPanel"
scout_layout_api_TabbedPanel.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_TabbedPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_TabbedPanelV1") -> Any:
        pass


scout_layout_api_TabbedPanelVisitor.__name__ = "TabbedPanelVisitor"
scout_layout_api_TabbedPanelVisitor.__qualname__ = "TabbedPanelVisitor"
scout_layout_api_TabbedPanelVisitor.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_TabbedPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId),
            'tabs': ConjureFieldDefinition('tabs', List[scout_layout_api_SingleTab])
        }

    __slots__: List[str] = ['_id', '_tabs']

    def __init__(self, id: str, tabs: List["scout_layout_api_SingleTab"]) -> None:
        self._id = id
        self._tabs = tabs

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def tabs(self) -> List["scout_layout_api_SingleTab"]:
        return self._tabs


scout_layout_api_TabbedPanelV1.__name__ = "TabbedPanelV1"
scout_layout_api_TabbedPanelV1.__qualname__ = "TabbedPanelV1"
scout_layout_api_TabbedPanelV1.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_VizPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_VizPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_VizPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_VizPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_VizPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_VizPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_VizPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_VizPanel.__name__ = "VizPanel"
scout_layout_api_VizPanel.__qualname__ = "VizPanel"
scout_layout_api_VizPanel.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_VizPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_VizPanelV1") -> Any:
        pass


scout_layout_api_VizPanelVisitor.__name__ = "VizPanelVisitor"
scout_layout_api_VizPanelVisitor.__qualname__ = "VizPanelVisitor"
scout_layout_api_VizPanelVisitor.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_VizPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId),
            'viz_id': ConjureFieldDefinition('vizId', scout_chartdefinition_api_VizId),
            'hide_legend': ConjureFieldDefinition('hideLegend', bool)
        }

    __slots__: List[str] = ['_id', '_viz_id', '_hide_legend']

    def __init__(self, hide_legend: bool, id: str, viz_id: str) -> None:
        self._id = id
        self._viz_id = viz_id
        self._hide_legend = hide_legend

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def viz_id(self) -> str:
        return self._viz_id

    @builtins.property
    def hide_legend(self) -> bool:
        return self._hide_legend


scout_layout_api_VizPanelV1.__name__ = "VizPanelV1"
scout_layout_api_VizPanelV1.__qualname__ = "VizPanelV1"
scout_layout_api_VizPanelV1.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_WorkbookLayout(ConjureUnionType):
    _v1: Optional["scout_layout_api_WorkbookLayoutV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_WorkbookLayoutV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_WorkbookLayoutV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_WorkbookLayoutV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_WorkbookLayoutVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_WorkbookLayoutVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_WorkbookLayout.__name__ = "WorkbookLayout"
scout_layout_api_WorkbookLayout.__qualname__ = "WorkbookLayout"
scout_layout_api_WorkbookLayout.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_WorkbookLayoutVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_WorkbookLayoutV1") -> Any:
        pass


scout_layout_api_WorkbookLayoutVisitor.__name__ = "WorkbookLayoutVisitor"
scout_layout_api_WorkbookLayoutVisitor.__qualname__ = "WorkbookLayoutVisitor"
scout_layout_api_WorkbookLayoutVisitor.__module__ = "scout_service_api.scout_layout_api"


class scout_layout_api_WorkbookLayoutV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'root_panel': ConjureFieldDefinition('rootPanel', scout_layout_api_Panel)
        }

    __slots__: List[str] = ['_root_panel']

    def __init__(self, root_panel: "scout_layout_api_Panel") -> None:
        self._root_panel = root_panel

    @builtins.property
    def root_panel(self) -> "scout_layout_api_Panel":
        return self._root_panel


scout_layout_api_WorkbookLayoutV1.__name__ = "WorkbookLayoutV1"
scout_layout_api_WorkbookLayoutV1.__qualname__ = "WorkbookLayoutV1"
scout_layout_api_WorkbookLayoutV1.__module__ = "scout_service_api.scout_layout_api"


class scout_metadata_ListPropertiesAndLabelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_types': ConjureFieldDefinition('resourceTypes', OptionalTypeWrapper[List[scout_metadata_ResourceType]])
        }

    __slots__: List[str] = ['_resource_types']

    def __init__(self, resource_types: Optional[List["scout_metadata_ResourceType"]] = None) -> None:
        self._resource_types = resource_types

    @builtins.property
    def resource_types(self) -> Optional[List["scout_metadata_ResourceType"]]:
        """
        If omitted, all resource types are included.
        """
        return self._resource_types


scout_metadata_ListPropertiesAndLabelsRequest.__name__ = "ListPropertiesAndLabelsRequest"
scout_metadata_ListPropertiesAndLabelsRequest.__qualname__ = "ListPropertiesAndLabelsRequest"
scout_metadata_ListPropertiesAndLabelsRequest.__module__ = "scout_service_api.scout_metadata"


class scout_metadata_ListPropertiesAndLabelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, List[scout_run_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_metadata_ListPropertiesAndLabelsResponse.__name__ = "ListPropertiesAndLabelsResponse"
scout_metadata_ListPropertiesAndLabelsResponse.__qualname__ = "ListPropertiesAndLabelsResponse"
scout_metadata_ListPropertiesAndLabelsResponse.__module__ = "scout_service_api.scout_metadata"


class scout_metadata_ResourceMetadataService(Service):
    """
    The Resource Metadata Service provides common metadata about resources.
    """

    def list_properties_and_labels(self, auth_header: str, request: "scout_metadata_ListPropertiesAndLabelsRequest") -> "scout_metadata_ListPropertiesAndLabelsResponse":
        """
        Returns all existing properties (key value pairs) and labels, which can be used to organize resources
such as runs and videos.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/scout/v1/metadata/list-properties-labels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_metadata_ListPropertiesAndLabelsResponse, self._return_none_for_unknown_union_types)


scout_metadata_ResourceMetadataService.__name__ = "ResourceMetadataService"
scout_metadata_ResourceMetadataService.__qualname__ = "ResourceMetadataService"
scout_metadata_ResourceMetadataService.__module__ = "scout_service_api.scout_metadata"


class scout_metadata_ResourceType(ConjureEnumType):

    RUN = 'RUN'
    '''RUN'''
    VIDEO = 'VIDEO'
    '''VIDEO'''
    ASSET = 'ASSET'
    '''ASSET'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_metadata_ResourceType.__name__ = "ResourceType"
scout_metadata_ResourceType.__qualname__ = "ResourceType"
scout_metadata_ResourceType.__module__ = "scout_service_api.scout_metadata"


class scout_notebook_api_ChartWithOverlays(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_ChartRid),
            'version': ConjureFieldDefinition('version', scout_rids_api_Version),
            'overlays': ConjureFieldDefinition('overlays', object)
        }

    __slots__: List[str] = ['_rid', '_version', '_overlays']

    def __init__(self, overlays: Any, rid: str, version: int) -> None:
        self._rid = rid
        self._version = version
        self._overlays = overlays

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def version(self) -> int:
        return self._version

    @builtins.property
    def overlays(self) -> Any:
        return self._overlays


scout_notebook_api_ChartWithOverlays.__name__ = "ChartWithOverlays"
scout_notebook_api_ChartWithOverlays.__qualname__ = "ChartWithOverlays"
scout_notebook_api_ChartWithOverlays.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_CreateNotebookRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'notebook_type': ConjureFieldDefinition('notebookType', OptionalTypeWrapper[scout_notebook_api_NotebookType]),
            'is_draft': ConjureFieldDefinition('isDraft', bool),
            'state_as_json': ConjureFieldDefinition('stateAsJson', str),
            'charts': ConjureFieldDefinition('charts', OptionalTypeWrapper[List[scout_notebook_api_ChartWithOverlays]]),
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[scout_run_api_RunRid]),
            'data_scope': ConjureFieldDefinition('dataScope', OptionalTypeWrapper[scout_notebook_api_NotebookDataScope]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookContent]),
            'content_v2': ConjureFieldDefinition('contentV2', OptionalTypeWrapper[scout_workbookcommon_api_UnifiedWorkbookContent])
        }

    __slots__: List[str] = ['_title', '_description', '_notebook_type', '_is_draft', '_state_as_json', '_charts', '_run_rid', '_data_scope', '_layout', '_content', '_content_v2']

    def __init__(self, description: str, is_draft: bool, layout: "scout_layout_api_WorkbookLayout", state_as_json: str, title: str, charts: Optional[List["scout_notebook_api_ChartWithOverlays"]] = None, content: Optional["scout_workbookcommon_api_WorkbookContent"] = None, content_v2: Optional["scout_workbookcommon_api_UnifiedWorkbookContent"] = None, data_scope: Optional["scout_notebook_api_NotebookDataScope"] = None, notebook_type: Optional["scout_notebook_api_NotebookType"] = None, run_rid: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._notebook_type = notebook_type
        self._is_draft = is_draft
        self._state_as_json = state_as_json
        self._charts = charts
        self._run_rid = run_rid
        self._data_scope = data_scope
        self._layout = layout
        self._content = content
        self._content_v2 = content_v2

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def notebook_type(self) -> Optional["scout_notebook_api_NotebookType"]:
        """
        Optional for backcompatibility. Default is a normal workbook.
        """
        return self._notebook_type

    @builtins.property
    def is_draft(self) -> bool:
        return self._is_draft

    @builtins.property
    def state_as_json(self) -> str:
        return self._state_as_json

    @builtins.property
    def charts(self) -> Optional[List["scout_notebook_api_ChartWithOverlays"]]:
        return self._charts

    @builtins.property
    def run_rid(self) -> Optional[str]:
        """
        deprecated. Use dataScope instead
        """
        return self._run_rid

    @builtins.property
    def data_scope(self) -> Optional["scout_notebook_api_NotebookDataScope"]:
        """
        Optional for back-compatibility.
        """
        return self._data_scope

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> Optional["scout_workbookcommon_api_WorkbookContent"]:
        return self._content

    @builtins.property
    def content_v2(self) -> Optional["scout_workbookcommon_api_UnifiedWorkbookContent"]:
        """
        Optional for backcompatibility
        """
        return self._content_v2


scout_notebook_api_CreateNotebookRequest.__name__ = "CreateNotebookRequest"
scout_notebook_api_CreateNotebookRequest.__qualname__ = "CreateNotebookRequest"
scout_notebook_api_CreateNotebookRequest.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_GetAllLabelsAndPropertiesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, List[scout_run_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_notebook_api_GetAllLabelsAndPropertiesResponse.__name__ = "GetAllLabelsAndPropertiesResponse"
scout_notebook_api_GetAllLabelsAndPropertiesResponse.__qualname__ = "GetAllLabelsAndPropertiesResponse"
scout_notebook_api_GetAllLabelsAndPropertiesResponse.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_Lock(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_locked': ConjureFieldDefinition('isLocked', bool),
            'updated_at': ConjureFieldDefinition('updatedAt', OptionalTypeWrapper[str]),
            'updated_by_rid': ConjureFieldDefinition('updatedByRid', OptionalTypeWrapper[scout_rids_api_UserRid])
        }

    __slots__: List[str] = ['_is_locked', '_updated_at', '_updated_by_rid']

    def __init__(self, is_locked: bool, updated_at: Optional[str] = None, updated_by_rid: Optional[str] = None) -> None:
        self._is_locked = is_locked
        self._updated_at = updated_at
        self._updated_by_rid = updated_by_rid

    @builtins.property
    def is_locked(self) -> bool:
        return self._is_locked

    @builtins.property
    def updated_at(self) -> Optional[str]:
        return self._updated_at

    @builtins.property
    def updated_by_rid(self) -> Optional[str]:
        return self._updated_by_rid


scout_notebook_api_Lock.__name__ = "Lock"
scout_notebook_api_Lock.__qualname__ = "Lock"
scout_notebook_api_Lock.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_Notebook(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_NotebookRid),
            'snapshot_rid': ConjureFieldDefinition('snapshotRid', scout_rids_api_SnapshotRid),
            'snapshot_author_rid': ConjureFieldDefinition('snapshotAuthorRid', scout_rids_api_UserRid),
            'snapshot_created_at': ConjureFieldDefinition('snapshotCreatedAt', str),
            'metadata': ConjureFieldDefinition('metadata', scout_notebook_api_NotebookMetadata),
            'state_as_json': ConjureFieldDefinition('stateAsJson', str),
            'charts': ConjureFieldDefinition('charts', OptionalTypeWrapper[List[scout_notebook_api_ChartWithOverlays]]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookContent]),
            'content_v2': ConjureFieldDefinition('contentV2', scout_workbookcommon_api_UnifiedWorkbookContent)
        }

    __slots__: List[str] = ['_rid', '_snapshot_rid', '_snapshot_author_rid', '_snapshot_created_at', '_metadata', '_state_as_json', '_charts', '_layout', '_content', '_content_v2']

    def __init__(self, content_v2: "scout_workbookcommon_api_UnifiedWorkbookContent", layout: "scout_layout_api_WorkbookLayout", metadata: "scout_notebook_api_NotebookMetadata", rid: str, snapshot_author_rid: str, snapshot_created_at: str, snapshot_rid: str, state_as_json: str, charts: Optional[List["scout_notebook_api_ChartWithOverlays"]] = None, content: Optional["scout_workbookcommon_api_WorkbookContent"] = None) -> None:
        self._rid = rid
        self._snapshot_rid = snapshot_rid
        self._snapshot_author_rid = snapshot_author_rid
        self._snapshot_created_at = snapshot_created_at
        self._metadata = metadata
        self._state_as_json = state_as_json
        self._charts = charts
        self._layout = layout
        self._content = content
        self._content_v2 = content_v2

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def snapshot_rid(self) -> str:
        return self._snapshot_rid

    @builtins.property
    def snapshot_author_rid(self) -> str:
        return self._snapshot_author_rid

    @builtins.property
    def snapshot_created_at(self) -> str:
        return self._snapshot_created_at

    @builtins.property
    def metadata(self) -> "scout_notebook_api_NotebookMetadata":
        return self._metadata

    @builtins.property
    def state_as_json(self) -> str:
        return self._state_as_json

    @builtins.property
    def charts(self) -> Optional[List["scout_notebook_api_ChartWithOverlays"]]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> Optional["scout_workbookcommon_api_WorkbookContent"]:
        return self._content

    @builtins.property
    def content_v2(self) -> "scout_workbookcommon_api_UnifiedWorkbookContent":
        return self._content_v2


scout_notebook_api_Notebook.__name__ = "Notebook"
scout_notebook_api_Notebook.__qualname__ = "Notebook"
scout_notebook_api_Notebook.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_NotebookDataScope(ConjureUnionType):
    _run_rids: Optional[List[str]] = None
    _asset_rids: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rids': ConjureFieldDefinition('runRids', List[scout_run_api_RunRid]),
            'asset_rids': ConjureFieldDefinition('assetRids', List[scout_rids_api_AssetRid])
        }

    def __init__(
            self,
            run_rids: Optional[List[str]] = None,
            asset_rids: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (run_rids is not None) + (asset_rids is not None) != 1:
                raise ValueError('a union must contain a single member')

            if run_rids is not None:
                self._run_rids = run_rids
                self._type = 'runRids'
            if asset_rids is not None:
                self._asset_rids = asset_rids
                self._type = 'assetRids'

        elif type_of_union == 'runRids':
            if run_rids is None:
                raise ValueError('a union value must not be None')
            self._run_rids = run_rids
            self._type = 'runRids'
        elif type_of_union == 'assetRids':
            if asset_rids is None:
                raise ValueError('a union value must not be None')
            self._asset_rids = asset_rids
            self._type = 'assetRids'

    @builtins.property
    def run_rids(self) -> Optional[List[str]]:
        return self._run_rids

    @builtins.property
    def asset_rids(self) -> Optional[List[str]]:
        return self._asset_rids

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_notebook_api_NotebookDataScopeVisitor):
            raise ValueError('{} is not an instance of scout_notebook_api_NotebookDataScopeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'runRids' and self.run_rids is not None:
            return visitor._run_rids(self.run_rids)
        if self._type == 'assetRids' and self.asset_rids is not None:
            return visitor._asset_rids(self.asset_rids)


scout_notebook_api_NotebookDataScope.__name__ = "NotebookDataScope"
scout_notebook_api_NotebookDataScope.__qualname__ = "NotebookDataScope"
scout_notebook_api_NotebookDataScope.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_NotebookDataScopeVisitor:

    @abstractmethod
    def _run_rids(self, run_rids: List[str]) -> Any:
        pass

    @abstractmethod
    def _asset_rids(self, asset_rids: List[str]) -> Any:
        pass


scout_notebook_api_NotebookDataScopeVisitor.__name__ = "NotebookDataScopeVisitor"
scout_notebook_api_NotebookDataScopeVisitor.__qualname__ = "NotebookDataScopeVisitor"
scout_notebook_api_NotebookDataScopeVisitor.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_NotebookMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[scout_run_api_RunRid]),
            'data_scope': ConjureFieldDefinition('dataScope', scout_notebook_api_NotebookDataScope),
            'notebook_type': ConjureFieldDefinition('notebookType', scout_notebook_api_NotebookType),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'is_draft': ConjureFieldDefinition('isDraft', bool),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'lock': ConjureFieldDefinition('lock', scout_notebook_api_Lock),
            'created_by_rid': ConjureFieldDefinition('createdByRid', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label])
        }

    __slots__: List[str] = ['_run_rid', '_data_scope', '_notebook_type', '_title', '_description', '_is_draft', '_is_archived', '_lock', '_created_by_rid', '_created_at', '_properties', '_labels']

    def __init__(self, created_at: str, created_by_rid: str, data_scope: "scout_notebook_api_NotebookDataScope", description: str, is_archived: bool, is_draft: bool, labels: List[str], lock: "scout_notebook_api_Lock", notebook_type: "scout_notebook_api_NotebookType", properties: Dict[str, str], title: str, run_rid: Optional[str] = None) -> None:
        self._run_rid = run_rid
        self._data_scope = data_scope
        self._notebook_type = notebook_type
        self._title = title
        self._description = description
        self._is_draft = is_draft
        self._is_archived = is_archived
        self._lock = lock
        self._created_by_rid = created_by_rid
        self._created_at = created_at
        self._properties = properties
        self._labels = labels

    @builtins.property
    def run_rid(self) -> Optional[str]:
        """
        deprecated. Use dataScope instead
        """
        return self._run_rid

    @builtins.property
    def data_scope(self) -> "scout_notebook_api_NotebookDataScope":
        return self._data_scope

    @builtins.property
    def notebook_type(self) -> "scout_notebook_api_NotebookType":
        return self._notebook_type

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def is_draft(self) -> bool:
        return self._is_draft

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived

    @builtins.property
    def lock(self) -> "scout_notebook_api_Lock":
        return self._lock

    @builtins.property
    def created_by_rid(self) -> str:
        return self._created_by_rid

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_notebook_api_NotebookMetadata.__name__ = "NotebookMetadata"
scout_notebook_api_NotebookMetadata.__qualname__ = "NotebookMetadata"
scout_notebook_api_NotebookMetadata.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_NotebookMetadataWithRid(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_NotebookRid),
            'metadata': ConjureFieldDefinition('metadata', scout_notebook_api_NotebookMetadata)
        }

    __slots__: List[str] = ['_rid', '_metadata']

    def __init__(self, metadata: "scout_notebook_api_NotebookMetadata", rid: str) -> None:
        self._rid = rid
        self._metadata = metadata

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def metadata(self) -> "scout_notebook_api_NotebookMetadata":
        return self._metadata


scout_notebook_api_NotebookMetadataWithRid.__name__ = "NotebookMetadataWithRid"
scout_notebook_api_NotebookMetadataWithRid.__qualname__ = "NotebookMetadataWithRid"
scout_notebook_api_NotebookMetadataWithRid.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_NotebookType(ConjureEnumType):

    WORKBOOK = 'WORKBOOK'
    '''WORKBOOK'''
    COMPARISON_WORKBOOK = 'COMPARISON_WORKBOOK'
    '''COMPARISON_WORKBOOK'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_notebook_api_NotebookType.__name__ = "NotebookType"
scout_notebook_api_NotebookType.__qualname__ = "NotebookType"
scout_notebook_api_NotebookType.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_SearchNotebooksQuery(ConjureUnionType):
    _and_: Optional[List["scout_notebook_api_SearchNotebooksQuery"]] = None
    _or_: Optional[List["scout_notebook_api_SearchNotebooksQuery"]] = None
    _exact_match: Optional[str] = None
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["scout_run_api_Property"] = None
    _author_rid: Optional[str] = None
    _run_rid: Optional[str] = None
    _notebook_type: Optional["scout_notebook_api_NotebookType"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', List[scout_notebook_api_SearchNotebooksQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_notebook_api_SearchNotebooksQuery]),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', scout_run_api_Label),
            'property': ConjureFieldDefinition('property', scout_run_api_Property),
            'author_rid': ConjureFieldDefinition('authorRid', scout_rids_api_UserRid),
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid),
            'notebook_type': ConjureFieldDefinition('notebookType', scout_notebook_api_NotebookType)
        }

    def __init__(
            self,
            and_: Optional[List["scout_notebook_api_SearchNotebooksQuery"]] = None,
            or_: Optional[List["scout_notebook_api_SearchNotebooksQuery"]] = None,
            exact_match: Optional[str] = None,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["scout_run_api_Property"] = None,
            author_rid: Optional[str] = None,
            run_rid: Optional[str] = None,
            notebook_type: Optional["scout_notebook_api_NotebookType"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (exact_match is not None) + (search_text is not None) + (label is not None) + (property is not None) + (author_rid is not None) + (run_rid is not None) + (notebook_type is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if author_rid is not None:
                self._author_rid = author_rid
                self._type = 'authorRid'
            if run_rid is not None:
                self._run_rid = run_rid
                self._type = 'runRid'
            if notebook_type is not None:
                self._notebook_type = notebook_type
                self._type = 'notebookType'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'authorRid':
            if author_rid is None:
                raise ValueError('a union value must not be None')
            self._author_rid = author_rid
            self._type = 'authorRid'
        elif type_of_union == 'runRid':
            if run_rid is None:
                raise ValueError('a union value must not be None')
            self._run_rid = run_rid
            self._type = 'runRid'
        elif type_of_union == 'notebookType':
            if notebook_type is None:
                raise ValueError('a union value must not be None')
            self._notebook_type = notebook_type
            self._type = 'notebookType'

    @builtins.property
    def and_(self) -> Optional[List["scout_notebook_api_SearchNotebooksQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_notebook_api_SearchNotebooksQuery"]]:
        return self._or_

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """
        Performs case insensitive exact match search on the title.
        """
        return self._exact_match

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["scout_run_api_Property"]:
        return self._property

    @builtins.property
    def author_rid(self) -> Optional[str]:
        return self._author_rid

    @builtins.property
    def run_rid(self) -> Optional[str]:
        return self._run_rid

    @builtins.property
    def notebook_type(self) -> Optional["scout_notebook_api_NotebookType"]:
        return self._notebook_type

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_notebook_api_SearchNotebooksQueryVisitor):
            raise ValueError('{} is not an instance of scout_notebook_api_SearchNotebooksQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'authorRid' and self.author_rid is not None:
            return visitor._author_rid(self.author_rid)
        if self._type == 'runRid' and self.run_rid is not None:
            return visitor._run_rid(self.run_rid)
        if self._type == 'notebookType' and self.notebook_type is not None:
            return visitor._notebook_type(self.notebook_type)


scout_notebook_api_SearchNotebooksQuery.__name__ = "SearchNotebooksQuery"
scout_notebook_api_SearchNotebooksQuery.__qualname__ = "SearchNotebooksQuery"
scout_notebook_api_SearchNotebooksQuery.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_SearchNotebooksQueryVisitor:

    @abstractmethod
    def _and(self, and_: List["scout_notebook_api_SearchNotebooksQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_notebook_api_SearchNotebooksQuery"]) -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_run_api_Property") -> Any:
        pass

    @abstractmethod
    def _author_rid(self, author_rid: str) -> Any:
        pass

    @abstractmethod
    def _run_rid(self, run_rid: str) -> Any:
        pass

    @abstractmethod
    def _notebook_type(self, notebook_type: "scout_notebook_api_NotebookType") -> Any:
        pass


scout_notebook_api_SearchNotebooksQueryVisitor.__name__ = "SearchNotebooksQueryVisitor"
scout_notebook_api_SearchNotebooksQueryVisitor.__qualname__ = "SearchNotebooksQueryVisitor"
scout_notebook_api_SearchNotebooksQueryVisitor.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_SearchNotebooksRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_notebook_api_SearchNotebooksQuery),
            'show_drafts': ConjureFieldDefinition('showDrafts', bool),
            'show_archived': ConjureFieldDefinition('showArchived', OptionalTypeWrapper[bool]),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[scout_notebook_api_SortBy]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_query', '_show_drafts', '_show_archived', '_sort_by', '_next_page_token', '_page_size']

    def __init__(self, query: "scout_notebook_api_SearchNotebooksQuery", show_drafts: bool, next_page_token: Optional[str] = None, page_size: Optional[int] = None, show_archived: Optional[bool] = None, sort_by: Optional["scout_notebook_api_SortBy"] = None) -> None:
        self._query = query
        self._show_drafts = show_drafts
        self._show_archived = show_archived
        self._sort_by = sort_by
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def query(self) -> "scout_notebook_api_SearchNotebooksQuery":
        return self._query

    @builtins.property
    def show_drafts(self) -> bool:
        return self._show_drafts

    @builtins.property
    def show_archived(self) -> Optional[bool]:
        return self._show_archived

    @builtins.property
    def sort_by(self) -> Optional["scout_notebook_api_SortBy"]:
        """
        UPDATED_AT descending by default
        """
        return self._sort_by

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 100. Will throw if larger than 1000.
        """
        return self._page_size


scout_notebook_api_SearchNotebooksRequest.__name__ = "SearchNotebooksRequest"
scout_notebook_api_SearchNotebooksRequest.__qualname__ = "SearchNotebooksRequest"
scout_notebook_api_SearchNotebooksRequest.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_SearchNotebooksResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_notebook_api_NotebookMetadataWithRid]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_notebook_api_NotebookMetadataWithRid"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_notebook_api_NotebookMetadataWithRid"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_notebook_api_SearchNotebooksResponse.__name__ = "SearchNotebooksResponse"
scout_notebook_api_SearchNotebooksResponse.__qualname__ = "SearchNotebooksResponse"
scout_notebook_api_SearchNotebooksResponse.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_SortBy(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_notebook_api_SortByField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_notebook_api_SortByField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_notebook_api_SortByField":
        return self._field


scout_notebook_api_SortBy.__name__ = "SortBy"
scout_notebook_api_SortBy.__qualname__ = "SortBy"
scout_notebook_api_SortBy.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_SortByField(ConjureEnumType):

    NAME = 'NAME'
    '''NAME'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UPDATED_AT = 'UPDATED_AT'
    '''UPDATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_notebook_api_SortByField.__name__ = "SortByField"
scout_notebook_api_SortByField.__qualname__ = "SortByField"
scout_notebook_api_SortByField.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_UpdateNotebookMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'data_scope': ConjureFieldDefinition('dataScope', OptionalTypeWrapper[scout_notebook_api_NotebookDataScope]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[scout_run_api_Label]]),
            'is_draft': ConjureFieldDefinition('isDraft', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_title', '_data_scope', '_description', '_properties', '_labels', '_is_draft']

    def __init__(self, data_scope: Optional["scout_notebook_api_NotebookDataScope"] = None, description: Optional[str] = None, is_draft: Optional[bool] = None, labels: Optional[List[str]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._data_scope = data_scope
        self._description = description
        self._properties = properties
        self._labels = labels
        self._is_draft = is_draft

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def data_scope(self) -> Optional["scout_notebook_api_NotebookDataScope"]:
        """
        Optional for backcompatibility.
        """
        return self._data_scope

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def is_draft(self) -> Optional[bool]:
        return self._is_draft


scout_notebook_api_UpdateNotebookMetadataRequest.__name__ = "UpdateNotebookMetadataRequest"
scout_notebook_api_UpdateNotebookMetadataRequest.__qualname__ = "UpdateNotebookMetadataRequest"
scout_notebook_api_UpdateNotebookMetadataRequest.__module__ = "scout_service_api.scout_notebook_api"


class scout_notebook_api_UpdateNotebookRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'state_as_json': ConjureFieldDefinition('stateAsJson', str),
            'charts': ConjureFieldDefinition('charts', OptionalTypeWrapper[List[scout_notebook_api_ChartWithOverlays]]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookContent]),
            'content_v2': ConjureFieldDefinition('contentV2', OptionalTypeWrapper[scout_workbookcommon_api_UnifiedWorkbookContent]),
            'latest_snapshot_rid': ConjureFieldDefinition('latestSnapshotRid', OptionalTypeWrapper[scout_rids_api_SnapshotRid])
        }

    __slots__: List[str] = ['_state_as_json', '_charts', '_layout', '_content', '_content_v2', '_latest_snapshot_rid']

    def __init__(self, layout: "scout_layout_api_WorkbookLayout", state_as_json: str, charts: Optional[List["scout_notebook_api_ChartWithOverlays"]] = None, content: Optional["scout_workbookcommon_api_WorkbookContent"] = None, content_v2: Optional["scout_workbookcommon_api_UnifiedWorkbookContent"] = None, latest_snapshot_rid: Optional[str] = None) -> None:
        self._state_as_json = state_as_json
        self._charts = charts
        self._layout = layout
        self._content = content
        self._content_v2 = content_v2
        self._latest_snapshot_rid = latest_snapshot_rid

    @builtins.property
    def state_as_json(self) -> str:
        return self._state_as_json

    @builtins.property
    def charts(self) -> Optional[List["scout_notebook_api_ChartWithOverlays"]]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> Optional["scout_workbookcommon_api_WorkbookContent"]:
        return self._content

    @builtins.property
    def content_v2(self) -> Optional["scout_workbookcommon_api_UnifiedWorkbookContent"]:
        """
        Optional for backcompatibility
        """
        return self._content_v2

    @builtins.property
    def latest_snapshot_rid(self) -> Optional[str]:
        """
        If provided, will only update the notebook if the latest snapshot matches the provided snapshot rid,
and throws SaveNotebookConflict otherwise.
        """
        return self._latest_snapshot_rid


scout_notebook_api_UpdateNotebookRequest.__name__ = "UpdateNotebookRequest"
scout_notebook_api_UpdateNotebookRequest.__qualname__ = "UpdateNotebookRequest"
scout_notebook_api_UpdateNotebookRequest.__module__ = "scout_service_api.scout_notebook_api"


class scout_plotting_TimestampType(ConjureEnumType):

    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_plotting_TimestampType.__name__ = "TimestampType"
scout_plotting_TimestampType.__qualname__ = "TimestampType"
scout_plotting_TimestampType.__module__ = "scout_service_api.scout_plotting"


class scout_rids_api_ArchivedStatus(ConjureEnumType):

    ARCHIVED = 'ARCHIVED'
    '''ARCHIVED'''
    NOT_ARCHIVED = 'NOT_ARCHIVED'
    '''NOT_ARCHIVED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_rids_api_ArchivedStatus.__name__ = "ArchivedStatus"
scout_rids_api_ArchivedStatus.__qualname__ = "ArchivedStatus"
scout_rids_api_ArchivedStatus.__module__ = "scout_service_api.scout_rids_api"


class scout_rids_api_Empty(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_rids_api_Empty.__name__ = "Empty"
scout_rids_api_Empty.__qualname__ = "Empty"
scout_rids_api_Empty.__module__ = "scout_service_api.scout_rids_api"


class scout_rids_api_VersionedChartRid(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_ChartRid),
            'version': ConjureFieldDefinition('version', scout_rids_api_Version)
        }

    __slots__: List[str] = ['_rid', '_version']

    def __init__(self, rid: str, version: int) -> None:
        self._rid = rid
        self._version = version

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def version(self) -> int:
        return self._version


scout_rids_api_VersionedChartRid.__name__ = "VersionedChartRid"
scout_rids_api_VersionedChartRid.__qualname__ = "VersionedChartRid"
scout_rids_api_VersionedChartRid.__module__ = "scout_service_api.scout_rids_api"


class scout_run_api_AllRunsPropertiesAndLabelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, List[scout_run_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_run_api_AllRunsPropertiesAndLabelsResponse.__name__ = "AllRunsPropertiesAndLabelsResponse"
scout_run_api_AllRunsPropertiesAndLabelsResponse.__qualname__ = "AllRunsPropertiesAndLabelsResponse"
scout_run_api_AllRunsPropertiesAndLabelsResponse.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_ChannelMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_api_Channel),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[scout_run_api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'data_type': ConjureFieldDefinition('dataType', OptionalTypeWrapper[scout_run_api_SeriesDataType])
        }

    __slots__: List[str] = ['_name', '_data_source', '_unit', '_description', '_data_type']

    def __init__(self, data_source: "scout_run_api_DataSource", name: str, data_type: Optional["scout_run_api_SeriesDataType"] = None, description: Optional[str] = None, unit: Optional["scout_run_api_Unit"] = None) -> None:
        self._name = name
        self._data_source = data_source
        self._unit = unit
        self._description = description
        self._data_type = data_type

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def unit(self) -> Optional["scout_run_api_Unit"]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def data_type(self) -> Optional["scout_run_api_SeriesDataType"]:
        return self._data_type


scout_run_api_ChannelMetadata.__name__ = "ChannelMetadata"
scout_run_api_ChannelMetadata.__qualname__ = "ChannelMetadata"
scout_run_api_ChannelMetadata.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_CreateOrUpdateRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[scout_run_api_RunRid]),
            'create_run_request': ConjureFieldDefinition('createRunRequest', scout_run_api_CreateRunRequest)
        }

    __slots__: List[str] = ['_run_rid', '_create_run_request']

    def __init__(self, create_run_request: "scout_run_api_CreateRunRequest", run_rid: Optional[str] = None) -> None:
        self._run_rid = run_rid
        self._create_run_request = create_run_request

    @builtins.property
    def run_rid(self) -> Optional[str]:
        """
        If a run with the same rid already exists, it will be updated.
Otherwise, a new run will be created.
        """
        return self._run_rid

    @builtins.property
    def create_run_request(self) -> "scout_run_api_CreateRunRequest":
        return self._create_run_request


scout_run_api_CreateOrUpdateRunRequest.__name__ = "CreateOrUpdateRunRequest"
scout_run_api_CreateOrUpdateRunRequest.__qualname__ = "CreateOrUpdateRunRequest"
scout_run_api_CreateOrUpdateRunRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_CreateRunDataSource(ConjureBeanType):
    """
    For write requests, we want to allow for optional fields
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_run_api_Duration]),
            'series_tags': ConjureFieldDefinition('seriesTags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_source', '_offset', '_series_tags']

    def __init__(self, data_source: "scout_run_api_DataSource", series_tags: Dict[str, str], offset: Optional["scout_run_api_Duration"] = None) -> None:
        self._data_source = data_source
        self._offset = offset
        self._series_tags = series_tags

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def offset(self) -> Optional["scout_run_api_Duration"]:
        return self._offset

    @builtins.property
    def series_tags(self) -> Dict[str, str]:
        """
        Used to resolve logical series for this data source.
        """
        return self._series_tags


scout_run_api_CreateRunDataSource.__name__ = "CreateRunDataSource"
scout_run_api_CreateRunDataSource.__qualname__ = "CreateRunDataSource"
scout_run_api_CreateRunDataSource.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_CreateRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'start_time': ConjureFieldDefinition('startTime', scout_run_api_UtcTimestamp),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label]),
            'links': ConjureFieldDefinition('links', List[scout_run_api_Link]),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str]),
            'data_sources': ConjureFieldDefinition('dataSources', Dict[scout_api_DataSourceRefName, scout_run_api_CreateRunDataSource]),
            'attachments': ConjureFieldDefinition('attachments', List[scout_rids_api_AttachmentRid]),
            'asset': ConjureFieldDefinition('asset', OptionalTypeWrapper[scout_rids_api_AssetRid])
        }

    __slots__: List[str] = ['_title', '_description', '_start_time', '_end_time', '_properties', '_labels', '_links', '_run_prefix', '_data_sources', '_attachments', '_asset']

    def __init__(self, attachments: List[str], data_sources: Dict[str, "scout_run_api_CreateRunDataSource"], description: str, labels: List[str], links: List["scout_run_api_Link"], properties: Dict[str, str], start_time: "scout_run_api_UtcTimestamp", title: str, asset: Optional[str] = None, end_time: Optional["scout_run_api_UtcTimestamp"] = None, run_prefix: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._start_time = start_time
        self._end_time = end_time
        self._properties = properties
        self._labels = labels
        self._links = links
        self._run_prefix = run_prefix
        self._data_sources = data_sources
        self._attachments = attachments
        self._asset = asset

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def start_time(self) -> "scout_run_api_UtcTimestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._end_time

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def links(self) -> List["scout_run_api_Link"]:
        return self._links

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        return self._run_prefix

    @builtins.property
    def data_sources(self) -> Dict[str, "scout_run_api_CreateRunDataSource"]:
        return self._data_sources

    @builtins.property
    def attachments(self) -> List[str]:
        return self._attachments

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset


scout_run_api_CreateRunRequest.__name__ = "CreateRunRequest"
scout_run_api_CreateRunRequest.__qualname__ = "CreateRunRequest"
scout_run_api_CreateRunRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_DataReviewAlertMetrics(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_review': ConjureFieldDefinition('pendingReview', int),
            'closed_with_ignore': ConjureFieldDefinition('closedWithIgnore', int),
            'closed_with_further_action': ConjureFieldDefinition('closedWithFurtherAction', int)
        }

    __slots__: List[str] = ['_pending_review', '_closed_with_ignore', '_closed_with_further_action']

    def __init__(self, closed_with_further_action: int, closed_with_ignore: int, pending_review: int) -> None:
        self._pending_review = pending_review
        self._closed_with_ignore = closed_with_ignore
        self._closed_with_further_action = closed_with_further_action

    @builtins.property
    def pending_review(self) -> int:
        return self._pending_review

    @builtins.property
    def closed_with_ignore(self) -> int:
        return self._closed_with_ignore

    @builtins.property
    def closed_with_further_action(self) -> int:
        return self._closed_with_further_action


scout_run_api_DataReviewAlertMetrics.__name__ = "DataReviewAlertMetrics"
scout_run_api_DataReviewAlertMetrics.__qualname__ = "DataReviewAlertMetrics"
scout_run_api_DataReviewAlertMetrics.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_DataReviewCheckMetrics(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_execution': ConjureFieldDefinition('pendingExecution', int),
            'executing': ConjureFieldDefinition('executing', int),
            'passing_automatic': ConjureFieldDefinition('passingAutomatic', int),
            'pending_review': ConjureFieldDefinition('pendingReview', int),
            'closed_with_ignore': ConjureFieldDefinition('closedWithIgnore', int),
            'closed_with_further_action': ConjureFieldDefinition('closedWithFurtherAction', int),
            'failed_to_execute_pending_review': ConjureFieldDefinition('failedToExecutePendingReview', int),
            'failed_to_execute_closed_with_ignore': ConjureFieldDefinition('failedToExecuteClosedWithIgnore', int),
            'failed_to_execute_closed_with_further_action': ConjureFieldDefinition('failedToExecuteClosedWithFurtherAction', int)
        }

    __slots__: List[str] = ['_pending_execution', '_executing', '_passing_automatic', '_pending_review', '_closed_with_ignore', '_closed_with_further_action', '_failed_to_execute_pending_review', '_failed_to_execute_closed_with_ignore', '_failed_to_execute_closed_with_further_action']

    def __init__(self, closed_with_further_action: int, closed_with_ignore: int, executing: int, failed_to_execute_closed_with_further_action: int, failed_to_execute_closed_with_ignore: int, failed_to_execute_pending_review: int, passing_automatic: int, pending_execution: int, pending_review: int) -> None:
        self._pending_execution = pending_execution
        self._executing = executing
        self._passing_automatic = passing_automatic
        self._pending_review = pending_review
        self._closed_with_ignore = closed_with_ignore
        self._closed_with_further_action = closed_with_further_action
        self._failed_to_execute_pending_review = failed_to_execute_pending_review
        self._failed_to_execute_closed_with_ignore = failed_to_execute_closed_with_ignore
        self._failed_to_execute_closed_with_further_action = failed_to_execute_closed_with_further_action

    @builtins.property
    def pending_execution(self) -> int:
        return self._pending_execution

    @builtins.property
    def executing(self) -> int:
        return self._executing

    @builtins.property
    def passing_automatic(self) -> int:
        return self._passing_automatic

    @builtins.property
    def pending_review(self) -> int:
        return self._pending_review

    @builtins.property
    def closed_with_ignore(self) -> int:
        return self._closed_with_ignore

    @builtins.property
    def closed_with_further_action(self) -> int:
        return self._closed_with_further_action

    @builtins.property
    def failed_to_execute_pending_review(self) -> int:
        return self._failed_to_execute_pending_review

    @builtins.property
    def failed_to_execute_closed_with_ignore(self) -> int:
        return self._failed_to_execute_closed_with_ignore

    @builtins.property
    def failed_to_execute_closed_with_further_action(self) -> int:
        return self._failed_to_execute_closed_with_further_action


scout_run_api_DataReviewCheckMetrics.__name__ = "DataReviewCheckMetrics"
scout_run_api_DataReviewCheckMetrics.__qualname__ = "DataReviewCheckMetrics"
scout_run_api_DataReviewCheckMetrics.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_DataReviewMetrics(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checks': ConjureFieldDefinition('checks', scout_run_api_DataReviewCheckMetrics),
            'alerts': ConjureFieldDefinition('alerts', scout_run_api_DataReviewAlertMetrics)
        }

    __slots__: List[str] = ['_checks', '_alerts']

    def __init__(self, alerts: "scout_run_api_DataReviewAlertMetrics", checks: "scout_run_api_DataReviewCheckMetrics") -> None:
        self._checks = checks
        self._alerts = alerts

    @builtins.property
    def checks(self) -> "scout_run_api_DataReviewCheckMetrics":
        return self._checks

    @builtins.property
    def alerts(self) -> "scout_run_api_DataReviewAlertMetrics":
        return self._alerts


scout_run_api_DataReviewMetrics.__name__ = "DataReviewMetrics"
scout_run_api_DataReviewMetrics.__qualname__ = "DataReviewMetrics"
scout_run_api_DataReviewMetrics.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_DataSource(ConjureUnionType):
    _dataset: Optional[str] = None
    _connection: Optional[str] = None
    _log_set: Optional[str] = None
    _video: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset': ConjureFieldDefinition('dataset', scout_run_api_DatasetRid),
            'connection': ConjureFieldDefinition('connection', scout_run_api_ConnectionRid),
            'log_set': ConjureFieldDefinition('logSet', scout_run_api_LogSetRid),
            'video': ConjureFieldDefinition('video', scout_run_api_VideoRid)
        }

    def __init__(
            self,
            dataset: Optional[str] = None,
            connection: Optional[str] = None,
            log_set: Optional[str] = None,
            video: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (dataset is not None) + (connection is not None) + (log_set is not None) + (video is not None) != 1:
                raise ValueError('a union must contain a single member')

            if dataset is not None:
                self._dataset = dataset
                self._type = 'dataset'
            if connection is not None:
                self._connection = connection
                self._type = 'connection'
            if log_set is not None:
                self._log_set = log_set
                self._type = 'logSet'
            if video is not None:
                self._video = video
                self._type = 'video'

        elif type_of_union == 'dataset':
            if dataset is None:
                raise ValueError('a union value must not be None')
            self._dataset = dataset
            self._type = 'dataset'
        elif type_of_union == 'connection':
            if connection is None:
                raise ValueError('a union value must not be None')
            self._connection = connection
            self._type = 'connection'
        elif type_of_union == 'logSet':
            if log_set is None:
                raise ValueError('a union value must not be None')
            self._log_set = log_set
            self._type = 'logSet'
        elif type_of_union == 'video':
            if video is None:
                raise ValueError('a union value must not be None')
            self._video = video
            self._type = 'video'

    @builtins.property
    def dataset(self) -> Optional[str]:
        return self._dataset

    @builtins.property
    def connection(self) -> Optional[str]:
        return self._connection

    @builtins.property
    def log_set(self) -> Optional[str]:
        return self._log_set

    @builtins.property
    def video(self) -> Optional[str]:
        return self._video

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_run_api_DataSourceVisitor):
            raise ValueError('{} is not an instance of scout_run_api_DataSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'dataset' and self.dataset is not None:
            return visitor._dataset(self.dataset)
        if self._type == 'connection' and self.connection is not None:
            return visitor._connection(self.connection)
        if self._type == 'logSet' and self.log_set is not None:
            return visitor._log_set(self.log_set)
        if self._type == 'video' and self.video is not None:
            return visitor._video(self.video)


scout_run_api_DataSource.__name__ = "DataSource"
scout_run_api_DataSource.__qualname__ = "DataSource"
scout_run_api_DataSource.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_DataSourceVisitor:

    @abstractmethod
    def _dataset(self, dataset: str) -> Any:
        pass

    @abstractmethod
    def _connection(self, connection: str) -> Any:
        pass

    @abstractmethod
    def _log_set(self, log_set: str) -> Any:
        pass

    @abstractmethod
    def _video(self, video: str) -> Any:
        pass


scout_run_api_DataSourceVisitor.__name__ = "DataSourceVisitor"
scout_run_api_DataSourceVisitor.__qualname__ = "DataSourceVisitor"
scout_run_api_DataSourceVisitor.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_DataSourceSeriesTag(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_TagName),
            'value': ConjureFieldDefinition('value', api_TagValue)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


scout_run_api_DataSourceSeriesTag.__name__ = "DataSourceSeriesTag"
scout_run_api_DataSourceSeriesTag.__qualname__ = "DataSourceSeriesTag"
scout_run_api_DataSourceSeriesTag.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_DataSourceType(ConjureEnumType):

    DATASET = 'DATASET'
    '''DATASET'''
    CONNECTION = 'CONNECTION'
    '''CONNECTION'''
    LOGSET = 'LOGSET'
    '''LOGSET'''
    VIDEO = 'VIDEO'
    '''VIDEO'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_DataSourceType.__name__ = "DataSourceType"
scout_run_api_DataSourceType.__qualname__ = "DataSourceType"
scout_run_api_DataSourceType.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_DeleteEventsFromRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'events': ConjureFieldDefinition('events', List[event_EventRid])
        }

    __slots__: List[str] = ['_events']

    def __init__(self, events: List[str]) -> None:
        self._events = events

    @builtins.property
    def events(self) -> List[str]:
        return self._events


scout_run_api_DeleteEventsFromRunRequest.__name__ = "DeleteEventsFromRunRequest"
scout_run_api_DeleteEventsFromRunRequest.__qualname__ = "DeleteEventsFromRunRequest"
scout_run_api_DeleteEventsFromRunRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_Duration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'seconds': ConjureFieldDefinition('seconds', int),
            'nanos': ConjureFieldDefinition('nanos', int),
            'picos': ConjureFieldDefinition('picos', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_seconds', '_nanos', '_picos']

    def __init__(self, nanos: int, seconds: int, picos: Optional[int] = None) -> None:
        self._seconds = seconds
        self._nanos = nanos
        self._picos = picos

    @builtins.property
    def seconds(self) -> int:
        return self._seconds

    @builtins.property
    def nanos(self) -> int:
        return self._nanos

    @builtins.property
    def picos(self) -> Optional[int]:
        return self._picos


scout_run_api_Duration.__name__ = "Duration"
scout_run_api_Duration.__qualname__ = "Duration"
scout_run_api_Duration.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_GetEventsForRunPage(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'events': ConjureFieldDefinition('events', List[event_EventRid]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_events', '_next_page_token']

    def __init__(self, events: List[str], next_page_token: Optional[str] = None) -> None:
        self._events = events
        self._next_page_token = next_page_token

    @builtins.property
    def events(self) -> List[str]:
        return self._events

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_GetEventsForRunPage.__name__ = "GetEventsForRunPage"
scout_run_api_GetEventsForRunPage.__qualname__ = "GetEventsForRunPage"
scout_run_api_GetEventsForRunPage.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_GetRunByIdRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_number': ConjureFieldDefinition('runNumber', int),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_run_number', '_run_prefix']

    def __init__(self, run_number: int, run_prefix: Optional[str] = None) -> None:
        self._run_number = run_number
        self._run_prefix = run_prefix

    @builtins.property
    def run_number(self) -> int:
        return self._run_number

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        return self._run_prefix


scout_run_api_GetRunByIdRequest.__name__ = "GetRunByIdRequest"
scout_run_api_GetRunByIdRequest.__qualname__ = "GetRunByIdRequest"
scout_run_api_GetRunByIdRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_GetRunsByAssetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset': ConjureFieldDefinition('asset', scout_rids_api_AssetRid),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_asset', '_next_page_token']

    def __init__(self, asset: str, next_page_token: Optional[str] = None) -> None:
        self._asset = asset
        self._next_page_token = next_page_token

    @builtins.property
    def asset(self) -> str:
        return self._asset

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_GetRunsByAssetRequest.__name__ = "GetRunsByAssetRequest"
scout_run_api_GetRunsByAssetRequest.__qualname__ = "GetRunsByAssetRequest"
scout_run_api_GetRunsByAssetRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_GetRunsByAssetResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_Run]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_Run"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_Run"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_GetRunsByAssetResponse.__name__ = "GetRunsByAssetResponse"
scout_run_api_GetRunsByAssetResponse.__qualname__ = "GetRunsByAssetResponse"
scout_run_api_GetRunsByAssetResponse.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_Link(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'url': ConjureFieldDefinition('url', str)
        }

    __slots__: List[str] = ['_title', '_url']

    def __init__(self, url: str, title: Optional[str] = None) -> None:
        self._title = title
        self._url = url

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def url(self) -> str:
        return self._url


scout_run_api_Link.__name__ = "Link"
scout_run_api_Link.__qualname__ = "Link"
scout_run_api_Link.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_Property(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_run_api_PropertyName),
            'value': ConjureFieldDefinition('value', scout_run_api_PropertyValue)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


scout_run_api_Property.__name__ = "Property"
scout_run_api_Property.__qualname__ = "Property"
scout_run_api_Property.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_PublishEventsToRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'events': ConjureFieldDefinition('events', List[event_EventRid])
        }

    __slots__: List[str] = ['_events']

    def __init__(self, events: List[str]) -> None:
        self._events = events

    @builtins.property
    def events(self) -> List[str]:
        return self._events


scout_run_api_PublishEventsToRunRequest.__name__ = "PublishEventsToRunRequest"
scout_run_api_PublishEventsToRunRequest.__qualname__ = "PublishEventsToRunRequest"
scout_run_api_PublishEventsToRunRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_RefNameAndType(ConjureBeanType):
    """
    Scoped to the org-level, intended to help the frontend
prevent users from submitting invalid ref names, ex.
using a `dataset` ref name for a `connection` data source
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_api_DataSourceRefName),
            'type': ConjureFieldDefinition('type', scout_run_api_DataSourceType)
        }

    __slots__: List[str] = ['_name', '_type']

    def __init__(self, name: str, type: "scout_run_api_DataSourceType") -> None:
        self._name = name
        self._type = type

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def type(self) -> "scout_run_api_DataSourceType":
        return self._type


scout_run_api_RefNameAndType.__name__ = "RefNameAndType"
scout_run_api_RefNameAndType.__qualname__ = "RefNameAndType"
scout_run_api_RefNameAndType.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_Run(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_run_api_RunRid),
            'run_number': ConjureFieldDefinition('runNumber', int),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str]),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'author_rid': ConjureFieldDefinition('authorRid', OptionalTypeWrapper[scout_rids_api_UserRid]),
            'start_time': ConjureFieldDefinition('startTime', scout_run_api_UtcTimestamp),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label]),
            'links': ConjureFieldDefinition('links', List[scout_run_api_Link]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', str),
            'data_sources': ConjureFieldDefinition('dataSources', Dict[scout_api_DataSourceRefName, scout_run_api_RunDataSource]),
            'attachments': ConjureFieldDefinition('attachments', List[scout_rids_api_AttachmentRid]),
            'asset': ConjureFieldDefinition('asset', OptionalTypeWrapper[scout_rids_api_AssetRid])
        }

    __slots__: List[str] = ['_rid', '_run_number', '_run_prefix', '_title', '_description', '_author_rid', '_start_time', '_end_time', '_properties', '_labels', '_links', '_created_at', '_updated_at', '_data_sources', '_attachments', '_asset']

    def __init__(self, attachments: List[str], created_at: str, data_sources: Dict[str, "scout_run_api_RunDataSource"], description: str, labels: List[str], links: List["scout_run_api_Link"], properties: Dict[str, str], rid: str, run_number: int, start_time: "scout_run_api_UtcTimestamp", title: str, updated_at: str, asset: Optional[str] = None, author_rid: Optional[str] = None, end_time: Optional["scout_run_api_UtcTimestamp"] = None, run_prefix: Optional[str] = None) -> None:
        self._rid = rid
        self._run_number = run_number
        self._run_prefix = run_prefix
        self._title = title
        self._description = description
        self._author_rid = author_rid
        self._start_time = start_time
        self._end_time = end_time
        self._properties = properties
        self._labels = labels
        self._links = links
        self._created_at = created_at
        self._updated_at = updated_at
        self._data_sources = data_sources
        self._attachments = attachments
        self._asset = asset

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def run_number(self) -> int:
        return self._run_number

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        return self._run_prefix

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def author_rid(self) -> Optional[str]:
        return self._author_rid

    @builtins.property
    def start_time(self) -> "scout_run_api_UtcTimestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._end_time

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def links(self) -> List["scout_run_api_Link"]:
        return self._links

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at

    @builtins.property
    def data_sources(self) -> Dict[str, "scout_run_api_RunDataSource"]:
        return self._data_sources

    @builtins.property
    def attachments(self) -> List[str]:
        return self._attachments

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset


scout_run_api_Run.__name__ = "Run"
scout_run_api_Run.__qualname__ = "Run"
scout_run_api_Run.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_RunDataReviewEvaluationStatus(ConjureEnumType):

    NO_CHECKS_APPLIED = 'NO_CHECKS_APPLIED'
    '''NO_CHECKS_APPLIED'''
    FAILED_TO_EXECUTE = 'FAILED_TO_EXECUTE'
    '''FAILED_TO_EXECUTE'''
    EXECUTING = 'EXECUTING'
    '''EXECUTING'''
    PENDING_EXECUTION = 'PENDING_EXECUTION'
    '''PENDING_EXECUTION'''
    CLOSED_WITH_FURTHER_ACTION = 'CLOSED_WITH_FURTHER_ACTION'
    '''CLOSED_WITH_FURTHER_ACTION'''
    GENERATED_ALERTS = 'GENERATED_ALERTS'
    '''GENERATED_ALERTS'''
    CLOSED_WITH_IGNORE = 'CLOSED_WITH_IGNORE'
    '''CLOSED_WITH_IGNORE'''
    PASSING = 'PASSING'
    '''PASSING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_RunDataReviewEvaluationStatus.__name__ = "RunDataReviewEvaluationStatus"
scout_run_api_RunDataReviewEvaluationStatus.__qualname__ = "RunDataReviewEvaluationStatus"
scout_run_api_RunDataReviewEvaluationStatus.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_RunDataReviewSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'evaluation_status': ConjureFieldDefinition('evaluationStatus', scout_run_api_RunDataReviewEvaluationStatus),
            'total_issue_count': ConjureFieldDefinition('totalIssueCount', int),
            'reviewed_issue_count': ConjureFieldDefinition('reviewedIssueCount', int),
            'issues_with_further_action_count': ConjureFieldDefinition('issuesWithFurtherActionCount', int),
            'execution_error_count': ConjureFieldDefinition('executionErrorCount', int)
        }

    __slots__: List[str] = ['_evaluation_status', '_total_issue_count', '_reviewed_issue_count', '_issues_with_further_action_count', '_execution_error_count']

    def __init__(self, evaluation_status: "scout_run_api_RunDataReviewEvaluationStatus", execution_error_count: int, issues_with_further_action_count: int, reviewed_issue_count: int, total_issue_count: int) -> None:
        self._evaluation_status = evaluation_status
        self._total_issue_count = total_issue_count
        self._reviewed_issue_count = reviewed_issue_count
        self._issues_with_further_action_count = issues_with_further_action_count
        self._execution_error_count = execution_error_count

    @builtins.property
    def evaluation_status(self) -> "scout_run_api_RunDataReviewEvaluationStatus":
        return self._evaluation_status

    @builtins.property
    def total_issue_count(self) -> int:
        return self._total_issue_count

    @builtins.property
    def reviewed_issue_count(self) -> int:
        return self._reviewed_issue_count

    @builtins.property
    def issues_with_further_action_count(self) -> int:
        return self._issues_with_further_action_count

    @builtins.property
    def execution_error_count(self) -> int:
        return self._execution_error_count


scout_run_api_RunDataReviewSummary.__name__ = "RunDataReviewSummary"
scout_run_api_RunDataReviewSummary.__qualname__ = "RunDataReviewSummary"
scout_run_api_RunDataReviewSummary.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_RunDataSource(ConjureBeanType):
    """
    For read requests, we want to require all fields
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'offset': ConjureFieldDefinition('offset', scout_run_api_Duration),
            'ref_name': ConjureFieldDefinition('refName', scout_api_DataSourceRefName),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_run_api_WeakTimestampType),
            'series_tags': ConjureFieldDefinition('seriesTags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_source', '_offset', '_ref_name', '_timestamp_type', '_series_tags']

    def __init__(self, data_source: "scout_run_api_DataSource", offset: "scout_run_api_Duration", ref_name: str, series_tags: Dict[str, str], timestamp_type: "scout_run_api_WeakTimestampType") -> None:
        self._data_source = data_source
        self._offset = offset
        self._ref_name = ref_name
        self._timestamp_type = timestamp_type
        self._series_tags = series_tags

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def offset(self) -> "scout_run_api_Duration":
        """
        This offset is used for small time-sync corrections. Notably, it is
not the offset to move a relative data source to the start of the run.
        """
        return self._offset

    @builtins.property
    def ref_name(self) -> str:
        """
        Included for convenience, duplicated from the key of the map
        """
        return self._ref_name

    @builtins.property
    def timestamp_type(self) -> "scout_run_api_WeakTimestampType":
        return self._timestamp_type

    @builtins.property
    def series_tags(self) -> Dict[str, str]:
        """
        Used to resolve logical series for this data source.
        """
        return self._series_tags


scout_run_api_RunDataSource.__name__ = "RunDataSource"
scout_run_api_RunDataSource.__qualname__ = "RunDataSource"
scout_run_api_RunDataSource.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_RunWithDataReviewMetrics(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run': ConjureFieldDefinition('run', scout_run_api_Run),
            'data_review_metrics': ConjureFieldDefinition('dataReviewMetrics', scout_run_api_DataReviewMetrics)
        }

    __slots__: List[str] = ['_run', '_data_review_metrics']

    def __init__(self, data_review_metrics: "scout_run_api_DataReviewMetrics", run: "scout_run_api_Run") -> None:
        self._run = run
        self._data_review_metrics = data_review_metrics

    @builtins.property
    def run(self) -> "scout_run_api_Run":
        return self._run

    @builtins.property
    def data_review_metrics(self) -> "scout_run_api_DataReviewMetrics":
        return self._data_review_metrics


scout_run_api_RunWithDataReviewMetrics.__name__ = "RunWithDataReviewMetrics"
scout_run_api_RunWithDataReviewMetrics.__qualname__ = "RunWithDataReviewMetrics"
scout_run_api_RunWithDataReviewMetrics.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_RunWithDataReviewSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run': ConjureFieldDefinition('run', scout_run_api_Run),
            'data_review_summary': ConjureFieldDefinition('dataReviewSummary', scout_run_api_RunDataReviewSummary)
        }

    __slots__: List[str] = ['_run', '_data_review_summary']

    def __init__(self, data_review_summary: "scout_run_api_RunDataReviewSummary", run: "scout_run_api_Run") -> None:
        self._run = run
        self._data_review_summary = data_review_summary

    @builtins.property
    def run(self) -> "scout_run_api_Run":
        return self._run

    @builtins.property
    def data_review_summary(self) -> "scout_run_api_RunDataReviewSummary":
        return self._data_review_summary


scout_run_api_RunWithDataReviewSummary.__name__ = "RunWithDataReviewSummary"
scout_run_api_RunWithDataReviewSummary.__qualname__ = "RunWithDataReviewSummary"
scout_run_api_RunWithDataReviewSummary.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SearchQuery(ConjureUnionType):
    _start_time_inclusive: Optional["scout_run_api_UtcTimestamp"] = None
    _end_time_inclusive: Optional["scout_run_api_UtcTimestamp"] = None
    _exact_match: Optional[str] = None
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["scout_run_api_Property"] = None
    _data_source_series_tag: Optional["scout_run_api_DataSourceSeriesTag"] = None
    _data_source_ref_name: Optional[str] = None
    _data_source: Optional["scout_run_api_DataSource"] = None
    _and_: Optional[List["scout_run_api_SearchQuery"]] = None
    _or_: Optional[List["scout_run_api_SearchQuery"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time_inclusive': ConjureFieldDefinition('startTimeInclusive', scout_run_api_UtcTimestamp),
            'end_time_inclusive': ConjureFieldDefinition('endTimeInclusive', scout_run_api_UtcTimestamp),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', scout_run_api_Label),
            'property': ConjureFieldDefinition('property', scout_run_api_Property),
            'data_source_series_tag': ConjureFieldDefinition('dataSourceSeriesTag', scout_run_api_DataSourceSeriesTag),
            'data_source_ref_name': ConjureFieldDefinition('dataSourceRefName', scout_api_DataSourceRefName),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'and_': ConjureFieldDefinition('and', List[scout_run_api_SearchQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_run_api_SearchQuery])
        }

    def __init__(
            self,
            start_time_inclusive: Optional["scout_run_api_UtcTimestamp"] = None,
            end_time_inclusive: Optional["scout_run_api_UtcTimestamp"] = None,
            exact_match: Optional[str] = None,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["scout_run_api_Property"] = None,
            data_source_series_tag: Optional["scout_run_api_DataSourceSeriesTag"] = None,
            data_source_ref_name: Optional[str] = None,
            data_source: Optional["scout_run_api_DataSource"] = None,
            and_: Optional[List["scout_run_api_SearchQuery"]] = None,
            or_: Optional[List["scout_run_api_SearchQuery"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (start_time_inclusive is not None) + (end_time_inclusive is not None) + (exact_match is not None) + (search_text is not None) + (label is not None) + (property is not None) + (data_source_series_tag is not None) + (data_source_ref_name is not None) + (data_source is not None) + (and_ is not None) + (or_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if start_time_inclusive is not None:
                self._start_time_inclusive = start_time_inclusive
                self._type = 'startTimeInclusive'
            if end_time_inclusive is not None:
                self._end_time_inclusive = end_time_inclusive
                self._type = 'endTimeInclusive'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if data_source_series_tag is not None:
                self._data_source_series_tag = data_source_series_tag
                self._type = 'dataSourceSeriesTag'
            if data_source_ref_name is not None:
                self._data_source_ref_name = data_source_ref_name
                self._type = 'dataSourceRefName'
            if data_source is not None:
                self._data_source = data_source
                self._type = 'dataSource'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'

        elif type_of_union == 'startTimeInclusive':
            if start_time_inclusive is None:
                raise ValueError('a union value must not be None')
            self._start_time_inclusive = start_time_inclusive
            self._type = 'startTimeInclusive'
        elif type_of_union == 'endTimeInclusive':
            if end_time_inclusive is None:
                raise ValueError('a union value must not be None')
            self._end_time_inclusive = end_time_inclusive
            self._type = 'endTimeInclusive'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'dataSourceSeriesTag':
            if data_source_series_tag is None:
                raise ValueError('a union value must not be None')
            self._data_source_series_tag = data_source_series_tag
            self._type = 'dataSourceSeriesTag'
        elif type_of_union == 'dataSourceRefName':
            if data_source_ref_name is None:
                raise ValueError('a union value must not be None')
            self._data_source_ref_name = data_source_ref_name
            self._type = 'dataSourceRefName'
        elif type_of_union == 'dataSource':
            if data_source is None:
                raise ValueError('a union value must not be None')
            self._data_source = data_source
            self._type = 'dataSource'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'

    @builtins.property
    def start_time_inclusive(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._start_time_inclusive

    @builtins.property
    def end_time_inclusive(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._end_time_inclusive

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """
        Performs case insensitive exact match search on the title.
        """
        return self._exact_match

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["scout_run_api_Property"]:
        return self._property

    @builtins.property
    def data_source_series_tag(self) -> Optional["scout_run_api_DataSourceSeriesTag"]:
        return self._data_source_series_tag

    @builtins.property
    def data_source_ref_name(self) -> Optional[str]:
        return self._data_source_ref_name

    @builtins.property
    def data_source(self) -> Optional["scout_run_api_DataSource"]:
        return self._data_source

    @builtins.property
    def and_(self) -> Optional[List["scout_run_api_SearchQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_run_api_SearchQuery"]]:
        return self._or_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_run_api_SearchQueryVisitor):
            raise ValueError('{} is not an instance of scout_run_api_SearchQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'startTimeInclusive' and self.start_time_inclusive is not None:
            return visitor._start_time_inclusive(self.start_time_inclusive)
        if self._type == 'endTimeInclusive' and self.end_time_inclusive is not None:
            return visitor._end_time_inclusive(self.end_time_inclusive)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'dataSourceSeriesTag' and self.data_source_series_tag is not None:
            return visitor._data_source_series_tag(self.data_source_series_tag)
        if self._type == 'dataSourceRefName' and self.data_source_ref_name is not None:
            return visitor._data_source_ref_name(self.data_source_ref_name)
        if self._type == 'dataSource' and self.data_source is not None:
            return visitor._data_source(self.data_source)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)


scout_run_api_SearchQuery.__name__ = "SearchQuery"
scout_run_api_SearchQuery.__qualname__ = "SearchQuery"
scout_run_api_SearchQuery.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SearchQueryVisitor:

    @abstractmethod
    def _start_time_inclusive(self, start_time_inclusive: "scout_run_api_UtcTimestamp") -> Any:
        pass

    @abstractmethod
    def _end_time_inclusive(self, end_time_inclusive: "scout_run_api_UtcTimestamp") -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_run_api_Property") -> Any:
        pass

    @abstractmethod
    def _data_source_series_tag(self, data_source_series_tag: "scout_run_api_DataSourceSeriesTag") -> Any:
        pass

    @abstractmethod
    def _data_source_ref_name(self, data_source_ref_name: str) -> Any:
        pass

    @abstractmethod
    def _data_source(self, data_source: "scout_run_api_DataSource") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_run_api_SearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_run_api_SearchQuery"]) -> Any:
        pass


scout_run_api_SearchQueryVisitor.__name__ = "SearchQueryVisitor"
scout_run_api_SearchQueryVisitor.__qualname__ = "SearchQueryVisitor"
scout_run_api_SearchQueryVisitor.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SearchRunChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'ref_name_filter': ConjureFieldDefinition('refNameFilter', OptionalTypeWrapper[List[scout_api_DataSourceRefName]]),
            'previously_selected_channels': ConjureFieldDefinition('previouslySelectedChannels', Dict[scout_api_DataSourceRefName, List[scout_api_Channel]]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_search_text', '_ref_name_filter', '_previously_selected_channels', '_next_page_token', '_page_size']

    def __init__(self, previously_selected_channels: Dict[str, List[str]], search_text: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, ref_name_filter: Optional[List[str]] = None) -> None:
        self._search_text = search_text
        self._ref_name_filter = ref_name_filter
        self._previously_selected_channels = previously_selected_channels
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def search_text(self) -> str:
        return self._search_text

    @builtins.property
    def ref_name_filter(self) -> Optional[List[str]]:
        """
        If not empty, will filter to channels from the selected DataSourceRefNames.
        """
        return self._ref_name_filter

    @builtins.property
    def previously_selected_channels(self) -> Dict[str, List[str]]:
        return self._previously_selected_channels

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 1000. Will throw if larger than 10000.
        """
        return self._page_size


scout_run_api_SearchRunChannelsRequest.__name__ = "SearchRunChannelsRequest"
scout_run_api_SearchRunChannelsRequest.__qualname__ = "SearchRunChannelsRequest"
scout_run_api_SearchRunChannelsRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SearchRunChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_ChannelMetadata]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_ChannelMetadata"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_ChannelMetadata"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_SearchRunChannelsResponse.__name__ = "SearchRunChannelsResponse"
scout_run_api_SearchRunChannelsResponse.__qualname__ = "SearchRunChannelsResponse"
scout_run_api_SearchRunChannelsResponse.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SearchRunsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', scout_run_api_SortOptions),
            'page_size': ConjureFieldDefinition('pageSize', int),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'query': ConjureFieldDefinition('query', scout_run_api_SearchQuery)
        }

    __slots__: List[str] = ['_sort', '_page_size', '_next_page_token', '_query']

    def __init__(self, page_size: int, query: "scout_run_api_SearchQuery", sort: "scout_run_api_SortOptions", next_page_token: Optional[str] = None) -> None:
        self._sort = sort
        self._page_size = page_size
        self._next_page_token = next_page_token
        self._query = query

    @builtins.property
    def sort(self) -> "scout_run_api_SortOptions":
        return self._sort

    @builtins.property
    def page_size(self) -> int:
        """
        Will reject page sizes greater than 10k.
        """
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def query(self) -> "scout_run_api_SearchQuery":
        return self._query


scout_run_api_SearchRunsRequest.__name__ = "SearchRunsRequest"
scout_run_api_SearchRunsRequest.__qualname__ = "SearchRunsRequest"
scout_run_api_SearchRunsRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SearchRunsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_Run]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_Run"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_Run"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_SearchRunsResponse.__name__ = "SearchRunsResponse"
scout_run_api_SearchRunsResponse.__qualname__ = "SearchRunsResponse"
scout_run_api_SearchRunsResponse.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SearchRunsWithDataReviewMetricsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_RunWithDataReviewMetrics]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_RunWithDataReviewMetrics"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_RunWithDataReviewMetrics"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_SearchRunsWithDataReviewMetricsResponse.__name__ = "SearchRunsWithDataReviewMetricsResponse"
scout_run_api_SearchRunsWithDataReviewMetricsResponse.__qualname__ = "SearchRunsWithDataReviewMetricsResponse"
scout_run_api_SearchRunsWithDataReviewMetricsResponse.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SearchRunsWithDataReviewSummaryResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_RunWithDataReviewSummary]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_RunWithDataReviewSummary"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_RunWithDataReviewSummary"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_SearchRunsWithDataReviewSummaryResponse.__name__ = "SearchRunsWithDataReviewSummaryResponse"
scout_run_api_SearchRunsWithDataReviewSummaryResponse.__qualname__ = "SearchRunsWithDataReviewSummaryResponse"
scout_run_api_SearchRunsWithDataReviewSummaryResponse.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SeriesDataType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_SeriesDataType.__name__ = "SeriesDataType"
scout_run_api_SeriesDataType.__qualname__ = "SeriesDataType"
scout_run_api_SeriesDataType.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SortField(ConjureEnumType):

    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    START_TIME = 'START_TIME'
    '''START_TIME'''
    END_TIME = 'END_TIME'
    '''END_TIME'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_SortField.__name__ = "SortField"
scout_run_api_SortField.__qualname__ = "SortField"
scout_run_api_SortField.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_run_api_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_run_api_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_run_api_SortField":
        return self._field


scout_run_api_SortOptions.__name__ = "SortOptions"
scout_run_api_SortOptions.__qualname__ = "SortOptions"
scout_run_api_SortOptions.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_Unit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'symbol': ConjureFieldDefinition('symbol', str)
        }

    __slots__: List[str] = ['_name', '_symbol']

    def __init__(self, name: str, symbol: str) -> None:
        self._name = name
        self._symbol = symbol

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def symbol(self) -> str:
        return self._symbol


scout_run_api_Unit.__name__ = "Unit"
scout_run_api_Unit.__qualname__ = "Unit"
scout_run_api_Unit.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_UpdateAttachmentsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'attachments_to_add': ConjureFieldDefinition('attachmentsToAdd', List[scout_rids_api_AttachmentRid]),
            'attachments_to_remove': ConjureFieldDefinition('attachmentsToRemove', List[scout_rids_api_AttachmentRid])
        }

    __slots__: List[str] = ['_attachments_to_add', '_attachments_to_remove']

    def __init__(self, attachments_to_add: List[str], attachments_to_remove: List[str]) -> None:
        self._attachments_to_add = attachments_to_add
        self._attachments_to_remove = attachments_to_remove

    @builtins.property
    def attachments_to_add(self) -> List[str]:
        return self._attachments_to_add

    @builtins.property
    def attachments_to_remove(self) -> List[str]:
        return self._attachments_to_remove


scout_run_api_UpdateAttachmentsRequest.__name__ = "UpdateAttachmentsRequest"
scout_run_api_UpdateAttachmentsRequest.__qualname__ = "UpdateAttachmentsRequest"
scout_run_api_UpdateAttachmentsRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_UpdateRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[scout_run_api_Label]]),
            'links': ConjureFieldDefinition('links', OptionalTypeWrapper[List[scout_run_api_Link]]),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str]),
            'data_sources': ConjureFieldDefinition('dataSources', OptionalTypeWrapper[Dict[scout_api_DataSourceRefName, scout_run_api_CreateRunDataSource]]),
            'attachments': ConjureFieldDefinition('attachments', OptionalTypeWrapper[List[scout_rids_api_AttachmentRid]]),
            'asset': ConjureFieldDefinition('asset', OptionalTypeWrapper[scout_rids_api_AssetRid])
        }

    __slots__: List[str] = ['_title', '_description', '_start_time', '_end_time', '_properties', '_labels', '_links', '_run_prefix', '_data_sources', '_attachments', '_asset']

    def __init__(self, asset: Optional[str] = None, attachments: Optional[List[str]] = None, data_sources: Optional[Dict[str, "scout_run_api_CreateRunDataSource"]] = None, description: Optional[str] = None, end_time: Optional["scout_run_api_UtcTimestamp"] = None, labels: Optional[List[str]] = None, links: Optional[List["scout_run_api_Link"]] = None, properties: Optional[Dict[str, str]] = None, run_prefix: Optional[str] = None, start_time: Optional["scout_run_api_UtcTimestamp"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._start_time = start_time
        self._end_time = end_time
        self._properties = properties
        self._labels = labels
        self._links = links
        self._run_prefix = run_prefix
        self._data_sources = data_sources
        self._attachments = attachments
        self._asset = asset

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def start_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._end_time

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def links(self) -> Optional[List["scout_run_api_Link"]]:
        return self._links

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        return self._run_prefix

    @builtins.property
    def data_sources(self) -> Optional[Dict[str, "scout_run_api_CreateRunDataSource"]]:
        return self._data_sources

    @builtins.property
    def attachments(self) -> Optional[List[str]]:
        return self._attachments

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset


scout_run_api_UpdateRunRequest.__name__ = "UpdateRunRequest"
scout_run_api_UpdateRunRequest.__qualname__ = "UpdateRunRequest"
scout_run_api_UpdateRunRequest.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_UtcTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'seconds_since_epoch': ConjureFieldDefinition('secondsSinceEpoch', int),
            'offset_nanoseconds': ConjureFieldDefinition('offsetNanoseconds', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_seconds_since_epoch', '_offset_nanoseconds']

    def __init__(self, seconds_since_epoch: int, offset_nanoseconds: Optional[int] = None) -> None:
        self._seconds_since_epoch = seconds_since_epoch
        self._offset_nanoseconds = offset_nanoseconds

    @builtins.property
    def seconds_since_epoch(self) -> int:
        return self._seconds_since_epoch

    @builtins.property
    def offset_nanoseconds(self) -> Optional[int]:
        return self._offset_nanoseconds


scout_run_api_UtcTimestamp.__name__ = "UtcTimestamp"
scout_run_api_UtcTimestamp.__qualname__ = "UtcTimestamp"
scout_run_api_UtcTimestamp.__module__ = "scout_service_api.scout_run_api"


class scout_run_api_WeakTimestampType(ConjureEnumType):
    """
    If a CSV data source is still being split, the timestamp type is not known.
    """

    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    PENDING = 'PENDING'
    '''PENDING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_WeakTimestampType.__name__ = "WeakTimestampType"
scout_run_api_WeakTimestampType.__qualname__ = "WeakTimestampType"
scout_run_api_WeakTimestampType.__module__ = "scout_service_api.scout_run_api"


class scout_template_api_CommitTemplateRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'charts': ConjureFieldDefinition('charts', List[scout_rids_api_VersionedChartRid]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', scout_workbookcommon_api_WorkbookContent),
            'message': ConjureFieldDefinition('message', str),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_charts', '_layout', '_content', '_message', '_latest_commit']

    def __init__(self, charts: List["scout_rids_api_VersionedChartRid"], content: "scout_workbookcommon_api_WorkbookContent", layout: "scout_layout_api_WorkbookLayout", message: str, latest_commit: Optional[str] = None) -> None:
        self._charts = charts
        self._layout = layout
        self._content = content
        self._message = message
        self._latest_commit = latest_commit

    @builtins.property
    def charts(self) -> List["scout_rids_api_VersionedChartRid"]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> "scout_workbookcommon_api_WorkbookContent":
        return self._content

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        """
        If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit


scout_template_api_CommitTemplateRequest.__name__ = "CommitTemplateRequest"
scout_template_api_CommitTemplateRequest.__qualname__ = "CommitTemplateRequest"
scout_template_api_CommitTemplateRequest.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_CreateTemplateRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]),
            'is_published': ConjureFieldDefinition('isPublished', OptionalTypeWrapper[bool]),
            'charts': ConjureFieldDefinition('charts', List[scout_rids_api_VersionedChartRid]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', scout_workbookcommon_api_WorkbookContent),
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_is_published', '_charts', '_layout', '_content', '_message']

    def __init__(self, charts: List["scout_rids_api_VersionedChartRid"], content: "scout_workbookcommon_api_WorkbookContent", description: str, labels: List[str], layout: "scout_layout_api_WorkbookLayout", message: str, properties: Dict[str, str], title: str, is_published: Optional[bool] = None) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._is_published = is_published
        self._charts = charts
        self._layout = layout
        self._content = content
        self._message = message

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def is_published(self) -> Optional[bool]:
        """
        Default is true
        """
        return self._is_published

    @builtins.property
    def charts(self) -> List["scout_rids_api_VersionedChartRid"]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> "scout_workbookcommon_api_WorkbookContent":
        return self._content

    @builtins.property
    def message(self) -> str:
        return self._message


scout_template_api_CreateTemplateRequest.__name__ = "CreateTemplateRequest"
scout_template_api_CreateTemplateRequest.__qualname__ = "CreateTemplateRequest"
scout_template_api_CreateTemplateRequest.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_GetAllLabelsAndPropertiesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, List[scout_run_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_template_api_GetAllLabelsAndPropertiesResponse.__name__ = "GetAllLabelsAndPropertiesResponse"
scout_template_api_GetAllLabelsAndPropertiesResponse.__qualname__ = "GetAllLabelsAndPropertiesResponse"
scout_template_api_GetAllLabelsAndPropertiesResponse.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_MergeToMainRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'branch_name': ConjureFieldDefinition('branchName', scout_versioning_api_BranchName),
            'message': ConjureFieldDefinition('message', str),
            'latest_commit_on_main': ConjureFieldDefinition('latestCommitOnMain', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_branch_name', '_message', '_latest_commit_on_main']

    def __init__(self, branch_name: str, message: str, latest_commit_on_main: Optional[str] = None) -> None:
        self._branch_name = branch_name
        self._message = message
        self._latest_commit_on_main = latest_commit_on_main

    @builtins.property
    def branch_name(self) -> str:
        """
        If "main", the request will throw.
        """
        return self._branch_name

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def latest_commit_on_main(self) -> Optional[str]:
        """
        If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit_on_main


scout_template_api_MergeToMainRequest.__name__ = "MergeToMainRequest"
scout_template_api_MergeToMainRequest.__qualname__ = "MergeToMainRequest"
scout_template_api_MergeToMainRequest.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_SaveTemplateRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'charts': ConjureFieldDefinition('charts', List[scout_rids_api_VersionedChartRid]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', scout_workbookcommon_api_WorkbookContent),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_charts', '_layout', '_content', '_latest_commit']

    def __init__(self, charts: List["scout_rids_api_VersionedChartRid"], content: "scout_workbookcommon_api_WorkbookContent", layout: "scout_layout_api_WorkbookLayout", latest_commit: Optional[str] = None) -> None:
        self._charts = charts
        self._layout = layout
        self._content = content
        self._latest_commit = latest_commit

    @builtins.property
    def charts(self) -> List["scout_rids_api_VersionedChartRid"]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> "scout_workbookcommon_api_WorkbookContent":
        return self._content

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        """
        If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit


scout_template_api_SaveTemplateRequest.__name__ = "SaveTemplateRequest"
scout_template_api_SaveTemplateRequest.__qualname__ = "SaveTemplateRequest"
scout_template_api_SaveTemplateRequest.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_SearchTemplatesQuery(ConjureUnionType):
    _and_: Optional[List["scout_template_api_SearchTemplatesQuery"]] = None
    _or_: Optional[List["scout_template_api_SearchTemplatesQuery"]] = None
    _exact_match: Optional[str] = None
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["scout_run_api_Property"] = None
    _created_by: Optional[str] = None
    _is_archived: Optional[bool] = None
    _is_published: Optional[bool] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', List[scout_template_api_SearchTemplatesQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_template_api_SearchTemplatesQuery]),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', scout_run_api_Label),
            'property': ConjureFieldDefinition('property', scout_run_api_Property),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'is_published': ConjureFieldDefinition('isPublished', bool)
        }

    def __init__(
            self,
            and_: Optional[List["scout_template_api_SearchTemplatesQuery"]] = None,
            or_: Optional[List["scout_template_api_SearchTemplatesQuery"]] = None,
            exact_match: Optional[str] = None,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["scout_run_api_Property"] = None,
            created_by: Optional[str] = None,
            is_archived: Optional[bool] = None,
            is_published: Optional[bool] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (exact_match is not None) + (search_text is not None) + (label is not None) + (property is not None) + (created_by is not None) + (is_archived is not None) + (is_published is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if created_by is not None:
                self._created_by = created_by
                self._type = 'createdBy'
            if is_archived is not None:
                self._is_archived = is_archived
                self._type = 'isArchived'
            if is_published is not None:
                self._is_published = is_published
                self._type = 'isPublished'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'createdBy':
            if created_by is None:
                raise ValueError('a union value must not be None')
            self._created_by = created_by
            self._type = 'createdBy'
        elif type_of_union == 'isArchived':
            if is_archived is None:
                raise ValueError('a union value must not be None')
            self._is_archived = is_archived
            self._type = 'isArchived'
        elif type_of_union == 'isPublished':
            if is_published is None:
                raise ValueError('a union value must not be None')
            self._is_published = is_published
            self._type = 'isPublished'

    @builtins.property
    def and_(self) -> Optional[List["scout_template_api_SearchTemplatesQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_template_api_SearchTemplatesQuery"]]:
        return self._or_

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """
        Performs case insensitive exact match search on the title.
        """
        return self._exact_match

    @builtins.property
    def search_text(self) -> Optional[str]:
        """
        Searches title and description only
        """
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["scout_run_api_Property"]:
        return self._property

    @builtins.property
    def created_by(self) -> Optional[str]:
        return self._created_by

    @builtins.property
    def is_archived(self) -> Optional[bool]:
        return self._is_archived

    @builtins.property
    def is_published(self) -> Optional[bool]:
        return self._is_published

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_template_api_SearchTemplatesQueryVisitor):
            raise ValueError('{} is not an instance of scout_template_api_SearchTemplatesQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'createdBy' and self.created_by is not None:
            return visitor._created_by(self.created_by)
        if self._type == 'isArchived' and self.is_archived is not None:
            return visitor._is_archived(self.is_archived)
        if self._type == 'isPublished' and self.is_published is not None:
            return visitor._is_published(self.is_published)


scout_template_api_SearchTemplatesQuery.__name__ = "SearchTemplatesQuery"
scout_template_api_SearchTemplatesQuery.__qualname__ = "SearchTemplatesQuery"
scout_template_api_SearchTemplatesQuery.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_SearchTemplatesQueryVisitor:

    @abstractmethod
    def _and(self, and_: List["scout_template_api_SearchTemplatesQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_template_api_SearchTemplatesQuery"]) -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_run_api_Property") -> Any:
        pass

    @abstractmethod
    def _created_by(self, created_by: str) -> Any:
        pass

    @abstractmethod
    def _is_archived(self, is_archived: bool) -> Any:
        pass

    @abstractmethod
    def _is_published(self, is_published: bool) -> Any:
        pass


scout_template_api_SearchTemplatesQueryVisitor.__name__ = "SearchTemplatesQueryVisitor"
scout_template_api_SearchTemplatesQueryVisitor.__qualname__ = "SearchTemplatesQueryVisitor"
scout_template_api_SearchTemplatesQueryVisitor.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_SearchTemplatesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_template_api_SearchTemplatesQuery),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[scout_template_api_SortBy]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_query', '_sort_by', '_next_page_token', '_page_size']

    def __init__(self, query: "scout_template_api_SearchTemplatesQuery", next_page_token: Optional[str] = None, page_size: Optional[int] = None, sort_by: Optional["scout_template_api_SortBy"] = None) -> None:
        self._query = query
        self._sort_by = sort_by
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def query(self) -> "scout_template_api_SearchTemplatesQuery":
        return self._query

    @builtins.property
    def sort_by(self) -> Optional["scout_template_api_SortBy"]:
        """
        EDITED_AT descending by default
        """
        return self._sort_by

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size


scout_template_api_SearchTemplatesRequest.__name__ = "SearchTemplatesRequest"
scout_template_api_SearchTemplatesRequest.__qualname__ = "SearchTemplatesRequest"
scout_template_api_SearchTemplatesRequest.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_SearchTemplatesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_template_api_TemplateSummary]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_template_api_TemplateSummary"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_template_api_TemplateSummary"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_template_api_SearchTemplatesResponse.__name__ = "SearchTemplatesResponse"
scout_template_api_SearchTemplatesResponse.__qualname__ = "SearchTemplatesResponse"
scout_template_api_SearchTemplatesResponse.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_SortBy(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_template_api_SortByField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_template_api_SortByField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_template_api_SortByField":
        return self._field


scout_template_api_SortBy.__name__ = "SortBy"
scout_template_api_SortBy.__qualname__ = "SortBy"
scout_template_api_SortBy.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_SortByField(ConjureEnumType):
    """
    UPDATED_AT is an alias for EDITED_AT.
    """

    NAME = 'NAME'
    '''NAME'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UPDATED_AT = 'UPDATED_AT'
    '''UPDATED_AT'''
    EDITED_AT = 'EDITED_AT'
    '''EDITED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_template_api_SortByField.__name__ = "SortByField"
scout_template_api_SortByField.__qualname__ = "SortByField"
scout_template_api_SortByField.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_Template(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_TemplateRid),
            'metadata': ConjureFieldDefinition('metadata', scout_template_api_TemplateMetadata),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_Commit),
            'charts': ConjureFieldDefinition('charts', List[scout_rids_api_VersionedChartRid]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', scout_workbookcommon_api_WorkbookContent)
        }

    __slots__: List[str] = ['_rid', '_metadata', '_commit', '_charts', '_layout', '_content']

    def __init__(self, charts: List["scout_rids_api_VersionedChartRid"], commit: "scout_versioning_api_Commit", content: "scout_workbookcommon_api_WorkbookContent", layout: "scout_layout_api_WorkbookLayout", metadata: "scout_template_api_TemplateMetadata", rid: str) -> None:
        self._rid = rid
        self._metadata = metadata
        self._commit = commit
        self._charts = charts
        self._layout = layout
        self._content = content

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def metadata(self) -> "scout_template_api_TemplateMetadata":
        return self._metadata

    @builtins.property
    def commit(self) -> "scout_versioning_api_Commit":
        return self._commit

    @builtins.property
    def charts(self) -> List["scout_rids_api_VersionedChartRid"]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> "scout_workbookcommon_api_WorkbookContent":
        return self._content


scout_template_api_Template.__name__ = "Template"
scout_template_api_Template.__qualname__ = "Template"
scout_template_api_Template.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_TemplateMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'labels': ConjureFieldDefinition('labels', List[scout_run_api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'is_published': ConjureFieldDefinition('isPublished', bool),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', str),
            'edited_at': ConjureFieldDefinition('editedAt', str)
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_is_archived', '_is_published', '_created_by', '_created_at', '_updated_at', '_edited_at']

    def __init__(self, created_at: str, created_by: str, description: str, edited_at: str, is_archived: bool, is_published: bool, labels: List[str], properties: Dict[str, str], title: str, updated_at: str) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._is_archived = is_archived
        self._is_published = is_published
        self._created_by = created_by
        self._created_at = created_at
        self._updated_at = updated_at
        self._edited_at = edited_at

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived

    @builtins.property
    def is_published(self) -> bool:
        return self._is_published

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at

    @builtins.property
    def edited_at(self) -> str:
        """
        The time of the last permanent commit to the main branch.
        """
        return self._edited_at


scout_template_api_TemplateMetadata.__name__ = "TemplateMetadata"
scout_template_api_TemplateMetadata.__qualname__ = "TemplateMetadata"
scout_template_api_TemplateMetadata.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_TemplateSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_TemplateRid),
            'metadata': ConjureFieldDefinition('metadata', scout_template_api_TemplateMetadata)
        }

    __slots__: List[str] = ['_rid', '_metadata']

    def __init__(self, metadata: "scout_template_api_TemplateMetadata", rid: str) -> None:
        self._rid = rid
        self._metadata = metadata

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def metadata(self) -> "scout_template_api_TemplateMetadata":
        return self._metadata


scout_template_api_TemplateSummary.__name__ = "TemplateSummary"
scout_template_api_TemplateSummary.__qualname__ = "TemplateSummary"
scout_template_api_TemplateSummary.__module__ = "scout_service_api.scout_template_api"


class scout_template_api_UpdateMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[scout_run_api_Label]]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[scout_run_api_PropertyName, scout_run_api_PropertyValue]]),
            'is_archived': ConjureFieldDefinition('isArchived', OptionalTypeWrapper[bool]),
            'is_published': ConjureFieldDefinition('isPublished', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_is_archived', '_is_published']

    def __init__(self, description: Optional[str] = None, is_archived: Optional[bool] = None, is_published: Optional[bool] = None, labels: Optional[List[str]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._is_archived = is_archived
        self._is_published = is_published

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def is_archived(self) -> Optional[bool]:
        return self._is_archived

    @builtins.property
    def is_published(self) -> Optional[bool]:
        return self._is_published


scout_template_api_UpdateMetadataRequest.__name__ = "UpdateMetadataRequest"
scout_template_api_UpdateMetadataRequest.__qualname__ = "UpdateMetadataRequest"
scout_template_api_UpdateMetadataRequest.__module__ = "scout_service_api.scout_template_api"


class scout_units_api_GetUnitsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'units_by_property': ConjureFieldDefinition('unitsByProperty', Dict[scout_units_api_UnitProperty, List[scout_units_api_Unit]])
        }

    __slots__: List[str] = ['_units_by_property']

    def __init__(self, units_by_property: Dict[str, List["scout_units_api_Unit"]]) -> None:
        self._units_by_property = units_by_property

    @builtins.property
    def units_by_property(self) -> Dict[str, List["scout_units_api_Unit"]]:
        return self._units_by_property


scout_units_api_GetUnitsResponse.__name__ = "GetUnitsResponse"
scout_units_api_GetUnitsResponse.__qualname__ = "GetUnitsResponse"
scout_units_api_GetUnitsResponse.__module__ = "scout_service_api.scout_units_api"


class scout_units_api_Unit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[scout_units_api_UnitName]),
            'symbol': ConjureFieldDefinition('symbol', scout_units_api_UnitSymbol),
            'property': ConjureFieldDefinition('property', OptionalTypeWrapper[scout_units_api_UnitProperty]),
            'dimension': ConjureFieldDefinition('dimension', OptionalTypeWrapper[scout_units_api_UnitDimension]),
            'system': ConjureFieldDefinition('system', scout_units_api_UnitSystem)
        }

    __slots__: List[str] = ['_name', '_symbol', '_property', '_dimension', '_system']

    def __init__(self, symbol: str, system: str, dimension: Optional["scout_units_api_UnitDimension"] = None, name: Optional[str] = None, property: Optional[str] = None) -> None:
        self._name = name
        self._symbol = symbol
        self._property = property
        self._dimension = dimension
        self._system = system

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def symbol(self) -> str:
        return self._symbol

    @builtins.property
    def property(self) -> Optional[str]:
        """
        Empty if no property is available. If two units measure different properties, it is not possible to 
convert between them.
        """
        return self._property

    @builtins.property
    def dimension(self) -> Optional["scout_units_api_UnitDimension"]:
        """
        The physical dimensions in terms of the base units of the system. It is only possible to convert units if 
they have the same dimension. Empty if the unit is a base unit.
        """
        return self._dimension

    @builtins.property
    def system(self) -> str:
        return self._system


scout_units_api_Unit.__name__ = "Unit"
scout_units_api_Unit.__qualname__ = "Unit"
scout_units_api_Unit.__module__ = "scout_service_api.scout_units_api"


class scout_units_api_UnitDimension(ConjureBeanType):
    """
    The fundamental base dimensions and their exponents, whose product compose a unit.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'base_dimensions': ConjureFieldDefinition('baseDimensions', Dict[str, int])
        }

    __slots__: List[str] = ['_base_dimensions']

    def __init__(self, base_dimensions: Dict[str, int]) -> None:
        self._base_dimensions = base_dimensions

    @builtins.property
    def base_dimensions(self) -> Dict[str, int]:
        return self._base_dimensions


scout_units_api_UnitDimension.__name__ = "UnitDimension"
scout_units_api_UnitDimension.__qualname__ = "UnitDimension"
scout_units_api_UnitDimension.__module__ = "scout_service_api.scout_units_api"


class scout_versioning_api_Branch(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_versioning_api_BranchRid),
            'name': ConjureFieldDefinition('name', scout_versioning_api_BranchName),
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_CommitId),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', str)
        }

    __slots__: List[str] = ['_rid', '_name', '_resource_rid', '_commit', '_created_by', '_created_at', '_updated_at']

    def __init__(self, commit: str, created_at: str, created_by: str, name: str, resource_rid: str, rid: str, updated_at: str) -> None:
        self._rid = rid
        self._name = name
        self._resource_rid = resource_rid
        self._commit = commit
        self._created_by = created_by
        self._created_at = created_at
        self._updated_at = updated_at

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def commit(self) -> str:
        return self._commit

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at


scout_versioning_api_Branch.__name__ = "Branch"
scout_versioning_api_Branch.__qualname__ = "Branch"
scout_versioning_api_Branch.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_BranchAndCommit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'branch': ConjureFieldDefinition('branch', scout_versioning_api_Branch),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_Commit)
        }

    __slots__: List[str] = ['_branch', '_commit']

    def __init__(self, branch: "scout_versioning_api_Branch", commit: "scout_versioning_api_Commit") -> None:
        self._branch = branch
        self._commit = commit

    @builtins.property
    def branch(self) -> "scout_versioning_api_Branch":
        return self._branch

    @builtins.property
    def commit(self) -> "scout_versioning_api_Commit":
        return self._commit


scout_versioning_api_BranchAndCommit.__name__ = "BranchAndCommit"
scout_versioning_api_BranchAndCommit.__qualname__ = "BranchAndCommit"
scout_versioning_api_BranchAndCommit.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_Commit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_versioning_api_CommitId),
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'parent_commit': ConjureFieldDefinition('parentCommit', OptionalTypeWrapper[scout_versioning_api_CommitId]),
            'merge_parent_commit': ConjureFieldDefinition('mergeParentCommit', OptionalTypeWrapper[scout_versioning_api_CommitId]),
            'message': ConjureFieldDefinition('message', str),
            'is_working_state': ConjureFieldDefinition('isWorkingState', bool),
            'committed_by': ConjureFieldDefinition('committedBy', scout_rids_api_UserRid),
            'committed_at': ConjureFieldDefinition('committedAt', str)
        }

    __slots__: List[str] = ['_id', '_resource_rid', '_parent_commit', '_merge_parent_commit', '_message', '_is_working_state', '_committed_by', '_committed_at']

    def __init__(self, committed_at: str, committed_by: str, id: str, is_working_state: bool, message: str, resource_rid: str, merge_parent_commit: Optional[str] = None, parent_commit: Optional[str] = None) -> None:
        self._id = id
        self._resource_rid = resource_rid
        self._parent_commit = parent_commit
        self._merge_parent_commit = merge_parent_commit
        self._message = message
        self._is_working_state = is_working_state
        self._committed_by = committed_by
        self._committed_at = committed_at

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def parent_commit(self) -> Optional[str]:
        return self._parent_commit

    @builtins.property
    def merge_parent_commit(self) -> Optional[str]:
        return self._merge_parent_commit

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def is_working_state(self) -> bool:
        """
        A working state commit is created via the `saveWorkingState` endpoint
and is non-permanent. In the future, it may be compacted and not exist.
        """
        return self._is_working_state

    @builtins.property
    def committed_by(self) -> str:
        return self._committed_by

    @builtins.property
    def committed_at(self) -> str:
        return self._committed_at


scout_versioning_api_Commit.__name__ = "Commit"
scout_versioning_api_Commit.__qualname__ = "Commit"
scout_versioning_api_Commit.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_CommitHistory(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'history': ConjureFieldDefinition('history', List[scout_versioning_api_Commit]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_api_Token])
        }

    __slots__: List[str] = ['_history', '_next_page_token']

    def __init__(self, history: List["scout_versioning_api_Commit"], next_page_token: Optional[str] = None) -> None:
        self._history = history
        self._next_page_token = next_page_token

    @builtins.property
    def history(self) -> List["scout_versioning_api_Commit"]:
        return self._history

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_versioning_api_CommitHistory.__name__ = "CommitHistory"
scout_versioning_api_CommitHistory.__qualname__ = "CommitHistory"
scout_versioning_api_CommitHistory.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_CommitRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new_commit': ConjureFieldDefinition('newCommit', scout_versioning_api_CommitId),
            'merge_parent_commit': ConjureFieldDefinition('mergeParentCommit', OptionalTypeWrapper[scout_versioning_api_CommitId]),
            'message': ConjureFieldDefinition('message', str),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_new_commit', '_merge_parent_commit', '_message', '_latest_commit']

    def __init__(self, message: str, new_commit: str, latest_commit: Optional[str] = None, merge_parent_commit: Optional[str] = None) -> None:
        self._new_commit = new_commit
        self._merge_parent_commit = merge_parent_commit
        self._message = message
        self._latest_commit = latest_commit

    @builtins.property
    def new_commit(self) -> str:
        return self._new_commit

    @builtins.property
    def merge_parent_commit(self) -> Optional[str]:
        """
        If present, this existing commit will be the merge parent
of the new commit. It will be made permanent if not already,
to prevent the merge parent from being compacted.
        """
        return self._merge_parent_commit

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        return self._latest_commit


scout_versioning_api_CommitRequest.__name__ = "CommitRequest"
scout_versioning_api_CommitRequest.__qualname__ = "CommitRequest"
scout_versioning_api_CommitRequest.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_CompactCommitsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'strategy': ConjureFieldDefinition('strategy', scout_versioning_api_CompactionStrategy)
        }

    __slots__: List[str] = ['_strategy']

    def __init__(self, strategy: "scout_versioning_api_CompactionStrategy") -> None:
        self._strategy = strategy

    @builtins.property
    def strategy(self) -> "scout_versioning_api_CompactionStrategy":
        return self._strategy


scout_versioning_api_CompactCommitsRequest.__name__ = "CompactCommitsRequest"
scout_versioning_api_CompactCommitsRequest.__qualname__ = "CompactCommitsRequest"
scout_versioning_api_CompactCommitsRequest.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_CompactionStrategy(ConjureUnionType):
    """Needs to be expressible as a database query"""
    _older_than_days: Optional[int] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'older_than_days': ConjureFieldDefinition('olderThanDays', int)
        }

    def __init__(
            self,
            older_than_days: Optional[int] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (older_than_days is not None) != 1:
                raise ValueError('a union must contain a single member')

            if older_than_days is not None:
                self._older_than_days = older_than_days
                self._type = 'olderThanDays'

        elif type_of_union == 'olderThanDays':
            if older_than_days is None:
                raise ValueError('a union value must not be None')
            self._older_than_days = older_than_days
            self._type = 'olderThanDays'

    @builtins.property
    def older_than_days(self) -> Optional[int]:
        return self._older_than_days

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_versioning_api_CompactionStrategyVisitor):
            raise ValueError('{} is not an instance of scout_versioning_api_CompactionStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'olderThanDays' and self.older_than_days is not None:
            return visitor._older_than_days(self.older_than_days)


scout_versioning_api_CompactionStrategy.__name__ = "CompactionStrategy"
scout_versioning_api_CompactionStrategy.__qualname__ = "CompactionStrategy"
scout_versioning_api_CompactionStrategy.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_CompactionStrategyVisitor:

    @abstractmethod
    def _older_than_days(self, older_than_days: int) -> Any:
        pass


scout_versioning_api_CompactionStrategyVisitor.__name__ = "CompactionStrategyVisitor"
scout_versioning_api_CompactionStrategyVisitor.__qualname__ = "CompactionStrategyVisitor"
scout_versioning_api_CompactionStrategyVisitor.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_CreateBranchRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'existing_commit': ConjureFieldDefinition('existingCommit', scout_versioning_api_CommitId),
            'branch_name': ConjureFieldDefinition('branchName', scout_versioning_api_BranchName)
        }

    __slots__: List[str] = ['_existing_commit', '_branch_name']

    def __init__(self, branch_name: str, existing_commit: str) -> None:
        self._existing_commit = existing_commit
        self._branch_name = branch_name

    @builtins.property
    def existing_commit(self) -> str:
        return self._existing_commit

    @builtins.property
    def branch_name(self) -> str:
        return self._branch_name


scout_versioning_api_CreateBranchRequest.__name__ = "CreateBranchRequest"
scout_versioning_api_CreateBranchRequest.__qualname__ = "CreateBranchRequest"
scout_versioning_api_CreateBranchRequest.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_CreateTagRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'existing_commit': ConjureFieldDefinition('existingCommit', scout_versioning_api_CommitId),
            'tag_name': ConjureFieldDefinition('tagName', scout_versioning_api_TagName)
        }

    __slots__: List[str] = ['_existing_commit', '_tag_name']

    def __init__(self, existing_commit: str, tag_name: str) -> None:
        self._existing_commit = existing_commit
        self._tag_name = tag_name

    @builtins.property
    def existing_commit(self) -> str:
        return self._existing_commit

    @builtins.property
    def tag_name(self) -> str:
        return self._tag_name


scout_versioning_api_CreateTagRequest.__name__ = "CreateTagRequest"
scout_versioning_api_CreateTagRequest.__qualname__ = "CreateTagRequest"
scout_versioning_api_CreateTagRequest.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_GetLeastCommonAncestorRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'commit1': ConjureFieldDefinition('commit1', scout_versioning_api_CommitId),
            'commit2': ConjureFieldDefinition('commit2', scout_versioning_api_CommitId)
        }

    __slots__: List[str] = ['_commit1', '_commit2']

    def __init__(self, commit1: str, commit2: str) -> None:
        self._commit1 = commit1
        self._commit2 = commit2

    @builtins.property
    def commit1(self) -> str:
        return self._commit1

    @builtins.property
    def commit2(self) -> str:
        return self._commit2


scout_versioning_api_GetLeastCommonAncestorRequest.__name__ = "GetLeastCommonAncestorRequest"
scout_versioning_api_GetLeastCommonAncestorRequest.__qualname__ = "GetLeastCommonAncestorRequest"
scout_versioning_api_GetLeastCommonAncestorRequest.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_InitResourceVersioningRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new_commit': ConjureFieldDefinition('newCommit', scout_versioning_api_CommitId),
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_new_commit', '_message']

    def __init__(self, message: str, new_commit: str) -> None:
        self._new_commit = new_commit
        self._message = message

    @builtins.property
    def new_commit(self) -> str:
        return self._new_commit

    @builtins.property
    def message(self) -> str:
        return self._message


scout_versioning_api_InitResourceVersioningRequest.__name__ = "InitResourceVersioningRequest"
scout_versioning_api_InitResourceVersioningRequest.__qualname__ = "InitResourceVersioningRequest"
scout_versioning_api_InitResourceVersioningRequest.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_ResourceAndBranchName(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'branch_name': ConjureFieldDefinition('branchName', scout_versioning_api_BranchName)
        }

    __slots__: List[str] = ['_resource_rid', '_branch_name']

    def __init__(self, branch_name: str, resource_rid: str) -> None:
        self._resource_rid = resource_rid
        self._branch_name = branch_name

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def branch_name(self) -> str:
        return self._branch_name


scout_versioning_api_ResourceAndBranchName.__name__ = "ResourceAndBranchName"
scout_versioning_api_ResourceAndBranchName.__qualname__ = "ResourceAndBranchName"
scout_versioning_api_ResourceAndBranchName.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_ResourceAndCommitId(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'commit_id': ConjureFieldDefinition('commitId', scout_versioning_api_CommitId)
        }

    __slots__: List[str] = ['_resource_rid', '_commit_id']

    def __init__(self, commit_id: str, resource_rid: str) -> None:
        self._resource_rid = resource_rid
        self._commit_id = commit_id

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def commit_id(self) -> str:
        return self._commit_id


scout_versioning_api_ResourceAndCommitId.__name__ = "ResourceAndCommitId"
scout_versioning_api_ResourceAndCommitId.__qualname__ = "ResourceAndCommitId"
scout_versioning_api_ResourceAndCommitId.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_SaveWorkingStateRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new_commit': ConjureFieldDefinition('newCommit', scout_versioning_api_CommitId),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_new_commit', '_latest_commit']

    def __init__(self, new_commit: str, latest_commit: Optional[str] = None) -> None:
        self._new_commit = new_commit
        self._latest_commit = latest_commit

    @builtins.property
    def new_commit(self) -> str:
        return self._new_commit

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        return self._latest_commit


scout_versioning_api_SaveWorkingStateRequest.__name__ = "SaveWorkingStateRequest"
scout_versioning_api_SaveWorkingStateRequest.__qualname__ = "SaveWorkingStateRequest"
scout_versioning_api_SaveWorkingStateRequest.__module__ = "scout_service_api.scout_versioning_api"


class scout_versioning_api_Tag(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_versioning_api_TagRid),
            'name': ConjureFieldDefinition('name', scout_versioning_api_TagName),
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_CommitId),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str)
        }

    __slots__: List[str] = ['_rid', '_name', '_resource_rid', '_commit', '_created_by', '_created_at']

    def __init__(self, commit: str, created_at: str, created_by: str, name: str, resource_rid: str, rid: str) -> None:
        self._rid = rid
        self._name = name
        self._resource_rid = resource_rid
        self._commit = commit
        self._created_by = created_by
        self._created_at = created_at

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def commit(self) -> str:
        return self._commit

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at


scout_versioning_api_Tag.__name__ = "Tag"
scout_versioning_api_Tag.__qualname__ = "Tag"
scout_versioning_api_Tag.__module__ = "scout_service_api.scout_versioning_api"


class scout_video_VideoSegmentService(Service):
    """
    Upon ingestion, every video is split into smaller segments. The Video Segment Service manages operations on videos
at the segment-level.
    """

    def get_segment_data(self, auth_header: str, segment_rid: str, video_rid: str) -> Any:
        """
        Retrieves the raw bytes of a video segment. The data will be returned as a transport stream.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
            'segmentRid': segment_rid,
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/segments/{segmentRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw

    def create_segments(self, auth_header: str, request: "scout_video_api_CreateSegmentsRequest", video_rid: str) -> "scout_video_api_CreateSegmentsResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/video/v1/videos/{videoRid}/create-segments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_CreateSegmentsResponse, self._return_none_for_unknown_union_types)

    def get_segment_by_timestamp(self, auth_header: str, request: "scout_video_api_GetSegmentByTimestampRequest", video_rid: str) -> Optional["scout_video_api_Segment"]:
        """
        Returns metadata for the segment containing the requested absolute timestamp. This endpoint should only be 
used for videos that were ingested with frame-level timestamps.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/video/v1/videos/{videoRid}/get-segment-by-timestamp'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[scout_video_api_Segment], self._return_none_for_unknown_union_types)


scout_video_VideoSegmentService.__name__ = "VideoSegmentService"
scout_video_VideoSegmentService.__qualname__ = "VideoSegmentService"
scout_video_VideoSegmentService.__module__ = "scout_service_api.scout_video"


class scout_video_VideoService(Service):
    """
    The video service manages videos and video metadata.
    """

    def get(self, auth_header: str, video_rid: str) -> "scout_video_api_Video":
        """
        Returns video metadata associated with a video rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_Video, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, request: "scout_video_api_GetVideosRequest") -> "scout_video_api_GetVideosResponse":
        """
        Returns video metadata about each video given a set of video rids.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/video/v1/videos/batchGet'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_GetVideosResponse, self._return_none_for_unknown_union_types)

    def search(self, auth_header: str, request: "scout_video_api_SearchVideosRequest") -> "scout_video_api_SearchVideosResponse":
        """
        Returns metadata about videos that match a given a query.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/video/v1/videos/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_SearchVideosResponse, self._return_none_for_unknown_union_types)

    def create(self, auth_header: str, request: "scout_video_api_CreateVideoRequest") -> "scout_video_api_Video":
        """
        Creates and persists a video entity with the given metadata.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/video/v1/videos'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_Video, self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "scout_video_api_UpdateVideoMetadataRequest", video_rid: str) -> "scout_video_api_Video":
        """
        Updates the metadata for a video associated with the given video rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/video/v1/videos/{videoRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_Video, self._return_none_for_unknown_union_types)

    def update_ingest_status(self, auth_header: str, request: "scout_video_api_UpdateIngestStatus", video_rid: str) -> None:

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/video/v1/videos/{videoRid}/ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_ingest_status(self, auth_header: str, video_rid: str) -> "scout_video_api_DetailedIngestStatus":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_DetailedIngestStatus, self._return_none_for_unknown_union_types)

    def batch_get_ingest_status(self, auth_header: str, video_rids: List[str] = None) -> Dict[str, "scout_video_api_DetailedIngestStatus"]:
        video_rids = video_rids if video_rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(video_rids)

        _path = '/video/v1/videos/batch-get-ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_video_api_VideoRid, scout_video_api_DetailedIngestStatus], self._return_none_for_unknown_union_types)

    def archive(self, auth_header: str, video_rid: str) -> None:
        """
        Archives a video, which excludes it from search and hides it from being publicly visible, but does not
permanently delete it. Archived videos can be unarchived.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, video_rid: str) -> None:
        """
        Unarchives a previously archived video.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_playlist(self, auth_header: str, video_rid: str) -> Any:
        """
        Generates an HLS playlist for a video with the given video rid to enable playback. The HLS playlist will contain
links to all of the segments in the video in sequential order.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/playlist'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw

    def update_target_duration(self, auth_header: str, request: "scout_video_api_UpdateTargetDurationRequest", video_rid: str) -> "scout_video_api_UpdateTargetDurationResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/video/v1/videos/{videoRid}/target-duration'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_UpdateTargetDurationResponse, self._return_none_for_unknown_union_types)

    def get_segment_summaries(self, auth_header: str, video_rid: str) -> List["scout_video_api_SegmentSummary"]:
        """
        Returns the min and max absolute and media timestamps for each segment in a video. To be used during 
frame-timestamp mapping.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'videoRid': video_rid,
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/segment-summaries'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_video_api_SegmentSummary], self._return_none_for_unknown_union_types)


scout_video_VideoService.__name__ = "VideoService"
scout_video_VideoService.__qualname__ = "VideoService"
scout_video_VideoService.__module__ = "scout_service_api.scout_video"


class scout_video_api_ArchivedStatus(ConjureEnumType):

    ARCHIVED = 'ARCHIVED'
    '''ARCHIVED'''
    NOT_ARCHIVED = 'NOT_ARCHIVED'
    '''NOT_ARCHIVED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_video_api_ArchivedStatus.__name__ = "ArchivedStatus"
scout_video_api_ArchivedStatus.__qualname__ = "ArchivedStatus"
scout_video_api_ArchivedStatus.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_CreateSegment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_handle': ConjureFieldDefinition('dataHandle', scout_video_api_Handle),
            'frame_rate': ConjureFieldDefinition('frameRate', float),
            'duration_seconds': ConjureFieldDefinition('durationSeconds', float),
            'timestamps': ConjureFieldDefinition('timestamps', scout_video_api_SegmentTimestamps),
            'segment_end_timestamp': ConjureFieldDefinition('segmentEndTimestamp', api_Timestamp)
        }

    __slots__: List[str] = ['_data_handle', '_frame_rate', '_duration_seconds', '_timestamps', '_segment_end_timestamp']

    def __init__(self, data_handle: "scout_video_api_Handle", duration_seconds: float, frame_rate: float, segment_end_timestamp: "api_Timestamp", timestamps: "scout_video_api_SegmentTimestamps") -> None:
        self._data_handle = data_handle
        self._frame_rate = frame_rate
        self._duration_seconds = duration_seconds
        self._timestamps = timestamps
        self._segment_end_timestamp = segment_end_timestamp

    @builtins.property
    def data_handle(self) -> "scout_video_api_Handle":
        return self._data_handle

    @builtins.property
    def frame_rate(self) -> float:
        """
        The average frame rate (FPS) of the segment calculated as total frames / duration in seconds.
        """
        return self._frame_rate

    @builtins.property
    def duration_seconds(self) -> float:
        return self._duration_seconds

    @builtins.property
    def timestamps(self) -> "scout_video_api_SegmentTimestamps":
        return self._timestamps

    @builtins.property
    def segment_end_timestamp(self) -> "api_Timestamp":
        return self._segment_end_timestamp


scout_video_api_CreateSegment.__name__ = "CreateSegment"
scout_video_api_CreateSegment.__qualname__ = "CreateSegment"
scout_video_api_CreateSegment.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_CreateSegmentsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[scout_video_api_CreateSegment])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["scout_video_api_CreateSegment"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["scout_video_api_CreateSegment"]:
        return self._requests


scout_video_api_CreateSegmentsRequest.__name__ = "CreateSegmentsRequest"
scout_video_api_CreateSegmentsRequest.__qualname__ = "CreateSegmentsRequest"
scout_video_api_CreateSegmentsRequest.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_CreateSegmentsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'segments': ConjureFieldDefinition('segments', List[scout_video_api_Segment])
        }

    __slots__: List[str] = ['_segments']

    def __init__(self, segments: List["scout_video_api_Segment"]) -> None:
        self._segments = segments

    @builtins.property
    def segments(self) -> List["scout_video_api_Segment"]:
        return self._segments


scout_video_api_CreateSegmentsResponse.__name__ = "CreateSegmentsResponse"
scout_video_api_CreateSegmentsResponse.__qualname__ = "CreateSegmentsResponse"
scout_video_api_CreateSegmentsResponse.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_CreateVideoRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', List[scout_video_api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_video_api_PropertyName, scout_video_api_PropertyValue]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_video_api_VideoOriginMetadata)
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_origin_metadata']

    def __init__(self, labels: List[str], origin_metadata: "scout_video_api_VideoOriginMetadata", properties: Dict[str, str], title: str, description: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._origin_metadata = origin_metadata

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def origin_metadata(self) -> "scout_video_api_VideoOriginMetadata":
        return self._origin_metadata


scout_video_api_CreateVideoRequest.__name__ = "CreateVideoRequest"
scout_video_api_CreateVideoRequest.__qualname__ = "CreateVideoRequest"
scout_video_api_CreateVideoRequest.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_DetailedIngestStatus(ConjureUnionType):
    _success: Optional["scout_video_api_SuccessIngestStatus"] = None
    _error: Optional["scout_video_api_ErrorIngestStatus"] = None
    _in_progress: Optional[float] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_video_api_SuccessIngestStatus),
            'error': ConjureFieldDefinition('error', scout_video_api_ErrorIngestStatus),
            'in_progress': ConjureFieldDefinition('inProgress', float)
        }

    def __init__(
            self,
            success: Optional["scout_video_api_SuccessIngestStatus"] = None,
            error: Optional["scout_video_api_ErrorIngestStatus"] = None,
            in_progress: Optional[float] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) + (in_progress is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'
            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'
        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'

    @builtins.property
    def success(self) -> Optional["scout_video_api_SuccessIngestStatus"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["scout_video_api_ErrorIngestStatus"]:
        return self._error

    @builtins.property
    def in_progress(self) -> Optional[float]:
        """
        A number between 0 and 1 representing percentage progress.
        """
        return self._in_progress

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_DetailedIngestStatusVisitor):
            raise ValueError('{} is not an instance of scout_video_api_DetailedIngestStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)


scout_video_api_DetailedIngestStatus.__name__ = "DetailedIngestStatus"
scout_video_api_DetailedIngestStatus.__qualname__ = "DetailedIngestStatus"
scout_video_api_DetailedIngestStatus.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_DetailedIngestStatusVisitor:

    @abstractmethod
    def _success(self, success: "scout_video_api_SuccessIngestStatus") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "scout_video_api_ErrorIngestStatus") -> Any:
        pass

    @abstractmethod
    def _in_progress(self, in_progress: float) -> Any:
        pass


scout_video_api_DetailedIngestStatusVisitor.__name__ = "DetailedIngestStatusVisitor"
scout_video_api_DetailedIngestStatusVisitor.__qualname__ = "DetailedIngestStatusVisitor"
scout_video_api_DetailedIngestStatusVisitor.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_Empty(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_video_api_Empty.__name__ = "Empty"
scout_video_api_Empty.__qualname__ = "Empty"
scout_video_api_Empty.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_ErrorIngestStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'errors': ConjureFieldDefinition('errors', List[scout_video_api_IngestError])
        }

    __slots__: List[str] = ['_errors']

    def __init__(self, errors: List["scout_video_api_IngestError"]) -> None:
        self._errors = errors

    @builtins.property
    def errors(self) -> List["scout_video_api_IngestError"]:
        return self._errors


scout_video_api_ErrorIngestStatus.__name__ = "ErrorIngestStatus"
scout_video_api_ErrorIngestStatus.__qualname__ = "ErrorIngestStatus"
scout_video_api_ErrorIngestStatus.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_GetSegmentByTimestampRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp)
        }

    __slots__: List[str] = ['_timestamp']

    def __init__(self, timestamp: "api_Timestamp") -> None:
        self._timestamp = timestamp

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp


scout_video_api_GetSegmentByTimestampRequest.__name__ = "GetSegmentByTimestampRequest"
scout_video_api_GetSegmentByTimestampRequest.__qualname__ = "GetSegmentByTimestampRequest"
scout_video_api_GetSegmentByTimestampRequest.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_GetVideosRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_rids': ConjureFieldDefinition('videoRids', List[scout_video_api_VideoRid])
        }

    __slots__: List[str] = ['_video_rids']

    def __init__(self, video_rids: List[str]) -> None:
        self._video_rids = video_rids

    @builtins.property
    def video_rids(self) -> List[str]:
        return self._video_rids


scout_video_api_GetVideosRequest.__name__ = "GetVideosRequest"
scout_video_api_GetVideosRequest.__qualname__ = "GetVideosRequest"
scout_video_api_GetVideosRequest.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_GetVideosResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[scout_video_api_Video])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["scout_video_api_Video"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["scout_video_api_Video"]:
        return self._responses


scout_video_api_GetVideosResponse.__name__ = "GetVideosResponse"
scout_video_api_GetVideosResponse.__qualname__ = "GetVideosResponse"
scout_video_api_GetVideosResponse.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_Handle(ConjureUnionType):
    _s3: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3': ConjureFieldDefinition('s3', scout_video_api_S3Path)
        }

    def __init__(
            self,
            s3: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3 is not None:
                self._s3 = s3
                self._type = 's3'

        elif type_of_union == 's3':
            if s3 is None:
                raise ValueError('a union value must not be None')
            self._s3 = s3
            self._type = 's3'

    @builtins.property
    def s3(self) -> Optional[str]:
        return self._s3

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_HandleVisitor):
            raise ValueError('{} is not an instance of scout_video_api_HandleVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3' and self.s3 is not None:
            return visitor._s3(self.s3)


scout_video_api_Handle.__name__ = "Handle"
scout_video_api_Handle.__qualname__ = "Handle"
scout_video_api_Handle.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_HandleVisitor:

    @abstractmethod
    def _s3(self, s3: str) -> Any:
        pass


scout_video_api_HandleVisitor.__name__ = "HandleVisitor"
scout_video_api_HandleVisitor.__qualname__ = "HandleVisitor"
scout_video_api_HandleVisitor.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_IngestError(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_type': ConjureFieldDefinition('errorType', scout_video_api_ErrorType),
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_error_type', '_message']

    def __init__(self, error_type: str, message: str) -> None:
        self._error_type = error_type
        self._message = message

    @builtins.property
    def error_type(self) -> str:
        return self._error_type

    @builtins.property
    def message(self) -> str:
        return self._message


scout_video_api_IngestError.__name__ = "IngestError"
scout_video_api_IngestError.__qualname__ = "IngestError"
scout_video_api_IngestError.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_IngestStatus(ConjureEnumType):

    SUCCEEDED = 'SUCCEEDED'
    '''SUCCEEDED'''
    FAILED = 'FAILED'
    '''FAILED'''
    IN_PROGRESS = 'IN_PROGRESS'
    '''IN_PROGRESS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_video_api_IngestStatus.__name__ = "IngestStatus"
scout_video_api_IngestStatus.__qualname__ = "IngestStatus"
scout_video_api_IngestStatus.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_NoTimestampManifest(ConjureBeanType):
    """
    these values will not be updated after ingest time, to allow for resetting. The updated values are stored 
implicitly through the segment timestamps.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'starting_timestamp': ConjureFieldDefinition('startingTimestamp', api_Timestamp),
            'scale_parameter': ConjureFieldDefinition('scaleParameter', OptionalTypeWrapper[scout_video_api_ScaleParameter])
        }

    __slots__: List[str] = ['_starting_timestamp', '_scale_parameter']

    def __init__(self, starting_timestamp: "api_Timestamp", scale_parameter: Optional["scout_video_api_ScaleParameter"] = None) -> None:
        self._starting_timestamp = starting_timestamp
        self._scale_parameter = scale_parameter

    @builtins.property
    def starting_timestamp(self) -> "api_Timestamp":
        """
        Specifies the original starting timestamp of the video.
        """
        return self._starting_timestamp

    @builtins.property
    def scale_parameter(self) -> Optional["scout_video_api_ScaleParameter"]:
        """
        A field that specifies that the frame rate of the video does not match the frame rate of the camera | i.e. a slowed down or sped up video. Can specify either the camera frame rate or the absolute end time.
        """
        return self._scale_parameter


scout_video_api_NoTimestampManifest.__name__ = "NoTimestampManifest"
scout_video_api_NoTimestampManifest.__qualname__ = "NoTimestampManifest"
scout_video_api_NoTimestampManifest.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_Property(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_video_api_PropertyName),
            'value': ConjureFieldDefinition('value', scout_video_api_PropertyValue)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


scout_video_api_Property.__name__ = "Property"
scout_video_api_Property.__qualname__ = "Property"
scout_video_api_Property.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_ScaleParameter(ConjureUnionType):
    _true_frame_rate: Optional[float] = None
    _ending_timestamp: Optional["api_Timestamp"] = None
    _scale_factor: Optional[float] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'true_frame_rate': ConjureFieldDefinition('trueFrameRate', float),
            'ending_timestamp': ConjureFieldDefinition('endingTimestamp', api_Timestamp),
            'scale_factor': ConjureFieldDefinition('scaleFactor', float)
        }

    def __init__(
            self,
            true_frame_rate: Optional[float] = None,
            ending_timestamp: Optional["api_Timestamp"] = None,
            scale_factor: Optional[float] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (true_frame_rate is not None) + (ending_timestamp is not None) + (scale_factor is not None) != 1:
                raise ValueError('a union must contain a single member')

            if true_frame_rate is not None:
                self._true_frame_rate = true_frame_rate
                self._type = 'trueFrameRate'
            if ending_timestamp is not None:
                self._ending_timestamp = ending_timestamp
                self._type = 'endingTimestamp'
            if scale_factor is not None:
                self._scale_factor = scale_factor
                self._type = 'scaleFactor'

        elif type_of_union == 'trueFrameRate':
            if true_frame_rate is None:
                raise ValueError('a union value must not be None')
            self._true_frame_rate = true_frame_rate
            self._type = 'trueFrameRate'
        elif type_of_union == 'endingTimestamp':
            if ending_timestamp is None:
                raise ValueError('a union value must not be None')
            self._ending_timestamp = ending_timestamp
            self._type = 'endingTimestamp'
        elif type_of_union == 'scaleFactor':
            if scale_factor is None:
                raise ValueError('a union value must not be None')
            self._scale_factor = scale_factor
            self._type = 'scaleFactor'

    @builtins.property
    def true_frame_rate(self) -> Optional[float]:
        return self._true_frame_rate

    @builtins.property
    def ending_timestamp(self) -> Optional["api_Timestamp"]:
        return self._ending_timestamp

    @builtins.property
    def scale_factor(self) -> Optional[float]:
        """
        the scale factor can be used to calculate whether media duration differs from a video's | real duration, and if so, the true frame rate of the camera. The video time will thus be scaled | by the ratio of the real duration to media duration, or media frame rate to true frame rate.
        """
        return self._scale_factor

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_ScaleParameterVisitor):
            raise ValueError('{} is not an instance of scout_video_api_ScaleParameterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'trueFrameRate' and self.true_frame_rate is not None:
            return visitor._true_frame_rate(self.true_frame_rate)
        if self._type == 'endingTimestamp' and self.ending_timestamp is not None:
            return visitor._ending_timestamp(self.ending_timestamp)
        if self._type == 'scaleFactor' and self.scale_factor is not None:
            return visitor._scale_factor(self.scale_factor)


scout_video_api_ScaleParameter.__name__ = "ScaleParameter"
scout_video_api_ScaleParameter.__qualname__ = "ScaleParameter"
scout_video_api_ScaleParameter.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_ScaleParameterVisitor:

    @abstractmethod
    def _true_frame_rate(self, true_frame_rate: float) -> Any:
        pass

    @abstractmethod
    def _ending_timestamp(self, ending_timestamp: "api_Timestamp") -> Any:
        pass

    @abstractmethod
    def _scale_factor(self, scale_factor: float) -> Any:
        pass


scout_video_api_ScaleParameterVisitor.__name__ = "ScaleParameterVisitor"
scout_video_api_ScaleParameterVisitor.__qualname__ = "ScaleParameterVisitor"
scout_video_api_ScaleParameterVisitor.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SearchVideosQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["scout_video_api_Property"] = None
    _and_: Optional[List["scout_video_api_SearchVideosQuery"]] = None
    _or_: Optional[List["scout_video_api_SearchVideosQuery"]] = None
    _ingest_status: Optional["scout_video_api_IngestStatus"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', scout_video_api_Label),
            'property': ConjureFieldDefinition('property', scout_video_api_Property),
            'and_': ConjureFieldDefinition('and', List[scout_video_api_SearchVideosQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_video_api_SearchVideosQuery]),
            'ingest_status': ConjureFieldDefinition('ingestStatus', scout_video_api_IngestStatus)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["scout_video_api_Property"] = None,
            and_: Optional[List["scout_video_api_SearchVideosQuery"]] = None,
            or_: Optional[List["scout_video_api_SearchVideosQuery"]] = None,
            ingest_status: Optional["scout_video_api_IngestStatus"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) + (ingest_status is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if ingest_status is not None:
                self._ingest_status = ingest_status
                self._type = 'ingestStatus'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'ingestStatus':
            if ingest_status is None:
                raise ValueError('a union value must not be None')
            self._ingest_status = ingest_status
            self._type = 'ingestStatus'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["scout_video_api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["scout_video_api_SearchVideosQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_video_api_SearchVideosQuery"]]:
        return self._or_

    @builtins.property
    def ingest_status(self) -> Optional["scout_video_api_IngestStatus"]:
        return self._ingest_status

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_SearchVideosQueryVisitor):
            raise ValueError('{} is not an instance of scout_video_api_SearchVideosQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'ingestStatus' and self.ingest_status is not None:
            return visitor._ingest_status(self.ingest_status)


scout_video_api_SearchVideosQuery.__name__ = "SearchVideosQuery"
scout_video_api_SearchVideosQuery.__qualname__ = "SearchVideosQuery"
scout_video_api_SearchVideosQuery.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SearchVideosQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_video_api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_video_api_SearchVideosQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_video_api_SearchVideosQuery"]) -> Any:
        pass

    @abstractmethod
    def _ingest_status(self, ingest_status: "scout_video_api_IngestStatus") -> Any:
        pass


scout_video_api_SearchVideosQueryVisitor.__name__ = "SearchVideosQueryVisitor"
scout_video_api_SearchVideosQueryVisitor.__qualname__ = "SearchVideosQueryVisitor"
scout_video_api_SearchVideosQueryVisitor.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SearchVideosRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_video_api_SearchVideosQuery),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[scout_video_api_Token]),
            'sort_options': ConjureFieldDefinition('sortOptions', scout_video_api_SortOptions),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[scout_video_api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_query', '_page_size', '_token', '_sort_options', '_archived_statuses']

    def __init__(self, query: "scout_video_api_SearchVideosQuery", sort_options: "scout_video_api_SortOptions", archived_statuses: Optional[List["scout_video_api_ArchivedStatus"]] = None, page_size: Optional[int] = None, token: Optional[str] = None) -> None:
        self._query = query
        self._page_size = page_size
        self._token = token
        self._sort_options = sort_options
        self._archived_statuses = archived_statuses

    @builtins.property
    def query(self) -> "scout_video_api_SearchVideosQuery":
        return self._query

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token

    @builtins.property
    def sort_options(self) -> "scout_video_api_SortOptions":
        return self._sort_options

    @builtins.property
    def archived_statuses(self) -> Optional[List["scout_video_api_ArchivedStatus"]]:
        """
        Default search status is NOT_ARCHIVED if none are provided. Allows for including archived videos in search.
        """
        return self._archived_statuses


scout_video_api_SearchVideosRequest.__name__ = "SearchVideosRequest"
scout_video_api_SearchVideosRequest.__qualname__ = "SearchVideosRequest"
scout_video_api_SearchVideosRequest.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SearchVideosResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_video_api_Video]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_video_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_video_api_Video"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_video_api_Video"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_video_api_SearchVideosResponse.__name__ = "SearchVideosResponse"
scout_video_api_SearchVideosResponse.__qualname__ = "SearchVideosResponse"
scout_video_api_SearchVideosResponse.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_Segment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_video_api_SegmentRid),
            'video_rid': ConjureFieldDefinition('videoRid', scout_video_api_VideoRid),
            'data_handle': ConjureFieldDefinition('dataHandle', scout_video_api_Handle),
            'frame_rate': ConjureFieldDefinition('frameRate', float),
            'duration_seconds': ConjureFieldDefinition('durationSeconds', float),
            'timestamps': ConjureFieldDefinition('timestamps', scout_video_api_SegmentTimestamps)
        }

    __slots__: List[str] = ['_rid', '_video_rid', '_data_handle', '_frame_rate', '_duration_seconds', '_timestamps']

    def __init__(self, data_handle: "scout_video_api_Handle", duration_seconds: float, frame_rate: float, rid: str, timestamps: "scout_video_api_SegmentTimestamps", video_rid: str) -> None:
        self._rid = rid
        self._video_rid = video_rid
        self._data_handle = data_handle
        self._frame_rate = frame_rate
        self._duration_seconds = duration_seconds
        self._timestamps = timestamps

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def video_rid(self) -> str:
        return self._video_rid

    @builtins.property
    def data_handle(self) -> "scout_video_api_Handle":
        return self._data_handle

    @builtins.property
    def frame_rate(self) -> float:
        """
        The average frame rate (FPS) of the segment calculated as total frames / duration in seconds.
        """
        return self._frame_rate

    @builtins.property
    def duration_seconds(self) -> float:
        """
        The duration of a segment in media time.
        """
        return self._duration_seconds

    @builtins.property
    def timestamps(self) -> "scout_video_api_SegmentTimestamps":
        """
        for videos with frame-level timestamps, we provide mappings, otherwise we just include a single list
of timestamps.
        """
        return self._timestamps


scout_video_api_Segment.__name__ = "Segment"
scout_video_api_Segment.__qualname__ = "Segment"
scout_video_api_Segment.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SegmentSummary(ConjureBeanType):
    """
    Bounding timestamps for the frames within a segment. For non-frame-mapped videos, the min and max media 
timestamps will be empty.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_absolute_timestamp': ConjureFieldDefinition('minAbsoluteTimestamp', api_Timestamp),
            'max_absolute_timestamp': ConjureFieldDefinition('maxAbsoluteTimestamp', api_Timestamp),
            'min_media_timestamp': ConjureFieldDefinition('minMediaTimestamp', OptionalTypeWrapper[float]),
            'max_media_timestamp': ConjureFieldDefinition('maxMediaTimestamp', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_min_absolute_timestamp', '_max_absolute_timestamp', '_min_media_timestamp', '_max_media_timestamp']

    def __init__(self, max_absolute_timestamp: "api_Timestamp", min_absolute_timestamp: "api_Timestamp", max_media_timestamp: Optional[float] = None, min_media_timestamp: Optional[float] = None) -> None:
        self._min_absolute_timestamp = min_absolute_timestamp
        self._max_absolute_timestamp = max_absolute_timestamp
        self._min_media_timestamp = min_media_timestamp
        self._max_media_timestamp = max_media_timestamp

    @builtins.property
    def min_absolute_timestamp(self) -> "api_Timestamp":
        return self._min_absolute_timestamp

    @builtins.property
    def max_absolute_timestamp(self) -> "api_Timestamp":
        return self._max_absolute_timestamp

    @builtins.property
    def min_media_timestamp(self) -> Optional[float]:
        return self._min_media_timestamp

    @builtins.property
    def max_media_timestamp(self) -> Optional[float]:
        return self._max_media_timestamp


scout_video_api_SegmentSummary.__name__ = "SegmentSummary"
scout_video_api_SegmentSummary.__qualname__ = "SegmentSummary"
scout_video_api_SegmentSummary.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SegmentTimestamps(ConjureUnionType):
    """A video segment will either contain timestamps or timestamp mappings depending on whether it is intended to
be frame-mapped. Without a frame-timestamp mapping manifest file, a list of absolute timestamps will be 
automatically assigned to each segment based on media timestamps.. Otherwise, media timestamps will be 
extracted and mapped to those in the provided manifest."""
    _timestamps: Optional[List["api_Timestamp"]] = None
    _timestamp_mappings: Optional["scout_video_api_TimestampMappings"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'timestamp_mappings': ConjureFieldDefinition('timestampMappings', scout_video_api_TimestampMappings)
        }

    def __init__(
            self,
            timestamps: Optional[List["api_Timestamp"]] = None,
            timestamp_mappings: Optional["scout_video_api_TimestampMappings"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (timestamps is not None) + (timestamp_mappings is not None) != 1:
                raise ValueError('a union must contain a single member')

            if timestamps is not None:
                self._timestamps = timestamps
                self._type = 'timestamps'
            if timestamp_mappings is not None:
                self._timestamp_mappings = timestamp_mappings
                self._type = 'timestampMappings'

        elif type_of_union == 'timestamps':
            if timestamps is None:
                raise ValueError('a union value must not be None')
            self._timestamps = timestamps
            self._type = 'timestamps'
        elif type_of_union == 'timestampMappings':
            if timestamp_mappings is None:
                raise ValueError('a union value must not be None')
            self._timestamp_mappings = timestamp_mappings
            self._type = 'timestampMappings'

    @builtins.property
    def timestamps(self) -> Optional[List["api_Timestamp"]]:
        return self._timestamps

    @builtins.property
    def timestamp_mappings(self) -> Optional["scout_video_api_TimestampMappings"]:
        return self._timestamp_mappings

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_SegmentTimestampsVisitor):
            raise ValueError('{} is not an instance of scout_video_api_SegmentTimestampsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timestamps' and self.timestamps is not None:
            return visitor._timestamps(self.timestamps)
        if self._type == 'timestampMappings' and self.timestamp_mappings is not None:
            return visitor._timestamp_mappings(self.timestamp_mappings)


scout_video_api_SegmentTimestamps.__name__ = "SegmentTimestamps"
scout_video_api_SegmentTimestamps.__qualname__ = "SegmentTimestamps"
scout_video_api_SegmentTimestamps.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SegmentTimestampsVisitor:

    @abstractmethod
    def _timestamps(self, timestamps: List["api_Timestamp"]) -> Any:
        pass

    @abstractmethod
    def _timestamp_mappings(self, timestamp_mappings: "scout_video_api_TimestampMappings") -> Any:
        pass


scout_video_api_SegmentTimestampsVisitor.__name__ = "SegmentTimestampsVisitor"
scout_video_api_SegmentTimestampsVisitor.__qualname__ = "SegmentTimestampsVisitor"
scout_video_api_SegmentTimestampsVisitor.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SortField(ConjureEnumType):

    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_video_api_SortField.__name__ = "SortField"
scout_video_api_SortField.__qualname__ = "SortField"
scout_video_api_SortField.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_video_api_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_video_api_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_video_api_SortField":
        return self._field


scout_video_api_SortOptions.__name__ = "SortOptions"
scout_video_api_SortOptions.__qualname__ = "SortOptions"
scout_video_api_SortOptions.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_SuccessIngestStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_video_api_SuccessIngestStatus.__name__ = "SuccessIngestStatus"
scout_video_api_SuccessIngestStatus.__qualname__ = "SuccessIngestStatus"
scout_video_api_SuccessIngestStatus.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_TimestampMappings(ConjureBeanType):
    """
    contains 2 equal-length lists, which contain the video media time and user-provided absolute time
for the frame at each index. Enables frame-mapping on the front-end.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'media_timestamps': ConjureFieldDefinition('mediaTimestamps', List[float]),
            'absolute_timestamps': ConjureFieldDefinition('absoluteTimestamps', List[api_Timestamp])
        }

    __slots__: List[str] = ['_media_timestamps', '_absolute_timestamps']

    def __init__(self, absolute_timestamps: List["api_Timestamp"], media_timestamps: List[float]) -> None:
        self._media_timestamps = media_timestamps
        self._absolute_timestamps = absolute_timestamps

    @builtins.property
    def media_timestamps(self) -> List[float]:
        return self._media_timestamps

    @builtins.property
    def absolute_timestamps(self) -> List["api_Timestamp"]:
        return self._absolute_timestamps


scout_video_api_TimestampMappings.__name__ = "TimestampMappings"
scout_video_api_TimestampMappings.__qualname__ = "TimestampMappings"
scout_video_api_TimestampMappings.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_UpdateIngestStatus(ConjureUnionType):
    _success: Optional["scout_video_api_SuccessIngestStatus"] = None
    _error: Optional["scout_video_api_ErrorIngestStatus"] = None
    _in_progress: Optional["scout_video_api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_video_api_SuccessIngestStatus),
            'error': ConjureFieldDefinition('error', scout_video_api_ErrorIngestStatus),
            'in_progress': ConjureFieldDefinition('inProgress', scout_video_api_Empty)
        }

    def __init__(
            self,
            success: Optional["scout_video_api_SuccessIngestStatus"] = None,
            error: Optional["scout_video_api_ErrorIngestStatus"] = None,
            in_progress: Optional["scout_video_api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) + (in_progress is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'
            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'
        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'

    @builtins.property
    def success(self) -> Optional["scout_video_api_SuccessIngestStatus"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["scout_video_api_ErrorIngestStatus"]:
        return self._error

    @builtins.property
    def in_progress(self) -> Optional["scout_video_api_Empty"]:
        return self._in_progress

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_UpdateIngestStatusVisitor):
            raise ValueError('{} is not an instance of scout_video_api_UpdateIngestStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)


scout_video_api_UpdateIngestStatus.__name__ = "UpdateIngestStatus"
scout_video_api_UpdateIngestStatus.__qualname__ = "UpdateIngestStatus"
scout_video_api_UpdateIngestStatus.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_UpdateIngestStatusVisitor:

    @abstractmethod
    def _success(self, success: "scout_video_api_SuccessIngestStatus") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "scout_video_api_ErrorIngestStatus") -> Any:
        pass

    @abstractmethod
    def _in_progress(self, in_progress: "scout_video_api_Empty") -> Any:
        pass


scout_video_api_UpdateIngestStatusVisitor.__name__ = "UpdateIngestStatusVisitor"
scout_video_api_UpdateIngestStatusVisitor.__qualname__ = "UpdateIngestStatusVisitor"
scout_video_api_UpdateIngestStatusVisitor.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_UpdateTargetDurationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'target_duration_seconds': ConjureFieldDefinition('targetDurationSeconds', float)
        }

    __slots__: List[str] = ['_target_duration_seconds']

    def __init__(self, target_duration_seconds: float) -> None:
        self._target_duration_seconds = target_duration_seconds

    @builtins.property
    def target_duration_seconds(self) -> float:
        """
        A value used to construct the HLS playlist which must be greater than or equal to the durations of all 
the segments within a video, when rounded to the nearest integer.
        """
        return self._target_duration_seconds


scout_video_api_UpdateTargetDurationRequest.__name__ = "UpdateTargetDurationRequest"
scout_video_api_UpdateTargetDurationRequest.__qualname__ = "UpdateTargetDurationRequest"
scout_video_api_UpdateTargetDurationRequest.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_UpdateTargetDurationResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'target_duration_seconds': ConjureFieldDefinition('targetDurationSeconds', float)
        }

    __slots__: List[str] = ['_target_duration_seconds']

    def __init__(self, target_duration_seconds: float) -> None:
        self._target_duration_seconds = target_duration_seconds

    @builtins.property
    def target_duration_seconds(self) -> float:
        """
        If the video already has a target duration, then the returned target duration will be the max of the one
sent in the request and the existing target duration.
        """
        return self._target_duration_seconds


scout_video_api_UpdateTargetDurationResponse.__name__ = "UpdateTargetDurationResponse"
scout_video_api_UpdateTargetDurationResponse.__qualname__ = "UpdateTargetDurationResponse"
scout_video_api_UpdateTargetDurationResponse.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_UpdateVideoMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[scout_video_api_Label]]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_video_api_PropertyName, scout_video_api_PropertyValue]),
            'starting_timestamp': ConjureFieldDefinition('startingTimestamp', OptionalTypeWrapper[api_Timestamp]),
            'scale_parameter': ConjureFieldDefinition('scaleParameter', OptionalTypeWrapper[scout_video_api_ScaleParameter])
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_starting_timestamp', '_scale_parameter']

    def __init__(self, properties: Dict[str, str], description: Optional[str] = None, labels: Optional[List[str]] = None, scale_parameter: Optional["scout_video_api_ScaleParameter"] = None, starting_timestamp: Optional["api_Timestamp"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._starting_timestamp = starting_timestamp
        self._scale_parameter = scale_parameter

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def starting_timestamp(self) -> Optional["api_Timestamp"]:
        return self._starting_timestamp

    @builtins.property
    def scale_parameter(self) -> Optional["scout_video_api_ScaleParameter"]:
        return self._scale_parameter


scout_video_api_UpdateVideoMetadataRequest.__name__ = "UpdateVideoMetadataRequest"
scout_video_api_UpdateVideoMetadataRequest.__qualname__ = "UpdateVideoMetadataRequest"
scout_video_api_UpdateVideoMetadataRequest.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_Video(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_video_api_VideoRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', List[scout_video_api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[scout_video_api_PropertyName, scout_video_api_PropertyValue]),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_video_api_VideoOriginMetadata),
            'all_segments_metadata': ConjureFieldDefinition('allSegmentsMetadata', OptionalTypeWrapper[scout_video_api_VideoAllSegmentsMetadata])
        }

    __slots__: List[str] = ['_rid', '_title', '_description', '_labels', '_properties', '_created_by', '_created_at', '_origin_metadata', '_all_segments_metadata']

    def __init__(self, created_at: str, created_by: str, labels: List[str], origin_metadata: "scout_video_api_VideoOriginMetadata", properties: Dict[str, str], rid: str, title: str, all_segments_metadata: Optional["scout_video_api_VideoAllSegmentsMetadata"] = None, description: Optional[str] = None) -> None:
        self._rid = rid
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._created_by = created_by
        self._created_at = created_at
        self._origin_metadata = origin_metadata
        self._all_segments_metadata = all_segments_metadata

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def origin_metadata(self) -> "scout_video_api_VideoOriginMetadata":
        return self._origin_metadata

    @builtins.property
    def all_segments_metadata(self) -> Optional["scout_video_api_VideoAllSegmentsMetadata"]:
        return self._all_segments_metadata


scout_video_api_Video.__name__ = "Video"
scout_video_api_Video.__qualname__ = "Video"
scout_video_api_Video.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_VideoAllSegmentsMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_video_api_VideoRid),
            'num_frames': ConjureFieldDefinition('numFrames', int),
            'num_segments': ConjureFieldDefinition('numSegments', int),
            'scale_factor': ConjureFieldDefinition('scaleFactor', float),
            'min_absolute_timestamp': ConjureFieldDefinition('minAbsoluteTimestamp', api_Timestamp),
            'max_absolute_timestamp': ConjureFieldDefinition('maxAbsoluteTimestamp', api_Timestamp),
            'media_duration_seconds': ConjureFieldDefinition('mediaDurationSeconds', float),
            'media_frame_rate': ConjureFieldDefinition('mediaFrameRate', float),
            'min_timestamp': ConjureFieldDefinition('minTimestamp', OptionalTypeWrapper[api_Timestamp]),
            'max_timestamp': ConjureFieldDefinition('maxTimestamp', OptionalTypeWrapper[api_Timestamp]),
            'duration_seconds': ConjureFieldDefinition('durationSeconds', OptionalTypeWrapper[float]),
            'frame_rate': ConjureFieldDefinition('frameRate', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_rid', '_num_frames', '_num_segments', '_scale_factor', '_min_absolute_timestamp', '_max_absolute_timestamp', '_media_duration_seconds', '_media_frame_rate', '_min_timestamp', '_max_timestamp', '_duration_seconds', '_frame_rate']

    def __init__(self, max_absolute_timestamp: "api_Timestamp", media_duration_seconds: float, media_frame_rate: float, min_absolute_timestamp: "api_Timestamp", num_frames: int, num_segments: int, rid: str, scale_factor: float, duration_seconds: Optional[float] = None, frame_rate: Optional[float] = None, max_timestamp: Optional["api_Timestamp"] = None, min_timestamp: Optional["api_Timestamp"] = None) -> None:
        self._rid = rid
        self._num_frames = num_frames
        self._num_segments = num_segments
        self._scale_factor = scale_factor
        self._min_absolute_timestamp = min_absolute_timestamp
        self._max_absolute_timestamp = max_absolute_timestamp
        self._media_duration_seconds = media_duration_seconds
        self._media_frame_rate = media_frame_rate
        self._min_timestamp = min_timestamp
        self._max_timestamp = max_timestamp
        self._duration_seconds = duration_seconds
        self._frame_rate = frame_rate

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def num_frames(self) -> int:
        return self._num_frames

    @builtins.property
    def num_segments(self) -> int:
        return self._num_segments

    @builtins.property
    def scale_factor(self) -> float:
        return self._scale_factor

    @builtins.property
    def min_absolute_timestamp(self) -> "api_Timestamp":
        return self._min_absolute_timestamp

    @builtins.property
    def max_absolute_timestamp(self) -> "api_Timestamp":
        """
        the timestamp corresponding to absolute starting timestamp plus absolute duration of the video.
        """
        return self._max_absolute_timestamp

    @builtins.property
    def media_duration_seconds(self) -> float:
        return self._media_duration_seconds

    @builtins.property
    def media_frame_rate(self) -> float:
        """
        The average media frame rate (FPS) of the video calculated as total frames / duration in seconds.
        """
        return self._media_frame_rate

    @builtins.property
    def min_timestamp(self) -> Optional["api_Timestamp"]:
        """
        deprecated
        """
        return self._min_timestamp

    @builtins.property
    def max_timestamp(self) -> Optional["api_Timestamp"]:
        """
        deprecated
        """
        return self._max_timestamp

    @builtins.property
    def duration_seconds(self) -> Optional[float]:
        """
        deprecated
        """
        return self._duration_seconds

    @builtins.property
    def frame_rate(self) -> Optional[float]:
        """
        deprecated
        """
        return self._frame_rate


scout_video_api_VideoAllSegmentsMetadata.__name__ = "VideoAllSegmentsMetadata"
scout_video_api_VideoAllSegmentsMetadata.__qualname__ = "VideoAllSegmentsMetadata"
scout_video_api_VideoAllSegmentsMetadata.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_VideoOriginMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_sources': ConjureFieldDefinition('videoSources', List[scout_video_api_Handle]),
            'video_sources_original_handles': ConjureFieldDefinition('videoSourcesOriginalHandles', OptionalTypeWrapper[List[scout_video_api_Handle]]),
            'timestamp_manifest': ConjureFieldDefinition('timestampManifest', scout_video_api_VideoTimestampManifest)
        }

    __slots__: List[str] = ['_video_sources', '_video_sources_original_handles', '_timestamp_manifest']

    def __init__(self, timestamp_manifest: "scout_video_api_VideoTimestampManifest", video_sources: List["scout_video_api_Handle"], video_sources_original_handles: Optional[List["scout_video_api_Handle"]] = None) -> None:
        self._video_sources = video_sources
        self._video_sources_original_handles = video_sources_original_handles
        self._timestamp_manifest = timestamp_manifest

    @builtins.property
    def video_sources(self) -> List["scout_video_api_Handle"]:
        return self._video_sources

    @builtins.property
    def video_sources_original_handles(self) -> Optional[List["scout_video_api_Handle"]]:
        """
        Will be present if the handles were copied from a different bucket to the Nominal bucket.
        """
        return self._video_sources_original_handles

    @builtins.property
    def timestamp_manifest(self) -> "scout_video_api_VideoTimestampManifest":
        return self._timestamp_manifest


scout_video_api_VideoOriginMetadata.__name__ = "VideoOriginMetadata"
scout_video_api_VideoOriginMetadata.__qualname__ = "VideoOriginMetadata"
scout_video_api_VideoOriginMetadata.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_VideoTimestampManifest(ConjureUnionType):
    _s3paths: Optional[List[str]] = None
    _no_manifest: Optional["scout_video_api_NoTimestampManifest"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3paths': ConjureFieldDefinition('s3paths', List[scout_video_api_S3Path]),
            'no_manifest': ConjureFieldDefinition('noManifest', scout_video_api_NoTimestampManifest)
        }

    def __init__(
            self,
            s3paths: Optional[List[str]] = None,
            no_manifest: Optional["scout_video_api_NoTimestampManifest"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3paths is not None) + (no_manifest is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3paths is not None:
                self._s3paths = s3paths
                self._type = 's3paths'
            if no_manifest is not None:
                self._no_manifest = no_manifest
                self._type = 'noManifest'

        elif type_of_union == 's3paths':
            if s3paths is None:
                raise ValueError('a union value must not be None')
            self._s3paths = s3paths
            self._type = 's3paths'
        elif type_of_union == 'noManifest':
            if no_manifest is None:
                raise ValueError('a union value must not be None')
            self._no_manifest = no_manifest
            self._type = 'noManifest'

    @builtins.property
    def s3paths(self) -> Optional[List[str]]:
        return self._s3paths

    @builtins.property
    def no_manifest(self) -> Optional["scout_video_api_NoTimestampManifest"]:
        return self._no_manifest

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_VideoTimestampManifestVisitor):
            raise ValueError('{} is not an instance of scout_video_api_VideoTimestampManifestVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3paths' and self.s3paths is not None:
            return visitor._s3paths(self.s3paths)
        if self._type == 'noManifest' and self.no_manifest is not None:
            return visitor._no_manifest(self.no_manifest)


scout_video_api_VideoTimestampManifest.__name__ = "VideoTimestampManifest"
scout_video_api_VideoTimestampManifest.__qualname__ = "VideoTimestampManifest"
scout_video_api_VideoTimestampManifest.__module__ = "scout_service_api.scout_video_api"


class scout_video_api_VideoTimestampManifestVisitor:

    @abstractmethod
    def _s3paths(self, s3paths: List[str]) -> Any:
        pass

    @abstractmethod
    def _no_manifest(self, no_manifest: "scout_video_api_NoTimestampManifest") -> Any:
        pass


scout_video_api_VideoTimestampManifestVisitor.__name__ = "VideoTimestampManifestVisitor"
scout_video_api_VideoTimestampManifestVisitor.__qualname__ = "VideoTimestampManifestVisitor"
scout_video_api_VideoTimestampManifestVisitor.__module__ = "scout_service_api.scout_video_api"


class scout_workbookcommon_api_UnifiedWorkbookContent(ConjureUnionType):
    _workbook: Optional["scout_workbookcommon_api_WorkbookContent"] = None
    _comparison_workbook: Optional["scout_comparisonnotebook_api_ComparisonWorkbookContent"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workbook': ConjureFieldDefinition('workbook', scout_workbookcommon_api_WorkbookContent),
            'comparison_workbook': ConjureFieldDefinition('comparisonWorkbook', scout_comparisonnotebook_api_ComparisonWorkbookContent)
        }

    def __init__(
            self,
            workbook: Optional["scout_workbookcommon_api_WorkbookContent"] = None,
            comparison_workbook: Optional["scout_comparisonnotebook_api_ComparisonWorkbookContent"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (workbook is not None) + (comparison_workbook is not None) != 1:
                raise ValueError('a union must contain a single member')

            if workbook is not None:
                self._workbook = workbook
                self._type = 'workbook'
            if comparison_workbook is not None:
                self._comparison_workbook = comparison_workbook
                self._type = 'comparisonWorkbook'

        elif type_of_union == 'workbook':
            if workbook is None:
                raise ValueError('a union value must not be None')
            self._workbook = workbook
            self._type = 'workbook'
        elif type_of_union == 'comparisonWorkbook':
            if comparison_workbook is None:
                raise ValueError('a union value must not be None')
            self._comparison_workbook = comparison_workbook
            self._type = 'comparisonWorkbook'

    @builtins.property
    def workbook(self) -> Optional["scout_workbookcommon_api_WorkbookContent"]:
        return self._workbook

    @builtins.property
    def comparison_workbook(self) -> Optional["scout_comparisonnotebook_api_ComparisonWorkbookContent"]:
        return self._comparison_workbook

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_workbookcommon_api_UnifiedWorkbookContentVisitor):
            raise ValueError('{} is not an instance of scout_workbookcommon_api_UnifiedWorkbookContentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'workbook' and self.workbook is not None:
            return visitor._workbook(self.workbook)
        if self._type == 'comparisonWorkbook' and self.comparison_workbook is not None:
            return visitor._comparison_workbook(self.comparison_workbook)


scout_workbookcommon_api_UnifiedWorkbookContent.__name__ = "UnifiedWorkbookContent"
scout_workbookcommon_api_UnifiedWorkbookContent.__qualname__ = "UnifiedWorkbookContent"
scout_workbookcommon_api_UnifiedWorkbookContent.__module__ = "scout_service_api.scout_workbookcommon_api"


class scout_workbookcommon_api_UnifiedWorkbookContentVisitor:

    @abstractmethod
    def _workbook(self, workbook: "scout_workbookcommon_api_WorkbookContent") -> Any:
        pass

    @abstractmethod
    def _comparison_workbook(self, comparison_workbook: "scout_comparisonnotebook_api_ComparisonWorkbookContent") -> Any:
        pass


scout_workbookcommon_api_UnifiedWorkbookContentVisitor.__name__ = "UnifiedWorkbookContentVisitor"
scout_workbookcommon_api_UnifiedWorkbookContentVisitor.__qualname__ = "UnifiedWorkbookContentVisitor"
scout_workbookcommon_api_UnifiedWorkbookContentVisitor.__module__ = "scout_service_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookContent(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_variables': ConjureFieldDefinition('channelVariables', scout_channelvariables_api_WorkbookChannelVariableMap),
            'charts': ConjureFieldDefinition('charts', scout_chartdefinition_api_WorkbookChartDefinitionMap),
            'visualizations': ConjureFieldDefinition('visualizations', scout_chartdefinition_api_WorkbookVizDefinitionMap)
        }

    __slots__: List[str] = ['_channel_variables', '_charts', '_visualizations']

    def __init__(self, channel_variables: Dict[str, "scout_channelvariables_api_ChannelVariable"], charts: Dict[str, "scout_chartdefinition_api_VizDefinition"], visualizations: Dict[str, "scout_chartdefinition_api_VizDefinition"]) -> None:
        self._channel_variables = channel_variables
        self._charts = charts
        self._visualizations = visualizations

    @builtins.property
    def channel_variables(self) -> Dict[str, "scout_channelvariables_api_ChannelVariable"]:
        return self._channel_variables

    @builtins.property
    def charts(self) -> Dict[str, "scout_chartdefinition_api_VizDefinition"]:
        return self._charts

    @builtins.property
    def visualizations(self) -> Dict[str, "scout_chartdefinition_api_VizDefinition"]:
        """
        empty for now. All visualizations are still being returned in charts.
        """
        return self._visualizations


scout_workbookcommon_api_WorkbookContent.__name__ = "WorkbookContent"
scout_workbookcommon_api_WorkbookContent.__qualname__ = "WorkbookContent"
scout_workbookcommon_api_WorkbookContent.__module__ = "scout_service_api.scout_workbookcommon_api"


class secrets_api_ArchivedStatus(ConjureEnumType):

    NOT_ARCHIVED = 'NOT_ARCHIVED'
    '''NOT_ARCHIVED'''
    ARCHIVED = 'ARCHIVED'
    '''ARCHIVED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


secrets_api_ArchivedStatus.__name__ = "ArchivedStatus"
secrets_api_ArchivedStatus.__qualname__ = "ArchivedStatus"
secrets_api_ArchivedStatus.__module__ = "scout_service_api.secrets_api"


class secrets_api_CreateSecretRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', str),
            'decrypted_value': ConjureFieldDefinition('decryptedValue', str),
            'properties': ConjureFieldDefinition('properties', Dict[secrets_api_PropertyName, secrets_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[secrets_api_Label])
        }

    __slots__: List[str] = ['_name', '_description', '_decrypted_value', '_properties', '_labels']

    def __init__(self, decrypted_value: str, description: str, labels: List[str], name: str, properties: Dict[str, str]) -> None:
        self._name = name
        self._description = description
        self._decrypted_value = decrypted_value
        self._properties = properties
        self._labels = labels

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def decrypted_value(self) -> str:
        return self._decrypted_value

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


secrets_api_CreateSecretRequest.__name__ = "CreateSecretRequest"
secrets_api_CreateSecretRequest.__qualname__ = "CreateSecretRequest"
secrets_api_CreateSecretRequest.__module__ = "scout_service_api.secrets_api"


class secrets_api_GetSecretsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'secret_rids': ConjureFieldDefinition('secretRids', List[secrets_api_SecretRid])
        }

    __slots__: List[str] = ['_secret_rids']

    def __init__(self, secret_rids: List[str]) -> None:
        self._secret_rids = secret_rids

    @builtins.property
    def secret_rids(self) -> List[str]:
        return self._secret_rids


secrets_api_GetSecretsRequest.__name__ = "GetSecretsRequest"
secrets_api_GetSecretsRequest.__qualname__ = "GetSecretsRequest"
secrets_api_GetSecretsRequest.__module__ = "scout_service_api.secrets_api"


class secrets_api_GetSecretsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'response': ConjureFieldDefinition('response', List[secrets_api_Secret])
        }

    __slots__: List[str] = ['_response']

    def __init__(self, response: List["secrets_api_Secret"]) -> None:
        self._response = response

    @builtins.property
    def response(self) -> List["secrets_api_Secret"]:
        return self._response


secrets_api_GetSecretsResponse.__name__ = "GetSecretsResponse"
secrets_api_GetSecretsResponse.__qualname__ = "GetSecretsResponse"
secrets_api_GetSecretsResponse.__module__ = "scout_service_api.secrets_api"


class secrets_api_Property(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', secrets_api_PropertyName),
            'value': ConjureFieldDefinition('value', secrets_api_PropertyValue)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


secrets_api_Property.__name__ = "Property"
secrets_api_Property.__qualname__ = "Property"
secrets_api_Property.__module__ = "scout_service_api.secrets_api"


class secrets_api_SearchSecretsQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["secrets_api_Property"] = None
    _and_: Optional[List["secrets_api_SearchSecretsQuery"]] = None
    _or_: Optional[List["secrets_api_SearchSecretsQuery"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', secrets_api_Label),
            'property': ConjureFieldDefinition('property', secrets_api_Property),
            'and_': ConjureFieldDefinition('and', List[secrets_api_SearchSecretsQuery]),
            'or_': ConjureFieldDefinition('or', List[secrets_api_SearchSecretsQuery])
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["secrets_api_Property"] = None,
            and_: Optional[List["secrets_api_SearchSecretsQuery"]] = None,
            or_: Optional[List["secrets_api_SearchSecretsQuery"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["secrets_api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["secrets_api_SearchSecretsQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["secrets_api_SearchSecretsQuery"]]:
        return self._or_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, secrets_api_SearchSecretsQueryVisitor):
            raise ValueError('{} is not an instance of secrets_api_SearchSecretsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)


secrets_api_SearchSecretsQuery.__name__ = "SearchSecretsQuery"
secrets_api_SearchSecretsQuery.__qualname__ = "SearchSecretsQuery"
secrets_api_SearchSecretsQuery.__module__ = "scout_service_api.secrets_api"


class secrets_api_SearchSecretsQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "secrets_api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["secrets_api_SearchSecretsQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["secrets_api_SearchSecretsQuery"]) -> Any:
        pass


secrets_api_SearchSecretsQueryVisitor.__name__ = "SearchSecretsQueryVisitor"
secrets_api_SearchSecretsQueryVisitor.__qualname__ = "SearchSecretsQueryVisitor"
secrets_api_SearchSecretsQueryVisitor.__module__ = "scout_service_api.secrets_api"


class secrets_api_SearchSecretsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', secrets_api_SearchSecretsQuery),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'sort': ConjureFieldDefinition('sort', secrets_api_SortOptions),
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[secrets_api_Token]),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[secrets_api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_query', '_page_size', '_sort', '_token', '_archived_statuses']

    def __init__(self, query: "secrets_api_SearchSecretsQuery", sort: "secrets_api_SortOptions", archived_statuses: Optional[List["secrets_api_ArchivedStatus"]] = None, page_size: Optional[int] = None, token: Optional[str] = None) -> None:
        self._query = query
        self._page_size = page_size
        self._sort = sort
        self._token = token
        self._archived_statuses = archived_statuses

    @builtins.property
    def query(self) -> "secrets_api_SearchSecretsQuery":
        return self._query

    @builtins.property
    def page_size(self) -> Optional[int]:
        """
        Defaults to 100. Will throw if larger than 1000.
        """
        return self._page_size

    @builtins.property
    def sort(self) -> "secrets_api_SortOptions":
        return self._sort

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token

    @builtins.property
    def archived_statuses(self) -> Optional[List["secrets_api_ArchivedStatus"]]:
        """
        Default search status is NOT_ARCHIVED if none are provided. Allows for including archived secrets in search.
        """
        return self._archived_statuses


secrets_api_SearchSecretsRequest.__name__ = "SearchSecretsRequest"
secrets_api_SearchSecretsRequest.__qualname__ = "SearchSecretsRequest"
secrets_api_SearchSecretsRequest.__module__ = "scout_service_api.secrets_api"


class secrets_api_SearchSecretsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[secrets_api_Secret]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[secrets_api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["secrets_api_Secret"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["secrets_api_Secret"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


secrets_api_SearchSecretsResponse.__name__ = "SearchSecretsResponse"
secrets_api_SearchSecretsResponse.__qualname__ = "SearchSecretsResponse"
secrets_api_SearchSecretsResponse.__module__ = "scout_service_api.secrets_api"


class secrets_api_Secret(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', secrets_api_SecretRid),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', str),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'properties': ConjureFieldDefinition('properties', Dict[secrets_api_PropertyName, secrets_api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[secrets_api_Label]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_name', '_description', '_created_by', '_properties', '_labels', '_created_at', '_is_archived']

    def __init__(self, created_at: str, created_by: str, description: str, is_archived: bool, labels: List[str], name: str, properties: Dict[str, str], rid: str) -> None:
        self._rid = rid
        self._name = name
        self._description = description
        self._created_by = created_by
        self._properties = properties
        self._labels = labels
        self._created_at = created_at
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


secrets_api_Secret.__name__ = "Secret"
secrets_api_Secret.__qualname__ = "Secret"
secrets_api_Secret.__module__ = "scout_service_api.secrets_api"


class secrets_api_SecretService(Service):
    """
    The secrets service provides functionality for creating and retrieving customer secrets (e.g. influx passwords, API keys, etc)
    """

    def create(self, auth_header: str, request: "secrets_api_CreateSecretRequest") -> "secrets_api_Secret":
        """
        Create a new secret. The secret value is immutable after creation.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/secrets/v1/secrets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_Secret, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, rid: str) -> "secrets_api_Secret":
        """
        Get secret by rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/secrets/v1/secrets/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_Secret, self._return_none_for_unknown_union_types)

    def get_batch(self, auth_header: str, request: "secrets_api_GetSecretsRequest") -> "secrets_api_GetSecretsResponse":
        """
        Get secrets by a set of rids.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/secrets/v1/secrets/batch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_GetSecretsResponse, self._return_none_for_unknown_union_types)

    def update(self, auth_header: str, request: "secrets_api_UpdateSecretRequest", rid: str) -> "secrets_api_Secret":
        """
        Update a secret by rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/secrets/v1/secrets/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_Secret, self._return_none_for_unknown_union_types)

    def delete(self, auth_header: str, rid: str) -> None:
        """
        Delete a secret by rid. This is a permanent deletion. To perform a soft delete,
use the archive endpoint.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/secrets/v1/secrets/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def archive(self, auth_header: str, rid: str) -> None:
        """
        Archive a secret by rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/secrets/v1/secrets/{rid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, rid: str) -> None:
        """
        Unarchive a secret by rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/secrets/v1/secrets/{rid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def search(self, auth_header: str, request: "secrets_api_SearchSecretsRequest") -> "secrets_api_SearchSecretsResponse":
        """
        Returns metadata about secrets that match a given query.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/secrets/v1/secrets/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_SearchSecretsResponse, self._return_none_for_unknown_union_types)


secrets_api_SecretService.__name__ = "SecretService"
secrets_api_SecretService.__qualname__ = "SecretService"
secrets_api_SecretService.__module__ = "scout_service_api.secrets_api"


class secrets_api_SortField(ConjureEnumType):

    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


secrets_api_SortField.__name__ = "SortField"
secrets_api_SortField.__qualname__ = "SortField"
secrets_api_SortField.__module__ = "scout_service_api.secrets_api"


class secrets_api_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', secrets_api_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "secrets_api_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "secrets_api_SortField":
        return self._field


secrets_api_SortOptions.__name__ = "SortOptions"
secrets_api_SortOptions.__qualname__ = "SortOptions"
secrets_api_SortOptions.__module__ = "scout_service_api.secrets_api"


class secrets_api_UpdateSecretRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[secrets_api_PropertyName, secrets_api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[secrets_api_Label]])
        }

    __slots__: List[str] = ['_name', '_description', '_properties', '_labels']

    def __init__(self, description: Optional[str] = None, labels: Optional[List[str]] = None, name: Optional[str] = None, properties: Optional[Dict[str, str]] = None) -> None:
        self._name = name
        self._description = description
        self._properties = properties
        self._labels = labels

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels


secrets_api_UpdateSecretRequest.__name__ = "UpdateSecretRequest"
secrets_api_UpdateSecretRequest.__qualname__ = "UpdateSecretRequest"
secrets_api_UpdateSecretRequest.__module__ = "scout_service_api.secrets_api"


class storage_datasource_api_CreateNominalDataSourceRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', storage_datasource_api_NominalDataSourceId),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_id', '_description']

    def __init__(self, id: str, description: Optional[str] = None) -> None:
        self._id = id
        self._description = description

    @builtins.property
    def id(self) -> str:
        """
        A human readable identifier. Must be unique within an organization.
        """
        return self._id

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description


storage_datasource_api_CreateNominalDataSourceRequest.__name__ = "CreateNominalDataSourceRequest"
storage_datasource_api_CreateNominalDataSourceRequest.__qualname__ = "CreateNominalDataSourceRequest"
storage_datasource_api_CreateNominalDataSourceRequest.__module__ = "scout_service_api.storage_datasource_api"


class storage_datasource_api_NominalDataSource(ConjureBeanType):
    """
    A logical grouping of series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', storage_datasource_api_NominalDataSourceRid),
            'id': ConjureFieldDefinition('id', storage_datasource_api_NominalDataSourceId),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'data_last_written_at': ConjureFieldDefinition('dataLastWrittenAt', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_rid', '_id', '_description', '_data_last_written_at']

    def __init__(self, id: str, rid: str, data_last_written_at: Optional[str] = None, description: Optional[str] = None) -> None:
        self._rid = rid
        self._id = id
        self._description = description
        self._data_last_written_at = data_last_written_at

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def data_last_written_at(self) -> Optional[str]:
        """
        Returns the approximate timestamp at which data was written to the data source.
Will be accurate to within 1 minute.
        """
        return self._data_last_written_at


storage_datasource_api_NominalDataSource.__name__ = "NominalDataSource"
storage_datasource_api_NominalDataSource.__qualname__ = "NominalDataSource"
storage_datasource_api_NominalDataSource.__module__ = "scout_service_api.storage_datasource_api"


class storage_datasource_api_NominalDataSourceService(Service):
    """
    Manages data sources (logical groupings of series) that are stored by Nominal.
    """

    def create(self, auth_header: str, request: "storage_datasource_api_CreateNominalDataSourceRequest") -> "storage_datasource_api_NominalDataSource":
        """
        Creates a data source.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/storage/data-source/v1'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), storage_datasource_api_NominalDataSource, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, rids: List[str] = None) -> List["storage_datasource_api_NominalDataSource"]:
        """
        Retrieves the data sources for the given data source RIDs.

Excludes data sources that do not exist or are unauthorized. A maximum of 1000 rids can be requested.
        """
        rids = rids if rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(rids)

        _path = '/storage/data-source/v1/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[storage_datasource_api_NominalDataSource], self._return_none_for_unknown_union_types)

    def update_last_written_timestamp(self, auth_header: str, rid: str, timestamp: str) -> None:
        """
        Sets the timestamp that the Nominal Data Source in question was last written to. Only needs to be called once per minute.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(timestamp)

        _path = '/storage/data-source/v1/{rid}/last-written'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


storage_datasource_api_NominalDataSourceService.__name__ = "NominalDataSourceService"
storage_datasource_api_NominalDataSourceService.__qualname__ = "NominalDataSourceService"
storage_datasource_api_NominalDataSourceService.__module__ = "scout_service_api.storage_datasource_api"


class storage_series_api_CreateSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'type': ConjureFieldDefinition('type', storage_series_api_NominalDataType),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', storage_datasource_api_NominalDataSourceRid),
            'channel': ConjureFieldDefinition('channel', storage_series_api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_type', '_data_source_rid', '_channel', '_tags']

    def __init__(self, channel: str, data_source_rid: str, tags: Dict[str, str], type: "storage_series_api_NominalDataType") -> None:
        self._type = type
        self._data_source_rid = data_source_rid
        self._channel = channel
        self._tags = tags

    @builtins.property
    def type(self) -> "storage_series_api_NominalDataType":
        return self._type

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags


storage_series_api_CreateSeriesRequest.__name__ = "CreateSeriesRequest"
storage_series_api_CreateSeriesRequest.__qualname__ = "CreateSeriesRequest"
storage_series_api_CreateSeriesRequest.__module__ = "scout_service_api.storage_series_api"


class storage_series_api_NominalDataType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


storage_series_api_NominalDataType.__name__ = "NominalDataType"
storage_series_api_NominalDataType.__qualname__ = "NominalDataType"
storage_series_api_NominalDataType.__module__ = "scout_service_api.storage_series_api"


class storage_series_api_NominalSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', storage_series_api_NominalSeriesRid),
            'type': ConjureFieldDefinition('type', storage_series_api_NominalDataType),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', storage_datasource_api_NominalDataSourceRid),
            'channel': ConjureFieldDefinition('channel', storage_series_api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_rid', '_type', '_data_source_rid', '_channel', '_tags']

    def __init__(self, channel: str, data_source_rid: str, rid: str, tags: Dict[str, str], type: "storage_series_api_NominalDataType") -> None:
        self._rid = rid
        self._type = type
        self._data_source_rid = data_source_rid
        self._channel = channel
        self._tags = tags

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def type(self) -> "storage_series_api_NominalDataType":
        return self._type

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags


storage_series_api_NominalSeries.__name__ = "NominalSeries"
storage_series_api_NominalSeries.__qualname__ = "NominalSeries"
storage_series_api_NominalSeries.__module__ = "scout_service_api.storage_series_api"


class storage_series_api_NominalSeriesService(Service):
    """
    Create and fetch series stored by Nominal
    """

    def get(self, auth_header: str, rid: str) -> "storage_series_api_NominalSeries":
        """
        Retrieves a series for the given series RID.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/storage/series/v1/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), storage_series_api_NominalSeries, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, rids: List[str] = None) -> List["storage_series_api_NominalSeries"]:
        """
        Retrieves series for the given series RIDs.
Excludes series that do not exist or are unauthorized. A maximum of 1000 rids can be requested.
        """
        rids = rids if rids is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(rids)

        _path = '/storage/series/v1/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[storage_series_api_NominalSeries], self._return_none_for_unknown_union_types)

    def create_or_get(self, auth_header: str, request: "storage_series_api_CreateSeriesRequest") -> "storage_series_api_NominalSeries":
        """
        Creates a new series if it doesn't already exist.

A series exists if there is already a series with the same channel name and tag values in the data source.
Returns the series that was created or the existing series.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/storage/series/v1'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), storage_series_api_NominalSeries, self._return_none_for_unknown_union_types)

    def batch_create_or_get(self, auth_header: str, request: List["storage_series_api_CreateSeriesRequest"] = None) -> List["storage_series_api_NominalSeries"]:
        """
        Creates new series if they don't already exist.

A series exists if there is already a series with the same channel name and tag values in the data source.
Returns series that were created and any existing series.
        """
        request = request if request is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/storage/series/v1/batch-create'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[storage_series_api_NominalSeries], self._return_none_for_unknown_union_types)

    def search(self, auth_header: str, request: "storage_series_api_SearchSeriesRequest") -> "storage_series_api_SearchSeriesResponse":
        """
        Retrieves series that match the search query.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/storage/series/v1/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), storage_series_api_SearchSeriesResponse, self._return_none_for_unknown_union_types)


storage_series_api_NominalSeriesService.__name__ = "NominalSeriesService"
storage_series_api_NominalSeriesService.__qualname__ = "NominalSeriesService"
storage_series_api_NominalSeriesService.__module__ = "scout_service_api.storage_series_api"


class storage_series_api_SearchSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', storage_series_api_Channel),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', storage_datasource_api_NominalDataSourceRid),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_channel', '_data_source_rid', '_tags']

    def __init__(self, channel: str, data_source_rid: str, tags: Dict[str, str]) -> None:
        self._channel = channel
        self._data_source_rid = data_source_rid
        self._tags = tags

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def tags(self) -> Dict[str, str]:
        """
        Returns all series that contain this set of tags, including those
whose tags are a superset.
        """
        return self._tags


storage_series_api_SearchSeriesRequest.__name__ = "SearchSeriesRequest"
storage_series_api_SearchSeriesRequest.__qualname__ = "SearchSeriesRequest"
storage_series_api_SearchSeriesRequest.__module__ = "scout_service_api.storage_series_api"


class storage_series_api_SearchSeriesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', List[storage_series_api_NominalSeries])
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: List["storage_series_api_NominalSeries"]) -> None:
        self._series = series

    @builtins.property
    def series(self) -> List["storage_series_api_NominalSeries"]:
        return self._series


storage_series_api_SearchSeriesResponse.__name__ = "SearchSeriesResponse"
storage_series_api_SearchSeriesResponse.__qualname__ = "SearchSeriesResponse"
storage_series_api_SearchSeriesResponse.__module__ = "scout_service_api.storage_series_api"


class storage_writer_api_DoublePoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', float)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: float) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> float:
        return self._value


storage_writer_api_DoublePoint.__name__ = "DoublePoint"
storage_writer_api_DoublePoint.__qualname__ = "DoublePoint"
storage_writer_api_DoublePoint.__module__ = "scout_service_api.storage_writer_api"


class storage_writer_api_NominalChannelWriterService(Service):
    """
    Write data points to Nominal data sources.
    """

    def write_batches(self, auth_header: str, request: "storage_writer_api_WriteBatchesRequest") -> None:
        """
        Synchronously writes batches of records to a Nominal data source.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/storage/writer/v1'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def write_telegraf_batches(self, auth_header: str, data_source_rid: str, request: "storage_writer_api_WriteTelegrafBatchesRequest") -> None:
        """
        Synchronously writes batches of records to a Nominal data source.

Has the same functionality as writeBatches, but is compatible with the Telegraf output format.
Assumes that the Telegraf batch format is used. Timestamp is assumed to be in nanoseconds.
The URL in the Telegraf output plugin configuration should be the fully qualified URL,
including the dataSourceRid query parameter.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'dataSourceRid': data_source_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/storage/writer/v1/telegraf/{dataSourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


storage_writer_api_NominalChannelWriterService.__name__ = "NominalChannelWriterService"
storage_writer_api_NominalChannelWriterService.__qualname__ = "NominalChannelWriterService"
storage_writer_api_NominalChannelWriterService.__module__ = "scout_service_api.storage_writer_api"


class storage_writer_api_Points(ConjureUnionType):
    _string: Optional[List["storage_writer_api_StringPoint"]] = None
    _double: Optional[List["storage_writer_api_DoublePoint"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'string': ConjureFieldDefinition('string', List[storage_writer_api_StringPoint]),
            'double': ConjureFieldDefinition('double', List[storage_writer_api_DoublePoint])
        }

    def __init__(
            self,
            string: Optional[List["storage_writer_api_StringPoint"]] = None,
            double: Optional[List["storage_writer_api_DoublePoint"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (string is not None) + (double is not None) != 1:
                raise ValueError('a union must contain a single member')

            if string is not None:
                self._string = string
                self._type = 'string'
            if double is not None:
                self._double = double
                self._type = 'double'

        elif type_of_union == 'string':
            if string is None:
                raise ValueError('a union value must not be None')
            self._string = string
            self._type = 'string'
        elif type_of_union == 'double':
            if double is None:
                raise ValueError('a union value must not be None')
            self._double = double
            self._type = 'double'

    @builtins.property
    def string(self) -> Optional[List["storage_writer_api_StringPoint"]]:
        return self._string

    @builtins.property
    def double(self) -> Optional[List["storage_writer_api_DoublePoint"]]:
        return self._double

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, storage_writer_api_PointsVisitor):
            raise ValueError('{} is not an instance of storage_writer_api_PointsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'string' and self.string is not None:
            return visitor._string(self.string)
        if self._type == 'double' and self.double is not None:
            return visitor._double(self.double)


storage_writer_api_Points.__name__ = "Points"
storage_writer_api_Points.__qualname__ = "Points"
storage_writer_api_Points.__module__ = "scout_service_api.storage_writer_api"


class storage_writer_api_PointsVisitor:

    @abstractmethod
    def _string(self, string: List["storage_writer_api_StringPoint"]) -> Any:
        pass

    @abstractmethod
    def _double(self, double: List["storage_writer_api_DoublePoint"]) -> Any:
        pass


storage_writer_api_PointsVisitor.__name__ = "PointsVisitor"
storage_writer_api_PointsVisitor.__qualname__ = "PointsVisitor"
storage_writer_api_PointsVisitor.__module__ = "scout_service_api.storage_writer_api"


class storage_writer_api_RecordsBatch(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', storage_series_api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'points': ConjureFieldDefinition('points', storage_writer_api_Points)
        }

    __slots__: List[str] = ['_channel', '_tags', '_points']

    def __init__(self, channel: str, points: "storage_writer_api_Points", tags: Dict[str, str]) -> None:
        self._channel = channel
        self._tags = tags
        self._points = points

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def points(self) -> "storage_writer_api_Points":
        return self._points


storage_writer_api_RecordsBatch.__name__ = "RecordsBatch"
storage_writer_api_RecordsBatch.__qualname__ = "RecordsBatch"
storage_writer_api_RecordsBatch.__module__ = "scout_service_api.storage_writer_api"


class storage_writer_api_StringPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: str) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> str:
        return self._value


storage_writer_api_StringPoint.__name__ = "StringPoint"
storage_writer_api_StringPoint.__qualname__ = "StringPoint"
storage_writer_api_StringPoint.__module__ = "scout_service_api.storage_writer_api"


class storage_writer_api_TelegrafMetric(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fields': ConjureFieldDefinition('fields', Dict[storage_writer_api_Field, object]),
            'name': ConjureFieldDefinition('name', storage_writer_api_MeasurementName),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'timestamp': ConjureFieldDefinition('timestamp', object)
        }

    __slots__: List[str] = ['_fields_', '_name', '_tags', '_timestamp']

    def __init__(self, fields: Dict[str, Any], name: str, tags: Dict[str, str], timestamp: Any) -> None:
        self._fields_ = fields
        self._name = name
        self._tags = tags
        self._timestamp = timestamp

    @builtins.property
    def fields(self) -> Dict[str, Any]:
        """
        The values are expected to be either numeric or string values
        """
        return self._fields_

    @builtins.property
    def name(self) -> str:
        """
        The measurement name. Measurement name and field are concatenated when creating the Nominal channel name.
        """
        return self._name

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def timestamp(self) -> Any:
        return self._timestamp


storage_writer_api_TelegrafMetric.__name__ = "TelegrafMetric"
storage_writer_api_TelegrafMetric.__qualname__ = "TelegrafMetric"
storage_writer_api_TelegrafMetric.__module__ = "scout_service_api.storage_writer_api"


class storage_writer_api_WriteBatchesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'batches': ConjureFieldDefinition('batches', List[storage_writer_api_RecordsBatch]),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', storage_datasource_api_NominalDataSourceRid)
        }

    __slots__: List[str] = ['_batches', '_data_source_rid']

    def __init__(self, batches: List["storage_writer_api_RecordsBatch"], data_source_rid: str) -> None:
        self._batches = batches
        self._data_source_rid = data_source_rid

    @builtins.property
    def batches(self) -> List["storage_writer_api_RecordsBatch"]:
        return self._batches

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid


storage_writer_api_WriteBatchesRequest.__name__ = "WriteBatchesRequest"
storage_writer_api_WriteBatchesRequest.__qualname__ = "WriteBatchesRequest"
storage_writer_api_WriteBatchesRequest.__module__ = "scout_service_api.storage_writer_api"


class storage_writer_api_WriteTelegrafBatchesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'metrics': ConjureFieldDefinition('metrics', List[storage_writer_api_TelegrafMetric])
        }

    __slots__: List[str] = ['_metrics']

    def __init__(self, metrics: List["storage_writer_api_TelegrafMetric"]) -> None:
        self._metrics = metrics

    @builtins.property
    def metrics(self) -> List["storage_writer_api_TelegrafMetric"]:
        return self._metrics


storage_writer_api_WriteTelegrafBatchesRequest.__name__ = "WriteTelegrafBatchesRequest"
storage_writer_api_WriteTelegrafBatchesRequest.__qualname__ = "WriteTelegrafBatchesRequest"
storage_writer_api_WriteTelegrafBatchesRequest.__module__ = "scout_service_api.storage_writer_api"


class timeseries_archetype_SeriesArchetypeService(Service):
    """
    [INTERNAL]
A series archetype represents the constant information about data in a series - specifically, the name, units, a
description, and the tags. Series archetypes can be used to query points from specific series depending on the tag
value selections.
    """

    def batch_get(self, auth_header: str, request: "timeseries_archetype_api_BatchGetSeriesArchetypeRequest") -> "timeseries_archetype_api_BatchGetSeriesArchetypeResponse":
        """
        Batch get series archetypes by DataSourceRid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/archetype/v1/series-archetype/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_archetype_api_BatchGetSeriesArchetypeResponse, self._return_none_for_unknown_union_types)

    def create(self, auth_header: str, request: "timeseries_archetype_api_CreateSeriesArchetypeRequest") -> "timeseries_archetype_api_SeriesArchetype":
        """
        Create a new series archetype. If a series archetype already exists with the same channel and data 
source, the existing series archetype will be returned.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/archetype/v1/series-archetype'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_archetype_api_SeriesArchetype, self._return_none_for_unknown_union_types)

    def batch_create(self, auth_header: str, request: "timeseries_archetype_api_BatchCreateSeriesArchetypeRequest") -> "timeseries_archetype_api_BatchCreateSeriesArchetypeResponse":
        """
        Idempotently creates series archetypes. If a series archetype already exists with the same channel and data 
source, the existing series archetype will be returned.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/archetype/v1/series-archetype/batch-create'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_archetype_api_BatchCreateSeriesArchetypeResponse, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, rid: str) -> "timeseries_archetype_api_SeriesArchetype":
        """
        Get a series archetype from its series archetype rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/timeseries/archetype/v1/series-archetype/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_archetype_api_SeriesArchetype, self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "timeseries_archetype_api_UpdateSeriesArchetypeMetadataRequest", rid: str) -> "timeseries_archetype_api_SeriesArchetype":
        """
        Update the metadata on an existing series archetype. 
Throws SeriesArchetypeNotFound if the series archetype does not exist.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/archetype/v1/series-archetype/{rid}/metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_archetype_api_SeriesArchetype, self._return_none_for_unknown_union_types)


timeseries_archetype_SeriesArchetypeService.__name__ = "SeriesArchetypeService"
timeseries_archetype_SeriesArchetypeService.__qualname__ = "SeriesArchetypeService"
timeseries_archetype_SeriesArchetypeService.__module__ = "scout_service_api.timeseries_archetype"


class timeseries_archetype_api_BatchCreateSeriesArchetypeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_archetype_api_CreateSeriesArchetypeRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_archetype_api_CreateSeriesArchetypeRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_archetype_api_CreateSeriesArchetypeRequest"]:
        return self._requests


timeseries_archetype_api_BatchCreateSeriesArchetypeRequest.__name__ = "BatchCreateSeriesArchetypeRequest"
timeseries_archetype_api_BatchCreateSeriesArchetypeRequest.__qualname__ = "BatchCreateSeriesArchetypeRequest"
timeseries_archetype_api_BatchCreateSeriesArchetypeRequest.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_BatchCreateSeriesArchetypeResponse(ConjureBeanType):
    """
    Returns responses in the same order as requests.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[timeseries_archetype_api_SeriesArchetype])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["timeseries_archetype_api_SeriesArchetype"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["timeseries_archetype_api_SeriesArchetype"]:
        return self._responses


timeseries_archetype_api_BatchCreateSeriesArchetypeResponse.__name__ = "BatchCreateSeriesArchetypeResponse"
timeseries_archetype_api_BatchCreateSeriesArchetypeResponse.__qualname__ = "BatchCreateSeriesArchetypeResponse"
timeseries_archetype_api_BatchCreateSeriesArchetypeResponse.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_BatchGetSeriesArchetypeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'datasources': ConjureFieldDefinition('datasources', List[timeseries_logicalseries_api_DataSourceRid])
        }

    __slots__: List[str] = ['_datasources']

    def __init__(self, datasources: List[str]) -> None:
        self._datasources = datasources

    @builtins.property
    def datasources(self) -> List[str]:
        return self._datasources


timeseries_archetype_api_BatchGetSeriesArchetypeRequest.__name__ = "BatchGetSeriesArchetypeRequest"
timeseries_archetype_api_BatchGetSeriesArchetypeRequest.__qualname__ = "BatchGetSeriesArchetypeRequest"
timeseries_archetype_api_BatchGetSeriesArchetypeRequest.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_BatchGetSeriesArchetypeResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', Dict[timeseries_logicalseries_api_DataSourceRid, List[timeseries_archetype_api_SeriesArchetype]])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: Dict[str, List["timeseries_archetype_api_SeriesArchetype"]]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> Dict[str, List["timeseries_archetype_api_SeriesArchetype"]]:
        return self._responses


timeseries_archetype_api_BatchGetSeriesArchetypeResponse.__name__ = "BatchGetSeriesArchetypeResponse"
timeseries_archetype_api_BatchGetSeriesArchetypeResponse.__qualname__ = "BatchGetSeriesArchetypeResponse"
timeseries_archetype_api_BatchGetSeriesArchetypeResponse.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_CreateSeriesArchetypeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', timeseries_logicalseries_api_Channel),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', timeseries_logicalseries_api_DataSourceRid),
            'locator': ConjureFieldDefinition('locator', timeseries_archetype_api_LocatorTemplate),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[timeseries_logicalseries_api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_channel', '_data_source_rid', '_locator', '_unit', '_description', '_tags']

    def __init__(self, channel: str, data_source_rid: str, locator: "timeseries_archetype_api_LocatorTemplate", tags: Dict[str, str], description: Optional[str] = None, unit: Optional[str] = None) -> None:
        self._channel = channel
        self._data_source_rid = data_source_rid
        self._locator = locator
        self._unit = unit
        self._description = description
        self._tags = tags

    @builtins.property
    def channel(self) -> str:
        """
        This name should be unique amongst SeriesArchetypes within the data source. All series created from this
archetype will share this name.
        """
        return self._channel

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def locator(self) -> "timeseries_archetype_api_LocatorTemplate":
        return self._locator

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def tags(self) -> Dict[str, str]:
        """
        Tags specified here will take precedence over tags specified in the RunDatasource, in the case that both specify the same TagName.
        """
        return self._tags


timeseries_archetype_api_CreateSeriesArchetypeRequest.__name__ = "CreateSeriesArchetypeRequest"
timeseries_archetype_api_CreateSeriesArchetypeRequest.__qualname__ = "CreateSeriesArchetypeRequest"
timeseries_archetype_api_CreateSeriesArchetypeRequest.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_Influx1LocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'database': ConjureFieldDefinition('database', timeseries_logicalseries_api_DatabaseName),
            'measurement': ConjureFieldDefinition('measurement', timeseries_logicalseries_api_MeasurementName),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_InfluxType)
        }

    __slots__: List[str] = ['_database', '_measurement', '_field', '_type']

    def __init__(self, database: str, field: str, measurement: str, type: "timeseries_logicalseries_api_InfluxType") -> None:
        self._database = database
        self._measurement = measurement
        self._field = field
        self._type = type

    @builtins.property
    def database(self) -> str:
        return self._database

    @builtins.property
    def measurement(self) -> str:
        return self._measurement

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_InfluxType":
        return self._type


timeseries_archetype_api_Influx1LocatorTemplate.__name__ = "Influx1LocatorTemplate"
timeseries_archetype_api_Influx1LocatorTemplate.__qualname__ = "Influx1LocatorTemplate"
timeseries_archetype_api_Influx1LocatorTemplate.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_Influx2LocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket': ConjureFieldDefinition('bucket', timeseries_logicalseries_api_BucketName),
            'measurement': ConjureFieldDefinition('measurement', timeseries_logicalseries_api_MeasurementName),
            'value_column': ConjureFieldDefinition('valueColumn', OptionalTypeWrapper[str]),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_InfluxType)
        }

    __slots__: List[str] = ['_bucket', '_measurement', '_value_column', '_field', '_type']

    def __init__(self, bucket: str, field: str, measurement: str, type: "timeseries_logicalseries_api_InfluxType", value_column: Optional[str] = None) -> None:
        self._bucket = bucket
        self._measurement = measurement
        self._value_column = value_column
        self._field = field
        self._type = type

    @builtins.property
    def bucket(self) -> str:
        return self._bucket

    @builtins.property
    def measurement(self) -> str:
        return self._measurement

    @builtins.property
    def value_column(self) -> Optional[str]:
        """
        If omitted, defaults to `_value`. Can be used to extract tag values.
        """
        return self._value_column

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_InfluxType":
        return self._type


timeseries_archetype_api_Influx2LocatorTemplate.__name__ = "Influx2LocatorTemplate"
timeseries_archetype_api_Influx2LocatorTemplate.__qualname__ = "Influx2LocatorTemplate"
timeseries_archetype_api_Influx2LocatorTemplate.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_LocatorTemplate(ConjureUnionType):
    _timescale_db: Optional["timeseries_archetype_api_TimescaleDbLocatorTemplate"] = None
    _influx: Optional["timeseries_archetype_api_Influx2LocatorTemplate"] = None
    _influx1: Optional["timeseries_archetype_api_Influx1LocatorTemplate"] = None
    _nominal: Optional["timeseries_archetype_api_NominalLocatorTemplate"] = None
    _timestream: Optional["timeseries_archetype_api_TimestreamLocatorTemplate"] = None
    _visual_crossing: Optional["timeseries_archetype_api_VisualCrossingLocatorTemplate"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timescale_db': ConjureFieldDefinition('timescaleDb', timeseries_archetype_api_TimescaleDbLocatorTemplate),
            'influx': ConjureFieldDefinition('influx', timeseries_archetype_api_Influx2LocatorTemplate),
            'influx1': ConjureFieldDefinition('influx1', timeseries_archetype_api_Influx1LocatorTemplate),
            'nominal': ConjureFieldDefinition('nominal', timeseries_archetype_api_NominalLocatorTemplate),
            'timestream': ConjureFieldDefinition('timestream', timeseries_archetype_api_TimestreamLocatorTemplate),
            'visual_crossing': ConjureFieldDefinition('visualCrossing', timeseries_archetype_api_VisualCrossingLocatorTemplate)
        }

    def __init__(
            self,
            timescale_db: Optional["timeseries_archetype_api_TimescaleDbLocatorTemplate"] = None,
            influx: Optional["timeseries_archetype_api_Influx2LocatorTemplate"] = None,
            influx1: Optional["timeseries_archetype_api_Influx1LocatorTemplate"] = None,
            nominal: Optional["timeseries_archetype_api_NominalLocatorTemplate"] = None,
            timestream: Optional["timeseries_archetype_api_TimestreamLocatorTemplate"] = None,
            visual_crossing: Optional["timeseries_archetype_api_VisualCrossingLocatorTemplate"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (timescale_db is not None) + (influx is not None) + (influx1 is not None) + (nominal is not None) + (timestream is not None) + (visual_crossing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if timescale_db is not None:
                self._timescale_db = timescale_db
                self._type = 'timescaleDb'
            if influx is not None:
                self._influx = influx
                self._type = 'influx'
            if influx1 is not None:
                self._influx1 = influx1
                self._type = 'influx1'
            if nominal is not None:
                self._nominal = nominal
                self._type = 'nominal'
            if timestream is not None:
                self._timestream = timestream
                self._type = 'timestream'
            if visual_crossing is not None:
                self._visual_crossing = visual_crossing
                self._type = 'visualCrossing'

        elif type_of_union == 'timescaleDb':
            if timescale_db is None:
                raise ValueError('a union value must not be None')
            self._timescale_db = timescale_db
            self._type = 'timescaleDb'
        elif type_of_union == 'influx':
            if influx is None:
                raise ValueError('a union value must not be None')
            self._influx = influx
            self._type = 'influx'
        elif type_of_union == 'influx1':
            if influx1 is None:
                raise ValueError('a union value must not be None')
            self._influx1 = influx1
            self._type = 'influx1'
        elif type_of_union == 'nominal':
            if nominal is None:
                raise ValueError('a union value must not be None')
            self._nominal = nominal
            self._type = 'nominal'
        elif type_of_union == 'timestream':
            if timestream is None:
                raise ValueError('a union value must not be None')
            self._timestream = timestream
            self._type = 'timestream'
        elif type_of_union == 'visualCrossing':
            if visual_crossing is None:
                raise ValueError('a union value must not be None')
            self._visual_crossing = visual_crossing
            self._type = 'visualCrossing'

    @builtins.property
    def timescale_db(self) -> Optional["timeseries_archetype_api_TimescaleDbLocatorTemplate"]:
        return self._timescale_db

    @builtins.property
    def influx(self) -> Optional["timeseries_archetype_api_Influx2LocatorTemplate"]:
        return self._influx

    @builtins.property
    def influx1(self) -> Optional["timeseries_archetype_api_Influx1LocatorTemplate"]:
        return self._influx1

    @builtins.property
    def nominal(self) -> Optional["timeseries_archetype_api_NominalLocatorTemplate"]:
        return self._nominal

    @builtins.property
    def timestream(self) -> Optional["timeseries_archetype_api_TimestreamLocatorTemplate"]:
        return self._timestream

    @builtins.property
    def visual_crossing(self) -> Optional["timeseries_archetype_api_VisualCrossingLocatorTemplate"]:
        return self._visual_crossing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_archetype_api_LocatorTemplateVisitor):
            raise ValueError('{} is not an instance of timeseries_archetype_api_LocatorTemplateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timescaleDb' and self.timescale_db is not None:
            return visitor._timescale_db(self.timescale_db)
        if self._type == 'influx' and self.influx is not None:
            return visitor._influx(self.influx)
        if self._type == 'influx1' and self.influx1 is not None:
            return visitor._influx1(self.influx1)
        if self._type == 'nominal' and self.nominal is not None:
            return visitor._nominal(self.nominal)
        if self._type == 'timestream' and self.timestream is not None:
            return visitor._timestream(self.timestream)
        if self._type == 'visualCrossing' and self.visual_crossing is not None:
            return visitor._visual_crossing(self.visual_crossing)


timeseries_archetype_api_LocatorTemplate.__name__ = "LocatorTemplate"
timeseries_archetype_api_LocatorTemplate.__qualname__ = "LocatorTemplate"
timeseries_archetype_api_LocatorTemplate.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_LocatorTemplateVisitor:

    @abstractmethod
    def _timescale_db(self, timescale_db: "timeseries_archetype_api_TimescaleDbLocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _influx(self, influx: "timeseries_archetype_api_Influx2LocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _influx1(self, influx1: "timeseries_archetype_api_Influx1LocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _nominal(self, nominal: "timeseries_archetype_api_NominalLocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _timestream(self, timestream: "timeseries_archetype_api_TimestreamLocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _visual_crossing(self, visual_crossing: "timeseries_archetype_api_VisualCrossingLocatorTemplate") -> Any:
        pass


timeseries_archetype_api_LocatorTemplateVisitor.__name__ = "LocatorTemplateVisitor"
timeseries_archetype_api_LocatorTemplateVisitor.__qualname__ = "LocatorTemplateVisitor"
timeseries_archetype_api_LocatorTemplateVisitor.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_NominalLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', timeseries_logicalseries_api_Channel),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_NominalType)
        }

    __slots__: List[str] = ['_channel', '_type']

    def __init__(self, channel: str, type: "timeseries_logicalseries_api_NominalType") -> None:
        self._channel = channel
        self._type = type

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_NominalType":
        return self._type


timeseries_archetype_api_NominalLocatorTemplate.__name__ = "NominalLocatorTemplate"
timeseries_archetype_api_NominalLocatorTemplate.__qualname__ = "NominalLocatorTemplate"
timeseries_archetype_api_NominalLocatorTemplate.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_SeriesArchetype(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', timeseries_archetype_api_SeriesArchetypeRid),
            'channel': ConjureFieldDefinition('channel', timeseries_logicalseries_api_Channel),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', timeseries_logicalseries_api_DataSourceRid),
            'locator': ConjureFieldDefinition('locator', timeseries_archetype_api_LocatorTemplate),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[timeseries_logicalseries_api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'series_data_type': ConjureFieldDefinition('seriesDataType', OptionalTypeWrapper[timeseries_logicalseries_api_SeriesDataType])
        }

    __slots__: List[str] = ['_rid', '_channel', '_data_source_rid', '_locator', '_unit', '_description', '_tags', '_series_data_type']

    def __init__(self, channel: str, data_source_rid: str, locator: "timeseries_archetype_api_LocatorTemplate", rid: str, tags: Dict[str, str], description: Optional[str] = None, series_data_type: Optional["timeseries_logicalseries_api_SeriesDataType"] = None, unit: Optional[str] = None) -> None:
        self._rid = rid
        self._channel = channel
        self._data_source_rid = data_source_rid
        self._locator = locator
        self._unit = unit
        self._description = description
        self._tags = tags
        self._series_data_type = series_data_type

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def locator(self) -> "timeseries_archetype_api_LocatorTemplate":
        return self._locator

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def tags(self) -> Dict[str, str]:
        """
        Tags specified here will take precedence over tags specified in the RunDatasource, in the case that both specify the same TagName.
        """
        return self._tags

    @builtins.property
    def series_data_type(self) -> Optional["timeseries_logicalseries_api_SeriesDataType"]:
        return self._series_data_type


timeseries_archetype_api_SeriesArchetype.__name__ = "SeriesArchetype"
timeseries_archetype_api_SeriesArchetype.__qualname__ = "SeriesArchetype"
timeseries_archetype_api_SeriesArchetype.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_TimescaleDbLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', timeseries_logicalseries_api_TableName),
            'schema': ConjureFieldDefinition('schema', timeseries_logicalseries_api_SchemaName),
            'column': ConjureFieldDefinition('column', timeseries_logicalseries_api_ColumnName),
            'time_column': ConjureFieldDefinition('timeColumn', timeseries_logicalseries_api_ColumnName),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_TimescaleType)
        }

    __slots__: List[str] = ['_table', '_schema', '_column', '_time_column', '_type']

    def __init__(self, column: str, schema: str, table: str, time_column: str, type: "timeseries_logicalseries_api_TimescaleType") -> None:
        self._table = table
        self._schema = schema
        self._column = column
        self._time_column = time_column
        self._type = type

    @builtins.property
    def table(self) -> str:
        return self._table

    @builtins.property
    def schema(self) -> str:
        return self._schema

    @builtins.property
    def column(self) -> str:
        return self._column

    @builtins.property
    def time_column(self) -> str:
        return self._time_column

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_TimescaleType":
        return self._type


timeseries_archetype_api_TimescaleDbLocatorTemplate.__name__ = "TimescaleDbLocatorTemplate"
timeseries_archetype_api_TimescaleDbLocatorTemplate.__qualname__ = "TimescaleDbLocatorTemplate"
timeseries_archetype_api_TimescaleDbLocatorTemplate.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_TimestreamLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', timeseries_logicalseries_api_TableName),
            'measure': ConjureFieldDefinition('measure', timeseries_logicalseries_api_MeasureName),
            'attribute': ConjureFieldDefinition('attribute', OptionalTypeWrapper[timeseries_logicalseries_api_AttributeName]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_NominalType)
        }

    __slots__: List[str] = ['_table', '_measure', '_attribute', '_type']

    def __init__(self, measure: str, table: str, type: "timeseries_logicalseries_api_NominalType", attribute: Optional[str] = None) -> None:
        self._table = table
        self._measure = measure
        self._attribute = attribute
        self._type = type

    @builtins.property
    def table(self) -> str:
        return self._table

    @builtins.property
    def measure(self) -> str:
        return self._measure

    @builtins.property
    def attribute(self) -> Optional[str]:
        return self._attribute

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_NominalType":
        return self._type


timeseries_archetype_api_TimestreamLocatorTemplate.__name__ = "TimestreamLocatorTemplate"
timeseries_archetype_api_TimestreamLocatorTemplate.__qualname__ = "TimestreamLocatorTemplate"
timeseries_archetype_api_TimestreamLocatorTemplate.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_UpdateSeriesArchetypeMetadataRequest(ConjureBeanType):
    """
    If fields are present, will override existing values.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[timeseries_logicalseries_api_Unit]),
            'unit_update': ConjureFieldDefinition('unitUpdate', OptionalTypeWrapper[timeseries_logicalseries_api_UnitUpdate]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_unit', '_unit_update', '_description']

    def __init__(self, description: Optional[str] = None, unit: Optional[str] = None, unit_update: Optional["timeseries_logicalseries_api_UnitUpdate"] = None) -> None:
        self._unit = unit
        self._unit_update = unit_update
        self._description = description

    @builtins.property
    def unit(self) -> Optional[str]:
        """
        Deprecated. Use unitUpdate instead.
        """
        return self._unit

    @builtins.property
    def unit_update(self) -> Optional["timeseries_logicalseries_api_UnitUpdate"]:
        return self._unit_update

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description


timeseries_archetype_api_UpdateSeriesArchetypeMetadataRequest.__name__ = "UpdateSeriesArchetypeMetadataRequest"
timeseries_archetype_api_UpdateSeriesArchetypeMetadataRequest.__qualname__ = "UpdateSeriesArchetypeMetadataRequest"
timeseries_archetype_api_UpdateSeriesArchetypeMetadataRequest.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_archetype_api_VisualCrossingLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'endpoint': ConjureFieldDefinition('endpoint', OptionalTypeWrapper[timeseries_logicalseries_api_VisualCrossingEndpointUri]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_VisualCrossingType)
        }

    __slots__: List[str] = ['_field', '_endpoint', '_type']

    def __init__(self, field: str, type: "timeseries_logicalseries_api_VisualCrossingType", endpoint: Optional["timeseries_logicalseries_api_VisualCrossingEndpointUri"] = None) -> None:
        self._field = field
        self._endpoint = endpoint
        self._type = type

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def endpoint(self) -> Optional["timeseries_logicalseries_api_VisualCrossingEndpointUri"]:
        """
        Defaults to HISTORY.
        """
        return self._endpoint

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_VisualCrossingType":
        return self._type


timeseries_archetype_api_VisualCrossingLocatorTemplate.__name__ = "VisualCrossingLocatorTemplate"
timeseries_archetype_api_VisualCrossingLocatorTemplate.__qualname__ = "VisualCrossingLocatorTemplate"
timeseries_archetype_api_VisualCrossingLocatorTemplate.__module__ = "scout_service_api.timeseries_archetype_api"


class timeseries_logicalseries_LogicalSeriesService(Service):
    """
    A logical series is a timeseries, represented by a channel name and a tag set.
    """

    def create_logical_series(self, auth_header: str, create_logical_series: "timeseries_logicalseries_api_CreateLogicalSeries") -> "timeseries_logicalseries_api_LogicalSeries":
        """
        Create a new logical series.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(create_logical_series)

        _path = '/timeseries/logical-series/v1/logical-series'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_logicalseries_api_LogicalSeries, self._return_none_for_unknown_union_types)

    def batch_create_logical_series(self, auth_header: str, request: "timeseries_logicalseries_api_BatchCreateLogicalSeriesRequest") -> "timeseries_logicalseries_api_BatchCreateLogicalSeriesResponse":
        """
        Batch create new logical series.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/logical-series/v1/logical-series/batch-create'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_logicalseries_api_BatchCreateLogicalSeriesResponse, self._return_none_for_unknown_union_types)

    def batch_update_logical_series(self, auth_header: str, request: "timeseries_logicalseries_api_BatchUpdateLogicalSeriesRequest") -> "timeseries_logicalseries_api_BatchUpdateLogicalSeriesResponse":
        """
        Batch update logical series descriptions and units.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/logical-series/v1/logical-series/batch-update'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_logicalseries_api_BatchUpdateLogicalSeriesResponse, self._return_none_for_unknown_union_types)

    def get_logical_series(self, auth_header: str, rid: str) -> "timeseries_logicalseries_api_LogicalSeries":
        """
        Get a logical series by logical series rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'rid': rid,
        }

        _json: Any = None

        _path = '/timeseries/logical-series/v1/logical-series/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_logicalseries_api_LogicalSeries, self._return_none_for_unknown_union_types)

    def resolve_batch(self, auth_header: str, request: "timeseries_logicalseries_api_BatchResolveSeriesRequest") -> "timeseries_logicalseries_api_BatchResolveSeriesResponse":
        """
        Resolves groups of channels, datasources and tags into logical series rids. An error response is provided
if the channel + datasource + tag cannot be resolved into a logical series rid.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/logical-series/v1/resolve'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_logicalseries_api_BatchResolveSeriesResponse, self._return_none_for_unknown_union_types)

    def get_suggested_tags(self, auth_header: str, request: "timeseries_logicalseries_api_GetSuggestedTagsRequest") -> "timeseries_logicalseries_api_GetSuggestedTagsResponse":
        """
        Returns suggested tags given a channel, datasource, and the existing tags by reading series archetypes,
external datasources, and other tagged channels.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/logical-series/v1/get-suggested-tags'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_logicalseries_api_GetSuggestedTagsResponse, self._return_none_for_unknown_union_types)


timeseries_logicalseries_LogicalSeriesService.__name__ = "LogicalSeriesService"
timeseries_logicalseries_LogicalSeriesService.__qualname__ = "LogicalSeriesService"
timeseries_logicalseries_LogicalSeriesService.__module__ = "scout_service_api.timeseries_logicalseries"


class timeseries_logicalseries_api_BatchCreateLogicalSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_logicalseries_api_CreateLogicalSeries])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_logicalseries_api_CreateLogicalSeries"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_logicalseries_api_CreateLogicalSeries"]:
        return self._requests


timeseries_logicalseries_api_BatchCreateLogicalSeriesRequest.__name__ = "BatchCreateLogicalSeriesRequest"
timeseries_logicalseries_api_BatchCreateLogicalSeriesRequest.__qualname__ = "BatchCreateLogicalSeriesRequest"
timeseries_logicalseries_api_BatchCreateLogicalSeriesRequest.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchCreateLogicalSeriesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[timeseries_logicalseries_api_LogicalSeries])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["timeseries_logicalseries_api_LogicalSeries"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["timeseries_logicalseries_api_LogicalSeries"]:
        return self._responses


timeseries_logicalseries_api_BatchCreateLogicalSeriesResponse.__name__ = "BatchCreateLogicalSeriesResponse"
timeseries_logicalseries_api_BatchCreateLogicalSeriesResponse.__qualname__ = "BatchCreateLogicalSeriesResponse"
timeseries_logicalseries_api_BatchCreateLogicalSeriesResponse.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchResolveSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_logicalseries_api_ResolveSeriesRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_logicalseries_api_ResolveSeriesRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_logicalseries_api_ResolveSeriesRequest"]:
        return self._requests


timeseries_logicalseries_api_BatchResolveSeriesRequest.__name__ = "BatchResolveSeriesRequest"
timeseries_logicalseries_api_BatchResolveSeriesRequest.__qualname__ = "BatchResolveSeriesRequest"
timeseries_logicalseries_api_BatchResolveSeriesRequest.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchResolveSeriesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', List[timeseries_logicalseries_api_ResolveSeriesResponse])
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: List["timeseries_logicalseries_api_ResolveSeriesResponse"]) -> None:
        self._series = series

    @builtins.property
    def series(self) -> List["timeseries_logicalseries_api_ResolveSeriesResponse"]:
        return self._series


timeseries_logicalseries_api_BatchResolveSeriesResponse.__name__ = "BatchResolveSeriesResponse"
timeseries_logicalseries_api_BatchResolveSeriesResponse.__qualname__ = "BatchResolveSeriesResponse"
timeseries_logicalseries_api_BatchResolveSeriesResponse.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchUpdateLogicalSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_logicalseries_api_UpdateLogicalSeries])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_logicalseries_api_UpdateLogicalSeries"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_logicalseries_api_UpdateLogicalSeries"]:
        return self._requests


timeseries_logicalseries_api_BatchUpdateLogicalSeriesRequest.__name__ = "BatchUpdateLogicalSeriesRequest"
timeseries_logicalseries_api_BatchUpdateLogicalSeriesRequest.__qualname__ = "BatchUpdateLogicalSeriesRequest"
timeseries_logicalseries_api_BatchUpdateLogicalSeriesRequest.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchUpdateLogicalSeriesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[timeseries_logicalseries_api_LogicalSeries])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["timeseries_logicalseries_api_LogicalSeries"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["timeseries_logicalseries_api_LogicalSeries"]:
        return self._responses


timeseries_logicalseries_api_BatchUpdateLogicalSeriesResponse.__name__ = "BatchUpdateLogicalSeriesResponse"
timeseries_logicalseries_api_BatchUpdateLogicalSeriesResponse.__qualname__ = "BatchUpdateLogicalSeriesResponse"
timeseries_logicalseries_api_BatchUpdateLogicalSeriesResponse.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Confidence(ConjureEnumType):

    LOW = 'LOW'
    '''LOW'''
    MEDIUM = 'MEDIUM'
    '''MEDIUM'''
    HIGH = 'HIGH'
    '''HIGH'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_Confidence.__name__ = "Confidence"
timeseries_logicalseries_api_Confidence.__qualname__ = "Confidence"
timeseries_logicalseries_api_Confidence.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Context(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[str, timeseries_logicalseries_api_ContextProperty])
        }

    __slots__: List[str] = ['_properties']

    def __init__(self, properties: Dict[str, "timeseries_logicalseries_api_ContextProperty"]) -> None:
        self._properties = properties

    @builtins.property
    def properties(self) -> Dict[str, "timeseries_logicalseries_api_ContextProperty"]:
        return self._properties


timeseries_logicalseries_api_Context.__name__ = "Context"
timeseries_logicalseries_api_Context.__qualname__ = "Context"
timeseries_logicalseries_api_Context.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ContextProperty(ConjureUnionType):
    _value: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', str)
        }

    def __init__(
            self,
            value: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (value is not None) != 1:
                raise ValueError('a union must contain a single member')

            if value is not None:
                self._value = value
                self._type = 'value'

        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'

    @builtins.property
    def value(self) -> Optional[str]:
        return self._value

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_logicalseries_api_ContextPropertyVisitor):
            raise ValueError('{} is not an instance of timeseries_logicalseries_api_ContextPropertyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)


timeseries_logicalseries_api_ContextProperty.__name__ = "ContextProperty"
timeseries_logicalseries_api_ContextProperty.__qualname__ = "ContextProperty"
timeseries_logicalseries_api_ContextProperty.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ContextPropertyVisitor:

    @abstractmethod
    def _value(self, value: str) -> Any:
        pass


timeseries_logicalseries_api_ContextPropertyVisitor.__name__ = "ContextPropertyVisitor"
timeseries_logicalseries_api_ContextPropertyVisitor.__qualname__ = "ContextPropertyVisitor"
timeseries_logicalseries_api_ContextPropertyVisitor.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_CreateLogicalSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', timeseries_logicalseries_api_Channel),
            'locator': ConjureFieldDefinition('locator', timeseries_logicalseries_api_Locator),
            'id_locator': ConjureFieldDefinition('idLocator', OptionalTypeWrapper[str]),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', timeseries_logicalseries_api_DataSourceRid),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[timeseries_logicalseries_api_Unit]),
            'series_data_type': ConjureFieldDefinition('seriesDataType', OptionalTypeWrapper[timeseries_logicalseries_api_SeriesDataType])
        }

    __slots__: List[str] = ['_channel', '_locator', '_id_locator', '_data_source_rid', '_description', '_unit', '_series_data_type']

    def __init__(self, channel: str, data_source_rid: str, locator: "timeseries_logicalseries_api_Locator", description: Optional[str] = None, id_locator: Optional[str] = None, series_data_type: Optional["timeseries_logicalseries_api_SeriesDataType"] = None, unit: Optional[str] = None) -> None:
        self._channel = channel
        self._locator = locator
        self._id_locator = id_locator
        self._data_source_rid = data_source_rid
        self._description = description
        self._unit = unit
        self._series_data_type = series_data_type

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def locator(self) -> "timeseries_logicalseries_api_Locator":
        return self._locator

    @builtins.property
    def id_locator(self) -> Optional[str]:
        """
        If present, will be used as the locator of the LogicalSeriesRid. If a logical series already exists
with this id, will throw a CONFLICT.
        """
        return self._id_locator

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def series_data_type(self) -> Optional["timeseries_logicalseries_api_SeriesDataType"]:
        return self._series_data_type


timeseries_logicalseries_api_CreateLogicalSeries.__name__ = "CreateLogicalSeries"
timeseries_logicalseries_api_CreateLogicalSeries.__qualname__ = "CreateLogicalSeries"
timeseries_logicalseries_api_CreateLogicalSeries.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_CsvLocator(ConjureBeanType):
    """
    Deprecated in favor of CsvLocatorV2
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3_path': ConjureFieldDefinition('s3Path', str),
            'index': ConjureFieldDefinition('index', int),
            'uses_legacy_format': ConjureFieldDefinition('usesLegacyFormat', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_s3_path', '_index', '_uses_legacy_format']

    def __init__(self, index: int, s3_path: str, uses_legacy_format: Optional[bool] = None) -> None:
        self._s3_path = s3_path
        self._index = index
        self._uses_legacy_format = uses_legacy_format

    @builtins.property
    def s3_path(self) -> str:
        return self._s3_path

    @builtins.property
    def index(self) -> int:
        return self._index

    @builtins.property
    def uses_legacy_format(self) -> Optional[bool]:
        """
        If empty, defaults to false. This refers to whether the CSV was ingested using legacy format where the timestamp
and values are split into two separate arrow files.
        """
        return self._uses_legacy_format


timeseries_logicalseries_api_CsvLocator.__name__ = "CsvLocator"
timeseries_logicalseries_api_CsvLocator.__qualname__ = "CsvLocator"
timeseries_logicalseries_api_CsvLocator.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_CsvLocatorV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3_path': ConjureFieldDefinition('s3Path', str),
            'index': ConjureFieldDefinition('index', int),
            'time_index': ConjureFieldDefinition('timeIndex', int)
        }

    __slots__: List[str] = ['_s3_path', '_index', '_time_index']

    def __init__(self, index: int, s3_path: str, time_index: int) -> None:
        self._s3_path = s3_path
        self._index = index
        self._time_index = time_index

    @builtins.property
    def s3_path(self) -> str:
        return self._s3_path

    @builtins.property
    def index(self) -> int:
        return self._index

    @builtins.property
    def time_index(self) -> int:
        return self._time_index


timeseries_logicalseries_api_CsvLocatorV2.__name__ = "CsvLocatorV2"
timeseries_logicalseries_api_CsvLocatorV2.__qualname__ = "CsvLocatorV2"
timeseries_logicalseries_api_CsvLocatorV2.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Empty(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



timeseries_logicalseries_api_Empty.__name__ = "Empty"
timeseries_logicalseries_api_Empty.__qualname__ = "Empty"
timeseries_logicalseries_api_Empty.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_GetSuggestedTagsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'current_tags': ConjureFieldDefinition('currentTags', Dict[api_TagName, api_TagValue]),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', timeseries_logicalseries_api_DataSourceRid),
            'channel': ConjureFieldDefinition('channel', timeseries_logicalseries_api_Channel)
        }

    __slots__: List[str] = ['_current_tags', '_data_source_rid', '_channel']

    def __init__(self, channel: str, current_tags: Dict[str, str], data_source_rid: str) -> None:
        self._current_tags = current_tags
        self._data_source_rid = data_source_rid
        self._channel = channel

    @builtins.property
    def current_tags(self) -> Dict[str, str]:
        return self._current_tags

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel


timeseries_logicalseries_api_GetSuggestedTagsRequest.__name__ = "GetSuggestedTagsRequest"
timeseries_logicalseries_api_GetSuggestedTagsRequest.__qualname__ = "GetSuggestedTagsRequest"
timeseries_logicalseries_api_GetSuggestedTagsRequest.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_GetSuggestedTagsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, List[api_TagValue]]),
            'confidence': ConjureFieldDefinition('confidence', timeseries_logicalseries_api_Confidence)
        }

    __slots__: List[str] = ['_tags', '_confidence']

    def __init__(self, confidence: "timeseries_logicalseries_api_Confidence", tags: Dict[str, List[str]]) -> None:
        self._tags = tags
        self._confidence = confidence

    @builtins.property
    def tags(self) -> Dict[str, List[str]]:
        return self._tags

    @builtins.property
    def confidence(self) -> "timeseries_logicalseries_api_Confidence":
        return self._confidence


timeseries_logicalseries_api_GetSuggestedTagsResponse.__name__ = "GetSuggestedTagsResponse"
timeseries_logicalseries_api_GetSuggestedTagsResponse.__qualname__ = "GetSuggestedTagsResponse"
timeseries_logicalseries_api_GetSuggestedTagsResponse.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Influx1Locator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'database': ConjureFieldDefinition('database', timeseries_logicalseries_api_DatabaseName),
            'measurement': ConjureFieldDefinition('measurement', timeseries_logicalseries_api_MeasurementName),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_InfluxType)
        }

    __slots__: List[str] = ['_database', '_measurement', '_field', '_tags', '_type']

    def __init__(self, database: str, field: str, measurement: str, tags: Dict[str, str], type: "timeseries_logicalseries_api_InfluxType") -> None:
        self._database = database
        self._measurement = measurement
        self._field = field
        self._tags = tags
        self._type = type

    @builtins.property
    def database(self) -> str:
        return self._database

    @builtins.property
    def measurement(self) -> str:
        return self._measurement

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_InfluxType":
        return self._type


timeseries_logicalseries_api_Influx1Locator.__name__ = "Influx1Locator"
timeseries_logicalseries_api_Influx1Locator.__qualname__ = "Influx1Locator"
timeseries_logicalseries_api_Influx1Locator.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Influx2Locator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket': ConjureFieldDefinition('bucket', timeseries_logicalseries_api_BucketName),
            'measurement': ConjureFieldDefinition('measurement', timeseries_logicalseries_api_MeasurementName),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'value_column': ConjureFieldDefinition('valueColumn', OptionalTypeWrapper[str]),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_InfluxType)
        }

    __slots__: List[str] = ['_bucket', '_measurement', '_field', '_value_column', '_tags', '_type']

    def __init__(self, bucket: str, field: str, measurement: str, tags: Dict[str, str], type: "timeseries_logicalseries_api_InfluxType", value_column: Optional[str] = None) -> None:
        self._bucket = bucket
        self._measurement = measurement
        self._field = field
        self._value_column = value_column
        self._tags = tags
        self._type = type

    @builtins.property
    def bucket(self) -> str:
        return self._bucket

    @builtins.property
    def measurement(self) -> str:
        return self._measurement

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def value_column(self) -> Optional[str]:
        """
        If omitted, defaults to `_value`. Can be used to extract tag values.
        """
        return self._value_column

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_InfluxType":
        return self._type


timeseries_logicalseries_api_Influx2Locator.__name__ = "Influx2Locator"
timeseries_logicalseries_api_Influx2Locator.__qualname__ = "Influx2Locator"
timeseries_logicalseries_api_Influx2Locator.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_InfluxType(ConjureEnumType):

    BOOLEAN = 'BOOLEAN'
    '''BOOLEAN'''
    NUMERIC = 'NUMERIC'
    '''NUMERIC'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_InfluxType.__name__ = "InfluxType"
timeseries_logicalseries_api_InfluxType.__qualname__ = "InfluxType"
timeseries_logicalseries_api_InfluxType.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Locator(ConjureUnionType):
    _csv_locator: Optional["timeseries_logicalseries_api_CsvLocator"] = None
    _csv_v2: Optional["timeseries_logicalseries_api_CsvLocatorV2"] = None
    _timescale_db_locator: Optional["timeseries_logicalseries_api_TimescaleDbLocator"] = None
    _influx_locator: Optional["timeseries_logicalseries_api_Influx2Locator"] = None
    _influx1_locator: Optional["timeseries_logicalseries_api_Influx1Locator"] = None
    _nominal_locator: Optional["timeseries_logicalseries_api_NominalLocator"] = None
    _timestream_locator: Optional["timeseries_logicalseries_api_TimestreamLocator"] = None
    _visual_crossing_locator: Optional["timeseries_logicalseries_api_VisualCrossingLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'csv_locator': ConjureFieldDefinition('csvLocator', timeseries_logicalseries_api_CsvLocator),
            'csv_v2': ConjureFieldDefinition('csvV2', timeseries_logicalseries_api_CsvLocatorV2),
            'timescale_db_locator': ConjureFieldDefinition('timescaleDbLocator', timeseries_logicalseries_api_TimescaleDbLocator),
            'influx_locator': ConjureFieldDefinition('influxLocator', timeseries_logicalseries_api_Influx2Locator),
            'influx1_locator': ConjureFieldDefinition('influx1Locator', timeseries_logicalseries_api_Influx1Locator),
            'nominal_locator': ConjureFieldDefinition('nominalLocator', timeseries_logicalseries_api_NominalLocator),
            'timestream_locator': ConjureFieldDefinition('timestreamLocator', timeseries_logicalseries_api_TimestreamLocator),
            'visual_crossing_locator': ConjureFieldDefinition('visualCrossingLocator', timeseries_logicalseries_api_VisualCrossingLocator)
        }

    def __init__(
            self,
            csv_locator: Optional["timeseries_logicalseries_api_CsvLocator"] = None,
            csv_v2: Optional["timeseries_logicalseries_api_CsvLocatorV2"] = None,
            timescale_db_locator: Optional["timeseries_logicalseries_api_TimescaleDbLocator"] = None,
            influx_locator: Optional["timeseries_logicalseries_api_Influx2Locator"] = None,
            influx1_locator: Optional["timeseries_logicalseries_api_Influx1Locator"] = None,
            nominal_locator: Optional["timeseries_logicalseries_api_NominalLocator"] = None,
            timestream_locator: Optional["timeseries_logicalseries_api_TimestreamLocator"] = None,
            visual_crossing_locator: Optional["timeseries_logicalseries_api_VisualCrossingLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (csv_locator is not None) + (csv_v2 is not None) + (timescale_db_locator is not None) + (influx_locator is not None) + (influx1_locator is not None) + (nominal_locator is not None) + (timestream_locator is not None) + (visual_crossing_locator is not None) != 1:
                raise ValueError('a union must contain a single member')

            if csv_locator is not None:
                self._csv_locator = csv_locator
                self._type = 'csvLocator'
            if csv_v2 is not None:
                self._csv_v2 = csv_v2
                self._type = 'csvV2'
            if timescale_db_locator is not None:
                self._timescale_db_locator = timescale_db_locator
                self._type = 'timescaleDbLocator'
            if influx_locator is not None:
                self._influx_locator = influx_locator
                self._type = 'influxLocator'
            if influx1_locator is not None:
                self._influx1_locator = influx1_locator
                self._type = 'influx1Locator'
            if nominal_locator is not None:
                self._nominal_locator = nominal_locator
                self._type = 'nominalLocator'
            if timestream_locator is not None:
                self._timestream_locator = timestream_locator
                self._type = 'timestreamLocator'
            if visual_crossing_locator is not None:
                self._visual_crossing_locator = visual_crossing_locator
                self._type = 'visualCrossingLocator'

        elif type_of_union == 'csvLocator':
            if csv_locator is None:
                raise ValueError('a union value must not be None')
            self._csv_locator = csv_locator
            self._type = 'csvLocator'
        elif type_of_union == 'csvV2':
            if csv_v2 is None:
                raise ValueError('a union value must not be None')
            self._csv_v2 = csv_v2
            self._type = 'csvV2'
        elif type_of_union == 'timescaleDbLocator':
            if timescale_db_locator is None:
                raise ValueError('a union value must not be None')
            self._timescale_db_locator = timescale_db_locator
            self._type = 'timescaleDbLocator'
        elif type_of_union == 'influxLocator':
            if influx_locator is None:
                raise ValueError('a union value must not be None')
            self._influx_locator = influx_locator
            self._type = 'influxLocator'
        elif type_of_union == 'influx1Locator':
            if influx1_locator is None:
                raise ValueError('a union value must not be None')
            self._influx1_locator = influx1_locator
            self._type = 'influx1Locator'
        elif type_of_union == 'nominalLocator':
            if nominal_locator is None:
                raise ValueError('a union value must not be None')
            self._nominal_locator = nominal_locator
            self._type = 'nominalLocator'
        elif type_of_union == 'timestreamLocator':
            if timestream_locator is None:
                raise ValueError('a union value must not be None')
            self._timestream_locator = timestream_locator
            self._type = 'timestreamLocator'
        elif type_of_union == 'visualCrossingLocator':
            if visual_crossing_locator is None:
                raise ValueError('a union value must not be None')
            self._visual_crossing_locator = visual_crossing_locator
            self._type = 'visualCrossingLocator'

    @builtins.property
    def csv_locator(self) -> Optional["timeseries_logicalseries_api_CsvLocator"]:
        return self._csv_locator

    @builtins.property
    def csv_v2(self) -> Optional["timeseries_logicalseries_api_CsvLocatorV2"]:
        return self._csv_v2

    @builtins.property
    def timescale_db_locator(self) -> Optional["timeseries_logicalseries_api_TimescaleDbLocator"]:
        return self._timescale_db_locator

    @builtins.property
    def influx_locator(self) -> Optional["timeseries_logicalseries_api_Influx2Locator"]:
        return self._influx_locator

    @builtins.property
    def influx1_locator(self) -> Optional["timeseries_logicalseries_api_Influx1Locator"]:
        return self._influx1_locator

    @builtins.property
    def nominal_locator(self) -> Optional["timeseries_logicalseries_api_NominalLocator"]:
        return self._nominal_locator

    @builtins.property
    def timestream_locator(self) -> Optional["timeseries_logicalseries_api_TimestreamLocator"]:
        return self._timestream_locator

    @builtins.property
    def visual_crossing_locator(self) -> Optional["timeseries_logicalseries_api_VisualCrossingLocator"]:
        return self._visual_crossing_locator

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_logicalseries_api_LocatorVisitor):
            raise ValueError('{} is not an instance of timeseries_logicalseries_api_LocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'csvLocator' and self.csv_locator is not None:
            return visitor._csv_locator(self.csv_locator)
        if self._type == 'csvV2' and self.csv_v2 is not None:
            return visitor._csv_v2(self.csv_v2)
        if self._type == 'timescaleDbLocator' and self.timescale_db_locator is not None:
            return visitor._timescale_db_locator(self.timescale_db_locator)
        if self._type == 'influxLocator' and self.influx_locator is not None:
            return visitor._influx_locator(self.influx_locator)
        if self._type == 'influx1Locator' and self.influx1_locator is not None:
            return visitor._influx1_locator(self.influx1_locator)
        if self._type == 'nominalLocator' and self.nominal_locator is not None:
            return visitor._nominal_locator(self.nominal_locator)
        if self._type == 'timestreamLocator' and self.timestream_locator is not None:
            return visitor._timestream_locator(self.timestream_locator)
        if self._type == 'visualCrossingLocator' and self.visual_crossing_locator is not None:
            return visitor._visual_crossing_locator(self.visual_crossing_locator)


timeseries_logicalseries_api_Locator.__name__ = "Locator"
timeseries_logicalseries_api_Locator.__qualname__ = "Locator"
timeseries_logicalseries_api_Locator.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_LocatorVisitor:

    @abstractmethod
    def _csv_locator(self, csv_locator: "timeseries_logicalseries_api_CsvLocator") -> Any:
        pass

    @abstractmethod
    def _csv_v2(self, csv_v2: "timeseries_logicalseries_api_CsvLocatorV2") -> Any:
        pass

    @abstractmethod
    def _timescale_db_locator(self, timescale_db_locator: "timeseries_logicalseries_api_TimescaleDbLocator") -> Any:
        pass

    @abstractmethod
    def _influx_locator(self, influx_locator: "timeseries_logicalseries_api_Influx2Locator") -> Any:
        pass

    @abstractmethod
    def _influx1_locator(self, influx1_locator: "timeseries_logicalseries_api_Influx1Locator") -> Any:
        pass

    @abstractmethod
    def _nominal_locator(self, nominal_locator: "timeseries_logicalseries_api_NominalLocator") -> Any:
        pass

    @abstractmethod
    def _timestream_locator(self, timestream_locator: "timeseries_logicalseries_api_TimestreamLocator") -> Any:
        pass

    @abstractmethod
    def _visual_crossing_locator(self, visual_crossing_locator: "timeseries_logicalseries_api_VisualCrossingLocator") -> Any:
        pass


timeseries_logicalseries_api_LocatorVisitor.__name__ = "LocatorVisitor"
timeseries_logicalseries_api_LocatorVisitor.__qualname__ = "LocatorVisitor"
timeseries_logicalseries_api_LocatorVisitor.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_LogicalSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', timeseries_logicalseries_api_LogicalSeriesRid),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', timeseries_logicalseries_api_DataSourceRid),
            'locator': ConjureFieldDefinition('locator', timeseries_logicalseries_api_Locator),
            'time_locator': ConjureFieldDefinition('timeLocator', OptionalTypeWrapper[timeseries_logicalseries_api_Locator]),
            'channel': ConjureFieldDefinition('channel', timeseries_logicalseries_api_Channel),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[timeseries_logicalseries_api_Unit]),
            'series_data_type': ConjureFieldDefinition('seriesDataType', OptionalTypeWrapper[timeseries_logicalseries_api_SeriesDataType])
        }

    __slots__: List[str] = ['_rid', '_data_source_rid', '_locator', '_time_locator', '_channel', '_description', '_unit', '_series_data_type']

    def __init__(self, channel: str, data_source_rid: str, locator: "timeseries_logicalseries_api_Locator", rid: str, description: Optional[str] = None, series_data_type: Optional["timeseries_logicalseries_api_SeriesDataType"] = None, time_locator: Optional["timeseries_logicalseries_api_Locator"] = None, unit: Optional[str] = None) -> None:
        self._rid = rid
        self._data_source_rid = data_source_rid
        self._locator = locator
        self._time_locator = time_locator
        self._channel = channel
        self._description = description
        self._unit = unit
        self._series_data_type = series_data_type

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def locator(self) -> "timeseries_logicalseries_api_Locator":
        return self._locator

    @builtins.property
    def time_locator(self) -> Optional["timeseries_logicalseries_api_Locator"]:
        """
        Only required to be present for legacy CSVs.
        """
        return self._time_locator

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def series_data_type(self) -> Optional["timeseries_logicalseries_api_SeriesDataType"]:
        return self._series_data_type


timeseries_logicalseries_api_LogicalSeries.__name__ = "LogicalSeries"
timeseries_logicalseries_api_LogicalSeries.__qualname__ = "LogicalSeries"
timeseries_logicalseries_api_LogicalSeries.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_NominalLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', timeseries_logicalseries_api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_NominalType)
        }

    __slots__: List[str] = ['_channel', '_tags', '_type']

    def __init__(self, channel: str, tags: Dict[str, str], type: "timeseries_logicalseries_api_NominalType") -> None:
        self._channel = channel
        self._tags = tags
        self._type = type

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_NominalType":
        return self._type


timeseries_logicalseries_api_NominalLocator.__name__ = "NominalLocator"
timeseries_logicalseries_api_NominalLocator.__qualname__ = "NominalLocator"
timeseries_logicalseries_api_NominalLocator.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_NominalType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_NominalType.__name__ = "NominalType"
timeseries_logicalseries_api_NominalType.__qualname__ = "NominalType"
timeseries_logicalseries_api_NominalType.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ResolveSeriesError(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'message': ConjureFieldDefinition('message', str),
            'args': ConjureFieldDefinition('args', Dict[str, str])
        }

    __slots__: List[str] = ['_message', '_args']

    def __init__(self, args: Dict[str, str], message: str) -> None:
        self._message = message
        self._args = args

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def args(self) -> Dict[str, str]:
        return self._args


timeseries_logicalseries_api_ResolveSeriesError.__name__ = "ResolveSeriesError"
timeseries_logicalseries_api_ResolveSeriesError.__qualname__ = "ResolveSeriesError"
timeseries_logicalseries_api_ResolveSeriesError.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ResolveSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', timeseries_logicalseries_api_Channel),
            'datasource': ConjureFieldDefinition('datasource', timeseries_logicalseries_api_DataSourceRid),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_name', '_datasource', '_tags']

    def __init__(self, datasource: str, name: str, tags: Dict[str, str]) -> None:
        self._name = name
        self._datasource = datasource
        self._tags = tags

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def datasource(self) -> str:
        return self._datasource

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags


timeseries_logicalseries_api_ResolveSeriesRequest.__name__ = "ResolveSeriesRequest"
timeseries_logicalseries_api_ResolveSeriesRequest.__qualname__ = "ResolveSeriesRequest"
timeseries_logicalseries_api_ResolveSeriesRequest.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ResolveSeriesResponse(ConjureUnionType):
    _rid: Optional[str] = None
    _error: Optional["timeseries_logicalseries_api_ResolveSeriesError"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', timeseries_logicalseries_api_LogicalSeriesRid),
            'error': ConjureFieldDefinition('error', timeseries_logicalseries_api_ResolveSeriesError)
        }

    def __init__(
            self,
            rid: Optional[str] = None,
            error: Optional["timeseries_logicalseries_api_ResolveSeriesError"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (rid is not None) + (error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if rid is not None:
                self._rid = rid
                self._type = 'rid'
            if error is not None:
                self._error = error
                self._type = 'error'

        elif type_of_union == 'rid':
            if rid is None:
                raise ValueError('a union value must not be None')
            self._rid = rid
            self._type = 'rid'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'

    @builtins.property
    def rid(self) -> Optional[str]:
        return self._rid

    @builtins.property
    def error(self) -> Optional["timeseries_logicalseries_api_ResolveSeriesError"]:
        return self._error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_logicalseries_api_ResolveSeriesResponseVisitor):
            raise ValueError('{} is not an instance of timeseries_logicalseries_api_ResolveSeriesResponseVisitor'.format(visitor.__class__.__name__))
        if self._type == 'rid' and self.rid is not None:
            return visitor._rid(self.rid)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)


timeseries_logicalseries_api_ResolveSeriesResponse.__name__ = "ResolveSeriesResponse"
timeseries_logicalseries_api_ResolveSeriesResponse.__qualname__ = "ResolveSeriesResponse"
timeseries_logicalseries_api_ResolveSeriesResponse.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ResolveSeriesResponseVisitor:

    @abstractmethod
    def _rid(self, rid: str) -> Any:
        pass

    @abstractmethod
    def _error(self, error: "timeseries_logicalseries_api_ResolveSeriesError") -> Any:
        pass


timeseries_logicalseries_api_ResolveSeriesResponseVisitor.__name__ = "ResolveSeriesResponseVisitor"
timeseries_logicalseries_api_ResolveSeriesResponseVisitor.__qualname__ = "ResolveSeriesResponseVisitor"
timeseries_logicalseries_api_ResolveSeriesResponseVisitor.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_SeriesDataType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_SeriesDataType.__name__ = "SeriesDataType"
timeseries_logicalseries_api_SeriesDataType.__qualname__ = "SeriesDataType"
timeseries_logicalseries_api_SeriesDataType.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_TimescaleDbLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', timeseries_logicalseries_api_TableName),
            'schema': ConjureFieldDefinition('schema', timeseries_logicalseries_api_SchemaName),
            'column': ConjureFieldDefinition('column', timeseries_logicalseries_api_ColumnName),
            'time_column': ConjureFieldDefinition('timeColumn', timeseries_logicalseries_api_ColumnName),
            'dimensions': ConjureFieldDefinition('dimensions', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_TimescaleType)
        }

    __slots__: List[str] = ['_table', '_schema', '_column', '_time_column', '_dimensions', '_type']

    def __init__(self, column: str, dimensions: Dict[str, str], schema: str, table: str, time_column: str, type: "timeseries_logicalseries_api_TimescaleType") -> None:
        self._table = table
        self._schema = schema
        self._column = column
        self._time_column = time_column
        self._dimensions = dimensions
        self._type = type

    @builtins.property
    def table(self) -> str:
        return self._table

    @builtins.property
    def schema(self) -> str:
        return self._schema

    @builtins.property
    def column(self) -> str:
        return self._column

    @builtins.property
    def time_column(self) -> str:
        return self._time_column

    @builtins.property
    def dimensions(self) -> Dict[str, str]:
        return self._dimensions

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_TimescaleType":
        return self._type


timeseries_logicalseries_api_TimescaleDbLocator.__name__ = "TimescaleDbLocator"
timeseries_logicalseries_api_TimescaleDbLocator.__qualname__ = "TimescaleDbLocator"
timeseries_logicalseries_api_TimescaleDbLocator.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_TimescaleType(ConjureEnumType):

    BOOLEAN = 'BOOLEAN'
    '''BOOLEAN'''
    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_TimescaleType.__name__ = "TimescaleType"
timeseries_logicalseries_api_TimescaleType.__qualname__ = "TimescaleType"
timeseries_logicalseries_api_TimescaleType.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_TimestreamLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', timeseries_logicalseries_api_TableName),
            'dimensions': ConjureFieldDefinition('dimensions', Dict[api_TagName, api_TagValue]),
            'measure': ConjureFieldDefinition('measure', timeseries_logicalseries_api_MeasureName),
            'attribute': ConjureFieldDefinition('attribute', OptionalTypeWrapper[timeseries_logicalseries_api_AttributeName]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_NominalType)
        }

    __slots__: List[str] = ['_table', '_dimensions', '_measure', '_attribute', '_type']

    def __init__(self, dimensions: Dict[str, str], measure: str, table: str, type: "timeseries_logicalseries_api_NominalType", attribute: Optional[str] = None) -> None:
        self._table = table
        self._dimensions = dimensions
        self._measure = measure
        self._attribute = attribute
        self._type = type

    @builtins.property
    def table(self) -> str:
        return self._table

    @builtins.property
    def dimensions(self) -> Dict[str, str]:
        return self._dimensions

    @builtins.property
    def measure(self) -> str:
        return self._measure

    @builtins.property
    def attribute(self) -> Optional[str]:
        """
        If present, will be the attribute within the measurement for multi-measures.
        """
        return self._attribute

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_NominalType":
        return self._type


timeseries_logicalseries_api_TimestreamLocator.__name__ = "TimestreamLocator"
timeseries_logicalseries_api_TimestreamLocator.__qualname__ = "TimestreamLocator"
timeseries_logicalseries_api_TimestreamLocator.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_UnitUpdate(ConjureUnionType):
    """UnitUpdate is used to either set a unit, or to clear an existing unit."""
    _unit: Optional[str] = None
    _clear_unit: Optional["timeseries_logicalseries_api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unit': ConjureFieldDefinition('unit', timeseries_logicalseries_api_Unit),
            'clear_unit': ConjureFieldDefinition('clearUnit', timeseries_logicalseries_api_Empty)
        }

    def __init__(
            self,
            unit: Optional[str] = None,
            clear_unit: Optional["timeseries_logicalseries_api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (unit is not None) + (clear_unit is not None) != 1:
                raise ValueError('a union must contain a single member')

            if unit is not None:
                self._unit = unit
                self._type = 'unit'
            if clear_unit is not None:
                self._clear_unit = clear_unit
                self._type = 'clearUnit'

        elif type_of_union == 'unit':
            if unit is None:
                raise ValueError('a union value must not be None')
            self._unit = unit
            self._type = 'unit'
        elif type_of_union == 'clearUnit':
            if clear_unit is None:
                raise ValueError('a union value must not be None')
            self._clear_unit = clear_unit
            self._type = 'clearUnit'

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def clear_unit(self) -> Optional["timeseries_logicalseries_api_Empty"]:
        return self._clear_unit

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_logicalseries_api_UnitUpdateVisitor):
            raise ValueError('{} is not an instance of timeseries_logicalseries_api_UnitUpdateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'unit' and self.unit is not None:
            return visitor._unit(self.unit)
        if self._type == 'clearUnit' and self.clear_unit is not None:
            return visitor._clear_unit(self.clear_unit)


timeseries_logicalseries_api_UnitUpdate.__name__ = "UnitUpdate"
timeseries_logicalseries_api_UnitUpdate.__qualname__ = "UnitUpdate"
timeseries_logicalseries_api_UnitUpdate.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_UnitUpdateVisitor:

    @abstractmethod
    def _unit(self, unit: str) -> Any:
        pass

    @abstractmethod
    def _clear_unit(self, clear_unit: "timeseries_logicalseries_api_Empty") -> Any:
        pass


timeseries_logicalseries_api_UnitUpdateVisitor.__name__ = "UnitUpdateVisitor"
timeseries_logicalseries_api_UnitUpdateVisitor.__qualname__ = "UnitUpdateVisitor"
timeseries_logicalseries_api_UnitUpdateVisitor.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_UpdateLogicalSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'logical_series_rid': ConjureFieldDefinition('logicalSeriesRid', timeseries_logicalseries_api_LogicalSeriesRid),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[timeseries_logicalseries_api_Unit]),
            'unit_update': ConjureFieldDefinition('unitUpdate', OptionalTypeWrapper[timeseries_logicalseries_api_UnitUpdate])
        }

    __slots__: List[str] = ['_logical_series_rid', '_description', '_unit', '_unit_update']

    def __init__(self, logical_series_rid: str, description: Optional[str] = None, unit: Optional[str] = None, unit_update: Optional["timeseries_logicalseries_api_UnitUpdate"] = None) -> None:
        self._logical_series_rid = logical_series_rid
        self._description = description
        self._unit = unit
        self._unit_update = unit_update

    @builtins.property
    def logical_series_rid(self) -> str:
        return self._logical_series_rid

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def unit_update(self) -> Optional["timeseries_logicalseries_api_UnitUpdate"]:
        return self._unit_update


timeseries_logicalseries_api_UpdateLogicalSeries.__name__ = "UpdateLogicalSeries"
timeseries_logicalseries_api_UpdateLogicalSeries.__qualname__ = "UpdateLogicalSeries"
timeseries_logicalseries_api_UpdateLogicalSeries.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_VisualCrossingEndpointUri(ConjureEnumType):

    HISTORY = 'HISTORY'
    '''HISTORY'''
    TIMELINE = 'TIMELINE'
    '''TIMELINE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_VisualCrossingEndpointUri.__name__ = "VisualCrossingEndpointUri"
timeseries_logicalseries_api_VisualCrossingEndpointUri.__qualname__ = "VisualCrossingEndpointUri"
timeseries_logicalseries_api_VisualCrossingEndpointUri.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_VisualCrossingLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'location': ConjureFieldDefinition('location', timeseries_logicalseries_api_LocationName),
            'endpoint': ConjureFieldDefinition('endpoint', OptionalTypeWrapper[timeseries_logicalseries_api_VisualCrossingEndpointUri]),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_VisualCrossingType)
        }

    __slots__: List[str] = ['_location', '_endpoint', '_field', '_type']

    def __init__(self, field: str, location: str, type: "timeseries_logicalseries_api_VisualCrossingType", endpoint: Optional["timeseries_logicalseries_api_VisualCrossingEndpointUri"] = None) -> None:
        self._location = location
        self._endpoint = endpoint
        self._field = field
        self._type = type

    @builtins.property
    def location(self) -> str:
        """
        Location to fetch data from.  Can be any arbitrary string (i.e. name, abbreviation,
zip code, lat/long, etc.) as remote endpoint performs location resolution.
        """
        return self._location

    @builtins.property
    def endpoint(self) -> Optional["timeseries_logicalseries_api_VisualCrossingEndpointUri"]:
        """
        Defaults to HISTORY.  Endpoint to fetch data from for this series.
        """
        return self._endpoint

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_VisualCrossingType":
        return self._type


timeseries_logicalseries_api_VisualCrossingLocator.__name__ = "VisualCrossingLocator"
timeseries_logicalseries_api_VisualCrossingLocator.__qualname__ = "VisualCrossingLocator"
timeseries_logicalseries_api_VisualCrossingLocator.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_VisualCrossingType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_VisualCrossingType.__name__ = "VisualCrossingType"
timeseries_logicalseries_api_VisualCrossingType.__qualname__ = "VisualCrossingType"
timeseries_logicalseries_api_VisualCrossingType.__module__ = "scout_service_api.timeseries_logicalseries_api"


class timeseries_seriescache_SeriesCacheService(Service):
    """
    The Series Cache service manages internal chunks of data cached by Nominal's backend.
    """

    def batch_get_cached_series(self, auth_header: str, request: "timeseries_seriescache_api_GetCachedSeriesRequest") -> "timeseries_seriescache_api_CachedSeriesResponse":
        """
        Fetches information about logical series that are cached in the Nominal time series database.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/series-cache/v1/logical-series/get-cached-series'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_seriescache_api_CachedSeriesResponse, self._return_none_for_unknown_union_types)

    def create_cached_series(self, auth_header: str, request: "timeseries_seriescache_api_CreateCachedSeriesRequest") -> None:
        """
        Records a logical series as cached in the Nominal time series database.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/series-cache/v1/logical-series/create-cached-series'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_chunks(self, auth_header: str, get_chunks_parameters: "timeseries_seriescache_api_GetChunksParameters", logical_series_rid: str) -> "timeseries_seriescache_api_GetChunksResponse":
        """
        Fetches "chunks" of series that are stored as Arrow files in S3.
This endpoint is being deprecated for new series in favor of batchGetCachedSeries
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'logicalSeriesRid': logical_series_rid,
        }

        _json: Any = ConjureEncoder().default(get_chunks_parameters)

        _path = '/timeseries/series-cache/v1/logical-series/{logicalSeriesRid}/get-chunks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_seriescache_api_GetChunksResponse, self._return_none_for_unknown_union_types)

    def create_chunks(self, auth_header: str, create_chunks_parameters: "timeseries_seriescache_api_CreateChunksParameters", logical_series_rid: str) -> "timeseries_seriescache_api_CreateChunksResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'logicalSeriesRid': logical_series_rid,
        }

        _json: Any = ConjureEncoder().default(create_chunks_parameters)

        _path = '/timeseries/series-cache/v1/logical-series/{logicalSeriesRid}/create-chunks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_seriescache_api_CreateChunksResponse, self._return_none_for_unknown_union_types)

    def batch_create_chunks(self, auth_header: str, request: "timeseries_seriescache_api_CreateChunksParameters") -> "timeseries_seriescache_api_CreateChunksResponse":

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/series-cache/v1/batch-create-chunks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_seriescache_api_CreateChunksResponse, self._return_none_for_unknown_union_types)

    def delete_chunks(self, auth_header: str, logical_series_rid: str, request: "timeseries_seriescache_api_DeleteChunksParameters") -> "timeseries_seriescache_api_DeleteChunksResponse":
        """
        Deletes the chunks that intersect the given time range. Does not delete the corresponding files from S3.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
            'logicalSeriesRid': logical_series_rid,
        }

        _json: Any = ConjureEncoder().default(request)

        _path = '/timeseries/series-cache/v1/logical-series/{logicalSeriesRid}/delete-chunks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_seriescache_api_DeleteChunksResponse, self._return_none_for_unknown_union_types)


timeseries_seriescache_SeriesCacheService.__name__ = "SeriesCacheService"
timeseries_seriescache_SeriesCacheService.__qualname__ = "SeriesCacheService"
timeseries_seriescache_SeriesCacheService.__module__ = "scout_service_api.timeseries_seriescache"


class timeseries_seriescache_api_CachedSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'logical_series_rid': ConjureFieldDefinition('logicalSeriesRid', timeseries_logicalseries_api_LogicalSeriesRid),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', api_Timestamp),
            'series_data_type': ConjureFieldDefinition('seriesDataType', timeseries_logicalseries_api_SeriesDataType)
        }

    __slots__: List[str] = ['_logical_series_rid', '_start_timestamp', '_end_timestamp', '_series_data_type']

    def __init__(self, end_timestamp: "api_Timestamp", logical_series_rid: str, series_data_type: "timeseries_logicalseries_api_SeriesDataType", start_timestamp: "api_Timestamp") -> None:
        self._logical_series_rid = logical_series_rid
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp
        self._series_data_type = series_data_type

    @builtins.property
    def logical_series_rid(self) -> str:
        return self._logical_series_rid

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> "api_Timestamp":
        return self._end_timestamp

    @builtins.property
    def series_data_type(self) -> "timeseries_logicalseries_api_SeriesDataType":
        return self._series_data_type


timeseries_seriescache_api_CachedSeries.__name__ = "CachedSeries"
timeseries_seriescache_api_CachedSeries.__qualname__ = "CachedSeries"
timeseries_seriescache_api_CachedSeries.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_CachedSeriesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'cached_series': ConjureFieldDefinition('cachedSeries', List[timeseries_seriescache_api_CachedSeries])
        }

    __slots__: List[str] = ['_cached_series']

    def __init__(self, cached_series: List["timeseries_seriescache_api_CachedSeries"]) -> None:
        self._cached_series = cached_series

    @builtins.property
    def cached_series(self) -> List["timeseries_seriescache_api_CachedSeries"]:
        return self._cached_series


timeseries_seriescache_api_CachedSeriesResponse.__name__ = "CachedSeriesResponse"
timeseries_seriescache_api_CachedSeriesResponse.__qualname__ = "CachedSeriesResponse"
timeseries_seriescache_api_CachedSeriesResponse.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_Chunk(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', timeseries_seriescache_api_ChunkRid),
            'type': ConjureFieldDefinition('type', timeseries_seriescache_api_ChunkType),
            'logical_series_rid': ConjureFieldDefinition('logicalSeriesRid', timeseries_logicalseries_api_LogicalSeriesRid),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', api_Timestamp),
            'count': ConjureFieldDefinition('count', int),
            'size_in_bytes': ConjureFieldDefinition('sizeInBytes', int),
            'resolution': ConjureFieldDefinition('resolution', timeseries_seriescache_api_Resolution),
            'handle': ConjureFieldDefinition('handle', timeseries_seriescache_api_Handle)
        }

    __slots__: List[str] = ['_rid', '_type', '_logical_series_rid', '_start_timestamp', '_end_timestamp', '_count', '_size_in_bytes', '_resolution', '_handle']

    def __init__(self, count: int, end_timestamp: "api_Timestamp", handle: "timeseries_seriescache_api_Handle", logical_series_rid: str, resolution: int, rid: str, size_in_bytes: int, start_timestamp: "api_Timestamp", type: "timeseries_seriescache_api_ChunkType") -> None:
        self._rid = rid
        self._type = type
        self._logical_series_rid = logical_series_rid
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp
        self._count = count
        self._size_in_bytes = size_in_bytes
        self._resolution = resolution
        self._handle = handle

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def type(self) -> "timeseries_seriescache_api_ChunkType":
        return self._type

    @builtins.property
    def logical_series_rid(self) -> str:
        return self._logical_series_rid

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> "api_Timestamp":
        return self._end_timestamp

    @builtins.property
    def count(self) -> int:
        """
        The number of distinct timestamps contained within the chunk.
        """
        return self._count

    @builtins.property
    def size_in_bytes(self) -> int:
        return self._size_in_bytes

    @builtins.property
    def resolution(self) -> int:
        return self._resolution

    @builtins.property
    def handle(self) -> "timeseries_seriescache_api_Handle":
        return self._handle


timeseries_seriescache_api_Chunk.__name__ = "Chunk"
timeseries_seriescache_api_Chunk.__qualname__ = "Chunk"
timeseries_seriescache_api_Chunk.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_ChunkType(ConjureEnumType):

    ARROW_WITH_RELATIVE_TIMESTAMPS = 'ARROW_WITH_RELATIVE_TIMESTAMPS'
    '''ARROW_WITH_RELATIVE_TIMESTAMPS'''
    ARROW_WITH_ABSOLUTE_TIMESTAMPS = 'ARROW_WITH_ABSOLUTE_TIMESTAMPS'
    '''ARROW_WITH_ABSOLUTE_TIMESTAMPS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_seriescache_api_ChunkType.__name__ = "ChunkType"
timeseries_seriescache_api_ChunkType.__qualname__ = "ChunkType"
timeseries_seriescache_api_ChunkType.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_CreateCachedSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_to_cache': ConjureFieldDefinition('seriesToCache', List[timeseries_seriescache_api_CachedSeries])
        }

    __slots__: List[str] = ['_series_to_cache']

    def __init__(self, series_to_cache: List["timeseries_seriescache_api_CachedSeries"]) -> None:
        self._series_to_cache = series_to_cache

    @builtins.property
    def series_to_cache(self) -> List["timeseries_seriescache_api_CachedSeries"]:
        return self._series_to_cache


timeseries_seriescache_api_CreateCachedSeriesRequest.__name__ = "CreateCachedSeriesRequest"
timeseries_seriescache_api_CreateCachedSeriesRequest.__qualname__ = "CreateCachedSeriesRequest"
timeseries_seriescache_api_CreateCachedSeriesRequest.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_CreateChunk(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'type': ConjureFieldDefinition('type', timeseries_seriescache_api_ChunkType),
            'logical_series_rid': ConjureFieldDefinition('logicalSeriesRid', timeseries_logicalseries_api_LogicalSeriesRid),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', api_Timestamp),
            'count': ConjureFieldDefinition('count', int),
            'size_in_bytes': ConjureFieldDefinition('sizeInBytes', int),
            'resolution': ConjureFieldDefinition('resolution', timeseries_seriescache_api_Resolution),
            'handle': ConjureFieldDefinition('handle', timeseries_seriescache_api_Handle)
        }

    __slots__: List[str] = ['_type', '_logical_series_rid', '_start_timestamp', '_end_timestamp', '_count', '_size_in_bytes', '_resolution', '_handle']

    def __init__(self, count: int, end_timestamp: "api_Timestamp", handle: "timeseries_seriescache_api_Handle", logical_series_rid: str, resolution: int, size_in_bytes: int, start_timestamp: "api_Timestamp", type: "timeseries_seriescache_api_ChunkType") -> None:
        self._type = type
        self._logical_series_rid = logical_series_rid
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp
        self._count = count
        self._size_in_bytes = size_in_bytes
        self._resolution = resolution
        self._handle = handle

    @builtins.property
    def type(self) -> "timeseries_seriescache_api_ChunkType":
        return self._type

    @builtins.property
    def logical_series_rid(self) -> str:
        return self._logical_series_rid

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> "api_Timestamp":
        return self._end_timestamp

    @builtins.property
    def count(self) -> int:
        return self._count

    @builtins.property
    def size_in_bytes(self) -> int:
        return self._size_in_bytes

    @builtins.property
    def resolution(self) -> int:
        return self._resolution

    @builtins.property
    def handle(self) -> "timeseries_seriescache_api_Handle":
        return self._handle


timeseries_seriescache_api_CreateChunk.__name__ = "CreateChunk"
timeseries_seriescache_api_CreateChunk.__qualname__ = "CreateChunk"
timeseries_seriescache_api_CreateChunk.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_CreateChunksParameters(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'create_chunks': ConjureFieldDefinition('createChunks', List[timeseries_seriescache_api_CreateChunk])
        }

    __slots__: List[str] = ['_create_chunks']

    def __init__(self, create_chunks: List["timeseries_seriescache_api_CreateChunk"]) -> None:
        self._create_chunks = create_chunks

    @builtins.property
    def create_chunks(self) -> List["timeseries_seriescache_api_CreateChunk"]:
        return self._create_chunks


timeseries_seriescache_api_CreateChunksParameters.__name__ = "CreateChunksParameters"
timeseries_seriescache_api_CreateChunksParameters.__qualname__ = "CreateChunksParameters"
timeseries_seriescache_api_CreateChunksParameters.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_CreateChunksResponse(ConjureBeanType):
    """
    Responses are returned in the same order as the requests.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'chunk_rids': ConjureFieldDefinition('chunkRids', List[timeseries_seriescache_api_ChunkRid])
        }

    __slots__: List[str] = ['_chunk_rids']

    def __init__(self, chunk_rids: List[str]) -> None:
        self._chunk_rids = chunk_rids

    @builtins.property
    def chunk_rids(self) -> List[str]:
        return self._chunk_rids


timeseries_seriescache_api_CreateChunksResponse.__name__ = "CreateChunksResponse"
timeseries_seriescache_api_CreateChunksResponse.__qualname__ = "CreateChunksResponse"
timeseries_seriescache_api_CreateChunksResponse.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_DeleteChunksParameters(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', api_Timestamp)
        }

    __slots__: List[str] = ['_start_timestamp', '_end_timestamp']

    def __init__(self, end_timestamp: "api_Timestamp", start_timestamp: "api_Timestamp") -> None:
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> "api_Timestamp":
        return self._end_timestamp


timeseries_seriescache_api_DeleteChunksParameters.__name__ = "DeleteChunksParameters"
timeseries_seriescache_api_DeleteChunksParameters.__qualname__ = "DeleteChunksParameters"
timeseries_seriescache_api_DeleteChunksParameters.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_DeleteChunksResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'deleted_chunk_rids': ConjureFieldDefinition('deletedChunkRids', List[timeseries_seriescache_api_ChunkRid])
        }

    __slots__: List[str] = ['_deleted_chunk_rids']

    def __init__(self, deleted_chunk_rids: List[str]) -> None:
        self._deleted_chunk_rids = deleted_chunk_rids

    @builtins.property
    def deleted_chunk_rids(self) -> List[str]:
        return self._deleted_chunk_rids


timeseries_seriescache_api_DeleteChunksResponse.__name__ = "DeleteChunksResponse"
timeseries_seriescache_api_DeleteChunksResponse.__qualname__ = "DeleteChunksResponse"
timeseries_seriescache_api_DeleteChunksResponse.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_GetCachedSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'logical_series_rids': ConjureFieldDefinition('logicalSeriesRids', List[timeseries_logicalseries_api_LogicalSeriesRid])
        }

    __slots__: List[str] = ['_logical_series_rids']

    def __init__(self, logical_series_rids: List[str]) -> None:
        self._logical_series_rids = logical_series_rids

    @builtins.property
    def logical_series_rids(self) -> List[str]:
        return self._logical_series_rids


timeseries_seriescache_api_GetCachedSeriesRequest.__name__ = "GetCachedSeriesRequest"
timeseries_seriescache_api_GetCachedSeriesRequest.__qualname__ = "GetCachedSeriesRequest"
timeseries_seriescache_api_GetCachedSeriesRequest.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_GetChunksParameters(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', api_Timestamp),
            'resolution_nanos': ConjureFieldDefinition('resolutionNanos', int)
        }

    __slots__: List[str] = ['_start_timestamp', '_end_timestamp', '_resolution_nanos']

    def __init__(self, end_timestamp: "api_Timestamp", resolution_nanos: int, start_timestamp: "api_Timestamp") -> None:
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp
        self._resolution_nanos = resolution_nanos

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> "api_Timestamp":
        return self._end_timestamp

    @builtins.property
    def resolution_nanos(self) -> int:
        return self._resolution_nanos


timeseries_seriescache_api_GetChunksParameters.__name__ = "GetChunksParameters"
timeseries_seriescache_api_GetChunksParameters.__qualname__ = "GetChunksParameters"
timeseries_seriescache_api_GetChunksParameters.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_GetChunksResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'chunks': ConjureFieldDefinition('chunks', List[timeseries_seriescache_api_Chunk])
        }

    __slots__: List[str] = ['_chunks']

    def __init__(self, chunks: List["timeseries_seriescache_api_Chunk"]) -> None:
        self._chunks = chunks

    @builtins.property
    def chunks(self) -> List["timeseries_seriescache_api_Chunk"]:
        return self._chunks


timeseries_seriescache_api_GetChunksResponse.__name__ = "GetChunksResponse"
timeseries_seriescache_api_GetChunksResponse.__qualname__ = "GetChunksResponse"
timeseries_seriescache_api_GetChunksResponse.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_Handle(ConjureUnionType):
    _s3: Optional["timeseries_seriescache_api_S3Handle"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3': ConjureFieldDefinition('s3', timeseries_seriescache_api_S3Handle)
        }

    def __init__(
            self,
            s3: Optional["timeseries_seriescache_api_S3Handle"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3 is not None:
                self._s3 = s3
                self._type = 's3'

        elif type_of_union == 's3':
            if s3 is None:
                raise ValueError('a union value must not be None')
            self._s3 = s3
            self._type = 's3'

    @builtins.property
    def s3(self) -> Optional["timeseries_seriescache_api_S3Handle"]:
        return self._s3

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_seriescache_api_HandleVisitor):
            raise ValueError('{} is not an instance of timeseries_seriescache_api_HandleVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3' and self.s3 is not None:
            return visitor._s3(self.s3)


timeseries_seriescache_api_Handle.__name__ = "Handle"
timeseries_seriescache_api_Handle.__qualname__ = "Handle"
timeseries_seriescache_api_Handle.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_HandleVisitor:

    @abstractmethod
    def _s3(self, s3: "timeseries_seriescache_api_S3Handle") -> Any:
        pass


timeseries_seriescache_api_HandleVisitor.__name__ = "HandleVisitor"
timeseries_seriescache_api_HandleVisitor.__qualname__ = "HandleVisitor"
timeseries_seriescache_api_HandleVisitor.__module__ = "scout_service_api.timeseries_seriescache_api"


class timeseries_seriescache_api_S3Handle(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3_path': ConjureFieldDefinition('s3Path', timeseries_seriescache_api_S3Path)
        }

    __slots__: List[str] = ['_s3_path']

    def __init__(self, s3_path: str) -> None:
        self._s3_path = s3_path

    @builtins.property
    def s3_path(self) -> str:
        return self._s3_path


timeseries_seriescache_api_S3Handle.__name__ = "S3Handle"
timeseries_seriescache_api_S3Handle.__qualname__ = "S3Handle"
timeseries_seriescache_api_S3Handle.__module__ = "scout_service_api.timeseries_seriescache_api"


class upload_api_UploadService(Service):
    """
    The Upload Service manages file uploads to S3.
    """

    def initiate_multipart_upload(self, auth_header: str, upload_request: "ingest_api_InitiateMultipartUploadRequest") -> "ingest_api_InitiateMultipartUploadResponse":
        """
        Initiates a multipart upload to S3.
Does not directly upload any parts, but returns an uploadId used to upload parts.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, Any] = {
        }

        _json: Any = ConjureEncoder().default(upload_request)

        _path = '/upload/v1/multipart-upload'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_InitiateMultipartUploadResponse, self._return_none_for_unknown_union_types)

    def list_parts(self, auth_header: str, key: str, upload_id: str) -> List["ingest_api_PartWithSize"]:
        """
        Lists the parts that have been uploaded for a given uploadId.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'key': key,
        }

        _path_params: Dict[str, Any] = {
            'uploadId': upload_id,
        }

        _json: Any = None

        _path = '/upload/v1/multipart-upload/{uploadId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[ingest_api_PartWithSize], self._return_none_for_unknown_union_types)

    def sign_part(self, auth_header: str, key: str, part_number: int, upload_id: str) -> "ingest_api_SignPartResponse":
        """
        Signs an upload request for a single part.
Returns a URL that will execute the upload without further authentication.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'key': key,
            'partNumber': part_number,
        }

        _path_params: Dict[str, Any] = {
            'uploadId': upload_id,
        }

        _json: Any = None

        _path = '/upload/v1/multipart-upload/{uploadId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_SignPartResponse, self._return_none_for_unknown_union_types)

    def complete_multipart_upload(self, auth_header: str, key: str, upload_id: str, parts: List["ingest_api_Part"] = None) -> "ingest_api_CompleteMultipartUploadResponse":
        """
        Completes a multipart upload to S3. This should be called after all parts have been uploaded.
        """
        parts = parts if parts is not None else []

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'key': key,
        }

        _path_params: Dict[str, Any] = {
            'uploadId': upload_id,
        }

        _json: Any = ConjureEncoder().default(parts)

        _path = '/upload/v1/multipart-upload/{uploadId}/complete'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_CompleteMultipartUploadResponse, self._return_none_for_unknown_union_types)

    def abort_multipart_upload(self, auth_header: str, key: str, upload_id: str) -> str:
        """
        Aborts a multipart upload to S3.
Frees storage used by previously uploaded parts and prevents further uploads to the same uploadId.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'key': key,
        }

        _path_params: Dict[str, Any] = {
            'uploadId': upload_id,
        }

        _json: Any = None

        _path = '/upload/v1/multipart-upload/{uploadId}/abort'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_Ignored, self._return_none_for_unknown_union_types)

    def upload_file(self, auth_header: str, body: Any, file_name: str, size_bytes: Optional[int] = None) -> str:
        """
        Uploads a file to S3. Intended for smaller files.
        """

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'fileName': file_name,
            'sizeBytes': size_bytes,
        }

        _path_params: Dict[str, Any] = {
        }

        _data: Any = body

        _path = '/upload/v1/upload-file'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            data=_data)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_S3Path, self._return_none_for_unknown_union_types)


upload_api_UploadService.__name__ = "UploadService"
upload_api_UploadService.__qualname__ = "UploadService"
upload_api_UploadService.__module__ = "scout_service_api.upload_api"


timeseries_logicalseries_api_MeasurementName = str

scout_compute_api_ErrorType = str

timeseries_seriescache_api_ChunkRid = str

ingest_api_DataSourceRid = str

authentication_api_Token = str

datasource_api_Channel = str

scout_compute_api_LogicalSeriesRid = str

timeseries_logicalseries_api_DatabaseName = str

scout_compute_api_VariableName = str

timeseries_logicalseries_api_Channel = str

scout_run_api_VideoRid = str

scout_rids_api_ChartRid = str

scout_units_api_UnitSystem = str

scout_compute_api_SeriesName = str

ingest_api_Label = str

scout_video_api_PropertyValue = str

scout_catalog_ErrorType = str

scout_datareview_api_ManualCheckEvaluationRid = str

scout_datasource_connection_api_MeasurementName = str

scout_datasource_connection_api_TableName = str

scout_rids_api_Version = int

ingest_api_DataSourceRefName = str

scout_chartdefinition_api_AxisId = str

scout_run_api_RunRid = str

storage_series_api_NominalSeriesRid = str

scout_chartdefinition_api_VizId = str

datasource_api_LogicalSeriesRid = str

scout_asset_api_DataScopeName = str

scout_datasource_connection_api_Channel = str

timeseries_seriescache_api_S3Path = str

datasource_PropertyValue = str

timeseries_logicalseries_api_AttributeName = str

attachments_api_PropertyName = str

scout_compute_api_ErrorCode = int

datasource_logset_api_LogSetRid = str

authentication_api_OrgRid = str

scout_asset_api_Channel = str

timeseries_archetype_api_SeriesArchetypeName = str

ingest_api_S3Path = str

ingest_api_ErrorType = str

timeseries_logicalseries_api_FieldName = str

secrets_api_PropertyValue = str

datasource_PropertyName = str

timeseries_logicalseries_api_LocationName = str

scout_datareview_api_CheckAlertRid = str

scout_units_api_UnitSymbol = str

scout_channelvariables_api_ChannelVariableName = str

scout_channelvariables_api_WorkbookChannelVariableMap = Dict[scout_channelvariables_api_ChannelVariableName, scout_channelvariables_api_ChannelVariable]

scout_rids_api_ChecklistRid = str

scout_run_api_PropertyValue = str

scout_versioning_api_BranchName = str

scout_asset_api_SeriesTagValue = str

scout_api_Token = str

scout_run_api_PropertyName = str

scout_rids_api_NotebookRid = str

timeseries_logicalseries_api_DataSourceRid = str

scout_datasource_connection_api_SecretName = str

attachments_api_Label = str

secrets_api_PropertyName = str

storage_datasource_api_NominalDataSourceId = str

scout_run_api_DatasetRid = str

datasource_api_DatasetRid = str

attachments_api_AttachmentRid = str

attachments_api_PropertyValue = str

scout_rids_api_CheckRid = str

scout_run_api_Label = str

scout_video_api_ErrorType = str

timeseries_logicalseries_api_LogicalSeriesRid = str

timeseries_logicalseries_api_Unit = str

scout_datasource_connection_api_OrganizationRid = str

scout_comparisonnotebook_api_ComparisonVizDefinitionMap = Dict[scout_chartdefinition_api_VizId, scout_comparisonnotebook_api_VizDefinition]

scout_chartdefinition_api_DataSourceRefName = str

scout_rids_api_AssetRid = str

datasource_DatasetRid = str

timeseries_logicalseries_api_BucketName = str

scout_api_HexColor = str

scout_rids_api_FunctionLineageRid = str

scout_rids_api_SnapshotRid = str

scout_datasource_connection_api_SecretRid = str

scout_rids_api_AttachmentRid = str

timeseries_logicalseries_api_TableName = str

scout_rids_api_CheckLineageRid = str

ingest_api_RunRid = str

scout_versioning_api_CommitId = str

scout_datasource_connection_api_SchemaName = str

timeseries_seriescache_api_Resolution = int

scout_video_api_Token = str

scout_video_api_Label = str

scout_datareview_api_DataReviewRid = str

scout_datasource_connection_api_ConnectionRid = str

comments_api_ReactionRid = str

scout_run_api_ConnectionRid = str

scout_datasource_connection_api_BucketName = str

scout_chartdefinition_api_WorkbookVizDefinitionMap = Dict[scout_chartdefinition_api_VizId, scout_chartdefinition_api_VizDefinition]

scout_datareview_api_AutomaticCheckEvaluationRid = str

scout_video_api_SegmentRid = str

datasource_api_DataSourceRid = str

timeseries_logicalseries_api_SchemaName = str

scout_layout_api_PanelId = str

comments_api_ResourceRid = str

timeseries_archetype_api_SeriesArchetypeRid = str

comments_api_CommentRid = str

scout_versioning_api_TagRid = str

event_EventRid = str

attachments_api_Token = str

scout_compute_api_LocalVariableName = str

scout_video_api_PropertyName = str

datasource_DatasetFileId = str

secrets_api_SecretRid = str

scout_chart_api_JsonString = str

scout_api_DataSourceRefName = str

timeseries_logicalseries_api_MeasureName = str

datasource_Token = str

scout_versioning_api_BranchRid = str

scout_versioning_api_TagName = str

scout_integrations_api_IntegrationRid = str

scout_api_Channel = str

scout_units_api_UnitName = str

scout_datasource_connection_api_NominalDataSourceRid = str

scout_compute_representation_api_ComputeExpression = str

scout_video_api_S3Path = str

secrets_api_Label = str

scout_chartdefinition_api_WorkbookChartDefinitionMap = Dict[scout_rids_api_ChartRid, scout_chartdefinition_api_VizDefinition]

datasource_Label = str

scout_channelvariables_api_ComputeSpecV1 = str

scout_video_api_VideoRid = str

ingest_api_PropertyValue = str

authorization_OrgRid = str

scout_datasource_connection_api_influx_OrgId = str

scout_datasource_connection_api_ColumnName = str

storage_writer_api_MeasurementName = str

attachments_api_S3Path = str

storage_writer_api_Field = str

ingest_api_PropertyName = str

scout_asset_api_SeriesTagName = str

scout_compute_api_FunctionReference = str

scout_datasource_connection_api_Unit = str

api_TagName = str

scout_checks_api_JobRid = str

scout_comparisonnotebook_api_ComparisonChartDefinitionMap = Dict[scout_rids_api_ChartRid, scout_comparisonnotebook_api_VizDefinition]

scout_run_api_LogSetRid = str

scout_rids_api_TemplateRid = str

api_TagValue = str

storage_series_api_Channel = str

datasource_api_SeriesArchetypeRid = str

scout_units_api_UnitProperty = str

datasource_logset_api_Token = str

datasource_pagination_api_PageToken = str

scout_datasource_connection_api_LocationName = str

scout_rids_api_UserRid = str

ingest_api_Ignored = str

scout_rids_api_FunctionRid = str

secrets_api_Token = str

timeseries_logicalseries_api_ColumnName = str

storage_datasource_api_NominalDataSourceRid = str

authentication_api_UserRid = str

scout_comparisonnotebook_api_VariableName = str

scout_comparisonnotebook_api_ComparisonChannelVariableMap = Dict[scout_comparisonnotebook_api_VariableName, scout_comparisonnotebook_api_ChannelVariable]

